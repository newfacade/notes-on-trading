{"problem_id": 2596, "slug": "check-knight-tour-configuration", "solutions": ["class Solution:\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\n        if grid[0][0]:\n            return False\n        n = len(grid)\n        pos = [None] * (n * n)\n        for i in range(n):\n            for j in range(n):\n                pos[grid[i][j]] = (i, j)\n        for (x1, y1), (x2, y2) in pairwise(pos):\n            dx, dy = abs(x1 - x2), abs(y1 - y2)\n            ok = (dx == 1 and dy == 2) or (dx == 2 and dy == 1)\n            if not ok:\n                return False\n        return True\n", "class Solution:\n  def checkValidGrid(self, grid: list[list[int]]) -> bool:\n    if grid[0][0] != 0:\n      return False\n\n    DIRS = ((1, 2), (2, 1), (2, -1), (1, -2),\n            (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n    n = len(grid)\n    i = 0\n    j = 0\n\n    def nextGrid(i: int, j: int, target: int) -> tuple[int, int]:\n      \"\"\"\n      Returns (x, y), where grid[x][y] == target if (i, j) can reach target.\n      \"\"\"\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x >= n or y < 0 or y >= n:\n          continue\n        if grid[x][y] == target:\n          return (x, y)\n      return (-1, -1)\n\n    for target in range(1, n * n):\n      x, y = nextGrid(i, j, target)\n      if x == -1 and y == -1:\n        return False\n      # Move (x, y) to (i, j).\n      i = x\n      j = y\n\n    return True\n"], "topic_tags": ["Depth-First Search", "Breadth-First Search", "Array", "Matrix", "Simulation"], "collection_date": "2025-03-28"}
{"problem_id": 2502, "slug": "design-memory-allocator", "solutions": ["class Allocator:\n    def __init__(self, n: int):\n        self.m = [0] * n\n\n    def allocate(self, size: int, mID: int) -> int:\n        cnt = 0\n        for i, v in enumerate(self.m):\n            if v:\n                cnt = 0\n            else:\n                cnt += 1\n                if cnt == size:\n                    self.m[i - size + 1 : i + 1] = [mID] * size\n                    return i - size + 1\n        return -1\n\n    def freeMemory(self, mID: int) -> int:\n        ans = 0\n        for i, v in enumerate(self.m):\n            if v == mID:\n                self.m[i] = 0\n                ans += 1\n        return ans\n\n\n# Your Allocator object will be instantiated and called as such:\n# obj = Allocator(n)\n# param_1 = obj.allocate(size,mID)\n# param_2 = obj.freeMemory(mID)\n", "class Allocator:\n  def __init__(self, n: int):\n    self.memory = [0] * n\n    self.mIDToIndices = [[] for _ in range(1001)]\n\n  def allocate(self, size: int, mID: int) -> int:\n    consecutiveFree = 0\n    for i, m in enumerate(self.memory):\n      consecutiveFree = consecutiveFree + 1 if m == 0 else 0\n      if consecutiveFree == size:\n        for j in range(i - consecutiveFree + 1, i + 1):\n          self.memory[j] = mID\n          self.mIDToIndices[mID].append(j)\n        return i - consecutiveFree + 1\n    return -1\n\n  def free(self, mID: int) -> int:\n    indices = self.mIDToIndices[mID]\n    freedUnits = len(indices)\n    for index in indices:\n      self.memory[index] = 0\n    indices.clear()\n    return freedUnits\n"], "topic_tags": ["Design", "Array", "Hash Table", "Simulation"], "collection_date": "2025-03-28"}
{"problem_id": 2513, "slug": "minimize-the-maximum-of-two-arrays", "solutions": ["class Solution:\n    def minimizeSet(\n        self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int\n    ) -> int:\n        def f(x):\n            cnt1 = x // divisor1 * (divisor1 - 1) + x % divisor1\n            cnt2 = x // divisor2 * (divisor2 - 1) + x % divisor2\n            cnt = x // divisor * (divisor - 1) + x % divisor\n            return (\n                cnt1 >= uniqueCnt1\n                and cnt2 >= uniqueCnt2\n                and cnt >= uniqueCnt1 + uniqueCnt2\n            )\n\n        divisor = lcm(divisor1, divisor2)\n        return bisect_left(range(10**10), True, key=f)\n", "class Solution:\n  def minimizeSet(\n      self,\n      divisor1: int,\n      divisor2: int,\n      uniqueCnt1: int,\n      uniqueCnt2: int,\n  ) -> int:\n    divisorLcm = math.lcm(divisor1, divisor2)\n    l = 0\n    r = 2**31 - 1\n\n    def isPossible(m: int) -> bool:\n      \"\"\"\n      Returns True if we can take uniqueCnt1 integers from [1..m] to arr1 and\n      take uniqueCnt2 integers from [1..m] to arr2.\n      \"\"\"\n      cnt1 = m - m // divisor1\n      cnt2 = m - m // divisor2\n      totalCnt = m - m // divisorLcm\n      return (cnt1 >= uniqueCnt1 and\n              cnt2 >= uniqueCnt2 and\n              totalCnt >= uniqueCnt1 + uniqueCnt2)\n\n    while l < r:\n      m = (l + r) // 2\n      if isPossible(m):\n        r = m\n      else:\n        l = m + 1\n\n    return l\n"], "topic_tags": ["Math", "Binary Search", "Number Theory"], "collection_date": "2025-03-28"}
{"problem_id": 2578, "slug": "split-with-minimum-sum", "solutions": ["class Solution:\n    def splitNum(self, num: int) -> int:\n        cnt = Counter()\n        n = 0\n        while num:\n            cnt[num % 10] += 1\n            num //= 10\n            n += 1\n        ans = [0] * 2\n        j = 0\n        for i in range(n):\n            while cnt[j] == 0:\n                j += 1\n            cnt[j] -= 1\n            ans[i & 1] = ans[i & 1] * 10 + j\n        return sum(ans)\n", "class Solution:\n  def splitNum(self, num: int) -> int:\n    s = ''.join(sorted(str(num)))\n    return sum(map(int, (s[::2], s[1::2])))\n"], "topic_tags": ["Greedy", "Math", "Sorting"], "collection_date": "2025-03-28"}
{"problem_id": 2571, "slug": "minimum-operations-to-reduce-an-integer-to-0", "solutions": ["class Solution:\n    def minOperations(self, n: int) -> int:\n        ans = cnt = 0\n        while n:\n            if n & 1:\n                cnt += 1\n            elif cnt:\n                ans += 1\n                cnt = 0 if cnt == 1 else 1\n            n >>= 1\n        if cnt == 1:\n            ans += 1\n        elif cnt > 1:\n            ans += 2\n        return ans\n", "class Solution:\n  def minOperations(self, n: int) -> int:\n    # The strategy is that when the end of n is\n    #   1. consecutive 1s, add 1 (2^0).\n    #   2. single 1, substract 1 (2^0).\n    #   3. 0, substract 2^k to omit the last 1. Equivalently, n >> 1.\n    #\n    # e.g.\n    #\n    #         n = 0b101\n    # n -= 2^0 -> 0b100\n    # n -= 2^2 -> 0b0\n    #         n = 0b1011\n    # n += 2^0 -> 0b1100\n    # n -= 2^2 -> 0b1000\n    # n -= 2^3 -> 0b0\n    ans = 0\n\n    while n > 0:\n      if (n & 3) == 3:\n        n += 1\n        ans += 1\n      elif n % 2 == 1:\n        n -= 1\n        ans += 1\n      else:\n        n >>= 1\n\n    return ans\n"], "topic_tags": ["Greedy", "Bit Manipulation", "Dynamic Programming"], "collection_date": "2025-03-28"}
{"problem_id": 2564, "slug": "substring-xor-queries", "solutions": ["class Solution:\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\n        d = {}\n        n = len(s)\n        for i in range(n):\n            x = 0\n            for j in range(32):\n                if i + j >= n:\n                    break\n                x = x << 1 | int(s[i + j])\n                if x not in d:\n                    d[x] = [i, i + j]\n                if x == 0:\n                    break\n        return [d.get(first ^ second, [-1, -1]) for first, second in queries]\n", "class Solution:\n  def substringXorQueries(self, s: str, queries: list[list[int]]) -> list[list[int]]:\n    MAX_BIT = 30\n    # {val: [left, right]} := s[left..right]'s decimal value = val\n    valToLeftAndRight = collections.defaultdict(lambda: [-1, -1])\n\n    for left, c in enumerate(s):\n      val = 0\n      if c == '0':\n        # edge case: Save the index of the first 0.\n        if 0 not in valToLeftAndRight:\n          valToLeftAndRight[0] = [left, left]\n        continue\n      for right in range(left, min(len(s), left + MAX_BIT)):\n        val = val * 2 + int(s[right])\n        if val not in valToLeftAndRight:\n          valToLeftAndRight[val] = [left, right]\n\n    return [valToLeftAndRight[first, right]\n            for first, right in queries]\n"], "topic_tags": ["Bit Manipulation", "Array", "Hash Table", "String"], "collection_date": "2025-03-28"}
{"problem_id": 2529, "slug": "maximum-count-of-positive-integer-and-negative-integer", "solutions": ["class Solution:\n    def maximumCount(self, nums: List[int]) -> int:\n        a = sum(x > 0 for x in nums)\n        b = sum(x < 0 for x in nums)\n        return max(a, b)\n", "class Solution:\n  def maximumCount(self, nums: list[int]) -> int:\n    return max(sum(num > 0 for num in nums), sum(num < 0 for num in nums))\n"], "topic_tags": ["Array", "Binary Search", "Counting"], "collection_date": "2025-03-28"}
{"problem_id": 2519, "slug": "count-the-number-of-k-big-indices", "solutions": ["class BinaryIndexedTree:\n    def __init__(self, n):\n        self.n = n\n        self.c = [0] * (n + 1)\n\n    def update(self, x, delta):\n        while x <= self.n:\n            self.c[x] += delta\n            x += x & -x\n\n    def query(self, x):\n        s = 0\n        while x:\n            s += self.c[x]\n            x -= x & -x\n        return s\n\n\nclass Solution:\n    def kBigIndices(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        tree1 = BinaryIndexedTree(n)\n        tree2 = BinaryIndexedTree(n)\n        for v in nums:\n            tree2.update(v, 1)\n        ans = 0\n        for v in nums:\n            tree2.update(v, -1)\n            ans += tree1.query(v - 1) >= k and tree2.query(v - 1) >= k\n            tree1.update(v, 1)\n        return ans\n", "class FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def add(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def kBigIndices(self, nums: list[int], k: int) -> int:\n    n = len(nums)\n    leftTree = FenwickTree(n)\n    rightTree = FenwickTree(n)\n    # left[i] := the number of `nums` < nums[i] with index < i\n    left = [0] * n\n    # right[i] := the number of `nums` < nums[i] with index > i\n    right = [0] * n\n\n    for i, num in enumerate(nums):\n      left[i] = leftTree.get(num - 1)\n      leftTree.add(num, 1)\n\n    for i in range(n - 1, -1, -1):\n      right[i] = rightTree.get(nums[i] - 1)\n      rightTree.add(nums[i], 1)\n\n    return sum(l >= k and r >= k for l, r in zip(left, right))\n"], "topic_tags": ["Binary Indexed Tree", "Segment Tree", "Array", "Binary Search", "Divide and Conquer", "Ordered Set", "Merge Sort"], "collection_date": "2025-03-28"}
{"problem_id": 2558, "slug": "take-gifts-from-the-richest-pile", "solutions": ["class Solution:\n    def pickGifts(self, gifts: List[int], k: int) -> int:\n        h = [-v for v in gifts]\n        heapify(h)\n        for _ in range(k):\n            heapreplace(h, -int(sqrt(-h[0])))\n        return -sum(h)\n", "class Solution:\n  def pickGifts(self, gifts: list[int], k: int) -> int:\n    maxHeap = [-gift for gift in gifts]\n    heapq.heapify(maxHeap)\n\n    for _ in range(k):\n      squaredMax = math.isqrt(-heapq.heappop(maxHeap))\n      heapq.heappush(maxHeap, -squaredMax)\n\n    return -sum(maxHeap)\n"], "topic_tags": ["Array", "Simulation", "Heap (Priority Queue)"], "collection_date": "2025-03-28"}
{"problem_id": 2552, "slug": "count-increasing-quadruplets", "solutions": ["class Solution:\n    def countQuadruplets(self, nums: List[int]) -> int:\n        n = len(nums)\n        f = [[0] * n for _ in range(n)]\n        g = [[0] * n for _ in range(n)]\n        for j in range(1, n - 2):\n            cnt = sum(nums[l] > nums[j] for l in range(j + 1, n))\n            for k in range(j + 1, n - 1):\n                if nums[j] > nums[k]:\n                    f[j][k] = cnt\n                else:\n                    cnt -= 1\n        for k in range(2, n - 1):\n            cnt = sum(nums[i] < nums[k] for i in range(k))\n            for j in range(k - 1, 0, -1):\n                if nums[j] > nums[k]:\n                    g[j][k] = cnt\n                else:\n                    cnt -= 1\n        return sum(\n            f[j][k] * g[j][k] for j in range(1, n - 2) for k in range(j + 1, n - 1)\n        )\n", "class Solution:\n  def countQuadruplets(self, nums: list[int]) -> int:\n    ans = 0\n    # dp[j] := the number of triplets (i, j, k) where i < j < k and nums[i] < nums[k] <\n    # nums[j]. Keep this information for l to use later.\n    dp = [0] * len(nums)\n\n    # k can be treated as l.\n    for k in range(2, len(nums)):\n      numLessThanK = 0\n      # j can be treated as i.\n      for j in range(k):\n        if nums[j] < nums[k]:\n          numLessThanK += 1  # nums[i] < nums[k]\n          # nums[j] < nums[l], so we should add dp[j] since we find a new\n          # quadruplets for (i, j, k, l).\n          ans += dp[j]\n        elif nums[j] > nums[k]:\n          dp[j] += numLessThanK\n\n    return ans\n"], "topic_tags": ["Binary Indexed Tree", "Array", "Dynamic Programming", "Enumeration", "Prefix Sum"], "collection_date": "2025-03-28"}
{"problem_id": 2532, "slug": "time-to-cross-a-bridge", "solutions": ["class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        time.sort(key=lambda x: x[0] + x[2])\n        cur = 0\n        wait_in_left, wait_in_right = [], []\n        work_in_left, work_in_right = [], []\n        for i in range(k):\n            heappush(wait_in_left, -i)\n        while 1:\n            while work_in_left:\n                t, i = work_in_left[0]\n                if t > cur:\n                    break\n                heappop(work_in_left)\n                heappush(wait_in_left, -i)\n            while work_in_right:\n                t, i = work_in_right[0]\n                if t > cur:\n                    break\n                heappop(work_in_right)\n                heappush(wait_in_right, -i)\n            left_to_go = n > 0 and wait_in_left\n            right_to_go = bool(wait_in_right)\n            if not left_to_go and not right_to_go:\n                nxt = inf\n                if work_in_left:\n                    nxt = min(nxt, work_in_left[0][0])\n                if work_in_right:\n                    nxt = min(nxt, work_in_right[0][0])\n                cur = nxt\n                continue\n            if right_to_go:\n                i = -heappop(wait_in_right)\n                cur += time[i][2]\n                if n == 0 and not wait_in_right and not work_in_right:\n                    return cur\n                heappush(work_in_left, (cur + time[i][3], i))\n            else:\n                i = -heappop(wait_in_left)\n                cur += time[i][0]\n                n -= 1\n                heappush(work_in_right, (cur + time[i][1], i))\n", "class Solution:\n  def findCrossingTime(self, n: int, k: int, time: list[list[int]]) -> int:\n    ans = 0\n    # (leftToRight + rightToLeft, i)\n    leftBridgeQueue = [\n        (-leftToRight - rightToLeft, -i) for i,\n        (leftToRight, pickOld, rightToLeft, pickNew) in enumerate(time)]\n    rightBridgeQueue = []\n    # (time to be idle, i)\n    leftWorkers = []\n    rightWorkers = []\n\n    heapq.heapify(leftBridgeQueue)\n\n    while n > 0 or rightBridgeQueue or rightWorkers:\n      # Idle left workers get on the left bridge.\n      while leftWorkers and leftWorkers[0][0] <= ans:\n        i = heapq.heappop(leftWorkers)[1]\n        leftWorkers.pop()\n        heapq.heappush(leftBridgeQueue, (-time[i][0] - time[i][2], -i))\n      # Idle right workers get on the right bridge.\n      while rightWorkers and rightWorkers[0][0] <= ans:\n        i = heapq.heappop(rightWorkers)[1]\n        heapq.heappush(rightBridgeQueue, (-time[i][0] - time[i][2], -i))\n      if rightBridgeQueue:\n        # If the bridge is free, the worker waiting on the right side of the\n        # bridge gets to cross the bridge. If more than one worker is waiting\n        # on the right side, the one with the lowest efficiency crosses first.\n        i = -heapq.heappop(rightBridgeQueue)[1]\n        ans += time[i][2]\n        heapq.heappush(leftWorkers, (ans + time[i][3], i))\n      elif leftBridgeQueue and n > 0:\n        # If the bridge is free and no worker is waiting on the right side, and\n       # at least one box remains at the old warehouse, the worker on the left\n       # side of the river gets to cross the bridge. If more than one worker\n       # is waiting on the left side, the one with the lowest efficiency\n       # crosses first.\n        i = -heapq.heappop(leftBridgeQueue)[1]\n        ans += time[i][0]\n        heapq.heappush(rightWorkers, (ans + time[i][1], i))\n        n -= 1\n      else:\n        # Advance the time of the last crossing worker.\n        ans = min(leftWorkers[0][0] if leftWorkers and n > 0 else math.inf,\n                  rightWorkers[0][0] if rightWorkers else math.inf)\n\n    return ans\n"], "topic_tags": ["Array", "Simulation", "Heap (Priority Queue)"], "collection_date": "2025-03-28"}
{"problem_id": 2584, "slug": "split-the-array-to-make-coprime-products", "solutions": ["class Solution:\n    def findValidSplit(self, nums: List[int]) -> int:\n        first = {}\n        n = len(nums)\n        last = list(range(n))\n        for i, x in enumerate(nums):\n            j = 2\n            while j <= x // j:\n                if x % j == 0:\n                    if j in first:\n                        last[first[j]] = i\n                    else:\n                        first[j] = i\n                    while x % j == 0:\n                        x //= j\n                j += 1\n            if x > 1:\n                if x in first:\n                    last[first[x]] = i\n                else:\n                    first[x] = i\n        mx = last[0]\n        for i, x in enumerate(last):\n            if mx < i:\n                return mx\n            mx = max(mx, x)\n        return -1\n", "class Solution:\n  def findValidSplit(self, nums: list[int]) -> int:\n    leftPrimeFactors = collections.Counter()\n    rightPrimeFactors = collections.Counter()\n\n    def getPrimeFactors(num: int) -> list[int]:\n      \"\"\"Gets the prime factors under sqrt(10^6).\"\"\"\n      primeFactors = []\n      for divisor in range(2, min(1000, num) + 1):\n        if num % divisor == 0:\n          primeFactors.append(divisor)\n          while num % divisor == 0:\n            num //= divisor\n      # Handle the case that `num` contains a prime factor > 1000.\n      if num > 1:\n        primeFactors.append(num)\n      return primeFactors\n\n    for num in nums:\n      for primeFactor in getPrimeFactors(num):\n        rightPrimeFactors[primeFactor] += 1\n\n    for i in range(len(nums) - 1):\n      for primeFactor in getPrimeFactors(nums[i]):\n        rightPrimeFactors[primeFactor] -= 1\n        if rightPrimeFactors[primeFactor] == 0:\n          # rightPrimeFactors[primeFactor] == 0, so no need to track\n          # leftPrimeFactors[primeFactor].\n          del rightPrimeFactors[primeFactor]\n          del leftPrimeFactors[primeFactor]\n        else:\n          # Otherwise, need to track leftPrimeFactors[primeFactor].\n          leftPrimeFactors[primeFactor] += 1\n      if not leftPrimeFactors:\n        return i\n\n    return -1\n"], "topic_tags": ["Array", "Hash Table", "Math", "Number Theory"], "collection_date": "2025-03-28"}
{"problem_id": 2585, "slug": "number-of-ways-to-earn-points", "solutions": ["class Solution:\n    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:\n        n = len(types)\n        mod = 10**9 + 7\n        f = [[0] * (target + 1) for _ in range(n + 1)]\n        f[0][0] = 1\n        for i in range(1, n + 1):\n            count, marks = types[i - 1]\n            for j in range(target + 1):\n                for k in range(count + 1):\n                    if j >= k * marks:\n                        f[i][j] = (f[i][j] + f[i - 1][j - k * marks]) % mod\n        return f[n][target]\n", "class Solution:\n  def waysToReachTarget(self, target: int, types: list[list[int]]) -> int:\n    MOD = 1_000_000_007\n    # dp[i][j] := the number of ways to earn j points with the first i types\n    dp = [[0] * (target + 1) for _ in range(len(types) + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, len(types) + 1):\n      count = types[i - 1][0]\n      mark = types[i - 1][1]\n      for j in range(target + 1):\n        for solved in range(count + 1):\n          if j - solved * mark >= 0:\n            dp[i][j] += dp[i - 1][j - solved * mark]\n            dp[i][j] %= MOD\n\n    return dp[len(types)][target]\n", "class Solution:\n  def waysToReachTarget(self, target: int, types: list[list[int]]) -> int:\n    MOD = 1_000_000_007\n    # dp[j] := the number of ways to earn j points with the types so far\n    dp = [1] + [0] * target\n\n    for count, mark in types:\n      for j in range(target, -1, -1):\n        for solved in range(1, count + 1):\n          if j - solved * mark >= 0:\n            dp[j] += dp[j - solved * mark]\n            dp[j] %= MOD\n\n    return dp[target]\n"], "topic_tags": ["Array", "Dynamic Programming"], "collection_date": "2025-03-28"}
{"problem_id": 2560, "slug": "house-robber-iv", "solutions": ["class Solution:\n    def minCapability(self, nums: List[int], k: int) -> int:\n        def f(x):\n            cnt, j = 0, -2\n            for i, v in enumerate(nums):\n                if v > x or i == j + 1:\n                    continue\n                cnt += 1\n                j = i\n            return cnt >= k\n\n        return bisect_left(range(max(nums) + 1), True, key=f)\n", "class Solution:\n  def minCapability(self, nums: list[int], k: int) -> int:\n    def numStolenHouses(capacity: int) -> int:\n      stolenHouses = 0\n      i = 0\n      while i < len(nums):\n        if nums[i] <= capacity:\n          stolenHouses += 1\n          i += 1\n        i += 1\n      return stolenHouses\n\n    return bisect.bisect_left(range(max(nums)), k, key=numStolenHouses)\n"], "topic_tags": ["Array", "Binary Search"], "collection_date": "2025-03-28"}
{"problem_id": 2567, "slug": "minimum-score-by-changing-two-elements", "solutions": ["class Solution:\n    def minimizeSum(self, nums: List[int]) -> int:\n        nums.sort()\n        return min(nums[-1] - nums[2], nums[-2] - nums[1], nums[-3] - nums[0])\n", "class Solution:\n  def minimizeSum(self, nums: list[int]) -> int:\n    nums.sort()\n    # Can always change the number to any other number in `nums`, so `low` becomes 0.\n    # Thus, rephrase the problem as finding the minimum `high`.\n    highOfChangingTwoMins = nums[-1] - nums[2]\n    highOfChangingTwoMaxs = nums[-3] - nums[0]\n    highOfChangingMinAndMax = nums[-2] - nums[1]\n    return min(highOfChangingTwoMins, highOfChangingTwoMaxs,\n               highOfChangingMinAndMax)\n"], "topic_tags": ["Greedy", "Array", "Sorting"], "collection_date": "2025-03-28"}
{"problem_id": 2500, "slug": "delete-greatest-value-in-each-row", "solutions": ["class Solution:\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\n        for row in grid:\n            row.sort()\n        return sum(max(col) for col in zip(*grid))\n", "class Solution:\n  def deleteGreatestValue(self, grid: list[list[int]]) -> int:\n    for row in grid:\n      row.sort()\n    return sum(max(col) for col in zip(*grid))\n"], "topic_tags": ["Array", "Matrix", "Sorting", "Simulation", "Heap (Priority Queue)"], "collection_date": "2025-03-28"}
{"problem_id": 2541, "slug": "minimum-operations-to-make-array-equal-ii", "solutions": ["class Solution:\n    def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:\n        ans = x = 0\n        for a, b in zip(nums1, nums2):\n            if k == 0:\n                if a != b:\n                    return -1\n                continue\n            if (a - b) % k:\n                return -1\n            y = (a - b) // k\n            ans += abs(y)\n            x += y\n        return -1 if x else ans // 2\n", "class Solution:\n  def minOperations(self, nums1: list[int], nums2: list[int], k: int) -> int:\n    if k == 0:\n      return 0 if nums1 == nums2 else -1\n\n    ans = 0\n    opsDiff = 0  # the number of increments - number of decrements\n\n    for num1, num2 in zip(nums1, nums2):\n      diff = num1 - num2\n      if diff == 0:\n        continue\n      if diff % k != 0:\n        return -1\n      ops = diff // k\n      opsDiff += ops\n      ans += abs(ops)\n\n    return ans // 2 if opsDiff == 0 else -1\n"], "topic_tags": ["Greedy", "Array", "Math"], "collection_date": "2025-03-28"}
{"problem_id": 2586, "slug": "count-the-number-of-vowel-strings-in-range", "solutions": ["class Solution:\n    def vowelStrings(self, words: List[str], left: int, right: int) -> int:\n        return sum(\n            w[0] in 'aeiou' and w[-1] in 'aeiou' for w in words[left : right + 1]\n        )\n", "class Solution:\n  def vowelStrings(self, words: list[str], left: int, right: int) -> int:\n    VOWELS = 'aeiou'\n    return sum(word[0] in VOWELS and word[-1] in VOWELS\n               for word in words[left:right + 1])\n"], "topic_tags": ["Array", "String", "Counting"], "collection_date": "2025-03-28"}
{"problem_id": 2545, "slug": "sort-the-students-by-their-kth-score", "solutions": ["class Solution:\n    def sortTheStudents(self, score: List[List[int]], k: int) -> List[List[int]]:\n        return sorted(score, key=lambda x: -x[k])\n", "class Solution:\n  def sortTheStudents(self, score: list[list[int]], k: int) -> list[list[int]]:\n    return sorted(score, key=lambda x: -x[k])\n"], "topic_tags": ["Array", "Matrix", "Sorting"], "collection_date": "2025-03-28"}
{"problem_id": 2591, "slug": "distribute-money-to-maximum-children", "solutions": ["class Solution:\n    def distMoney(self, money: int, children: int) -> int:\n        if money < children:\n            return -1\n        if money > 8 * children:\n            return children - 1\n        if money == 8 * children - 4:\n            return children - 2\n        # money-8x >= children-x, x <= (money-children)/7\n        return (money - children) // 7\n", "class Solution:\n  def distMoney(self, money: int, children: int) -> int:\n    # Everyone must receive at least 1 dollar.\n    money -= children\n    if money < 0:\n      return -1\n\n    count7 = money // 7\n    remaining = money % 7\n\n    # Distribute 8 dollars to every child.\n    if count7 == children and remaining == 0:\n      return count7\n\n    # Need to move 1 dollar from the last child with 4 dollars to one of other\n    # children. That's why we need to substract 1.\n    if count7 == children - 1 and remaining == 3:\n      return count7 - 1\n\n    # Though there might be child with 4 dollars, since count7 < children - 1,\n    # we have 'extra' spot to move money to if needed.\n    return min(children - 1, count7)\n"], "topic_tags": ["Greedy", "Math"], "collection_date": "2025-03-28"}
{"problem_id": 2563, "slug": "count-the-number-of-fair-pairs", "solutions": ["class Solution:\n    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\n        nums.sort()\n        ans = 0\n        for i, x in enumerate(nums):\n            j = bisect_left(nums, lower - x, lo=i + 1)\n            k = bisect_left(nums, upper - x + 1, lo=i + 1)\n            ans += k - j\n        return ans\n", "class Solution:\n  def countFairPairs(self, nums: list[int], lower: int, upper: int) -> int:\n    # nums[i] + nums[j] == nums[j] + nums[i], so the condition that i < j\n    # degrades to i != j and we can sort the array.\n    nums.sort()\n\n    def countLess(summ: int) -> int:\n      res = 0\n      i = 0\n      j = len(nums) - 1\n      while i < j:\n        while i < j and nums[i] + nums[j] > summ:\n          j -= 1\n        res += j - i\n        i += 1\n      return res\n\n    return countLess(upper) - countLess(lower - 1)\n"], "topic_tags": ["Array", "Two Pointers", "Binary Search", "Sorting"], "collection_date": "2025-03-28"}
{"problem_id": 2537, "slug": "count-the-number-of-good-subarrays", "solutions": ["class Solution:\n    def countGood(self, nums: List[int], k: int) -> int:\n        cnt = Counter()\n        ans = cur = 0\n        i = 0\n        for x in nums:\n            cur += cnt[x]\n            cnt[x] += 1\n            while cur - cnt[nums[i]] + 1 >= k:\n                cnt[nums[i]] -= 1\n                cur -= cnt[nums[i]]\n                i += 1\n            if cur >= k:\n                ans += i + 1\n        return ans\n"], "topic_tags": ["Array", "Hash Table", "Sliding Window"], "collection_date": "2025-03-28"}
{"problem_id": 2509, "slug": "cycle-length-queries-in-a-tree", "solutions": ["class Solution:\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        ans = []\n        for a, b in queries:\n            t = 1\n            while a != b:\n                if a > b:\n                    a >>= 1\n                else:\n                    b >>= 1\n                t += 1\n            ans.append(t)\n        return ans\n", "class Solution:\n  def cycleLengthQueries(self, n: int, queries: list[list[int]]) -> list[int]:\n    def getCycleLength(a: int, b: int):\n      cycleLength = 1\n      while a != b:\n        if a > b:\n          a //= 2\n        else:\n          b //= 2\n        cycleLength += 1\n      return cycleLength\n\n    return [getCycleLength(*query) for query in queries]\n"], "topic_tags": ["Tree", "Array", "Binary Tree"], "collection_date": "2025-03-28"}
{"problem_id": 2598, "slug": "smallest-missing-non-negative-integer-after-operations", "solutions": ["class Solution:\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\n        cnt = Counter(x % value for x in nums)\n        for i in range(len(nums) + 1):\n            if cnt[i % value] == 0:\n                return i\n            cnt[i % value] -= 1\n", "class Solution:\n  def findSmallestInteger(self, nums: list[int], value: int) -> int:\n    count = collections.Counter([num % value for num in nums])\n\n    for i in range(len(nums)):\n      if count[i % value] == 0:\n        return i\n      count[i % value] -= 1\n\n    return len(nums)\n"], "topic_tags": ["Greedy", "Array", "Hash Table", "Math"], "collection_date": "2025-03-28"}
{"problem_id": 2514, "slug": "count-anagrams", "solutions": ["class Solution:\n    def countAnagrams(self, s: str) -> int:\n        mod = 10**9 + 7\n        ans = mul = 1\n        for w in s.split():\n            cnt = Counter()\n            for i, c in enumerate(w, 1):\n                cnt[c] += 1\n                mul = mul * cnt[c] % mod\n                ans = ans * i % mod\n        return ans * pow(mul, -1, mod) % mod\n", "class Solution:\n  def countAnagrams(self, s: str) -> int:\n    ans = 1\n\n    for word in s.split():\n      ans = ans * math.factorial(len(word))\n      count = collections.Counter(word)\n      for freq in count.values():\n        ans //= math.factorial(freq)\n\n    return ans % 1_000_000_007\n"], "topic_tags": ["Hash Table", "Math", "String", "Combinatorics", "Counting"], "collection_date": "2025-03-28"}
{"problem_id": 2590, "slug": "design-a-todo-list", "solutions": ["class TodoList:\n    def __init__(self):\n        self.i = 1\n        self.tasks = defaultdict(SortedList)\n\n    def addTask(\n        self, userId: int, taskDescription: str, dueDate: int, tags: List[str]\n    ) -> int:\n        taskId = self.i\n        self.i += 1\n        self.tasks[userId].add([dueDate, taskDescription, set(tags), taskId, False])\n        return taskId\n\n    def getAllTasks(self, userId: int) -> List[str]:\n        return [x[1] for x in self.tasks[userId] if not x[4]]\n\n    def getTasksForTag(self, userId: int, tag: str) -> List[str]:\n        return [x[1] for x in self.tasks[userId] if not x[4] and tag in x[2]]\n\n    def completeTask(self, userId: int, taskId: int) -> None:\n        for task in self.tasks[userId]:\n            if task[3] == taskId:\n                task[4] = True\n                break\n\n\n# Your TodoList object will be instantiated and called as such:\n# obj = TodoList()\n# param_1 = obj.addTask(userId,taskDescription,dueDate,tags)\n# param_2 = obj.getAllTasks(userId)\n# param_3 = obj.getTasksForTag(userId,tag)\n# obj.completeTask(userId,taskId)\n", "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass Task:\n  taskDescription: str\n  dueDate: int\n  tags: list[str]\n\n\nclass TodoList:\n  def __init__(self):\n    self.taskId = 0\n    self.taskIds = set()\n    self.userIdToTaskIdToTasks: dict[int, dict[int, list[Task]]] = {}\n\n  def addTask(self, userId: int, taskDescription: str, dueDate: int,\n              tags: list[str]) -> int:\n    self.taskId += 1\n    taskIdToTasks = self.userIdToTaskIdToTasks.setdefault(userId, {})\n    taskIdToTasks[self.taskId] = Task(taskDescription, dueDate, tags)\n    self.taskIds.add(self.taskId)\n    return self.taskId\n\n  def getAllTasks(self, userId: int) -> list[str]:\n    return [task.taskDescription\n            for task in self._getTasksSortedByDueDate(userId)]\n\n  def getTasksForTag(self, userId: int, tag: str) -> list[str]:\n    return [task.taskDescription\n            for task in self._getTasksSortedByDueDate(userId)\n            if tag in task.tags]\n\n  def completeTask(self, userId: int, taskId: int) -> None:\n    if taskId not in self.taskIds:\n      return\n    if userId not in self.userIdToTaskIdToTasks:\n      return\n    taskIdToTasks = self.userIdToTaskIdToTasks[userId]\n    if taskId not in taskIdToTasks:\n      return\n    del taskIdToTasks[taskId]\n\n  def _getTasksSortedByDueDate(self, userId: int) -> list[Task]:\n    if userId not in self.userIdToTaskIdToTasks:\n      return []\n    taskIdToTasks = self.userIdToTaskIdToTasks[userId]\n    return sorted(\n        [task for task in taskIdToTasks.values()],\n        key=lambda x: x.dueDate)\n"], "topic_tags": ["Design", "Array", "Hash Table", "String", "Sorting"], "collection_date": "2025-03-28"}
{"problem_id": 2518, "slug": "number-of-great-partitions", "solutions": ["class Solution:\n    def countPartitions(self, nums: List[int], k: int) -> int:\n        if sum(nums) < k * 2:\n            return 0\n        mod = 10**9 + 7\n        n = len(nums)\n        f = [[0] * k for _ in range(n + 1)]\n        f[0][0] = 1\n        ans = 1\n        for i in range(1, n + 1):\n            ans = ans * 2 % mod\n            for j in range(k):\n                f[i][j] = f[i - 1][j]\n                if j >= nums[i - 1]:\n                    f[i][j] = (f[i][j] + f[i - 1][j - nums[i - 1]]) % mod\n        return (ans - sum(f[-1]) * 2 + mod) % mod\n", "class Solution:\n  def countPartitions(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    summ = sum(nums)\n    ans = pow(2, len(nums), MOD)  # 2^n % MOD\n    dp = [1] + [0] * k\n\n    for num in nums:\n      for i in range(k, num - 1, -1):\n        dp[i] += dp[i - num]\n        dp[i] %= MOD\n\n    # Substract the cases that're not satisfied.\n    for i in range(k):\n      if summ - i < k:  # Both group1 and group2 < k.\n        ans -= dp[i]\n      else:\n        ans -= dp[i] * 2\n\n    return ans % MOD\n"], "topic_tags": ["Array", "Dynamic Programming"], "collection_date": "2025-03-28"}
{"problem_id": 2587, "slug": "rearrange-array-to-maximize-prefix-score", "solutions": ["class Solution:\n    def maxScore(self, nums: List[int]) -> int:\n        nums.sort(reverse=True)\n        s = 0\n        for i, x in enumerate(nums):\n            s += x\n            if s <= 0:\n                return i\n        return len(nums)\n", "class Solution:\n  def maxScore(self, nums: list[int]) -> int:\n    return sum(num > 0\n               for num in itertools.accumulate(sorted(nums, reverse=True)))\n"], "topic_tags": ["Greedy", "Array", "Prefix Sum", "Sorting"], "collection_date": "2025-03-28"}
{"problem_id": 2576, "slug": "find-the-maximum-number-of-marked-indices", "solutions": ["class Solution:\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\n        nums.sort()\n        i, n = 0, len(nums)\n        for x in nums[(n + 1) // 2 :]:\n            if nums[i] * 2 <= x:\n                i += 1\n        return i * 2\n", "class Solution:\n  def maxNumOfMarkedIndices(self, nums: list[int]) -> int:\n    nums.sort()\n\n    def isPossible(m: int) -> bool:\n      for i in range(m):\n        if 2 * nums[i] > nums[-m + i]:\n          return False\n      return True\n\n    l = bisect.bisect_left(range(len(nums) // 2 + 1), True,\n                           key=lambda m: not isPossible(m))\n    return (l - 1) * 2\n", "class Solution:\n  def maxNumOfMarkedIndices(self, nums: list[int]) -> int:\n    nums.sort()\n\n    i = 0\n    for j in range(len(nums) // 2, len(nums)):\n      if 2 * nums[i] <= nums[j]:\n        i += 1\n        if i == len(nums) // 2:\n          break\n\n    return i * 2\n"], "topic_tags": ["Greedy", "Array", "Two Pointers", "Binary Search", "Sorting"], "collection_date": "2025-03-28"}
{"problem_id": 2569, "slug": "handling-sum-queries-after-update", "solutions": ["class Node:\n    def __init__(self):\n        self.l = self.r = 0\n        self.s = self.lazy = 0\n\n\nclass SegmentTree:\n    def __init__(self, nums):\n        self.nums = nums\n        n = len(nums)\n        self.tr = [Node() for _ in range(n << 2)]\n        self.build(1, 1, n)\n\n    def build(self, u, l, r):\n        self.tr[u].l, self.tr[u].r = l, r\n        if l == r:\n            self.tr[u].s = self.nums[l - 1]\n            return\n        mid = (l + r) >> 1\n        self.build(u << 1, l, mid)\n        self.build(u << 1 | 1, mid + 1, r)\n        self.pushup(u)\n\n    def modify(self, u, l, r):\n        if self.tr[u].l >= l and self.tr[u].r <= r:\n            self.tr[u].lazy ^= 1\n            self.tr[u].s = self.tr[u].r - self.tr[u].l + 1 - self.tr[u].s\n            return\n        self.pushdown(u)\n        mid = (self.tr[u].l + self.tr[u].r) >> 1\n        if l <= mid:\n            self.modify(u << 1, l, r)\n        if r > mid:\n            self.modify(u << 1 | 1, l, r)\n        self.pushup(u)\n\n    def query(self, u, l, r):\n        if self.tr[u].l >= l and self.tr[u].r <= r:\n            return self.tr[u].s\n        self.pushdown(u)\n        mid = (self.tr[u].l + self.tr[u].r) >> 1\n        res = 0\n        if l <= mid:\n            res += self.query(u << 1, l, r)\n        if r > mid:\n            res += self.query(u << 1 | 1, l, r)\n        return res\n\n    def pushup(self, u):\n        self.tr[u].s = self.tr[u << 1].s + self.tr[u << 1 | 1].s\n\n    def pushdown(self, u):\n        if self.tr[u].lazy:\n            mid = (self.tr[u].l + self.tr[u].r) >> 1\n            self.tr[u << 1].s = mid - self.tr[u].l + 1 - self.tr[u << 1].s\n            self.tr[u << 1].lazy ^= 1\n            self.tr[u << 1 | 1].s = self.tr[u].r - mid - self.tr[u << 1 | 1].s\n            self.tr[u << 1 | 1].lazy ^= 1\n            self.tr[u].lazy ^= 1\n\n\nclass Solution:\n    def handleQuery(\n        self, nums1: List[int], nums2: List[int], queries: List[List[int]]\n    ) -> List[int]:\n        tree = SegmentTree(nums1)\n        s = sum(nums2)\n        ans = []\n        for op, a, b in queries:\n            if op == 1:\n                tree.modify(1, a + 1, b + 1)\n            elif op == 2:\n                s += a * tree.query(1, 1, len(nums1))\n            else:\n                ans.append(s)\n        return ans\n"], "topic_tags": ["Segment Tree", "Array"], "collection_date": "2025-03-28"}
{"problem_id": 2595, "slug": "number-of-even-and-odd-bits", "solutions": ["class Solution:\n    def evenOddBit(self, n: int) -> List[int]:\n        ans = [0, 0]\n        i = 0\n        while n:\n            ans[i] += n & 1\n            i ^= 1\n            n >>= 1\n        return ans\n", "class Solution:\n  def evenOddBit(self, n: int) -> list[int]:\n    ans = [0] * 2\n    i = 0  # 0 := even, 1 := odd\n\n    while n > 0:\n      ans[i] += n & 1\n      n >>= 1\n      i ^= 1\n\n    return ans\n"], "topic_tags": ["Bit Manipulation"], "collection_date": "2025-03-28"}
{"problem_id": 2592, "slug": "maximize-greatness-of-an-array", "solutions": ["class Solution:\n    def maximizeGreatness(self, nums: List[int]) -> int:\n        nums.sort()\n        i = 0\n        for x in nums:\n            i += x > nums[i]\n        return i\n", "class Solution:\n  def maximizeGreatness(self, nums: list[int]) -> int:\n    ans = 0\n\n    nums.sort()\n\n    for num in nums:\n      if num > nums[ans]:\n        ans += 1\n\n    return ans\n"], "topic_tags": ["Greedy", "Array", "Two Pointers", "Sorting"], "collection_date": "2025-03-28"}
{"problem_id": 2520, "slug": "count-the-digits-that-divide-a-number", "solutions": ["class Solution:\n    def countDigits(self, num: int) -> int:\n        ans, x = 0, num\n        while x:\n            x, val = divmod(x, 10)\n            ans += num % val == 0\n        return ans\n", "class Solution:\n  def countDigits(self, num: int) -> int:\n    return sum(num % int(d) == 0 for d in str(num))\n"], "topic_tags": ["Math"], "collection_date": "2025-03-28"}
{"problem_id": 2544, "slug": "alternating-digit-sum", "solutions": ["class Solution:\n    def alternateDigitSum(self, n: int) -> int:\n        return sum((-1) ** i * int(x) for i, x in enumerate(str(n)))\n", "class Solution:\n  def alternateDigitSum(self, n: int) -> int:\n    ans = 0\n    sign = 1\n\n    while n > 0:\n      sign *= -1\n      ans += n % 10 * sign\n      n //= 10\n\n    return sign * ans\n"], "topic_tags": ["Math"], "collection_date": "2025-03-28"}
{"problem_id": 2533, "slug": "number-of-good-binary-strings", "solutions": ["class Solution:\n    def goodBinaryStrings(\n        self, minLength: int, maxLength: int, oneGroup: int, zeroGroup: int\n    ) -> int:\n        mod = 10**9 + 7\n        f = [1] + [0] * maxLength\n        for i in range(1, len(f)):\n            if i - oneGroup >= 0:\n                f[i] += f[i - oneGroup]\n            if i - zeroGroup >= 0:\n                f[i] += f[i - zeroGroup]\n            f[i] %= mod\n        return sum(f[minLength:]) % mod\n", "class Solution:\n  def goodBinaryStrings(\n      self,\n      minLength: int,\n      maxLength: int,\n      oneGroup: int,\n      zeroGroup: int,\n  ) -> int:\n    MOD = 1_000_000_007\n    # dp[i] := the number of good binary strings with length i\n    dp = [1] + [0] * maxLength\n\n    for i in range(maxLength + 1):\n      # There are good binary strings with length i, so we can append\n      # consecutive 0s or 1s after it.\n      if dp[i] > 0:\n        appendZeros = i + zeroGroup\n        if appendZeros <= maxLength:\n          dp[appendZeros] += dp[i]\n          dp[appendZeros] %= MOD\n        appendOnes = i + oneGroup\n        if appendOnes <= maxLength:\n          dp[appendOnes] += dp[i]\n          dp[appendOnes] %= MOD\n\n    return sum(dp[minLength:]) % MOD\n"], "topic_tags": ["Dynamic Programming"], "collection_date": "2025-03-28"}
{"problem_id": 2517, "slug": "maximum-tastiness-of-candy-basket", "solutions": ["class Solution:\n    def maximumTastiness(self, price: List[int], k: int) -> int:\n        def check(x: int) -> bool:\n            cnt, pre = 0, -x\n            for cur in price:\n                if cur - pre >= x:\n                    pre = cur\n                    cnt += 1\n            return cnt >= k\n\n        price.sort()\n        l, r = 0, price[-1] - price[0]\n        while l < r:\n            mid = (l + r + 1) >> 1\n            if check(mid):\n                l = mid\n            else:\n                r = mid - 1\n        return l\n", "class Solution:\n  def maximumTastiness(self, price: list[int], k: int) -> int:\n    price.sort()\n\n    def numBaskets(m: int) -> int:\n      \"\"\"Returns the number of baskets we can pick for m tastiness.\"\"\"\n      baskets = 0\n      prevPrice = -m\n      for p in price:\n        if p >= prevPrice + m:\n          prevPrice = p\n          baskets += 1\n      return baskets\n\n    l = bisect.bisect_left(range(max(price) - min(price) + 1), True,\n                           key=lambda m: numBaskets(m) < k)\n    return l - 1\n"], "topic_tags": ["Greedy", "Array", "Binary Search", "Sorting"], "collection_date": "2025-03-28"}
{"problem_id": 2524, "slug": "maximum-frequency-score-of-a-subarray", "solutions": ["class Solution:\n    def maxFrequencyScore(self, nums: List[int], k: int) -> int:\n        mod = 10**9 + 7\n        cnt = Counter(nums[:k])\n        ans = cur = sum(pow(k, v, mod) for k, v in cnt.items()) % mod\n        i = k\n        while i < len(nums):\n            a, b = nums[i - k], nums[i]\n            if a != b:\n                cur += (b - 1) * pow(b, cnt[b], mod) if cnt[b] else b\n                cur -= (a - 1) * pow(a, cnt[a] - 1, mod) if cnt[a] > 1 else a\n                cur %= mod\n                cnt[b] += 1\n                cnt[a] -= 1\n                ans = max(ans, cur)\n            i += 1\n        return ans\n", "class Solution:\n  def maxFrequencyScore(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    count = collections.Counter(nums[:k])\n    summ = self._getInitialSumm(count, MOD)\n    ans = summ\n\n    for i in range(k, len(nums)):\n      # Remove the leftmost number that's out-of-window.\n      leftNum = nums[i - k]\n      summ = (summ - pow(leftNum, count[leftNum], MOD) + MOD) % MOD\n      # After decreasing its frequency, if it's still > 0, then add it back.\n      count[leftNum] -= 1\n      if count[leftNum] > 0:\n        summ = (summ + pow(leftNum, count[leftNum], MOD)) % MOD\n      # Otherwise, remove it from the count map.\n      else:\n        del count[leftNum]\n      # Add the current number. Similarly, remove the current score like above.\n      rightNum = nums[i]\n      if count[rightNum] > 0:\n        summ = (summ - pow(rightNum, count[rightNum], MOD) + MOD) % MOD\n      count[rightNum] += 1\n      summ = (summ + pow(rightNum, count[rightNum], MOD)) % MOD\n      ans = max(ans, summ)\n\n    return ans\n\n  def _getInitialSumm(self, count: dict[int, int], MOD: int) -> int:\n    summ = 0\n    for num, freq in count.items():\n      summ = (summ + pow(num, freq, MOD)) % MOD\n    return summ\n"], "topic_tags": ["Stack", "Array", "Hash Table", "Math", "Sliding Window"], "collection_date": "2025-03-28"}
{"problem_id": 2589, "slug": "minimum-time-to-complete-all-tasks", "solutions": ["class Solution:\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\n        tasks.sort(key=lambda x: x[1])\n        vis = [0] * 2010\n        ans = 0\n        for start, end, duration in tasks:\n            duration -= sum(vis[start : end + 1])\n            i = end\n            while i >= start and duration > 0:\n                if not vis[i]:\n                    duration -= 1\n                    vis[i] = 1\n                    ans += 1\n                i -= 1\n        return ans\n", "class Solution:\n  def findMinimumTime(self, tasks: list[list[int]]) -> int:\n    MAX = 2000\n    running = [False] * (MAX + 1)\n\n    # Sort tasks by end.\n    for start, end, duration in sorted(tasks, key=lambda x: x[1]):\n      neededDuration = (duration -\n                        sum(running[i] for i in range(start, end + 1)))\n      # Greedily run the task as late as possible so that later tasks can run\n      # simultaneously.\n      i = end\n      while neededDuration > 0:\n        if not running[i]:\n          running[i] = True\n          neededDuration -= 1\n        i -= 1\n\n    return sum(running)\n"], "topic_tags": ["Stack", "Greedy", "Array", "Binary Search", "Sorting"], "collection_date": "2025-03-28"}
{"problem_id": 2515, "slug": "shortest-distance-to-target-string-in-a-circular-array", "solutions": ["class Solution:\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\n        n = len(words)\n        ans = n\n        for i, w in enumerate(words):\n            if w == target:\n                t = abs(i - startIndex)\n                ans = min(ans, t, n - t)\n        return -1 if ans == n else ans\n", "class Solution:\n  def closetTarget(self, words: list[str], target: str, startIndex: int) -> int:\n    n = len(words)\n\n    for i in range(n):\n      if words[(startIndex + i + n) % n] == target:\n        return i\n      if words[(startIndex - i + n) % n] == target:\n        return i\n\n    return -1\n"], "topic_tags": ["Array", "String"], "collection_date": "2025-03-28"}
{"problem_id": 2562, "slug": "find-the-array-concatenation-value", "solutions": ["class Solution:\n    def findTheArrayConcVal(self, nums: List[int]) -> int:\n        ans = 0\n        i, j = 0, len(nums) - 1\n        while i < j:\n            ans += int(str(nums[i]) + str(nums[j]))\n            i, j = i + 1, j - 1\n        if i == j:\n            ans += nums[i]\n        return ans\n"], "topic_tags": ["Array", "Two Pointers", "Simulation"], "collection_date": "2025-03-28"}
{"problem_id": 2512, "slug": "reward-top-k-students", "solutions": ["class Solution:\n    def topStudents(\n        self,\n        positive_feedback: List[str],\n        negative_feedback: List[str],\n        report: List[str],\n        student_id: List[int],\n        k: int,\n    ) -> List[int]:\n        ps = set(positive_feedback)\n        ns = set(negative_feedback)\n        arr = []\n        for sid, r in zip(student_id, report):\n            t = 0\n            for w in r.split():\n                if w in ps:\n                    t += 3\n                elif w in ns:\n                    t -= 1\n            arr.append((t, sid))\n        arr.sort(key=lambda x: (-x[0], x[1]))\n        return [v[1] for v in arr[:k]]\n", "class Solution:\n  def topStudents(\n      self,\n      positive_feedback: list[str],\n      negative_feedback: list[str],\n      report: list[str],\n      student_id: list[int],\n      k: int,\n  ) -> list[int]:\n    scoreAndIds = []\n    pos = set(positive_feedback)\n    neg = set(negative_feedback)\n\n    for sid, r in zip(student_id, report):\n      score = 0\n      for word in r.split():\n        if word in pos:\n          score += 3\n        if word in neg:\n          score -= 1\n      scoreAndIds.append((-score, sid))\n\n    return [sid for _, sid in sorted(scoreAndIds)[:k]]\n"], "topic_tags": ["Array", "Hash Table", "String", "Sorting", "Heap (Priority Queue)"], "collection_date": "2025-03-28"}
{"problem_id": 2582, "slug": "pass-the-pillow", "solutions": ["class Solution:\n    def passThePillow(self, n: int, time: int) -> int:\n        ans = k = 1\n        for _ in range(time):\n            ans += k\n            if ans == 1 or ans == n:\n                k *= -1\n        return ans\n", "class Solution:\n  def passThePillow(self, n: int, time: int) -> int:\n    # Repeat every (n - 1) * 2 seconds.\n    time %= (n - 1) * 2\n    if time < n:  # Go forward from 1.\n      return 1 + time\n    return n - (time - (n - 1))  # Go backward from n.\n"], "topic_tags": ["Math", "Simulation"], "collection_date": "2025-03-28"}
{"problem_id": 2535, "slug": "difference-between-element-sum-and-digit-sum-of-an-array", "solutions": ["class Solution:\n    def differenceOfSum(self, nums: List[int]) -> int:\n        x = y = 0\n        for v in nums:\n            x += v\n            while v:\n                y += v % 10\n                v //= 10\n        return x - y\n", "class Solution:\n  def differenceOfSum(self, nums: list[int]) -> int:\n    elementSum = sum(nums)\n    digitSum = self._getAllDigitSum(nums)\n    return abs(elementSum - digitSum)\n\n  def _getAllDigitSum(self, nums: list[int]) -> int:\n    return sum(self._getDigitSum(num) for num in nums)\n\n  def _getDigitSum(self, num: int) -> int:\n    return sum(int(digit) for digit in str(num))\n"], "topic_tags": ["Array", "Math"], "collection_date": "2025-03-28"}
{"problem_id": 2581, "slug": "count-number-of-possible-root-nodes", "solutions": ["class Solution:\n    def rootCount(\n        self, edges: List[List[int]], guesses: List[List[int]], k: int\n    ) -> int:\n        def dfs1(i, fa):\n            nonlocal cnt\n            for j in g[i]:\n                if j != fa:\n                    cnt += gs[(i, j)]\n                    dfs1(j, i)\n\n        def dfs2(i, fa):\n            nonlocal ans, cnt\n            ans += cnt >= k\n            for j in g[i]:\n                if j != fa:\n                    cnt -= gs[(i, j)]\n                    cnt += gs[(j, i)]\n                    dfs2(j, i)\n                    cnt -= gs[(j, i)]\n                    cnt += gs[(i, j)]\n\n        g = defaultdict(list)\n        for a, b in edges:\n            g[a].append(b)\n            g[b].append(a)\n        gs = Counter((u, v) for u, v in guesses)\n        cnt = 0\n        dfs1(0, -1)\n        ans = 0\n        dfs2(0, -1)\n        return ans\n", "class Solution:\n  def rootCount(\n      self,\n      edges: list[list[int]],\n      guesses: list[list[int]],\n      k: int,\n  ) -> int:\n    ans = 0\n    n = len(edges) + 1\n    graph = [[] for _ in range(n)]\n    guessGraph = [set() for _ in range(n)]\n    parent = [0] * n\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    for u, v in guesses:\n      guessGraph[u].add(v)\n\n    def dfs(u: int, prev: int) -> None:\n      parent[u] = prev\n      for v in graph[u]:\n        if v != prev:\n          dfs(v, u)\n\n    # Precalculate `parent`.\n    dfs(0, -1)\n\n    # Calculate `correctGuess` for tree rooted at 0.\n    correctGuess = sum(i in guessGraph[parent[i]] for i in range(1, n))\n\n    def reroot(u: int, prev: int, correctGuess: int) -> None:\n      nonlocal ans\n      if u != 0:\n        # The tree is rooted at u, so a guess edge (u, prev) will match the new\n        # `parent` relationship.\n        if prev in guessGraph[u]:\n          correctGuess += 1\n        # A guess edge (prev, u) matching the old `parent` relationship will no\n        # longer be True.\n        if u in guessGraph[prev]:\n          correctGuess -= 1\n      if correctGuess >= k:\n        ans += 1\n      for v in graph[u]:\n        if v != prev:\n          reroot(v, u, correctGuess)\n\n    reroot(0, -1, correctGuess)\n    return ans\n"], "topic_tags": ["Tree", "Depth-First Search", "Array", "Hash Table", "Dynamic Programming"], "collection_date": "2025-03-28"}
{"problem_id": 2539, "slug": "count-the-number-of-good-subsequences", "solutions": ["N = 10001\nMOD = 10**9 + 7\nf = [1] * N\ng = [1] * N\nfor i in range(1, N):\n    f[i] = f[i - 1] * i % MOD\n    g[i] = pow(f[i], MOD - 2, MOD)\n\n\ndef comb(n, k):\n    return f[n] * g[k] * g[n - k] % MOD\n\n\nclass Solution:\n    def countGoodSubsequences(self, s: str) -> int:\n        cnt = Counter(s)\n        ans = 0\n        for i in range(1, max(cnt.values()) + 1):\n            x = 1\n            for v in cnt.values():\n                if v >= i:\n                    x = x * (comb(v, i) + 1) % MOD\n            ans = (ans + x - 1) % MOD\n        return ans\n", "class Solution:\n  def countGoodSubsequences(self, s: str) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    count = collections.Counter(s)\n\n    @functools.lru_cache(None)\n    def fact(i: int) -> int:\n      return 1 if i <= 1 else i * fact(i - 1) % MOD\n\n    @functools.lru_cache(None)\n    def inv(i: int) -> int:\n      return pow(i, MOD - 2, MOD)\n\n    @functools.lru_cache(None)\n    def nCk(n: int, k: int) -> int:\n      return fact(n) * inv(fact(k)) * inv(fact(n - k)) % MOD\n\n    for freq in range(1, max(count.values()) + 1):\n      numSubseqs = 1  # \"\"\n      for charFreq in count.values():\n        if charFreq >= freq:\n          numSubseqs = numSubseqs * (1 + nCk(charFreq, freq)) % MOD\n      ans += numSubseqs - 1  # Minus \"\".\n      ans %= MOD\n\n    return ans\n"], "topic_tags": ["Hash Table", "Math", "String", "Combinatorics", "Counting"], "collection_date": "2025-03-28"}
{"problem_id": 2508, "slug": "add-edges-to-make-degrees-of-all-nodes-even", "solutions": ["class Solution:\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n        g = defaultdict(set)\n        for a, b in edges:\n            g[a].add(b)\n            g[b].add(a)\n        vs = [i for i, v in g.items() if len(v) & 1]\n        if len(vs) == 0:\n            return True\n        if len(vs) == 2:\n            a, b = vs\n            if a not in g[b]:\n                return True\n            return any(a not in g[c] and c not in g[b] for c in range(1, n + 1))\n        if len(vs) == 4:\n            a, b, c, d = vs\n            if a not in g[b] and c not in g[d]:\n                return True\n            if a not in g[c] and b not in g[d]:\n                return True\n            if a not in g[d] and b not in g[c]:\n                return True\n            return False\n        return False\n", "class Solution:\n  def isPossible(self, n: int, edges: list[list[int]]) -> bool:\n    graph = [set() for _ in range(n)]\n\n    for u, v in edges:\n      graph[u - 1].add(v - 1)\n      graph[v - 1].add(u - 1)\n\n    oddNodes = [i for i, neighbor in enumerate(\n        graph) if len(neighbor) % 2 == 1]\n    if not oddNodes:\n      return True\n    if len(oddNodes) == 2:\n      a, b = oddNodes\n      return any(a not in graph[i] and b not in graph[i] for i in range(n))\n    if len(oddNodes) == 4:\n      a, b, c, d = oddNodes\n      return ((b not in graph[a] and d not in graph[c]) or\n              (c not in graph[a] and d not in graph[b]) or\n              (d not in graph[a] and c not in graph[b]))\n    return False\n"], "topic_tags": ["Graph", "Hash Table"], "collection_date": "2025-03-28"}
{"problem_id": 2540, "slug": "minimum-common-value", "solutions": ["class Solution:\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\n        i = j = 0\n        m, n = len(nums1), len(nums2)\n        while i < m and j < n:\n            if nums1[i] == nums2[j]:\n                return nums1[i]\n            if nums1[i] < nums2[j]:\n                i += 1\n            else:\n                j += 1\n        return -1\n", "class Solution:\n  def getCommon(self, nums1: list[int], nums2: list[int]) -> int:\n    i = 0  # nums1's index\n    j = 0  # nums2's index\n\n    while i < len(nums1) and j < len(nums2):\n      if nums1[i] == nums2[j]:\n        return nums1[i]\n      if nums1[i] < nums2[j]:\n        i += 1\n      else:\n        j += 1\n\n    return -1\n"], "topic_tags": ["Array", "Hash Table", "Two Pointers", "Binary Search"], "collection_date": "2025-03-28"}
{"problem_id": 2505, "slug": "bitwise-or-of-all-subsequence-sums", "solutions": ["class Solution:\n    def subsequenceSumOr(self, nums: List[int]) -> int:\n        cnt = [0] * 64\n        ans = 0\n        for v in nums:\n            for i in range(31):\n                if (v >> i) & 1:\n                    cnt[i] += 1\n        for i in range(63):\n            if cnt[i]:\n                ans |= 1 << i\n            cnt[i + 1] += cnt[i] // 2\n        return ans\n", "class Solution:\n  def subsequenceSumOr(self, nums: list[int]) -> int:\n    ans = 0\n    prefix = 0\n\n    for num in nums:\n      prefix += num\n      ans |= num | prefix\n\n    return ans\n"], "topic_tags": ["Bit Manipulation", "Brainteaser", "Array", "Math"], "collection_date": "2025-03-28"}
{"problem_id": 2501, "slug": "longest-square-streak-in-an-array", "solutions": ["class Solution:\n    def longestSquareStreak(self, nums: List[int]) -> int:\n        s = set(nums)\n        ans = -1\n        for v in nums:\n            t = 0\n            while v in s:\n                v *= v\n                t += 1\n            if t > 1:\n                ans = max(ans, t)\n        return ans\n"], "topic_tags": ["Array", "Hash Table", "Binary Search", "Dynamic Programming", "Sorting"], "collection_date": "2025-03-28"}
{"problem_id": 2504, "slug": "concatenate-the-name-and-the-profession", "solutions": [], "topic_tags": ["Database"], "collection_date": "2025-03-28"}
{"problem_id": 2528, "slug": "maximize-the-minimum-powered-city", "solutions": ["class Solution:\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\n        def check(x, k):\n            d = [0] * (n + 1)\n            t = 0\n            for i in range(n):\n                t += d[i]\n                dist = x - (s[i] + t)\n                if dist > 0:\n                    if k < dist:\n                        return False\n                    k -= dist\n                    j = min(i + r, n - 1)\n                    left, right = max(0, j - r), min(j + r, n - 1)\n                    d[left] += dist\n                    d[right + 1] -= dist\n                    t += dist\n            return True\n\n        n = len(stations)\n        d = [0] * (n + 1)\n        for i, v in enumerate(stations):\n            left, right = max(0, i - r), min(i + r, n - 1)\n            d[left] += v\n            d[right + 1] -= v\n        s = list(accumulate(d))\n        left, right = 0, 1 << 40\n        while left < right:\n            mid = (left + right + 1) >> 1\n            if check(mid, k):\n                left = mid\n            else:\n                right = mid - 1\n        return left\n", "class Solution:\n  def maxPower(self, stations: list[int], r: int, k: int) -> int:\n    n = len(stations)\n    left = min(stations)\n    right = sum(stations) + k + 1\n\n    def check(\n            stations: list[int],\n            additionalStations: int, minPower: int) -> bool:\n      \"\"\"Returns True if each city can have at least `minPower`.\"\"\"\n      # Initilaize `power` as the 0-th city's power - stations[r].\n      power = sum(stations[:r])\n\n      for i in range(n):\n        if i + r < n:\n          power += stations[i + r]  # `power` = sum(stations[i - r..i + r]).\n        if power < minPower:\n          requiredPower = minPower - power\n          # There're not enough stations to plant.\n          if requiredPower > additionalStations:\n            return False\n          # Greedily plant `requiredPower` power stations in the farthest place\n          # to cover as many cities as possible.\n          stations[min(n - 1, i + r)] += requiredPower\n          additionalStations -= requiredPower\n          power += requiredPower\n        if i - r >= 0:\n          power -= stations[i - r]\n\n      return True\n\n    while left < right:\n      mid = (left + right) // 2\n      if check(stations.copy(), k, mid):\n        left = mid + 1\n      else:\n        right = mid\n\n    return left - 1\n"], "topic_tags": ["Greedy", "Queue", "Array", "Binary Search", "Prefix Sum", "Sliding Window"], "collection_date": "2025-03-28"}
{"problem_id": 2568, "slug": "minimum-impossible-or", "solutions": ["class Solution:\n    def minImpossibleOR(self, nums: List[int]) -> int:\n        s = set(nums)\n        return next(1 << i for i in range(32) if 1 << i not in s)\n", "class Solution:\n  def minImpossibleOR(self, nums: list[int]) -> int:\n    ans = 1\n    numsSet = set(nums)\n\n    while ans in numsSet:\n      ans <<= 1\n\n    return ans\n"], "topic_tags": ["Bit Manipulation", "Brainteaser", "Array"], "collection_date": "2025-03-28"}
{"problem_id": 2583, "slug": "kth-largest-sum-in-a-binary-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\n        arr = []\n        q = deque([root])\n        while q:\n            t = 0\n            for _ in range(len(q)):\n                root = q.popleft()\n                t += root.val\n                if root.left:\n                    q.append(root.left)\n                if root.right:\n                    q.append(root.right)\n            arr.append(t)\n        return -1 if len(arr) < k else nlargest(k, arr)[-1]\n", "class Solution:\n  def kthLargestLevelSum(self, root: TreeNode | None, k: int) -> int:\n    levelSums = []\n\n    def dfs(root: TreeNode | None, level: int) -> None:\n      if not root:\n        return\n      if len(levelSums) == level:\n        levelSums.append(0)\n      levelSums[level] += root.val\n      dfs(root.left, level + 1)\n      dfs(root.right, level + 1)\n\n    dfs(root, 0)\n    if len(levelSums) < k:\n      return -1\n\n    return sorted(levelSums, reverse=True)[k - 1]\n"], "topic_tags": ["Tree", "Breadth-First Search", "Binary Tree", "Sorting"], "collection_date": "2025-03-28"}
{"problem_id": 2554, "slug": "maximum-number-of-integers-to-choose-from-a-range-i", "solutions": ["class Solution:\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\n        ans = s = 0\n        ban = set(banned)\n        for i in range(1, n + 1):\n            if s + i > maxSum:\n                break\n            if i not in ban:\n                ans += 1\n                s += i\n        return ans\n", "class Solution:\n  def maxCount(self, banned: list[int], n: int, maxSum: int) -> int:\n    ans = 0\n    summ = 0\n    bannedSet = set(banned)\n\n    for i in range(1, n + 1):\n      if i not in bannedSet and summ + i <= maxSum:\n        ans += 1\n        summ += i\n\n    return ans\n"], "topic_tags": ["Greedy", "Array", "Hash Table", "Binary Search", "Sorting"], "collection_date": "2025-03-28"}
{"problem_id": 2525, "slug": "categorize-box-according-to-criteria", "solutions": ["class Solution:\n    def categorizeBox(self, length: int, width: int, height: int, mass: int) -> str:\n        v = length * width * height\n        bulky = int(any(x >= 10000 for x in (length, width, height)) or v >= 10**9)\n        heavy = int(mass >= 100)\n        i = heavy << 1 | bulky\n        d = ['Neither', 'Bulky', 'Heavy', 'Both']\n        return d[i]\n", "class Solution:\n  def categorizeBox(\n      self,\n      length: int,\n      width: int,\n      height: int,\n      mass: int,\n  ) -> str:\n    isBulky = (length >= 10000 or\n               width >= 10000 or height >= 10000 or\n               length * width * height >= 1_000_000_000)\n    isHeavy = mass >= 100\n    if isBulky and isHeavy:\n      return 'Both'\n    if isBulky:\n      return 'Bulky'\n    if isHeavy:\n      return 'Heavy'\n    return 'Neither'\n"], "topic_tags": ["Math"], "collection_date": "2025-03-28"}
{"problem_id": 2546, "slug": "apply-bitwise-operations-to-make-strings-equal", "solutions": ["class Solution:\n    def makeStringsEqual(self, s: str, target: str) -> bool:\n        return (\"1\" in s) == (\"1\" in target)\n", "class Solution:\n  def makeStringsEqual(self, s: str, target: str) -> bool:\n    return ('1' in s) == ('1' in target)\n"], "topic_tags": ["Bit Manipulation", "String"], "collection_date": "2025-03-28"}
{"problem_id": 2553, "slug": "separate-the-digits-in-an-array", "solutions": ["class Solution:\n    def separateDigits(self, nums: List[int]) -> List[int]:\n        ans = []\n        for x in nums:\n            t = []\n            while x:\n                t.append(x % 10)\n                x //= 10\n            ans.extend(t[::-1])\n        return ans\n", "class Solution:\n  def separateDigits(self, nums: list[int]) -> list[int]:\n    return [int(c) for num in nums for c in str(num)]\n"], "topic_tags": ["Array", "Simulation"], "collection_date": "2025-03-28"}
{"problem_id": 2511, "slug": "maximum-enemy-forts-that-can-be-captured", "solutions": ["class Solution:\n    def captureForts(self, forts: List[int]) -> int:\n        n = len(forts)\n        i = ans = 0\n        while i < n:\n            j = i + 1\n            if forts[i]:\n                while j < n and forts[j] == 0:\n                    j += 1\n                if j < n and forts[i] + forts[j] == 0:\n                    ans = max(ans, j - i - 1)\n            i = j\n        return ans\n", "class Solution:\n  def captureForts(self, forts: list[int]) -> int:\n    ans = 0\n\n    j = 0\n    for i, fort in enumerate(forts):\n      if fort != 0:  # -1 or 1\n        if fort == -forts[j]:\n          ans = max(ans, i - j - 1)\n        j = i\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2572, "slug": "count-the-number-of-square-free-subsets", "solutions": ["class Solution:\n    def squareFreeSubsets(self, nums: List[int]) -> int:\n        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n        cnt = Counter(nums)\n        mod = 10**9 + 7\n        n = len(primes)\n        f = [0] * (1 << n)\n        f[0] = pow(2, cnt[1])\n        for x in range(2, 31):\n            if cnt[x] == 0 or x % 4 == 0 or x % 9 == 0 or x % 25 == 0:\n                continue\n            mask = 0\n            for i, p in enumerate(primes):\n                if x % p == 0:\n                    mask |= 1 << i\n            for state in range((1 << n) - 1, 0, -1):\n                if state & mask == mask:\n                    f[state] = (f[state] + cnt[x] * f[state ^ mask]) % mod\n        return sum(v for v in f) % mod - 1\n", "class Solution:\n  def squareFreeSubsets(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n\n    def getMask(num: int) -> int:\n      \"\"\"\n      e.g. num = 10 = 2 * 5, so mask = 0b101 . 0b1010 (append a 0)\n           num = 15 = 3 * 5, so mask = 0b110 . 0b1100 (append a 0)\n           num = 25 = 5 * 5, so mask =  (-1)2 . (1..1)2 (invalid)\n      \"\"\"\n      mask = 0\n      for i, prime in enumerate(primes):\n        rootCount = 0\n        while num % prime == 0:\n          num //= prime\n          rootCount += 1\n        if rootCount >= 2:\n          return -1\n        if rootCount == 1:\n          mask |= 1 << i\n      return mask << 1\n\n    masks = [getMask(num) for num in nums]\n\n    @functools.lru_cache(None)\n    def dp(i: int, used: int) -> int:\n      if i == len(masks):\n        return 1\n      pick = dp(i + 1, used | masks[i]) if (masks[i] & used) == 0 else 0\n      skip = dp(i + 1, used)\n      return (pick + skip) % MOD\n\n    # -1 means that we take no number.\n    # `used` is initialized to 1 so that -1 & 1 = 1 instead of 0.\n    return (dp(0, 1) - 1 + MOD) % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2557, "slug": "maximum-number-of-integers-to-choose-from-a-range-ii", "solutions": ["class Solution:\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\n        banned.extend([0, n + 1])\n        ban = sorted(set(banned))\n        ans = 0\n        for i, j in pairwise(ban):\n            left, right = 0, j - i - 1\n            while left < right:\n                mid = (left + right + 1) >> 1\n                if (i + 1 + i + mid) * mid // 2 <= maxSum:\n                    left = mid\n                else:\n                    right = mid - 1\n            ans += left\n            maxSum -= (i + 1 + i + left) * left // 2\n            if maxSum <= 0:\n                break\n        return ans\n", "class Solution:\n  def maxCount(self, banned: list[int], n: int, maxSum: int) -> int:\n    bannedSet = set(banned)\n    l = 1\n    r = n\n\n    while l < r:\n      m = (l + r + 1) // 2\n      if self._getSum(bannedSet, m) > maxSum:\n        r = m - 1\n      else:\n        l = m\n\n    return l - sum(b <= l for b in banned)\n\n  # Returns sum([1..m]) - sum(bannedSet).\n  def _getSum(self, bannedSet: set[int], m: int) -> int:\n    return m * (m + 1) // 2 - sum(b for b in bannedSet if b <= m)\n"], "topic_tags": ["Greedy", "Array", "Binary Search", "Sorting"], "collection_date": "2025-03-28"}
{"problem_id": 2521, "slug": "distinct-prime-factors-of-product-of-array", "solutions": ["class Solution:\n    def distinctPrimeFactors(self, nums: List[int]) -> int:\n        s = set()\n        for n in nums:\n            i = 2\n            while i <= n // i:\n                if n % i == 0:\n                    s.add(i)\n                    while n % i == 0:\n                        n //= i\n                i += 1\n            if n > 1:\n                s.add(n)\n        return len(s)\n", "class Solution:\n  def distinctPrimeFactors(self, nums: list[int]) -> int:\n    primes = set()\n\n    for num in nums:\n      self._addPrimeFactors(primes, num)\n\n    return len(primes)\n\n  def _addPrimeFactors(self, primes: set[int], num: int) -> None:\n    for divisor in range(2, num + 1):\n      if num % divisor == 0:\n        primes.add(divisor)\n        while num % divisor == 0:\n          num //= divisor\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2579, "slug": "count-total-number-of-colored-cells", "solutions": ["class Solution:\n    def coloredCells(self, n: int) -> int:\n        return 2 * n * (n - 1) + 1\n", "class Solution:\n  def coloredCells(self, n: int) -> int:\n    return n**2 + (n - 1)**2\n"], "topic_tags": ["Math"], "collection_date": "2025-03-28"}
{"problem_id": 2580, "slug": "count-ways-to-group-overlapping-ranges", "solutions": ["class Solution:\n    def countWays(self, ranges: List[List[int]]) -> int:\n        ranges.sort()\n        cnt, mx = 0, -1\n        for start, end in ranges:\n            if start > mx:\n                cnt += 1\n            mx = max(mx, end)\n        mod = 10**9 + 7\n        return pow(2, cnt, mod)\n", "class Solution:\n  def countWays(self, ranges: list[list[int]]) -> int:\n    MOD = 1_000_000_007\n    ans = 1\n    prevEnd = -1\n\n    for start, end in sorted(ranges):\n      if start > prevEnd:\n        ans = ans * 2 % MOD\n      prevEnd = max(prevEnd, end)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2599, "slug": "make-the-prefix-sum-non-negative", "solutions": ["class Solution:\n    def makePrefSumNonNegative(self, nums: List[int]) -> int:\n        h = []\n        ans = s = 0\n        for x in nums:\n            s += x\n            if x < 0:\n                heappush(h, x)\n            while s < 0:\n                s -= heappop(h)\n                ans += 1\n        return ans\n", "class Solution:\n  def makePrefSumNonNegative(self, nums: list[int]) -> int:\n    ans = 0\n    prefix = 0\n    minHeap = []\n\n    for num in nums:\n      prefix += num\n      if num < 0:\n        heapq.heappush(minHeap, num)\n      while prefix < 0:\n        prefix -= heapq.heappop(minHeap)\n        ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2550, "slug": "count-collisions-of-monkeys-on-a-polygon", "solutions": ["class Solution:\n    def monkeyMove(self, n: int) -> int:\n        mod = 10**9 + 7\n        return (pow(2, n, mod) - 2) % mod\n", "class Solution:\n  def monkeyMove(self, n: int) -> int:\n    MOD = 1_000_000_007\n    res = pow(2, n, MOD) - 2\n    return res + MOD if res < 0 else res\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2526, "slug": "find-consecutive-integers-from-a-data-stream", "solutions": ["class DataStream:\n    def __init__(self, value: int, k: int):\n        self.val, self.k = value, k\n        self.cnt = 0\n\n    def consec(self, num: int) -> bool:\n        self.cnt = 0 if num != self.val else self.cnt + 1\n        return self.cnt >= self.k\n\n\n# Your DataStream object will be instantiated and called as such:\n# obj = DataStream(value, k)\n# param_1 = obj.consec(num)\n", "class DataStream:\n  def __init__(self, value: int, k: int):\n    self.value = value\n    self.k = k\n    self.q = deque()\n    self.count = 0\n\n  def consec(self, num: int) -> bool:\n    if len(self.q) == self.k and self.q.popleft() == self.value:\n      self.count -= 1\n    if num == self.value:\n      self.count += 1\n    self.q.append(num)\n    return self.count == self.k\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2551, "slug": "put-marbles-in-bags", "solutions": ["class Solution:\n    def putMarbles(self, weights: List[int], k: int) -> int:\n        arr = sorted(a + b for a, b in pairwise(weights))\n        return sum(arr[len(arr) - k + 1 :]) - sum(arr[: k - 1])\n", "class Solution:\n  def putMarbles(self, weights: list[int], k: int) -> int:\n    # To distribute marbles into k bags, there will be k - 1 cuts. If there's a\n    # cut after weights[i], then weights[i] and weights[i + 1] will be added to\n    # the cost. Also, no matter how we cut, weights[0] and weights[n - 1] will\n    # be counted. So, the goal is to find the max//min k - 1 weights[i] +\n    # weights[i + 1].\n\n    # weights[i] + weights[i + 1]\n    arr = [a + b for a, b in itertools.pairwise(weights)]\n    return sum(heapq.nlargest(k - 1, arr)) - sum(heapq.nsmallest(k - 1, arr))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2559, "slug": "count-vowel-strings-in-ranges", "solutions": ["class Solution:\n    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\n        vowels = set(\"aeiou\")\n        nums = [i for i, w in enumerate(words) if w[0] in vowels and w[-1] in vowels]\n        return [bisect_right(nums, r) - bisect_left(nums, l) for l, r in queries]\n", "class Solution:\n  def vowelStrings(\n      self,\n      words: list[str],\n      queries: list[list[int]],\n  ) -> list[int]:\n    VOWELS = 'aeiou'\n    # prefix[i] := the number of the first i words that start with and end in a vowel\n    prefix = [0] * (len(words) + 1)\n\n    for i, word in enumerate(words):\n      prefix[i + 1] += prefix[i] + (word[0] in VOWELS and word[-1] in VOWELS)\n\n    return [prefix[r + 1] - prefix[l]\n            for l, r in queries]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2543, "slug": "check-if-point-is-reachable", "solutions": ["class Solution:\n    def isReachable(self, targetX: int, targetY: int) -> bool:\n        x = gcd(targetX, targetY)\n        return x & (x - 1) == 0\n", "class Solution:\n  def isReachable(self, targetX: int, targetY: int) -> bool:\n    return math.gcd(targetX, targetY).bit_count() == 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2570, "slug": "merge-two-2d-arrays-by-summing-values", "solutions": ["class Solution:\n    def mergeArrays(\n        self, nums1: List[List[int]], nums2: List[List[int]]\n    ) -> List[List[int]]:\n        cnt = Counter()\n        for i, v in nums1 + nums2:\n            cnt[i] += v\n        return sorted(cnt.items())\n", "class Solution:\n  def mergeArrays(self, nums1: list[list[int]],\n                  nums2: list[list[int]]) -> list[list[int]]:\n    count = [0] * (1001)\n    self._addCount(nums1, count)\n    self._addCount(nums2, count)\n    return [[i, c] for i, c in enumerate(count) if c > 0]\n\n  def _addCount(self, nums: list[list[int]], count: list[int]) -> None:\n    for id_, val in nums:\n      count[id_] += val\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2549, "slug": "count-distinct-numbers-on-board", "solutions": ["class Solution:\n    def distinctIntegers(self, n: int) -> int:\n        return max(1, n - 1)\n", "class Solution:\n  def distinctIntegers(self, n: int) -> int:\n    return max(n - 1, 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2507, "slug": "smallest-value-after-replacing-with-sum-of-prime-factors", "solutions": ["class Solution:\n    def smallestValue(self, n: int) -> int:\n        while 1:\n            t, s, i = n, 0, 2\n            while i <= n // i:\n                while n % i == 0:\n                    n //= i\n                    s += i\n                i += 1\n            if n > 1:\n                s += n\n            if s == t:\n                return t\n            n = s\n", "class Solution:\n  def smallestValue(self, n: int) -> int:\n    def getPrimeSum(n: int) -> int:\n      primeSum = 0\n      for i in range(2, n + 1):\n        while n % i == 0:\n          n //= i\n          primeSum += i\n      return primeSum\n\n    primeSum = getPrimeSum(n)\n    while n != primeSum:\n      n = primeSum\n      primeSum = getPrimeSum(n)\n    return n\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2516, "slug": "take-k-of-each-character-from-left-and-right", "solutions": ["class Solution:\n    def takeCharacters(self, s: str, k: int) -> int:\n        cnt = Counter(s)\n        if any(cnt[c] < k for c in \"abc\"):\n            return -1\n        mx = j = 0\n        for i, c in enumerate(s):\n            cnt[c] -= 1\n            while cnt[c] < k:\n                cnt[s[j]] += 1\n                j += 1\n            mx = max(mx, i - j + 1)\n        return len(s) - mx\n", "class Solution:\n  def takeCharacters(self, s: str, k: int) -> int:\n    n = len(s)\n    ans = n\n    count = collections.Counter(s)\n    if any(count[c] < k for c in 'abc'):\n      return -1\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] -= 1\n      while count[c] < k:\n        count[s[l]] += 1\n        l += 1\n      ans = min(ans, n - (r - l + 1))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2597, "slug": "the-number-of-beautiful-subsets", "solutions": ["class Solution:\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\n        def dfs(i: int) -> None:\n            nonlocal ans\n            if i >= len(nums):\n                ans += 1\n                return\n            dfs(i + 1)\n            if cnt[nums[i] + k] == 0 and cnt[nums[i] - k] == 0:\n                cnt[nums[i]] += 1\n                dfs(i + 1)\n                cnt[nums[i]] -= 1\n\n        ans = -1\n        cnt = Counter()\n        dfs(0)\n        return ans\n", "# e.g. nums = [2, 3, 4, 4], k = 2\n#\n# subset[0] = [2, 4, 4']\n# subset[1] = [1]\n# count = {2: 1, 4: 2, 1: 1}\n#\n# Initially, skip = len([]) = 0, pick = len([]) = 0\n#\n# * For values in subset[0]:\n#   After 2:\n#     skip = skip + pick = len([]) = 0\n#     pick = (2^count[2] - 1) * (1 + skip + pick)\n#          = len([[2]]) * len([[]])\n#          = len([[2]]) = 1\n#   After 4:\n#     skip = skip + pick = len([[2]]) = 1\n#     pick = (2^count[4] - 1) * (1 + skip)\n#          = len([[4], [4'], [4, 4']]) * len([[]])\n#          = len([[4], [4'], [4, 4']]) = 3\n#\n# * For values in subset[1]:\n#   After 1:\n#     skip = skip + pick\n#          = len([[2], [4], [4'], [4, 4']]) = 4\n#     pick = (2^count[1] - 1) * (1 + skip + pick)\n#          = len([[1]]) * len([[], [2], [4], [4'], [4, 4']])\n#          = len([[1], [1, 2], [1, 4], [1, 4'], [1, 4, 4']]) = 5\n#\n# So, ans = skip + pick = 9\n\nclass Solution:\n  def beautifulSubsets(self, nums: list[int], k: int) -> int:\n    count = collections.Counter(nums)\n    modToSubset = collections.defaultdict(set)\n\n    for num in nums:\n      modToSubset[num % k].add(num)\n\n    prevNum = -k\n    skip = 0\n    pick = 0\n\n    for subset in modToSubset.values():\n      for num in sorted(subset):\n        nonEmptyCount = 2**count[num] - 1\n        skip, pick = (skip + pick,\n                      nonEmptyCount *\n                      (1 + skip + (0 if num - prevNum == k else pick)))\n        prevNum = num\n\n    return skip + pick\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2556, "slug": "disconnect-path-in-a-binary-matrix-by-at-most-one-flip", "solutions": ["class Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        def dfs(i, j):\n            if i >= m or j >= n or grid[i][j] == 0:\n                return False\n            grid[i][j] = 0\n            if i == m - 1 and j == n - 1:\n                return True\n            return dfs(i + 1, j) or dfs(i, j + 1)\n\n        m, n = len(grid), len(grid[0])\n        a = dfs(0, 0)\n        grid[0][0] = grid[-1][-1] = 1\n        b = dfs(0, 0)\n        return not (a and b)\n", "class Solution:\n  def isPossibleToCutPath(self, grid: list[list[int]]) -> bool:\n    # Returns True is there's a path from (0, 0) to (m - 1, n - 1).\n    # Also marks the visited path as 0 except (m - 1, n - 1).\n    def hasPath(i: int, j: int) -> bool:\n      if i == len(grid) or j == len(grid[0]):\n        return False\n      if i == len(grid) - 1 and j == len(grid[0]) - 1:\n        return True\n      if grid[i][j] == 0:\n        return False\n\n      grid[i][j] = 0\n      # Go down first. Since we use OR logic, we'll only mark one path.\n      return hasPath(i + 1, j) or hasPath(i, j + 1)\n\n    if not hasPath(0, 0):\n      return True\n    # Reassign (0, 0) as 1.\n    grid[0][0] = 1\n    return not hasPath(0, 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2542, "slug": "maximum-subsequence-score", "solutions": ["class Solution:\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\n        nums = sorted(zip(nums2, nums1), reverse=True)\n        q = []\n        ans = s = 0\n        for a, b in nums:\n            s += b\n            heappush(q, b)\n            if len(q) == k:\n                ans = max(ans, s * a)\n                s -= heappop(q)\n        return ans\n", "class Solution:\n  # Same as 1383. Maximum Performance of a Team\n  def maxScore(self, nums1: list[int], nums2: list[int], k: int) -> int:\n    ans = 0\n    summ = 0\n    # (nums2[i], nums1[i]) sorted by nums2[i] in descending order\n    A = sorted([(num2, num1)\n               for num1, num2 in zip(nums1, nums2)], reverse=True)\n    minHeap = []\n\n    for num2, num1 in A:\n      heapq.heappush(minHeap, num1)\n      summ += num1\n      if len(minHeap) > k:\n        summ -= heapq.heappop(minHeap)\n      if len(minHeap) == k:\n        ans = max(ans, summ * num2)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2565, "slug": "subsequence-with-the-minimum-score", "solutions": ["class Solution:\n    def minimumScore(self, s: str, t: str) -> int:\n        def check(x):\n            for k in range(n):\n                i, j = k - 1, k + x\n                l = f[i] if i >= 0 else -1\n                r = g[j] if j < n else m + 1\n                if l < r:\n                    return True\n            return False\n\n        m, n = len(s), len(t)\n        f = [inf] * n\n        g = [-1] * n\n        i, j = 0, 0\n        while i < m and j < n:\n            if s[i] == t[j]:\n                f[j] = i\n                j += 1\n            i += 1\n        i, j = m - 1, n - 1\n        while i >= 0 and j >= 0:\n            if s[i] == t[j]:\n                g[j] = i\n                j -= 1\n            i -= 1\n\n        return bisect_left(range(n + 1), True, key=check)\n", "class Solution:\n  def minimumScore(self, s: str, t: str) -> int:\n    # leftmost[j] := the minimum index i s.t. t[0..j] is a subsequence of s[0..i].\n    #          -1 := impossible\n    leftmost = [-1] * len(t)\n    # rightmost[j] := the maximum index i s.t. t[j:] is a subsequence of s[i..n).\n    #           -1 := impossible\n    rightmost = [-1] * len(t)\n\n    j = 0  # t's index\n    for i in range(len(s)):\n      if s[i] == t[j]:\n        leftmost[j] = i\n        j += 1\n        if j == len(t):\n          break\n\n    j = len(t) - 1  # t's index\n    for i in reversed(range(len(s))):\n      if s[i] == t[j]:\n        rightmost[j] = i\n        j -= 1\n        if j == -1:\n          break\n\n    # The worst case is to delete t[0:j] since t[j:] is a subsequence of s. (deduced\n    # from the above loop).\n    ans = j + 1\n\n    j = 0\n    for i in range(len(t)):\n      # It's impossible that t[0..i] is a subsequence of s. So, stop the loop since\n      # no need to consider any larger i.\n      if leftmost[i] == -1:\n        break\n      # While t[0..i] + t[j:] is not a subsequence of s, increase j.\n      while j < len(t) and leftmost[i] >= rightmost[j]:\n        j += 1\n      # Now, leftmost[i] < rightmost[j], so t[0..i] + t[j:n] is a subsequence of s.\n      # If i == j that means t is a subsequence of s, so just return 0.\n      if i == j:\n        return 0\n      # Delete t[i + 1..j - 1] and that's a total of j - i - 1 letters.\n      ans = min(ans, j - i - 1)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2593, "slug": "find-score-of-an-array-after-marking-all-elements", "solutions": ["class Solution:\n    def findScore(self, nums: List[int]) -> int:\n        n = len(nums)\n        vis = [False] * n\n        q = [(x, i) for i, x in enumerate(nums)]\n        heapify(q)\n        ans = 0\n        while q:\n            x, i = heappop(q)\n            ans += x\n            vis[i] = True\n            for j in (i - 1, i + 1):\n                if 0 <= j < n:\n                    vis[j] = True\n            while q and vis[q[0][1]]:\n                heappop(q)\n        return ans\n", "class Solution:\n  def findScore(self, nums: list[int]) -> int:\n    ans = 0\n    seen = set()\n\n    for num, i in sorted([(num, i) for i, num in enumerate(nums)]):\n      if i in seen:\n        continue\n      seen.add(i - 1)\n      seen.add(i + 1)\n      seen.add(i)\n      ans += num\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2506, "slug": "count-pairs-of-similar-strings", "solutions": ["class Solution:\n    def similarPairs(self, words: List[str]) -> int:\n        ans = 0\n        cnt = Counter()\n        for s in words:\n            x = 0\n            for c in map(ord, s):\n                x |= 1 << (c - ord(\"a\"))\n            ans += cnt[x]\n            cnt[x] += 1\n        return ans\n", "class Solution:\n  def similarPairs(self, words: list[str]) -> int:\n    return sum(set(words[i]) == set(words[j])\n               for i in range(len(words))\n               for j in range(i + 1, len(words)))\n", "class Solution:\n  def similarPairs(self, words: list[str]) -> int:\n    ans = 0\n\n    def getMask(word: str) -> int:\n      mask = 0\n      for c in word:\n        mask |= 1 << ord(c) - ord('a')\n      return mask\n\n    masks = [getMask(word) for word in words]\n\n    for i in range(len(masks)):\n      for j in range(i + 1, len(masks)):\n        if masks[i] == masks[j]:\n          ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2523, "slug": "closest-prime-numbers-in-range", "solutions": ["class Solution:\n    def closestPrimes(self, left: int, right: int) -> List[int]:\n        cnt = 0\n        st = [False] * (right + 1)\n        prime = [0] * (right + 1)\n        for i in range(2, right + 1):\n            if not st[i]:\n                prime[cnt] = i\n                cnt += 1\n            j = 0\n            while prime[j] <= right // i:\n                st[prime[j] * i] = 1\n                if i % prime[j] == 0:\n                    break\n                j += 1\n        p = [v for v in prime[:cnt] if left <= v <= right]\n        mi = inf\n        ans = [-1, -1]\n        for a, b in pairwise(p):\n            if (d := b - a) < mi:\n                mi = d\n                ans = [a, b]\n        return ans\n", "class Solution:\n  def closestPrimes(self, left: int, right: int) -> list[int]:\n    isPrime = self._sieveEratosthenes(right + 1)\n    primes = [i for i in range(left, right + 1) if isPrime[i]]\n\n    if len(primes) < 2:\n      return [-1, -1]\n\n    minDiff = math.inf\n    num1 = -1\n    num2 = -1\n\n    for a, b in zip(primes, primes[1:]):\n      diff = b - a\n      if diff < minDiff:\n        minDiff = diff\n        num1 = a\n        num2 = b\n\n    return [num1, num2]\n\n  def _sieveEratosthenes(self, n: int) -> list[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2573, "slug": "find-the-string-with-lcp", "solutions": ["class Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        n = len(lcp)\n        s = [\"\"] * n\n        i = 0\n        for c in ascii_lowercase:\n            while i < n and s[i]:\n                i += 1\n            if i == n:\n                break\n            for j in range(i, n):\n                if lcp[i][j]:\n                    s[j] = c\n        if \"\" in s:\n            return \"\"\n        for i in range(n - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                if s[i] == s[j]:\n                    if i == n - 1 or j == n - 1:\n                        if lcp[i][j] != 1:\n                            return \"\"\n                    elif lcp[i][j] != lcp[i + 1][j + 1] + 1:\n                        return \"\"\n                elif lcp[i][j]:\n                    return \"\"\n        return \"\".join(s)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2594, "slug": "minimum-time-to-repair-cars", "solutions": ["class Solution:\n    def repairCars(self, ranks: List[int], cars: int) -> int:\n        def check(t: int) -> bool:\n            return sum(int(sqrt(t // r)) for r in ranks) >= cars\n\n        return bisect_left(range(ranks[0] * cars * cars), True, key=check)\n", "class Solution:\n  def repairCars(self, ranks: list[int], cars: int) -> int:\n    def numCarsFixed(minutes: int) -> int:\n      #    r * n^2 = minutes\n      # -> n = sqrt(minutes / r)\n      return sum(math.isqrt(minutes // rank) for rank in ranks)\n\n    return bisect.bisect_left(range(min(ranks) * cars**2), cars,\n                              key=numCarsFixed)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2574, "slug": "left-and-right-sum-differences", "solutions": ["class Solution:\n    def leftRigthDifference(self, nums: List[int]) -> List[int]:\n        left, right = 0, sum(nums)\n        ans = []\n        for x in nums:\n            right -= x\n            ans.append(abs(left - right))\n            left += x\n        return ans\n", "class Solution:\n  def leftRigthDifference(self, nums: list[int]) -> list[int]:\n    ans = []\n    leftSum = 0\n    rightSum = sum(nums)\n\n    for num in nums:\n      rightSum -= num\n      ans.append(abs(leftSum - rightSum))\n      leftSum += num\n\n    return ans\n", "class Solution:\n  def leftRigthDifference(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n    leftSum = [0] * n\n    rightSum = [0] * n\n    prefix = 0\n    suffix = 0\n\n    for i in range(n):\n      if i > 0:\n        prefix += nums[i - 1]\n      leftSum[i] = prefix\n\n    for i in range(n - 1, -1, -1):\n      if i + 1 < n:\n        suffix += nums[i + 1]\n      rightSum[i] = suffix\n\n    return [abs(l - r) for l, r in zip(leftSum, rightSum)]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2575, "slug": "find-the-divisibility-array-of-a-string", "solutions": ["class Solution:\n    def divisibilityArray(self, word: str, m: int) -> List[int]:\n        ans = []\n        x = 0\n        for c in word:\n            x = (x * 10 + int(c)) % m\n            ans.append(1 if x == 0 else 0)\n        return ans\n", "class Solution:\n  def divisibilityArray(self, word: str, m: int) -> list[int]:\n    ans = []\n    prevRemainder = 0\n\n    for c in word:\n      remainder = (prevRemainder * 10 + int(c)) % m\n      ans.append(1 if remainder == 0 else 0)\n      prevRemainder = remainder\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2588, "slug": "count-the-number-of-beautiful-subarrays", "solutions": ["class Solution:\n    def beautifulSubarrays(self, nums: List[int]) -> int:\n        cnt = Counter({0: 1})\n        ans = mask = 0\n        for x in nums:\n            mask ^= x\n            ans += cnt[mask]\n            cnt[mask] += 1\n        return ans\n", "class Solution:\n  def beautifulSubarrays(self, nums: list[int]) -> int:\n    # A subarray is beautiful if xor(subarray) = 0.\n    ans = 0\n    prefix = 0\n    prefixCount = collections.Counter({0: 1})\n\n    for num in nums:\n      prefix ^= num\n      ans += prefixCount[prefix]\n      prefixCount[prefix] += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2522, "slug": "partition-string-into-substrings-with-values-at-most-k", "solutions": ["class Solution:\n    def minimumPartition(self, s: str, k: int) -> int:\n        @cache\n        def dfs(i):\n            if i >= n:\n                return 0\n            res, v = inf, 0\n            for j in range(i, n):\n                v = v * 10 + int(s[j])\n                if v > k:\n                    break\n                res = min(res, dfs(j + 1))\n            return res + 1\n\n        n = len(s)\n        ans = dfs(0)\n        return ans if ans < inf else -1\n", "class Solution:\n  def minimumPartition(self, s: str, k: int) -> int:\n    ans = 1\n    curr = 0\n\n    for c in s:\n      curr = curr * 10 + int(c)\n      if curr > k:\n        curr = int(c)\n        ans += 1\n      if curr > k:\n        return -1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2548, "slug": "maximum-price-to-fill-a-bag", "solutions": ["class Solution:\n    def maxPrice(self, items: List[List[int]], capacity: int) -> float:\n        ans = 0\n        for p, w in sorted(items, key=lambda x: x[1] / x[0]):\n            v = min(w, capacity)\n            ans += v / w * p\n            capacity -= v\n        return -1 if capacity else ans\n", "class Solution:\n  def maxPrice(self, items: list[list[int]], capacity: int) -> float:\n    ans = 0\n\n    # Sort items based on price//weight.\n    for price, weight in sorted(items, key=lambda x: -x[0] / x[1]):\n      # The bag is filled.\n      if capacity <= weight:\n        return ans + price * capacity / weight\n      ans += price\n      capacity -= weight\n\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2510, "slug": "check-if-there-is-a-path-with-equal-number-of-0s-and-1s", "solutions": ["class Solution:\n    def isThereAPath(self, grid: List[List[int]]) -> bool:\n        @cache\n        def dfs(i, j, k):\n            if i >= m or j >= n:\n                return False\n            k += grid[i][j]\n            if k > s or i + j + 1 - k > s:\n                return False\n            if i == m - 1 and j == n - 1:\n                return k == s\n            return dfs(i + 1, j, k) or dfs(i, j + 1, k)\n\n        m, n = len(grid), len(grid[0])\n        s = m + n - 1\n        if s & 1:\n            return False\n        s >>= 1\n        return dfs(0, 0, 0)\n", "class Solution:\n  def isThereAPath(self, grid: list[list[int]]) -> bool:\n    m = len(grid)\n    n = len(grid[0])\n    if m + n - 1 & 1:\n      return False\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, summ: int) -> bool:\n      \"\"\"\n      Returns 1 if there's a path to grid[i][j] s.t.\n      `summ` = (the number of 0s - the number of 1s).\n      \"\"\"\n      if i == m or j == n:\n        return False\n      summ += 1 if grid[i][j] == 0 else -1\n      if i == m - 1 and j == n - 1:\n        return summ == 0\n      return dp(i + 1, j, summ) or dp(i, j + 1, summ)\n\n    return dp(0, 0, 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2534, "slug": "time-taken-to-cross-the-door", "solutions": ["class Solution:\n    def timeTaken(self, arrival: List[int], state: List[int]) -> List[int]:\n        q = [deque(), deque()]\n        n = len(arrival)\n        t = i = 0\n        st = 1\n        ans = [0] * n\n        while i < n or q[0] or q[1]:\n            while i < n and arrival[i] <= t:\n                q[state[i]].append(i)\n                i += 1\n            if q[0] and q[1]:\n                ans[q[st].popleft()] = t\n            elif q[0] or q[1]:\n                st = 0 if q[0] else 1\n                ans[q[st].popleft()] = t\n            else:\n                st = 1\n            t += 1\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2577, "slug": "minimum-time-to-visit-a-cell-in-a-grid", "solutions": ["class Solution:\n    def minimumTime(self, grid: List[List[int]]) -> int:\n        if grid[0][1] > 1 and grid[1][0] > 1:\n            return -1\n        m, n = len(grid), len(grid[0])\n        dist = [[inf] * n for _ in range(m)]\n        dist[0][0] = 0\n        q = [(0, 0, 0)]\n        dirs = (-1, 0, 1, 0, -1)\n        while 1:\n            t, i, j = heappop(q)\n            if i == m - 1 and j == n - 1:\n                return t\n            for a, b in pairwise(dirs):\n                x, y = i + a, j + b\n                if 0 <= x < m and 0 <= y < n:\n                    nt = t + 1\n                    if nt < grid[x][y]:\n                        nt = grid[x][y] + (grid[x][y] - nt) % 2\n                    if nt < dist[x][y]:\n                        dist[x][y] = nt\n                        heappush(q, (nt, x, y))\n", "class Solution:\n  def minimumTime(self, grid: list[list[int]]) -> int:\n    if grid[0][1] > 1 and grid[1][0] > 1:\n      return -1\n\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    minHeap = [(0, 0, 0)]  # (time, i, j)\n    seen = {(0, 0)}\n\n    while minHeap:\n      time, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        return time\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if (x, y) in seen:\n          continue\n        extraWait = 1 if (grid[x][y] - time) % 2 == 0 else 0\n        nextTime = max(time + 1, grid[x][y] + extraWait)\n        heapq.heappush(minHeap, (nextTime, x, y))\n        seen.add((x, y))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2531, "slug": "make-number-of-distinct-characters-equal", "solutions": ["class Solution:\n    def isItPossible(self, word1: str, word2: str) -> bool:\n        cnt1 = Counter(word1)\n        cnt2 = Counter(word2)\n        x, y = len(cnt1), len(cnt2)\n        for c1, v1 in cnt1.items():\n            for c2, v2 in cnt2.items():\n                if c1 == c2:\n                    if x == y:\n                        return True\n                else:\n                    a = x - (v1 == 1) + (cnt1[c2] == 0)\n                    b = y - (v2 == 1) + (cnt2[c1] == 0)\n                    if a == b:\n                        return True\n        return False\n", "class Solution:\n  def isItPossible(self, word1: str, word2: str) -> bool:\n    count1 = collections.Counter(word1)\n    count2 = collections.Counter(word2)\n    distinct1 = len(count1)\n    distinct2 = len(count2)\n\n    for a in count1:\n      for b in count2:\n        if a == b:\n          # Swapping the same letters won't change the number of distinct\n          # letters in each string, so just check if `distinct1 == distinct2`.\n          if distinct1 == distinct2:\n            return True\n          continue\n        # The calculation is meaningful only when a != b\n        # Swap a in word1 with b in word2.\n        distinctAfterSwap1 = distinct1 - (count1[a] == 1) + (count1[b] == 0)\n        distinctAfterSwap2 = distinct2 - (count2[b] == 1) + (count2[a] == 0)\n        if distinctAfterSwap1 == distinctAfterSwap2:\n          return True\n\n    return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2530, "slug": "maximal-score-after-applying-k-operations", "solutions": ["class Solution:\n    def maxKelements(self, nums: List[int], k: int) -> int:\n        h = [-v for v in nums]\n        heapify(h)\n        ans = 0\n        for _ in range(k):\n            v = -heappop(h)\n            ans += v\n            heappush(h, -(ceil(v / 3)))\n        return ans\n", "class Solution:\n  def maxKelements(self, nums: list[int], k: int) -> int:\n    ans = 0\n    maxHeap = [-num for num in nums]\n    heapq.heapify(maxHeap)\n\n    for _ in range(k):\n      num = -heapq.heappop(maxHeap)\n      ans += num\n      heapq.heappush(maxHeap, -math.ceil(num / 3))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2555, "slug": "maximize-win-from-two-segments", "solutions": ["class Solution:\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\n        n = len(prizePositions)\n        f = [0] * (n + 1)\n        ans = 0\n        for i, x in enumerate(prizePositions, 1):\n            j = bisect_left(prizePositions, x - k)\n            ans = max(ans, f[j] + i - j)\n            f[i] = max(f[i - 1], i - j)\n        return ans\n", "class Solution:\n  def maximizeWin(self, prizePositions: list[int], k: int) -> int:\n    ans = 0\n    # dp[i] := the maximum number of prizes to choose the first i\n    # `prizePositions`\n    dp = [0] * (len(prizePositions) + 1)\n\n    j = 0\n    for i, prizePosition in enumerate(prizePositions):\n      while prizePosition - prizePositions[j] > k:\n        j += 1\n      covered = i - j + 1\n      dp[i + 1] = max(dp[i], covered)\n      ans = max(ans, dp[j] + covered)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2566, "slug": "maximum-difference-by-remapping-a-digit", "solutions": ["class Solution:\n    def minMaxDifference(self, num: int) -> int:\n        s = str(num)\n        mi = int(s.replace(s[0], '0'))\n        for c in s:\n            if c != '9':\n                return int(s.replace(c, '9')) - mi\n        return num - mi\n", "class Solution:\n  def minMaxDifference(self, num: int) -> int:\n    s = str(num)\n    to9 = s[self._firstNotNineIndex(s)]\n    to0 = s[0]\n    return int(s.replace(to9, '9')) - int(s.replace(to0, '0'))\n\n  def _firstNotNineIndex(self, s: str) -> int:\n    for i, c in enumerate(s):\n      if c != '9':\n        return i\n    return 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2538, "slug": "difference-between-maximum-and-minimum-price-sum", "solutions": ["class Solution:\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\n        def dfs(i, fa):\n            a, b = price[i], 0\n            for j in g[i]:\n                if j != fa:\n                    c, d = dfs(j, i)\n                    nonlocal ans\n                    ans = max(ans, a + d, b + c)\n                    a = max(a, price[i] + c)\n                    b = max(b, price[i] + d)\n            return a, b\n\n        g = defaultdict(list)\n        for a, b in edges:\n            g[a].append(b)\n            g[b].append(a)\n        ans = 0\n        dfs(0, -1)\n        return ans\n", "class Solution:\n  def maxOutput(self, n: int, edges: list[list[int]], price: list[int]) -> int:\n    ans = 0\n    tree = [[] for _ in range(n)]\n    maxSums = [0] * n  # maxSums[i] := the maximum the sum of path rooted at i\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def maxSum(u: int, prev: int) -> int:\n      maxChildSum = 0\n      for v in tree[u]:\n        if v != prev:\n          maxChildSum = max(maxChildSum, maxSum(v, u))\n      maxSums[u] = price[u] + maxChildSum\n      return maxSums[u]\n\n    # Precalculate `maxSums`.\n    maxSum(0, -1)\n\n    def reroot(u: int, prev: int, parentSum: int) -> None:\n      nonlocal ans\n      # Get the top two subtree sums and the top one node index.\n      maxSubtreeSum1 = 0\n      maxSubtreeSum2 = 0\n      maxNode = -1\n      for v in tree[u]:\n        if v == prev:\n          continue\n        if maxSums[v] > maxSubtreeSum1:\n          maxSubtreeSum2 = maxSubtreeSum1\n          maxSubtreeSum1 = maxSums[v]\n          maxNode = v\n        elif maxSums[v] > maxSubtreeSum2:\n          maxSubtreeSum2 = maxSums[v]\n\n      if len(tree[u]) == 1:\n        ans = max(ans, parentSum, maxSubtreeSum1)\n\n      for v in tree[u]:\n        if v == prev:\n          continue\n        nextParentSum = (\n            price[u] + max(parentSum, maxSubtreeSum2) if v == maxNode else\n            price[u] + max(parentSum, maxSubtreeSum1))\n        reroot(v, u, nextParentSum)\n\n    reroot(0, -1, 0)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2527, "slug": "find-xor-beauty-of-array", "solutions": ["class Solution:\n    def xorBeauty(self, nums: List[int]) -> int:\n        return reduce(xor, nums)\n", "class Solution:\n  def xorBeauty(self, nums: list[int]) -> int:\n    return functools.reduce(operator.xor, nums)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2547, "slug": "minimum-cost-to-split-an-array", "solutions": ["class Solution:\n    def minCost(self, nums: List[int], k: int) -> int:\n        @cache\n        def dfs(i):\n            if i >= n:\n                return 0\n            cnt = Counter()\n            one = 0\n            ans = inf\n            for j in range(i, n):\n                cnt[nums[j]] += 1\n                if cnt[nums[j]] == 1:\n                    one += 1\n                elif cnt[nums[j]] == 2:\n                    one -= 1\n                ans = min(ans, k + j - i + 1 - one + dfs(j + 1))\n            return ans\n\n        n = len(nums)\n        return dfs(0)\n", "class Solution:\n  def minCost(self, nums: list[int], k: int) -> int:\n    MAX = 1001\n    n = len(nums)\n    # trimmedLength[i][j] := trimmed(nums[i..j]).length\n    trimmedLength = [[0] * n for _ in range(n)]\n    # dp[i] := the minimum cost to split nums[i..n)\n    dp = [math.inf] * n + [0]\n\n    for i in range(n):\n      length = 0\n      count = [0] * MAX\n      for j in range(i, n):\n        count[nums[j]] += 1\n        if count[nums[j]] == 2:\n          length += 2\n        elif count[nums[j]] > 2:\n          length += 1\n        trimmedLength[i][j] = length\n\n    dp[n] = 0\n\n    for i in range(n - 1, -1, -1):\n      for j in range(i, n):\n        dp[i] = min(dp[i], k + trimmedLength[i][j] + dp[j + 1])\n\n    return dp[0]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2536, "slug": "increment-submatrices-by-one", "solutions": ["class Solution:\n    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:\n        mat = [[0] * n for _ in range(n)]\n        for x1, y1, x2, y2 in queries:\n            mat[x1][y1] += 1\n            if x2 + 1 < n:\n                mat[x2 + 1][y1] -= 1\n            if y2 + 1 < n:\n                mat[x1][y2 + 1] -= 1\n            if x2 + 1 < n and y2 + 1 < n:\n                mat[x2 + 1][y2 + 1] += 1\n\n        for i in range(n):\n            for j in range(n):\n                if i:\n                    mat[i][j] += mat[i - 1][j]\n                if j:\n                    mat[i][j] += mat[i][j - 1]\n                if i and j:\n                    mat[i][j] -= mat[i - 1][j - 1]\n        return mat\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2503, "slug": "maximum-number-of-points-from-grid-queries", "solutions": ["class Solution:\n    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\n        m, n = len(grid), len(grid[0])\n        qs = sorted((v, i) for i, v in enumerate(queries))\n        ans = [0] * len(qs)\n        q = [(grid[0][0], 0, 0)]\n        cnt = 0\n        vis = [[False] * n for _ in range(m)]\n        vis[0][0] = True\n        for v, k in qs:\n            while q and q[0][0] < v:\n                _, i, j = heappop(q)\n                cnt += 1\n                for a, b in pairwise((-1, 0, 1, 0, -1)):\n                    x, y = i + a, j + b\n                    if 0 <= x < m and 0 <= y < n and not vis[x][y]:\n                        heappush(q, (grid[x][y], x, y))\n                        vis[x][y] = True\n            ans[k] = cnt\n        return ans\n", "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass IndexedQuery:\n  queryIndex: int\n  query: int\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.query\n\n\nclass Solution:\n  def maxPoints(self, grid: list[list[int]], queries: list[int]) -> list[int]:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    ans = [0] * len(queries)\n    minHeap = [(grid[0][0], 0, 0)]  # (grid[i][j], i, j)\n    seen = {(0, 0)}\n    accumulate = 0\n\n    for queryIndex, query in sorted([IndexedQuery(i, query)\n                                     for i, query in enumerate(queries)],\n                                    key=lambda x: x.query):\n      while minHeap:\n        val, i, j = heapq.heappop(minHeap)\n        if val >= query:\n          # The smallest neighbor is still larger than `query`, so no need to\n          # keep exploring. Re-push (i, j, grid[i][j]) back to the `minHeap`.\n          heapq.heappush(minHeap, (val, i, j))\n          break\n        accumulate += 1\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          heapq.heappush(minHeap, (grid[x][y], x, y))\n          seen.add((x, y))\n      ans[queryIndex] = accumulate\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2561, "slug": "rearranging-fruits", "solutions": ["class Solution:\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\n        cnt = Counter()\n        for a, b in zip(basket1, basket2):\n            cnt[a] += 1\n            cnt[b] -= 1\n        mi = min(cnt)\n        nums = []\n        for x, v in cnt.items():\n            if v % 2:\n                return -1\n            nums.extend([x] * (abs(v) // 2))\n        nums.sort()\n        m = len(nums) // 2\n        return sum(min(x, mi * 2) for x in nums[:m])\n", "class Solution:\n  def minCost(self, basket1: list[int], basket2: list[int]) -> int:\n    swapped = []\n    count = collections.Counter(basket1)\n    count.subtract(collections.Counter(basket2))\n\n    for num, freq in count.items():\n      if freq % 2 != 0:\n        return -1\n      swapped += [num] * abs(freq // 2)\n\n    swapped.sort()\n    minNum = min(min(basket1), min(basket2))\n    # Other than directly swap basket1[i] and basket2[j], we can swap basket1[i]\n    # with `minNum` first then swap `minNum` with basket2[j], and vice versa.\n    # That's why we take min(2 * minNum, num) in the below.\n    return sum(min(2 * minNum, num) for num in swapped[0:len(swapped) // 2])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 787, "slug": "cheapest-flights-within-k-stops", "solutions": ["class Solution:\n    def findCheapestPrice(\n        self, n: int, flights: List[List[int]], src: int, dst: int, k: int\n    ) -> int:\n        INF = 0x3F3F3F3F\n        dist = [INF] * n\n        dist[src] = 0\n        for _ in range(k + 1):\n            backup = dist.copy()\n            for f, t, p in flights:\n                dist[t] = min(dist[t], backup[f] + p)\n        return -1 if dist[dst] == INF else dist[dst]\n", "class Solution:\n  def findCheapestPrice(\n      self,\n      n: int,\n      flights: list[list[int]],\n      src: int,\n      dst: int,\n      k: int,\n  ) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in flights:\n      graph[u].append((v, w))\n\n    return self._dijkstra(graph, src, dst, k)\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n      dst: int,\n      k: int,\n  ) -> int:\n    dist = [[math.inf] * (k + 2) for _ in range(len(graph))]\n\n    dist[src][k + 1] = 0\n    minHeap = [(dist[src][k + 1], src, k + 1)]  # (d, u, stops)\n\n    while minHeap:\n      d, u, stops = heapq.heappop(minHeap)\n      if u == dst:\n        return d\n      if stops == 0 or d > dist[u][stops]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v][stops - 1]:\n          dist[v][stops - 1] = d + w\n          heapq.heappush(minHeap, (dist[v][stops - 1], v, stops - 1))\n\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 754, "slug": "reach-a-number", "solutions": ["class Solution:\n    def reachNumber(self, target: int) -> int:\n        target = abs(target)\n        s = k = 0\n        while 1:\n            if s >= target and (s - target) % 2 == 0:\n                return k\n            k += 1\n            s += k\n", "class Solution:\n  def reachNumber(self, target: int) -> int:\n    ans = 0\n    pos = 0\n    target = abs(target)\n\n    while pos < target:\n      ans += 1\n      pos += ans\n\n    while (pos - target) % 2 == 1:\n      ans += 1\n      pos += ans\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 795, "slug": "number-of-subarrays-with-bounded-maximum", "solutions": ["class Solution:\n    def numSubarrayBoundedMax(self, nums: List[int], left: int, right: int) -> int:\n        def f(x):\n            cnt = t = 0\n            for v in nums:\n                t = 0 if v > x else t + 1\n                cnt += t\n            return cnt\n\n        return f(right) - f(left - 1)\n", "class Solution:\n  def numSubarrayBoundedMax(\n      self,\n      nums: list[int],\n      left: int,\n      right: int,\n  ) -> int:\n    ans = 0\n    l = -1\n    r = -1\n\n    for i, num in enumerate(nums):\n      if num > right:  # Handle the reset value.\n        l = i\n      if num >= left:  # Handle the reset and the needed value.\n        r = i\n      ans += r - l\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 700, "slug": "search-in-a-binary-search-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\n        if root is None or root.val == val:\n            return root\n        return (\n            self.searchBST(root.left, val)\n            if root.val > val\n            else self.searchBST(root.right, val)\n        )\n", "class Solution:\n  def searchBST(self, root: TreeNode | None, val: int) -> TreeNode | None:\n    if not root:\n      return None\n    if root.val == val:\n      return root\n    if root.val > val:\n      return self.searchBST(root.left, val)\n    return self.searchBST(root.right, val)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 794, "slug": "valid-tic-tac-toe-state", "solutions": ["class Solution:\n    def validTicTacToe(self, board: List[str]) -> bool:\n        def win(x):\n            for i in range(3):\n                if all(board[i][j] == x for j in range(3)):\n                    return True\n                if all(board[j][i] == x for j in range(3)):\n                    return True\n            if all(board[i][i] == x for i in range(3)):\n                return True\n            return all(board[i][2 - i] == x for i in range(3))\n\n        x = sum(board[i][j] == 'X' for i in range(3) for j in range(3))\n        o = sum(board[i][j] == 'O' for i in range(3) for j in range(3))\n        if x != o and x - 1 != o:\n            return False\n        if win('X') and x - 1 != o:\n            return False\n        return not (win('O') and x != o)\n", "class Solution:\n  def validTicTacToe(self, board: list[str]) -> bool:\n    def isWin(c: str) -> bool:\n      return (any(row.count(c) == 3 for row in board) or\n              any(row.count(c) == 3 for row in list(zip(*board))) or\n              all(board[i][i] == c for i in range(3)) or\n              all(board[i][2 - i] == c for i in range(3)))\n\n    countX = sum(row.count('X') for row in board)\n    countO = sum(row.count('O') for row in board)\n\n    if countX < countO or countX - countO > 1:\n      return False\n    if isWin('X') and countX == countO or isWin('O') and countX != countO:\n      return False\n\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 769, "slug": "max-chunks-to-make-sorted", "solutions": ["class Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        mx = ans = 0\n        for i, v in enumerate(arr):\n            mx = max(mx, v)\n            if i == mx:\n                ans += 1\n        return ans\n", "class Solution:\n  def maxChunksToSorted(self, arr: list[int]) -> int:\n    ans = 0\n    mx = -math.inf\n\n    for i, a in enumerate(arr):\n      mx = max(mx, a)\n      if mx == i:\n        ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 723, "slug": "candy-crush", "solutions": ["class Solution:\n    def candyCrush(self, board: List[List[int]]) -> List[List[int]]:\n        m, n = len(board), len(board[0])\n        run = True\n        while run:\n            run = False\n            for i in range(m):\n                for j in range(2, n):\n                    if board[i][j] and abs(board[i][j]) == abs(board[i][j - 1]) == abs(\n                        board[i][j - 2]\n                    ):\n                        run = True\n                        board[i][j] = board[i][j - 1] = board[i][j - 2] = -abs(\n                            board[i][j]\n                        )\n            for j in range(n):\n                for i in range(2, m):\n                    if board[i][j] and abs(board[i][j]) == abs(board[i - 1][j]) == abs(\n                        board[i - 2][j]\n                    ):\n                        run = True\n                        board[i][j] = board[i - 1][j] = board[i - 2][j] = -abs(\n                            board[i][j]\n                        )\n            if run:\n                for j in range(n):\n                    k = m - 1\n                    for i in range(m - 1, -1, -1):\n                        if board[i][j] > 0:\n                            board[k][j] = board[i][j]\n                            k -= 1\n                    while k >= 0:\n                        board[k][j] = 0\n                        k -= 1\n        return board\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 756, "slug": "pyramid-transition-matrix", "solutions": ["class Solution:\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\n        @cache\n        def dfs(s):\n            if len(s) == 1:\n                return True\n            t = []\n            for a, b in pairwise(s):\n                cs = d[a, b]\n                if not cs:\n                    return False\n                t.append(cs)\n            return any(dfs(''.join(nxt)) for nxt in product(*t))\n\n        d = defaultdict(list)\n        for a, b, c in allowed:\n            d[a, b].append(c)\n        return dfs(bottom)\n", "class Solution:\n  def pyramidTransition(self, bottom: str, allowed: list[str]) -> bool:\n    prefixToBlocks = collections.defaultdict(list)\n\n    for a in allowed:\n      prefixToBlocks[a[:2]].append(a[2])\n\n    def dfs(row: str, nextRow: str, i: int) -> bool:\n      if len(row) == 1:\n        return True\n      if len(nextRow) + 1 == len(row):\n        return dfs(nextRow, '', 0)\n\n      for c in prefixToBlocks[row[i:i + 2]]:\n        if dfs(row, nextRow + c, i + 1):\n          return True\n\n      return False\n\n    return dfs(bottom, '', 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 707, "slug": "design-linked-list", "solutions": ["class MyLinkedList:\n    def __init__(self):\n        self.dummy = ListNode()\n        self.cnt = 0\n\n    def get(self, index: int) -> int:\n        if index < 0 or index >= self.cnt:\n            return -1\n        cur = self.dummy.next\n        for _ in range(index):\n            cur = cur.next\n        return cur.val\n\n    def addAtHead(self, val: int) -> None:\n        self.addAtIndex(0, val)\n\n    def addAtTail(self, val: int) -> None:\n        self.addAtIndex(self.cnt, val)\n\n    def addAtIndex(self, index: int, val: int) -> None:\n        if index > self.cnt:\n            return\n        pre = self.dummy\n        for _ in range(index):\n            pre = pre.next\n        pre.next = ListNode(val, pre.next)\n        self.cnt += 1\n\n    def deleteAtIndex(self, index: int) -> None:\n        if index >= self.cnt:\n            return\n        pre = self.dummy\n        for _ in range(index):\n            pre = pre.next\n        t = pre.next\n        pre.next = t.next\n        t.next = None\n        self.cnt -= 1\n\n\n# Your MyLinkedList object will be instantiated and called as such:\n# obj = MyLinkedList()\n# param_1 = obj.get(index)\n# obj.addAtHead(val)\n# obj.addAtTail(val)\n# obj.addAtIndex(index,val)\n# obj.deleteAtIndex(index)\n", "from dataclasses import dataclass\n\n\n@dataclass\nclass ListNode:\n  val: int\n  next: ListNode | None = None\n\n\nclass MyLinkedList:\n  def __init__(self):\n    self.length = 0\n    self.dummy = ListNode(0)\n\n  def get(self, index: int) -> int:\n    if index < 0 or index >= self.length:\n      return -1\n    curr = self.dummy.next\n    for _ in range(index):\n      curr = curr.next\n    return curr.val\n\n  def addAtHead(self, val: int) -> None:\n    curr = self.dummy.next\n    self.dummy.next = ListNode(val)\n    self.dummy.next.next = curr\n    self.length += 1\n\n  def addAtTail(self, val: int) -> None:\n    curr = self.dummy\n    while curr.next:\n      curr = curr.next\n    curr.next = ListNode(val)\n    self.length += 1\n\n  def addAtIndex(self, index: int, val: int) -> None:\n    if index > self.length:\n      return\n    curr = self.dummy\n    for _ in range(index):\n      curr = curr.next\n    temp = curr.next\n    curr.next = ListNode(val)\n    curr.next.next = temp\n    self.length += 1\n\n  def deleteAtIndex(self, index: int) -> None:\n    if index < 0 or index >= self.length:\n      return\n    curr = self.dummy\n    for _ in range(index):\n      curr = curr.next\n    temp = curr.next\n    curr.next = temp.next\n    self.length -= 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 713, "slug": "subarray-product-less-than-k", "solutions": ["class Solution:\n    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:\n        ans = l = 0\n        p = 1\n        for r, x in enumerate(nums):\n            p *= x\n            while l <= r and p >= k:\n                p //= nums[l]\n                l += 1\n            ans += r - l + 1\n        return ans\n", "class Solution:\n  def numSubarrayProductLessThanK(self, nums: list[int], k: int) -> int:\n    if k <= 1:\n      return 0\n\n    ans = 0\n    prod = 1\n\n    j = 0\n    for i, num in enumerate(nums):\n      prod *= num\n      while prod >= k:\n        prod /= nums[j]\n        j += 1\n      ans += i - j + 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 718, "slug": "maximum-length-of-repeated-subarray", "solutions": ["class Solution:\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\n        m, n = len(nums1), len(nums2)\n        f = [[0] * (n + 1) for _ in range(m + 1)]\n        ans = 0\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if nums1[i - 1] == nums2[j - 1]:\n                    f[i][j] = f[i - 1][j - 1] + 1\n                    ans = max(ans, f[i][j])\n        return ans\n", "class Solution:\n  def findLength(self, nums1: list[int], nums2: list[int]) -> int:\n    m = len(nums1)\n    n = len(nums2)\n    ans = 0\n    # dp[i][j] := the maximum length of a subarray that appears in both\n    # nums1[i..m) and nums2[j..n)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in reversed(range(m)):\n      for j in reversed(range(n)):\n        if nums1[i] == nums2[j]:\n          dp[i][j] = dp[i + 1][j + 1] + 1\n          ans = max(ans, dp[i][j])\n\n    return ans\n", "class Solution:\n  def findLength(self, nums1: list[int], nums2: list[int]) -> int:\n    ans = 0\n    dp = [0] * (len(nums2) + 1)\n\n    for a in reversed(nums1):\n      for j, b in enumerate(nums2):  # The order is important.\n        dp[j] = dp[j + 1] + 1 if a == b else 0\n        ans = max(ans, dp[j])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 793, "slug": "preimage-size-of-factorial-zeroes-function", "solutions": ["class Solution:\n    def preimageSizeFZF(self, k: int) -> int:\n        def f(x):\n            if x == 0:\n                return 0\n            return x // 5 + f(x // 5)\n\n        def g(k):\n            return bisect_left(range(5 * k), k, key=f)\n\n        return g(k + 1) - g(k)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 778, "slug": "swim-in-rising-water", "solutions": ["class Solution:\n    def swimInWater(self, grid: List[List[int]]) -> int:\n        def find(x):\n            if p[x] != x:\n                p[x] = find(p[x])\n            return p[x]\n\n        n = len(grid)\n        p = list(range(n * n))\n        hi = [0] * (n * n)\n        for i, row in enumerate(grid):\n            for j, h in enumerate(row):\n                hi[h] = i * n + j\n        for t in range(n * n):\n            i, j = hi[t] // n, hi[t] % n\n            for a, b in [(0, -1), (0, 1), (1, 0), (-1, 0)]:\n                x, y = i + a, j + b\n                if 0 <= x < n and 0 <= y < n and grid[x][y] <= t:\n                    p[find(x * n + y)] = find(hi[t])\n                if find(0) == find(n * n - 1):\n                    return t\n        return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 712, "slug": "minimum-ascii-delete-sum-for-two-strings", "solutions": ["class Solution:\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\n        m, n = len(s1), len(s2)\n        f = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            f[i][0] = f[i - 1][0] + ord(s1[i - 1])\n        for j in range(1, n + 1):\n            f[0][j] = f[0][j - 1] + ord(s2[j - 1])\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if s1[i - 1] == s2[j - 1]:\n                    f[i][j] = f[i - 1][j - 1]\n                else:\n                    f[i][j] = min(\n                        f[i - 1][j] + ord(s1[i - 1]), f[i][j - 1] + ord(s2[j - 1])\n                    )\n        return f[m][n]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 737, "slug": "sentence-similarity-ii", "solutions": ["class Solution:\n    def areSentencesSimilarTwo(\n        self, sentence1: List[str], sentence2: List[str], similarPairs: List[List[str]]\n    ) -> bool:\n        if len(sentence1) != len(sentence2):\n            return False\n        n = len(similarPairs)\n        p = list(range(n << 1))\n\n        def find(x):\n            if p[x] != x:\n                p[x] = find(p[x])\n            return p[x]\n\n        words = {}\n        idx = 0\n        for a, b in similarPairs:\n            if a not in words:\n                words[a] = idx\n                idx += 1\n            if b not in words:\n                words[b] = idx\n                idx += 1\n            p[find(words[a])] = find(words[b])\n\n        for i in range(len(sentence1)):\n            if sentence1[i] == sentence2[i]:\n                continue\n            if (\n                sentence1[i] not in words\n                or sentence2[i] not in words\n                or find(words[sentence1[i]]) != find(words[sentence2[i]])\n            ):\n                return False\n        return True\n", "class Solution:\n  def areSentencesSimilarTwo(\n      self,\n      words1: list[str],\n      words2: list[str],\n      pairs: list[list[str]],\n  ) -> bool:\n    if len(words1) != len(words2):\n      return False\n\n    # graph[key] := all the similar words of key\n    graph = collections.defaultdict(set)\n\n    for a, b in pairs:\n      graph[a].add(b)\n      graph[b].add(a)\n\n    def dfs(word1: str, word2: str, seen: set) -> bool:\n      if word1 in graph[word2]:\n        return True\n\n      seen.add(word1)\n\n      for child in graph[word1]:\n        if child in seen:\n          continue\n        if dfs(child, word2, seen):\n          return True\n\n      return False\n\n    for word1, word2 in zip(words1, words2):\n      if word1 == word2:\n        continue\n      if word1 not in graph:\n        return False\n      if not dfs(word1, word2, set()):\n        return False\n\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 792, "slug": "number-of-matching-subsequences", "solutions": ["class Solution:\n    def numMatchingSubseq(self, s: str, words: List[str]) -> int:\n        d = defaultdict(deque)\n        for w in words:\n            d[w[0]].append(w)\n        ans = 0\n        for c in s:\n            for _ in range(len(d[c])):\n                t = d[c].popleft()\n                if len(t) == 1:\n                    ans += 1\n                else:\n                    d[t[1]].append(t[1:])\n        return ans\n", "class Solution:\n  def numMatchingSubseq(self, s: str, words: list[str]) -> int:\n    ans = 0\n    # [(i, j)] := words[i] and the letter words[i][j] is waiting for\n    bucket = [[] for _ in range(26)]\n\n    # For each word, it's waiting for word[0].\n    for i, word in enumerate(words):\n      bucket[ord(word[0]) - ord('a')].append((i, 0))\n\n    for c in s:\n      # Let prevBucket = bucket[c] and clear bucket[c].\n      index = ord(c) - ord('a')\n      prevBucket = bucket[index]\n      bucket[index] = []\n      for i, j in prevBucket:\n        j += 1\n        if j == len(words[i]):  # All the letters in words[i] are matched.\n          ans += 1\n        else:\n          bucket[ord(words[i][j]) - ord('a')].append((i, j))\n\n    return ans\n", "class Solution:\n  def numMatchingSubseq(self, s: str, words: list[str]) -> int:\n    root = {}\n\n    def insert(word: str) -> None:\n      node = root\n      for c in word:\n        if c not in node:\n          node[c] = {'count': 0}\n        node = node[c]\n      node['count'] += 1\n\n    for word in words:\n      insert(word)\n\n    def dfs(s: str, i: int, node: dict) -> int:\n      ans = node['count'] if 'count' in node else 0\n\n      if i >= len(s):\n        return ans\n\n      for c in string.ascii_lowercase:\n        if c in node:\n          try:\n            index = s.index(c, i)\n            ans += dfs(s, index + 1, node[c])\n          except ValueError:\n            continue\n\n      return ans\n\n    return dfs(s, 0, root)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 724, "slug": "find-pivot-index", "solutions": ["class Solution:\n    def pivotIndex(self, nums: List[int]) -> int:\n        left, right = 0, sum(nums)\n        for i, x in enumerate(nums):\n            right -= x\n            if left == right:\n                return i\n            left += x\n        return -1\n", "class Solution:\n  def pivotIndex(self, nums: list[int]) -> int:\n    summ = sum(nums)\n    prefix = 0\n\n    for i, num in enumerate(nums):\n      if prefix == summ - prefix - num:\n        return i\n      prefix += num\n\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 798, "slug": "smallest-rotation-with-highest-score", "solutions": ["class Solution:\n    def bestRotation(self, nums: List[int]) -> int:\n        n = len(nums)\n        mx, ans = -1, n\n        d = [0] * n\n        for i, v in enumerate(nums):\n            l, r = (i + 1) % n, (n + i + 1 - v) % n\n            d[l] += 1\n            d[r] -= 1\n        s = 0\n        for k, t in enumerate(d):\n            s += t\n            if s > mx:\n                mx = s\n                ans = k\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 775, "slug": "global-and-local-inversions", "solutions": ["class Solution:\n    def isIdealPermutation(self, nums: List[int]) -> bool:\n        mx = 0\n        for i in range(2, len(nums)):\n            if (mx := max(mx, nums[i - 2])) > nums[i]:\n                return False\n        return True\n", "class Solution:\n  def isIdealPermutation(self, nums: list[int]) -> bool:\n    for i, num in enumerate(nums):\n      if abs(num - i) > 1:\n        return False\n    return True\n", "class Solution:\n  def isIdealPermutation(self, nums: list[int]) -> bool:\n    mx = -1  # the number that is most likely > nums[i + 2]\n\n    for i in range(len(nums) - 2):\n      mx = max(mx, nums[i])\n      if mx > nums[i + 2]:\n        return False\n\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 733, "slug": "flood-fill", "solutions": ["class Solution:\n    def floodFill(\n        self, image: List[List[int]], sr: int, sc: int, color: int\n    ) -> List[List[int]]:\n        def dfs(i: int, j: int):\n            image[i][j] = color\n            for a, b in pairwise(dirs):\n                x, y = i + a, j + b\n                if 0 <= x < len(image) and 0 <= y < len(image[0]) and image[x][y] == oc:\n                    dfs(x, y)\n\n        oc = image[sr][sc]\n        if oc != color:\n            dirs = (-1, 0, 1, 0, -1)\n            dfs(sr, sc)\n        return image\n", "class Solution:\n  def floodFill(self, image: list[list[int]],\n                sr: int, sc: int, newColor: int) -> list[list[int]]:\n    startColor = image[sr][sc]\n    seen = set()\n\n    def dfs(i: int, j: int) -> None:\n      if i < 0 or i == len(image) or j < 0 or j == len(image[0]):\n        return\n      if image[i][j] != startColor or (i, j) in seen:\n        return\n\n      image[i][j] = newColor\n      seen.add((i, j))\n\n      dfs(i + 1, j)\n      dfs(i - 1, j)\n      dfs(i, j + 1)\n      dfs(i, j - 1)\n\n    dfs(sr, sc)\n    return image\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 726, "slug": "number-of-atoms", "solutions": ["class Solution:\n  def countOfAtoms(self, formula: str) -> str:\n    def parse() -> dict:\n      ans = collections.defaultdict(int)\n\n      nonlocal i\n      while i < n:\n        if formula[i] == '(':\n          i += 1\n          for elem, freq in parse().items():\n            ans[elem] += freq\n        elif formula[i] == ')':\n          i += 1\n          numStart = i\n          while i < n and formula[i].isdigit():\n            i += 1\n          factor = int(formula[numStart:i])\n          for elem, freq in ans.items():\n            ans[elem] *= factor\n          return ans\n        elif formula[i].isupper():\n          elemStart = i\n          i += 1\n          while i < n and formula[i].islower():\n            i += 1\n          elem = formula[elemStart:i]\n          numStart = i\n          while i < n and formula[i].isdigit():\n            i += 1\n          num = 1 if i == numStart else int(\n              formula[numStart:i])\n          ans[elem] += num\n\n      return ans\n\n    n = len(formula)\n\n    ans = \"\"\n    i = 0\n    count = parse()\n\n    for elem in sorted(count.keys()):\n      ans += elem\n      if count[elem] > 1:\n        ans += str(count[elem])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 773, "slug": "sliding-puzzle", "solutions": ["class Solution:\n    def slidingPuzzle(self, board: List[List[int]]) -> int:\n        t = [None] * 6\n\n        def gets():\n            for i in range(2):\n                for j in range(3):\n                    t[i * 3 + j] = str(board[i][j])\n            return ''.join(t)\n\n        def setb(s):\n            for i in range(2):\n                for j in range(3):\n                    board[i][j] = int(s[i * 3 + j])\n\n        def f():\n            res = []\n            i, j = next((i, j) for i in range(2) for j in range(3) if board[i][j] == 0)\n            for a, b in [[0, -1], [0, 1], [1, 0], [-1, 0]]:\n                x, y = i + a, j + b\n                if 0 <= x < 2 and 0 <= y < 3:\n                    board[i][j], board[x][y] = board[x][y], board[i][j]\n                    res.append(gets())\n                    board[i][j], board[x][y] = board[x][y], board[i][j]\n            return res\n\n        start = gets()\n        end = \"123450\"\n        if start == end:\n            return 0\n        vis = {start}\n        q = deque([(start)])\n        ans = 0\n        while q:\n            ans += 1\n            for _ in range(len(q)):\n                x = q.popleft()\n                setb(x)\n                for y in f():\n                    if y == end:\n                        return ans\n                    if y not in vis:\n                        vis.add(y)\n                        q.append(y)\n        return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 799, "slug": "champagne-tower", "solutions": ["class Solution:\n    def champagneTower(self, poured: int, query_row: int, query_glass: int) -> float:\n        f = [[0] * 101 for _ in range(101)]\n        f[0][0] = poured\n        for i in range(query_row + 1):\n            for j in range(i + 1):\n                if f[i][j] > 1:\n                    half = (f[i][j] - 1) / 2\n                    f[i][j] = 1\n                    f[i + 1][j] += half\n                    f[i + 1][j + 1] += half\n        return f[query_row][query_glass]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 751, "slug": "ip-to-cidr", "solutions": ["class Solution:\n  def ipToCIDR(self, ip: str, n: int) -> list[str]:\n    ans = []\n    num = self._getNum(ip.split('.'))\n\n    while n > 0:\n      lowbit = num & -num\n      count = self._maxLow(n) if lowbit == 0 else self._firstFit(lowbit, n)\n      ans.append(self._getCIDR(num, self._getPrefix(count)))\n      n -= count\n      num += count\n\n    return ans\n\n  def _getNum(self, x: list[str]) -> int:\n    num = 0\n    for i in range(4):\n      num = num * 256 + int(x[i])\n    return num\n\n  def _maxLow(self, n: int) -> int | None:\n    \"\"\"Returns the maximum i s.t. 2^i < n.\"\"\"\n    for i in range(32):\n      if 1 << i + 1 > n:\n        return 1 << i\n\n  def _firstFit(self, lowbit: int, n: int) -> int:\n    while lowbit > n:\n      lowbit >>= 1\n    return lowbit\n\n  def _getCIDR(self, num: int, prefix: int) -> str:\n    d = num & 255\n    num >>= 8\n    c = num & 255\n    num >>= 8\n    b = num & 255\n    num >>= 8\n    a = num & 255\n    return '.'.join([str(s) for s in [a, b, c, d]]) + '/' + str(prefix)\n\n  def _getPrefix(self, count: int) -> int | None:\n    \"\"\"\n    e.g. count = 8 = 2^3 . prefix = 32 - 3 = 29\n         count = 1 = 2^0 . prefix = 32 - 0 = 32\n    \"\"\"\n    for i in range(32):\n      if count == 1 << i:\n        return 32 - i\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 780, "slug": "reaching-points", "solutions": ["class Solution:\n    def reachingPoints(self, sx: int, sy: int, tx: int, ty: int) -> bool:\n        while tx > sx and ty > sy and tx != ty:\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        if tx == sx and ty == sy:\n            return True\n        if tx == sx:\n            return ty > sy and (ty - sy) % tx == 0\n        if ty == sy:\n            return tx > sx and (tx - sx) % ty == 0\n        return False\n", "class Solution:\n  def reachingPoints(self, sx: int, sy: int, tx: int, ty: int) -> bool:\n    while sx < tx and sy < ty:\n      tx, ty = tx % ty, ty % tx\n\n    return (sx == tx and sy <= ty and (ty - sy) % tx == 0 or\n            sy == ty and sx <= tx and (tx - sx) % ty == 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 764, "slug": "largest-plus-sign", "solutions": ["class Solution:\n    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:\n        dp = [[n] * n for _ in range(n)]\n        for x, y in mines:\n            dp[x][y] = 0\n        for i in range(n):\n            left = right = up = down = 0\n            for j, k in zip(range(n), reversed(range(n))):\n                left = left + 1 if dp[i][j] else 0\n                right = right + 1 if dp[i][k] else 0\n                up = up + 1 if dp[j][i] else 0\n                down = down + 1 if dp[k][i] else 0\n                dp[i][j] = min(dp[i][j], left)\n                dp[i][k] = min(dp[i][k], right)\n                dp[j][i] = min(dp[j][i], up)\n                dp[k][i] = min(dp[k][i], down)\n        return max(max(v) for v in dp)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 753, "slug": "cracking-the-safe", "solutions": ["class Solution:\n    def crackSafe(self, n: int, k: int) -> str:\n        def dfs(u):\n            for x in range(k):\n                e = u * 10 + x\n                if e not in vis:\n                    vis.add(e)\n                    v = e % mod\n                    dfs(v)\n                    ans.append(str(x))\n\n        mod = 10 ** (n - 1)\n        vis = set()\n        ans = []\n        dfs(0)\n        ans.append(\"0\" * (n - 1))\n        return \"\".join(ans)\n", "class Solution:\n  def crackSafe(self, n: int, k: int) -> str:\n    passwordSize = k**n\n    path = '0' * n\n    seen = set()\n    seen.add(path)\n\n    def dfs(path: str) -> str:\n      if len(seen) == passwordSize:\n        return path\n\n      for c in map(str, range(k)):\n        node = path[-n + 1:] + c if n > 1 else c\n        if node not in seen:\n          seen.add(node)\n          res = dfs(path + c)\n          if res:\n            return res\n          seen.remove(node)\n\n    return dfs(path)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 702, "slug": "search-in-a-sorted-array-of-unknown-size", "solutions": ["# \"\"\"\n# This is ArrayReader's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# class ArrayReader:\n#    def get(self, index: int) -> int:\n\n\nclass Solution:\n    def search(self, reader: \"ArrayReader\", target: int) -> int:\n        r = 1\n        while reader.get(r) < target:\n            r <<= 1\n        l = r >> 1\n        while l < r:\n            mid = (l + r) >> 1\n            if reader.get(mid) >= target:\n                r = mid\n            else:\n                l = mid + 1\n        return l if reader.get(l) == target else -1\n", "# \"\"\"\n# This is ArrayReader's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# Class ArrayReader:\n#   def get(self, index: int) -> int:\n\nclass Solution:\n  def search(self, reader: 'ArrayReader', target: int) -> int:\n    l = bisect.bisect_left(range(10**4), target,\n                           key=lambda m: reader.get(m))\n    return l if reader.get(l) == target else -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 717, "slug": "1-bit-and-2-bit-characters", "solutions": ["class Solution:\n    def isOneBitCharacter(self, bits: List[int]) -> bool:\n        i, n = 0, len(bits)\n        while i < n - 1:\n            i += bits[i] + 1\n        return i == n - 1\n", "class Solution:\n  def isOneBitCharacter(self, bits: list[int]) -> bool:\n    i = 0\n    while i < len(bits) - 1:\n      i += bits[i] + 1\n\n    return i == len(bits) - 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 763, "slug": "partition-labels", "solutions": ["class Solution:\n    def partitionLabels(self, s: str) -> List[int]:\n        last = {c: i for i, c in enumerate(s)}\n        mx = j = 0\n        ans = []\n        for i, c in enumerate(s):\n            mx = max(mx, last[c])\n            if mx == i:\n                ans.append(i - j + 1)\n                j = i + 1\n        return ans\n", "class Solution:\n  def partitionLabels(self, s: str) -> list[int]:\n    ans = []\n    letterToRightmostIndex = {c: i for i, c in enumerate(s)}\n\n    l = 0  # the leftmost index of the current running string\n    r = 0  # the rightmost index of the current running string\n\n    for i, c in enumerate(s):\n      r = max(r, letterToRightmostIndex[c])\n      if i == r:\n        ans.append(r - l + 1)\n        l = r + 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 779, "slug": "k-th-symbol-in-grammar", "solutions": ["class Solution:\n    def kthGrammar(self, n: int, k: int) -> int:\n        if n == 1:\n            return 0\n        if k <= (1 << (n - 2)):\n            return self.kthGrammar(n - 1, k)\n        return self.kthGrammar(n - 1, k - (1 << (n - 2))) ^ 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 770, "slug": "basic-calculator-iv", "solutions": ["class Poly:\n  def __init__(self, term: str = None, coef: int = None):\n    if term and coef:\n      self.terms = collections.Counter({term: coef})\n    else:\n      self.terms = collections.Counter()\n\n  def __add__(self, other):\n    for term, coef in other.terms.items():\n      self.terms[term] += coef\n    return self\n\n  def __sub__(self, other):\n    for term, coef in other.terms.items():\n      self.terms[term] -= coef\n    return self\n\n  def __mul__(self, other):\n    res = Poly()\n    for a, aCoef in self.terms.items():\n      for b, bCoef in other.terms.items():\n        res.terms[self._merge(a, b)] += aCoef * bCoef\n    return res\n\n  # Def __str__(self):\n  #   res = []\n  #   for term, coef in self.terms.items():\n  #     res.append(term + ': ' + str(coef))\n  #   return '{' + ', '.join(res) + '}'\n\n  def toList(self) -> list[str]:\n    for term in list(self.terms.keys()):\n      if not self.terms[term]:\n        del self.terms[term]\n\n    def cmp(term: str) -> tuple:\n      # the minimum degree is the last\n      if term == '1':\n        return (0,)\n      var = term.split('*')\n      # the maximum degree is the first\n      # Break ties by their lexicographic orders.\n      return (-len(var), term)\n\n    def concat(term: str) -> str:\n      if term == '1':\n        return str(self.terms[term])\n      return str(self.terms[term]) + '*' + term\n\n    terms = list(self.terms.keys())\n    terms.sort(key=cmp)\n    return [concat(term) for term in terms]\n\n  def _merge(self, a: str, b: str) -> str:\n    if a == '1':\n      return b\n    if b == '1':\n      return a\n    res = []\n    A = a.split('*')\n    B = b.split('*')\n    i = 0  # A's index\n    j = 0  # B's index\n    while i < len(A) and j < len(B):\n      if A[i] < B[j]:\n        res.append(A[i])\n        i += 1\n      else:\n        res.append(B[j])\n        j += 1\n    return '*'.join(res + A[i:] + B[j:])\n\n\nclass Solution:\n  def basicCalculatorIV(\n      self,\n      expression: str,\n      evalvars: list[str],\n      evalints: list[int],\n  ) -> list[str]:\n    tokens = list(self._getTokens(expression))\n    evalMap = {a: b for a, b in zip(evalvars, evalints)}\n\n    for i, token in enumerate(tokens):\n      if token in evalMap:\n        tokens[i] = str(evalMap[token])\n\n    postfix = self._infixToPostfix(tokens)\n    return self._evaluate(postfix).toList()\n\n  def _getTokens(self, s: str) -> Iterator[str]:\n    i = 0\n    for j, c in enumerate(s):\n      if c == ' ':\n        if i < j:\n          yield s[i:j]\n        i = j + 1\n      elif c in '()+-*':\n        if i < j:\n          yield s[i:j]\n        yield c\n        i = j + 1\n    if i < len(s):\n      yield s[i:]\n\n  def _infixToPostfix(self, tokens: list[str]) -> list[str]:\n    postfix = []\n    ops = []\n\n    def precedes(prevOp: str, currOp: str) -> bool:\n      if prevOp == '(':\n        return False\n      return prevOp == '*' or currOp in '+-'\n\n    for token in tokens:\n      if token == '(':\n        ops.append(token)\n      elif token == ')':\n        while ops[-1] != '(':\n          postfix.append(ops.pop())\n        ops.pop()\n      elif token in '+-*':  # isOperator(token)\n        while ops and precedes(ops[-1], token):\n          postfix.append(ops.pop())\n        ops.append(token)\n      else:  # isOperand(token)\n        postfix.append(token)\n    return postfix + ops[::-1]\n\n  def _evaluate(self, postfix: list[str]) -> Poly:\n    polys: list[Poly] = []\n    for token in postfix:\n      if token in '+-*':\n        b = polys.pop()\n        a = polys.pop()\n        if token == '+':\n          polys.append(a + b)\n        elif token == '-':\n          polys.append(a - b)\n        else:  # token == '*'\n          polys.append(a * b)\n      elif token.lstrip('-').isnumeric():\n        polys.append(Poly(\"1\", int(token)))\n      else:\n        polys.append(Poly(token, 1))\n    return polys[0]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 727, "slug": "minimum-window-subsequence", "solutions": ["class Solution:\n    def minWindow(self, s1: str, s2: str) -> str:\n        m, n = len(s1), len(s2)\n        f = [[0] * (n + 1) for _ in range(m + 1)]\n        for i, a in enumerate(s1, 1):\n            for j, b in enumerate(s2, 1):\n                if a == b:\n                    f[i][j] = i if j == 1 else f[i - 1][j - 1]\n                else:\n                    f[i][j] = f[i - 1][j]\n        p, k = 0, m + 1\n        for i, a in enumerate(s1, 1):\n            if a == s2[n - 1] and f[i][n]:\n                j = f[i][n] - 1\n                if i - j < k:\n                    k = i - j\n                    p = j\n        return \"\" if k > m else s1[p : p + k]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 744, "slug": "find-smallest-letter-greater-than-target", "solutions": ["class Solution:\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\n        i = bisect_right(letters, ord(target), key=lambda c: ord(c))\n        return letters[i % len(letters)]\n", "class Solution:\n  def nextGreatestLetter(self, letters: list[str], target: str) -> str:\n    l = bisect.bisect_right(range(len(letters)), target,\n                            key=lambda m: letters[m])\n    return letters[l % len(letters)]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 738, "slug": "monotone-increasing-digits", "solutions": ["class Solution:\n    def monotoneIncreasingDigits(self, n: int) -> int:\n        s = list(str(n))\n        i = 1\n        while i < len(s) and s[i - 1] <= s[i]:\n            i += 1\n        if i < len(s):\n            while i and s[i - 1] > s[i]:\n                s[i - 1] = str(int(s[i - 1]) - 1)\n                i -= 1\n            i += 1\n            while i < len(s):\n                s[i] = '9'\n                i += 1\n        return int(''.join(s))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 746, "slug": "min-cost-climbing-stairs", "solutions": ["class Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        @cache\n        def dfs(i: int) -> int:\n            if i >= len(cost):\n                return 0\n            return cost[i] + min(dfs(i + 1), dfs(i + 2))\n\n        return min(dfs(0), dfs(1))\n", "class Solution:\n  def minCostClimbingStairs(self, cost: list[int]) -> int:\n    cost.append(0)\n\n    for i in range(2, len(cost)):\n      cost[i] += min(cost[i - 1], cost[i - 2])\n\n    return cost[-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 781, "slug": "rabbits-in-forest", "solutions": ["class Solution:\n    def numRabbits(self, answers: List[int]) -> int:\n        cnt = Counter(answers)\n        ans = 0\n        for x, v in cnt.items():\n            group = x + 1\n            ans += (v + group - 1) // group * group\n        return ans\n", "class Solution:\n  def numRabbits(self, answers: list[int]) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    for answer in answers:\n      if count[answer] % (answer + 1) == 0:\n        ans += answer + 1\n      count[answer] += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 728, "slug": "self-dividing-numbers", "solutions": ["class Solution:\n    def selfDividingNumbers(self, left: int, right: int) -> List[int]:\n        def check(x: int) -> bool:\n            y = x\n            while y:\n                if y % 10 == 0 or x % (y % 10):\n                    return False\n                y //= 10\n            return True\n\n        return [x for x in range(left, right + 1) if check(x)]\n", "class Solution:\n  def selfDividingNumbers(self, left: int, right: int) -> list[int]:\n    return [num for num in range(left, right + 1) if all(n != 0 and num % n == 0 for n in map(int, str(num)))]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 762, "slug": "prime-number-of-set-bits-in-binary-representation", "solutions": ["class Solution:\n    def countPrimeSetBits(self, left: int, right: int) -> int:\n        primes = {2, 3, 5, 7, 11, 13, 17, 19}\n        return sum(i.bit_count() in primes for i in range(left, right + 1))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 759, "slug": "employee-free-time", "solutions": ["class Solution:\n  def employeeFreeTime(self, schedule: '[[Interval]]') -> '[Interval]':\n    ans = []\n    intervals = []\n\n    for s in schedule:\n      intervals.extend(s)\n\n    intervals.sort(key=lambda x: x.start)\n\n    prevEnd = intervals[0].end\n\n    for interval in intervals:\n      if interval.start > prevEnd:\n        ans.append(Interval(prevEnd, interval.start))\n      prevEnd = max(prevEnd, interval.end)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 735, "slug": "asteroid-collision", "solutions": ["class Solution:\n    def asteroidCollision(self, asteroids: List[int]) -> List[int]:\n        stk = []\n        for x in asteroids:\n            if x > 0:\n                stk.append(x)\n            else:\n                while stk and stk[-1] > 0 and stk[-1] < -x:\n                    stk.pop()\n                if stk and stk[-1] == -x:\n                    stk.pop()\n                elif not stk or stk[-1] < 0:\n                    stk.append(x)\n        return stk\n", "class Solution:\n  def asteroidCollision(self, asteroids: list[int]) -> list[int]:\n    stack = []\n\n    for a in asteroids:\n      if a > 0:\n        stack.append(a)\n      else:  # a < 0\n        # Destroy the previous positive one(s).\n        while stack and stack[-1] > 0 and stack[-1] < -a:\n          stack.pop()\n        if not stack or stack[-1] < 0:\n          stack.append(a)\n        elif stack[-1] == -a:\n          stack.pop()  # Both asteroids explode.\n        else:  # stack[-1] > the current asteroid.\n          pass  # Destroy the current asteroid, so do nothing.\n\n    return stack\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 797, "slug": "all-paths-from-source-to-target", "solutions": ["class Solution:\n    def allPathsSourceTarget(self, graph: List[List[int]]) -> List[List[int]]:\n        n = len(graph)\n        q = deque([[0]])\n        ans = []\n        while q:\n            path = q.popleft()\n            u = path[-1]\n            if u == n - 1:\n                ans.append(path)\n                continue\n            for v in graph[u]:\n                q.append(path + [v])\n        return ans\n", "class Solution:\n  def allPathsSourceTarget(self, graph: list[list[int]]) -> list[list[int]]:\n    ans = []\n\n    def dfs(u: int, path: list[int]) -> None:\n      if u == len(graph) - 1:\n        ans.append(path)\n        return\n\n      for v in graph[u]:\n        dfs(v, path + [v])\n\n    dfs(0, [0])\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 791, "slug": "custom-sort-string", "solutions": ["class Solution:\n    def customSortString(self, order: str, s: str) -> str:\n        d = {c: i for i, c in enumerate(order)}\n        return ''.join(sorted(s, key=lambda x: d.get(x, 0)))\n", "class Solution:\n  def customSortString(self, order: str, s: str) -> str:\n    ans = \"\"\n    count = [0] * 26\n\n    for c in s:\n      count[ord(c) - ord('a')] += 1\n\n    for c in order:\n      while count[ord(c) - ord('a')] > 0:\n        ans += c\n        count[ord(c) - ord('a')] -= 1\n\n    for c in string.ascii_lowercase:\n      for _ in range(count[ord(c) - ord('a')]):\n        ans += c\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 783, "slug": "minimum-distance-between-bst-nodes", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minDiffInBST(self, root: Optional[TreeNode]) -> int:\n        def dfs(root: Optional[TreeNode]):\n            if root is None:\n                return\n            dfs(root.left)\n            nonlocal pre, ans\n            ans = min(ans, root.val - pre)\n            pre = root.val\n            dfs(root.right)\n\n        pre = -inf\n        ans = inf\n        dfs(root)\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 720, "slug": "longest-word-in-dictionary", "solutions": ["class Trie:\n    def __init__(self):\n        self.children: List[Optional[Trie]] = [None] * 26\n        self.is_end = False\n\n    def insert(self, w: str):\n        node = self\n        for c in w:\n            idx = ord(c) - ord(\"a\")\n            if node.children[idx] is None:\n                node.children[idx] = Trie()\n            node = node.children[idx]\n        node.is_end = True\n\n    def search(self, w: str) -> bool:\n        node = self\n        for c in w:\n            idx = ord(c) - ord(\"a\")\n            if node.children[idx] is None:\n                return False\n            node = node.children[idx]\n            if not node.is_end:\n                return False\n        return True\n\n\nclass Solution:\n    def longestWord(self, words: List[str]) -> str:\n        trie = Trie()\n        for w in words:\n            trie.insert(w)\n        ans = \"\"\n        for w in words:\n            if trie.search(w) and (\n                len(ans) < len(w) or (len(ans) == len(w) and ans > w)\n            ):\n                ans = w\n        return ans\n", "class Solution:\n  def longestWord(self, words: list[str]) -> str:\n    root = {}\n\n    for word in words:\n      node = root\n      for c in word:\n        if c not in node:\n          node[c] = {}\n        node = node[c]\n      node['word'] = word\n\n    def dfs(node: dict) -> str:\n      ans = node['word'] if 'word' in node else ''\n\n      for child in node:\n        if 'word' in node[child] and len(node[child]['word']) > 0:\n          childWord = dfs(node[child])\n          if len(childWord) > len(ans) or (\n                  len(childWord) == len(ans) and childWord < ans):\n            ans = childWord\n\n      return ans\n\n    return dfs(root)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 771, "slug": "jewels-and-stones", "solutions": ["class Solution:\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\n        s = set(jewels)\n        return sum(c in s for c in stones)\n", "class Solution:\n  def numJewelsInStones(self, jewels: str, stones: str) -> int:\n    jewelsSet = set(jewels)\n    return sum(stone in jewelsSet for stone in stones)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 725, "slug": "split-linked-list-in-parts", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def splitListToParts(\n        self, head: Optional[ListNode], k: int\n    ) -> List[Optional[ListNode]]:\n        n = 0\n        cur = head\n        while cur:\n            n += 1\n            cur = cur.next\n        cnt, mod = divmod(n, k)\n        ans = [None] * k\n        cur = head\n        for i in range(k):\n            if cur is None:\n                break\n            ans[i] = cur\n            m = cnt + int(i < mod)\n            for _ in range(1, m):\n                cur = cur.next\n            nxt = cur.next\n            cur.next = None\n            cur = nxt\n        return ans\n", "class Solution:\n  def splitListToParts(self, root: ListNode, k: int) -> list[ListNode]:\n    ans = [[] for _ in range(k)]\n    length = 0\n    curr = root\n    while curr:\n      length += 1\n      curr = curr.next\n    subLength = length // k\n    remainder = length % k\n\n    prev = None\n    head = root\n\n    for i in range(k):\n      ans[i] = head\n      for j in range(subLength + (1 if remainder > 0 else 0)):\n        prev = head\n        head = head.next\n      if prev:\n        prev.next = None\n      remainder -= 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 767, "slug": "reorganize-string", "solutions": ["class Solution:\n    def reorganizeString(self, s: str) -> str:\n        n = len(s)\n        cnt = Counter(s)\n        mx = max(cnt.values())\n        if mx > (n + 1) // 2:\n            return ''\n        i = 0\n        ans = [None] * n\n        for k, v in cnt.most_common():\n            while v:\n                ans[i] = k\n                v -= 1\n                i += 2\n                if i >= n:\n                    i = 1\n        return ''.join(ans)\n", "class Solution:\n  def reorganizeString(self, s: str) -> str:\n    count = collections.Counter(s)\n    if max(count.values()) > (len(s) + 1) // 2:\n      return ''\n\n    ans = []\n    maxHeap = [(-freq, c) for c, freq in count.items()]\n    heapq.heapify(maxHeap)\n    prevFreq = 0\n    prevChar = '@'\n\n    while maxHeap:\n      # Get the letter with the maximum frequency.\n      freq, c = heapq.heappop(maxHeap)\n      ans.append(c)\n      # Add the previous letter back s.t. any two adjacent characters are not\n      # the same.\n      if prevFreq < 0:\n        heapq.heappush(maxHeap, (prevFreq, prevChar))\n      prevFreq = freq + 1\n      prevChar = c\n\n    return ''.join(ans)\n", "class Solution:\n  def reorganizeString(self, s: str) -> str:\n    n = len(s)\n    count = collections.Counter(s)\n    maxCount = max(count.values())\n\n    if maxCount > (n + 1) // 2:\n      return ''\n\n    if maxCount == (n + 1) // 2:\n      maxLetter = max(count, key=count.get)\n      ans = [maxLetter if i % 2 == 0 else '' for i in range(n)]\n      del count[maxLetter]\n      i = 1\n    else:\n      ans = [''] * n\n      i = 0\n\n    for c, freq in count.items():\n      for _ in range(freq):\n        ans[i] = c\n        i += 2\n        if i >= n:\n          i = 1\n\n    return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 701, "slug": "insert-into-a-binary-search-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\n        if root is None:\n            return TreeNode(val)\n        if root.val > val:\n            root.left = self.insertIntoBST(root.left, val)\n        else:\n            root.right = self.insertIntoBST(root.right, val)\n        return root\n", "class Solution:\n  def insertIntoBST(self, root: TreeNode | None, val: int) -> TreeNode | None:\n    if not root:\n      return TreeNode(val)\n    if root.val > val:\n      root.left = self.insertIntoBST(root.left, val)\n    else:\n      root.right = self.insertIntoBST(root.right, val)\n    return root\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 784, "slug": "letter-case-permutation", "solutions": ["class Solution:\n    def letterCasePermutation(self, s: str) -> List[str]:\n        def dfs(i: int) -> None:\n            if i >= len(t):\n                ans.append(\"\".join(t))\n                return\n            dfs(i + 1)\n            if t[i].isalpha():\n                t[i] = chr(ord(t[i]) ^ 32)\n                dfs(i + 1)\n\n        t = list(s)\n        ans = []\n        dfs(0)\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 752, "slug": "open-the-lock", "solutions": ["class Solution:\n    def openLock(self, deadends: List[str], target: str) -> int:\n        def next(s):\n            res = []\n            s = list(s)\n            for i in range(4):\n                c = s[i]\n                s[i] = '9' if c == '0' else str(int(c) - 1)\n                res.append(''.join(s))\n                s[i] = '0' if c == '9' else str(int(c) + 1)\n                res.append(''.join(s))\n                s[i] = c\n            return res\n\n        if target == '0000':\n            return 0\n        s = set(deadends)\n        if '0000' in s:\n            return -1\n        q = deque([('0000')])\n        s.add('0000')\n        ans = 0\n        while q:\n            ans += 1\n            for _ in range(len(q)):\n                p = q.popleft()\n                for t in next(p):\n                    if t == target:\n                        return ans\n                    if t not in s:\n                        q.append(t)\n                        s.add(t)\n        return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 786, "slug": "k-th-smallest-prime-fraction", "solutions": ["class Solution:\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\n        h = [(1 / y, 0, j + 1) for j, y in enumerate(arr[1:])]\n        heapify(h)\n        for _ in range(k - 1):\n            _, i, j = heappop(h)\n            if i + 1 < j:\n                heappush(h, (arr[i + 1] / arr[j], i + 1, j))\n        return [arr[h[0][1]], arr[h[0][2]]]\n", "class Solution:\n  def kthSmallestPrimeFraction(self, arr: list[int], k: int) -> list[int]:\n    n = len(arr)\n    ans = [0, 1]\n    l = 0\n    r = 1\n\n    while True:\n      m = (l + r) / 2\n      ans[0] = 0\n      count = 0\n      j = 1\n\n      for i in range(n):\n        while j < n and arr[i] > m * arr[j]:\n          j += 1\n        count += n - j\n        if j == n:\n          break\n        if ans[0] * arr[j] < ans[1] * arr[i]:\n          ans[0] = arr[i]\n          ans[1] = arr[j]\n\n      if count < k:\n        l = m\n      elif count > k:\n        r = m\n      else:\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 736, "slug": "parse-lisp-expression", "solutions": ["class Solution:\n    def evaluate(self, expression: str) -> int:\n        def parseVar():\n            nonlocal i\n            j = i\n            while i < n and expression[i] not in \" )\":\n                i += 1\n            return expression[j:i]\n\n        def parseInt():\n            nonlocal i\n            sign, v = 1, 0\n            if expression[i] == \"-\":\n                sign = -1\n                i += 1\n            while i < n and expression[i].isdigit():\n                v = v * 10 + int(expression[i])\n                i += 1\n            return sign * v\n\n        def eval():\n            nonlocal i\n            if expression[i] != \"(\":\n                return scope[parseVar()][-1] if expression[i].islower() else parseInt()\n            i += 1\n            if expression[i] == \"l\":\n                i += 4\n                vars = []\n                while 1:\n                    var = parseVar()\n                    if expression[i] == \")\":\n                        ans = scope[var][-1]\n                        break\n                    vars.append(var)\n                    i += 1\n                    scope[var].append(eval())\n                    i += 1\n                    if not expression[i].islower():\n                        ans = eval()\n                        break\n                for v in vars:\n                    scope[v].pop()\n            else:\n                add = expression[i] == \"a\"\n                i += 4 if add else 5\n                a = eval()\n                i += 1\n                b = eval()\n                ans = a + b if add else a * b\n            i += 1\n            return ans\n\n        i, n = 0, len(expression)\n        scope = defaultdict(list)\n        return eval()\n", "class Solution:\n  def evaluate(self, expression: str) -> int:\n    def evaluate(e: str, prevScope: dict) -> int:\n      if e[0].isdigit() or e[0] == '-':\n        return int(e)\n      if e in prevScope:\n        return prevScope[e]\n\n      scope = prevScope.copy()\n      nextExpression = e[e.index(' ') + 1:-1]\n      tokens = parse(nextExpression)\n\n      if e[1] == 'm':  # 'mult'\n        return evaluate(tokens[0], scope) * evaluate(tokens[1], scope)\n      if e[1] == 'a':  # 'add'\n        return evaluate(tokens[0], scope) + evaluate(tokens[1], scope)\n\n      # 'let'\n      for i in range(0, len(tokens) - 2, 2):\n        scope[tokens[i]] = evaluate(tokens[i + 1], scope)\n\n      return evaluate(tokens[-1], scope)\n\n    def parse(e: str):\n      tokens = []\n      s = ''\n      opened = 0\n\n      for c in e:\n        if c == '(':\n          opened += 1\n        elif c == ')':\n          opened -= 1\n        if opened == 0 and c == ' ':\n          tokens.append(s)\n          s = ''\n        else:\n          s += c\n\n      if len(s) > 0:\n        tokens.append(s)\n      return tokens\n\n    return evaluate(expression, {})\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 729, "slug": "my-calendar-i", "solutions": ["class MyCalendar:\n    def __init__(self):\n        self.sd = SortedDict()\n\n    def book(self, start: int, end: int) -> bool:\n        idx = self.sd.bisect_right(start)\n        if idx < len(self.sd) and self.sd.values()[idx] < end:\n            return False\n        self.sd[end] = start\n        return True\n\n\n# Your MyCalendar object will be instantiated and called as such:\n# obj = MyCalendar()\n# param_1 = obj.book(start,end)\n", "class MyCalendar:\n  def __init__(self):\n    self.timeline = []\n\n  def book(self, start: int, end: int) -> bool:\n    for s, e in self.timeline:\n      if max(start, s) < min(end, e):\n        return False\n    self.timeline.append((start, end))\n    return True\n", "from dataclasses import dataclass\n\n\n@dataclass\nclass Node:\n  start: int\n  end: int\n  left = None\n  right = None\n\n\nclass Tree:\n  def __init__(self):\n    self.root = None\n\n  def insert(self, node: Node, root: Node = None) -> bool:\n    if not root:\n      if not self.root:\n        self.root = node\n        return True\n      else:\n        root = self.root\n\n    if node.start >= root.end:\n      if not root.right:\n        root.right = node\n        return True\n      return self.insert(node, root.right)\n    elif node.end <= root.start:\n      if not root.left:\n        root.left = node\n        return True\n      return self.insert(node, root.left)\n    else:\n      return False\n\n\nclass MyCalendar:\n  def __init__(self):\n    self.tree = Tree()\n\n  def book(self, start: int, end: int) -> bool:\n    return self.tree.insert(Node(start, end))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 719, "slug": "find-k-th-smallest-pair-distance", "solutions": ["class Solution:\n    def smallestDistancePair(self, nums: List[int], k: int) -> int:\n        def count(dist):\n            cnt = 0\n            for i, b in enumerate(nums):\n                a = b - dist\n                j = bisect_left(nums, a, 0, i)\n                cnt += i - j\n            return cnt\n\n        nums.sort()\n        return bisect_left(range(nums[-1] - nums[0]), k, key=count)\n", "class Solution:\n  def smallestDistancePair(self, nums: list[int], k: int) -> int:\n    nums.sort()\n\n    def numPairDistancesNoGreaterThan(m: int) -> int:\n      count = 0\n      j = 1\n      # For each index i, find the first index j s.t. nums[j] > nums[i] + m,\n      # so numPairDistancesNoGreaterThan for the index i will be j - i - 1.\n      for i, num in enumerate(nums):\n        while j < len(nums) and nums[j] <= num + m:\n          j += 1\n        count += j - i - 1\n      return count\n\n    return bisect.bisect_left(range(nums[-1] - nums[0]), k,\n                              key=numPairDistancesNoGreaterThan)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 768, "slug": "max-chunks-to-make-sorted-ii", "solutions": ["class Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stk = []\n        for v in arr:\n            if not stk or v >= stk[-1]:\n                stk.append(v)\n            else:\n                mx = stk.pop()\n                while stk and stk[-1] > v:\n                    stk.pop()\n                stk.append(mx)\n        return len(stk)\n", "class Solution:\n  def maxChunksToSorted(self, arr: list[int]) -> int:\n    n = len(arr)\n    ans = 0\n    mx = -math.inf\n    mn = [arr[-1]] * n\n\n    for i in reversed(range(n - 1)):\n      mn[i] = min(mn[i + 1], arr[i])\n\n    for i in range(n - 1):\n      mx = max(mx, arr[i])\n      if mx <= mn[i + 1]:\n        ans += 1\n\n    return ans + 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 730, "slug": "count-different-palindromic-subsequences", "solutions": ["class Solution:\n    def countPalindromicSubsequences(self, s: str) -> int:\n        mod = 10**9 + 7\n        n = len(s)\n        dp = [[[0] * 4 for _ in range(n)] for _ in range(n)]\n        for i, c in enumerate(s):\n            dp[i][i][ord(c) - ord('a')] = 1\n        for l in range(2, n + 1):\n            for i in range(n - l + 1):\n                j = i + l - 1\n                for c in 'abcd':\n                    k = ord(c) - ord('a')\n                    if s[i] == s[j] == c:\n                        dp[i][j][k] = 2 + sum(dp[i + 1][j - 1])\n                    elif s[i] == c:\n                        dp[i][j][k] = dp[i][j - 1][k]\n                    elif s[j] == c:\n                        dp[i][j][k] = dp[i + 1][j][k]\n                    else:\n                        dp[i][j][k] = dp[i + 1][j - 1][k]\n        return sum(dp[0][-1]) % mod\n", "class Solution:\n  def countPalindromicSubsequences(self, s: str) -> int:\n    MOD = 1_000_000_007\n    n = len(s)\n    # dp[i][j] := the number of different non-empty palindromic subsequences in\n    # s[i..j]\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i] = 1\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        if s[i] == s[j]:\n          lo = i + 1\n          hi = j - 1\n          while lo <= hi and s[lo] != s[i]:\n            lo += 1\n          while lo <= hi and s[hi] != s[i]:\n            hi -= 1\n          if lo > hi:\n            dp[i][j] = dp[i + 1][j - 1] * 2 + 2\n          elif lo == hi:\n            dp[i][j] = dp[i + 1][j - 1] * 2 + 1\n          else:\n            dp[i][j] = dp[i + 1][j - 1] * 2 - dp[lo + 1][hi - 1]\n        else:\n          dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1]\n        dp[i][j] = (dp[i][j] + MOD) % MOD\n\n    return dp[0][n - 1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 703, "slug": "kth-largest-element-in-a-stream", "solutions": ["class KthLargest:\n\n    def __init__(self, k: int, nums: List[int]):\n        self.k = k\n        self.min_q = []\n        for x in nums:\n            self.add(x)\n\n    def add(self, val: int) -> int:\n        heappush(self.min_q, val)\n        if len(self.min_q) > self.k:\n            heappop(self.min_q)\n        return self.min_q[0]\n\n\n# Your KthLargest object will be instantiated and called as such:\n# obj = KthLargest(k, nums)\n# param_1 = obj.add(val)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 721, "slug": "accounts-merge", "solutions": ["class UnionFind:\n    def __init__(self, n):\n        self.p = list(range(n))\n        self.size = [1] * n\n\n    def find(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n\n    def union(self, a, b):\n        pa, pb = self.find(a), self.find(b)\n        if pa == pb:\n            return False\n        if self.size[pa] > self.size[pb]:\n            self.p[pb] = pa\n            self.size[pa] += self.size[pb]\n        else:\n            self.p[pa] = pb\n            self.size[pb] += self.size[pa]\n        return True\n\n\nclass Solution:\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\n        uf = UnionFind(len(accounts))\n        d = {}\n        for i, (_, *emails) in enumerate(accounts):\n            for email in emails:\n                if email in d:\n                    uf.union(i, d[email])\n                else:\n                    d[email] = i\n        g = defaultdict(set)\n        for i, (_, *emails) in enumerate(accounts):\n            root = uf.find(i)\n            g[root].update(emails)\n        return [[accounts[root][0]] + sorted(emails) for root, emails in g.items()]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 709, "slug": "to-lower-case", "solutions": ["class Solution:\n    def toLowerCase(self, s: str) -> str:\n        return \"\".join([chr(ord(c) | 32) if c.isupper() else c for c in s])\n", "class Solution:\n  def toLowerCase(self, str: str) -> str:\n    return ''.join(chr(ord(c) + 32) if 'A' <= c <= 'Z' else c for c in str)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 766, "slug": "toeplitz-matrix", "solutions": ["class Solution:\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\n        m, n = len(matrix), len(matrix[0])\n        for i in range(1, m):\n            for j in range(1, n):\n                if matrix[i][j] != matrix[i - 1][j - 1]:\n                    return False\n        return True\n", "class Solution:\n  def isToeplitzMatrix(self, matrix: list[list[int]]) -> bool:\n    for i in range(len(matrix) - 1):\n      for j in range(len(matrix[0]) - 1):\n        if matrix[i][j] != matrix[i + 1][j + 1]:\n          return False\n\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 734, "slug": "sentence-similarity", "solutions": ["class Solution:\n    def areSentencesSimilar(\n        self, sentence1: List[str], sentence2: List[str], similarPairs: List[List[str]]\n    ) -> bool:\n        if len(sentence1) != len(sentence2):\n            return False\n        s = {(x, y) for x, y in similarPairs}\n        for x, y in zip(sentence1, sentence2):\n            if x != y and (x, y) not in s and (y, x) not in s:\n                return False\n        return True\n", "class Solution:\n  def areSentencesSimilar(\n      self,\n      sentence1: list[str],\n      sentence2: list[str],\n      similarPairs: list[list[str]],\n  ) -> bool:\n    if len(sentence1) != len(sentence2):\n      return False\n\n    # map[key] := all the similar words of key\n    map = collections.defaultdict(set)\n\n    for a, b in similarPairs:\n      map[a].add(b)\n      map[b].add(a)\n\n    for word1, word2 in zip(sentence1, sentence2):\n      if word1 == word2:\n        continue\n      if word1 not in map:\n        return False\n      if word2 not in map[word1]:\n        return False\n\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 716, "slug": "max-stack", "solutions": ["class Node:\n    def __init__(self, val=0):\n        self.val = val\n        self.prev: Union[Node, None] = None\n        self.next: Union[Node, None] = None\n\n\nclass DoubleLinkedList:\n    def __init__(self):\n        self.head = Node()\n        self.tail = Node()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def append(self, val) -> Node:\n        node = Node(val)\n        node.next = self.tail\n        node.prev = self.tail.prev\n        self.tail.prev = node\n        node.prev.next = node\n        return node\n\n    @staticmethod\n    def remove(node) -> Node:\n        node.prev.next = node.next\n        node.next.prev = node.prev\n        return node\n\n    def pop(self) -> Node:\n        return self.remove(self.tail.prev)\n\n    def peek(self):\n        return self.tail.prev.val\n\n\nclass MaxStack:\n    def __init__(self):\n        self.stk = DoubleLinkedList()\n        self.sl = SortedList(key=lambda x: x.val)\n\n    def push(self, x: int) -> None:\n        node = self.stk.append(x)\n        self.sl.add(node)\n\n    def pop(self) -> int:\n        node = self.stk.pop()\n        self.sl.remove(node)\n        return node.val\n\n    def top(self) -> int:\n        return self.stk.peek()\n\n    def peekMax(self) -> int:\n        return self.sl[-1].val\n\n    def popMax(self) -> int:\n        node = self.sl.pop()\n        DoubleLinkedList.remove(node)\n        return node.val\n\n\n# Your MaxStack object will be instantiated and called as such:\n# obj = MaxStack()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.top()\n# param_4 = obj.peekMax()\n# param_5 = obj.popMax()\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 790, "slug": "domino-and-tromino-tiling", "solutions": ["class Solution:\n    def numTilings(self, n: int) -> int:\n        f = [1, 0, 0, 0]\n        mod = 10**9 + 7\n        for i in range(1, n + 1):\n            g = [0] * 4\n            g[0] = (f[0] + f[1] + f[2] + f[3]) % mod\n            g[1] = (f[2] + f[3]) % mod\n            g[2] = (f[1] + f[3]) % mod\n            g[3] = f[0]\n            f = g\n        return f[0]\n", "class Solution:\n  def numTilings(self, n: int) -> int:\n    MOD = 1_000_000_007\n    dp = [0, 1, 2, 5] + [0] * 997\n\n    for i in range(4, n + 1):\n      dp[i] = 2 * dp[i - 1] + dp[i - 3]\n\n    return dp[n] % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 750, "slug": "number-of-corner-rectangles", "solutions": ["class Solution:\n    def countCornerRectangles(self, grid: List[List[int]]) -> int:\n        ans = 0\n        cnt = Counter()\n        n = len(grid[0])\n        for row in grid:\n            for i, c1 in enumerate(row):\n                if c1:\n                    for j in range(i + 1, n):\n                        if row[j]:\n                            ans += cnt[(i, j)]\n                            cnt[(i, j)] += 1\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 758, "slug": "bold-words-in-string", "solutions": ["class Trie:\n    def __init__(self):\n        self.children = [None] * 128\n        self.is_end = False\n\n    def insert(self, word):\n        node = self\n        for c in word:\n            idx = ord(c)\n            if node.children[idx] is None:\n                node.children[idx] = Trie()\n            node = node.children[idx]\n        node.is_end = True\n\n\nclass Solution:\n    def boldWords(self, words: List[str], s: str) -> str:\n        trie = Trie()\n        for w in words:\n            trie.insert(w)\n        n = len(s)\n        pairs = []\n        for i in range(n):\n            node = trie\n            for j in range(i, n):\n                idx = ord(s[j])\n                if node.children[idx] is None:\n                    break\n                node = node.children[idx]\n                if node.is_end:\n                    pairs.append([i, j])\n        if not pairs:\n            return s\n        st, ed = pairs[0]\n        t = []\n        for a, b in pairs[1:]:\n            if ed + 1 < a:\n                t.append([st, ed])\n                st, ed = a, b\n            else:\n                ed = max(ed, b)\n        t.append([st, ed])\n\n        ans = []\n        i = j = 0\n        while i < n:\n            if j == len(t):\n                ans.append(s[i:])\n                break\n            st, ed = t[j]\n            if i < st:\n                ans.append(s[i:st])\n            ans.append('<b>')\n            ans.append(s[st : ed + 1])\n            ans.append('</b>')\n            j += 1\n            i = ed + 1\n\n        return ''.join(ans)\n", "class Solution:\n  def boldWords(self, words: list[str], s: str) -> str:\n    n = len(s)\n    ans = []\n    # bold[i] := True if s[i] should be bolded\n    bold = [0] * n\n\n    boldEnd = -1  # s[i:boldEnd] should be bolded\n    for i in range(n):\n      for word in words:\n        if s[i:].startswith(word):\n          boldEnd = max(boldEnd, i + len(word))\n      bold[i] = boldEnd > i\n\n    # Construct the string with the bold tags.\n    i = 0\n    while i < n:\n      if bold[i]:\n        j = i\n        while j < n and bold[j]:\n          j += 1\n        # s[i..j) should be bolded.\n        ans.append('<b>' + s[i:j] + '</b>')\n        i = j\n      else:\n        ans.append(s[i])\n        i += 1\n\n    return ''.join(ans)\n", "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.isWord = False\n\n\nclass Solution:\n  def boldWords(self, words: list[str], s: str) -> str:\n    n = len(s)\n    ans = []\n    # bold[i] := True if s[i] should be bolded\n    bold = [0] * n\n    root = TrieNode()\n\n    def insert(word: str) -> None:\n      node = root\n      for c in word:\n        if c not in node.children:\n          node.children[c] = TrieNode()\n        node = node.children[c]\n      node.isWord = True\n\n    def find(s: str, i: int) -> int:\n      node = root\n      ans = -1\n      for j in range(i, len(s)):\n        node = node.children.setdefault(s[j], TrieNode())\n        if node.isWord:\n          ans = j\n      return ans\n\n    for word in words:\n      insert(word)\n\n    boldEnd = -1  # `s[i..boldEnd]` should be bolded.\n    for i in range(n):\n      boldEnd = max(boldEnd, find(s, i))\n      bold[i] = boldEnd >= i\n\n    # Construct the with bold tags\n    i = 0\n    while i < n:\n      if bold[i]:\n        j = i\n        while j < n and bold[j]:\n          j += 1\n        # `s[i..j)` should be bolded.\n        ans.append('<b>' + s[i:j] + '</b>')\n        i = j\n      else:\n        ans.append(s[i])\n        i += 1\n\n    return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 732, "slug": "my-calendar-iii", "solutions": ["class Node:\n    def __init__(self, l, r):\n        self.left = None\n        self.right = None\n        self.l = l\n        self.r = r\n        self.mid = (l + r) >> 1\n        self.v = 0\n        self.add = 0\n\n\nclass SegmentTree:\n    def __init__(self):\n        self.root = Node(1, int(1e9 + 1))\n\n    def modify(self, l: int, r: int, v: int, node: Node = None):\n        if l > r:\n            return\n        if node is None:\n            node = self.root\n        if node.l >= l and node.r <= r:\n            node.v += v\n            node.add += v\n            return\n        self.pushdown(node)\n        if l <= node.mid:\n            self.modify(l, r, v, node.left)\n        if r > node.mid:\n            self.modify(l, r, v, node.right)\n        self.pushup(node)\n\n    def query(self, l: int, r: int, node: Node = None) -> int:\n        if l > r:\n            return 0\n        if node is None:\n            node = self.root\n        if node.l >= l and node.r <= r:\n            return node.v\n        self.pushdown(node)\n        v = 0\n        if l <= node.mid:\n            v = max(v, self.query(l, r, node.left))\n        if r > node.mid:\n            v = max(v, self.query(l, r, node.right))\n        return v\n\n    def pushup(self, node: Node):\n        node.v = max(node.left.v, node.right.v)\n\n    def pushdown(self, node: Node):\n        if node.left is None:\n            node.left = Node(node.l, node.mid)\n        if node.right is None:\n            node.right = Node(node.mid + 1, node.r)\n        if node.add:\n            node.left.v += node.add\n            node.right.v += node.add\n            node.left.add += node.add\n            node.right.add += node.add\n            node.add = 0\n\n\nclass MyCalendarThree:\n    def __init__(self):\n        self.tree = SegmentTree()\n\n    def book(self, start: int, end: int) -> int:\n        self.tree.modify(start + 1, end, 1)\n        return self.tree.query(1, int(1e9 + 1))\n\n\n# Your MyCalendarThree object will be instantiated and called as such:\n# obj = MyCalendarThree()\n# param_1 = obj.book(start,end)\n", "from sortedcontainers import SortedDict\n\n\nclass MyCalendarThree:\n  def __init__(self):\n    self.timeline = SortedDict()\n\n  def book(self, start: int, end: int) -> int:\n    self.timeline[start] = self.timeline.get(start, 0) + 1\n    self.timeline[end] = self.timeline.get(end, 0) - 1\n\n    ans = 0\n    activeEvents = 0\n\n    for count in self.timeline.values():\n      activeEvents += count\n      ans = max(ans, activeEvents)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 748, "slug": "shortest-completing-word", "solutions": ["class Solution:\n    def shortestCompletingWord(self, licensePlate: str, words: List[str]) -> str:\n        cnt = Counter(c.lower() for c in licensePlate if c.isalpha())\n        ans = None\n        for w in words:\n            if ans and len(w) >= len(ans):\n                continue\n            t = Counter(w)\n            if all(v <= t[c] for c, v in cnt.items()):\n                ans = w\n        return ans\n", "class Solution:\n  def shortestCompletingWord(self, licensePlate: str, words: list[str]) -> str:\n    def isMatch(word: str) -> bool:\n      wordCount = collections.Counter(word)\n      return False if any(\n          wordCount[i] < count[i] for i in string.ascii_letters) else True\n\n    ans = '*' * 16\n    count = collections.defaultdict(int)\n\n    for c in licensePlate:\n      if c.isalpha():\n        count[c.lower()] += 1\n\n    for word in words:\n      if len(word) < len(ans) and isMatch(word):\n        ans = word\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 715, "slug": "range-module", "solutions": ["class Node:\n    __slots__ = ['left', 'right', 'add', 'v']\n\n    def __init__(self):\n        self.left = None\n        self.right = None\n        self.add = 0\n        self.v = False\n\n\nclass SegmentTree:\n    __slots__ = ['root']\n\n    def __init__(self):\n        self.root = Node()\n\n    def modify(self, left, right, v, l=1, r=int(1e9), node=None):\n        if node is None:\n            node = self.root\n        if l >= left and r <= right:\n            if v == 1:\n                node.add = 1\n                node.v = True\n            else:\n                node.add = -1\n                node.v = False\n            return\n        self.pushdown(node)\n        mid = (l + r) >> 1\n        if left <= mid:\n            self.modify(left, right, v, l, mid, node.left)\n        if right > mid:\n            self.modify(left, right, v, mid + 1, r, node.right)\n        self.pushup(node)\n\n    def query(self, left, right, l=1, r=int(1e9), node=None):\n        if node is None:\n            node = self.root\n        if l >= left and r <= right:\n            return node.v\n        self.pushdown(node)\n        mid = (l + r) >> 1\n        v = True\n        if left <= mid:\n            v = v and self.query(left, right, l, mid, node.left)\n        if right > mid:\n            v = v and self.query(left, right, mid + 1, r, node.right)\n        return v\n\n    def pushup(self, node):\n        node.v = bool(node.left and node.left.v and node.right and node.right.v)\n\n    def pushdown(self, node):\n        if node.left is None:\n            node.left = Node()\n        if node.right is None:\n            node.right = Node()\n        if node.add:\n            node.left.add = node.right.add = node.add\n            node.left.v = node.add == 1\n            node.right.v = node.add == 1\n            node.add = 0\n\n\nclass RangeModule:\n    def __init__(self):\n        self.tree = SegmentTree()\n\n    def addRange(self, left: int, right: int) -> None:\n        self.tree.modify(left, right - 1, 1)\n\n    def queryRange(self, left: int, right: int) -> bool:\n        return self.tree.query(left, right - 1)\n\n    def removeRange(self, left: int, right: int) -> None:\n        self.tree.modify(left, right - 1, -1)\n\n\n# Your RangeModule object will be instantiated and called as such:\n# obj = RangeModule()\n# obj.addRange(left,right)\n# param_2 = obj.queryRange(left,right)\n# obj.removeRange(left,right)\n", "class RangeModule:\n  def __init__(self):\n    self.A = []\n\n  def addRange(self, left: int, right: int) -> None:\n    i = bisect_left(self.A, left)\n    j = bisect_right(self.A, right)\n    self.A[i:j] = [left] * (i % 2 == 0) + [right] * (j % 2 == 0)\n\n  def queryRange(self, left: int, right: int) -> bool:\n    i = bisect_right(self.A, left)\n    j = bisect_left(self.A, right)\n    return i == j and i % 2 == 1\n\n  def removeRange(self, left: int, right: int) -> None:\n    i = bisect_left(self.A, left)\n    j = bisect_right(self.A, right)\n    self.A[i:j] = [left] * (i % 2 == 1) + [right] * (j % 2 == 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 740, "slug": "delete-and-earn", "solutions": ["class Solution:\n    def deleteAndEarn(self, nums: List[int]) -> int:\n        mx = -inf\n        for num in nums:\n            mx = max(mx, num)\n        total = [0] * (mx + 1)\n        for num in nums:\n            total[num] += num\n        first = total[0]\n        second = max(total[0], total[1])\n        for i in range(2, mx + 1):\n            cur = max(first + total[i], second)\n            first = second\n            second = cur\n        return second\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 761, "slug": "special-binary-string", "solutions": ["class Solution:\n    def makeLargestSpecial(self, s: str) -> str:\n        if s == '':\n            return ''\n        ans = []\n        cnt = 0\n        i = j = 0\n        while i < len(s):\n            cnt += 1 if s[i] == '1' else -1\n            if cnt == 0:\n                ans.append('1' + self.makeLargestSpecial(s[j + 1 : i]) + '0')\n                j = i + 1\n            i += 1\n        ans.sort(reverse=True)\n        return ''.join(ans)\n", "class Solution:\n  def makeLargestSpecial(self, s: str) -> str:\n    specials = []\n    count = 0\n\n    i = 0\n    for j, c in enumerate(s):\n      count += 1 if c == '1' else -1\n      if count == 0:\n        specials.append(\n            '1' + self.makeLargestSpecial(s[i + 1:j]) + '0')\n        i = j + 1\n\n    return ''.join(sorted(specials)[::-1])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 772, "slug": "basic-calculator-iii", "solutions": ["class Solution:\n    def calculate(self, s: str) -> int:\n        def dfs(q):\n            num, sign, stk = 0, \"+\", []\n            while q:\n                c = q.popleft()\n                if c.isdigit():\n                    num = num * 10 + int(c)\n                if c == \"(\":\n                    num = dfs(q)\n                if c in \"+-*/)\" or not q:\n                    match sign:\n                        case \"+\":\n                            stk.append(num)\n                        case \"-\":\n                            stk.append(-num)\n                        case \"*\":\n                            stk.append(stk.pop() * num)\n                        case \"/\":\n                            stk.append(int(stk.pop() / num))\n                    num, sign = 0, c\n                if c == \")\":\n                    break\n            return sum(stk)\n\n        return dfs(deque(s))\n", "class Solution:\n  def calculate(self, s: str) -> int:\n    nums = []\n    ops = []\n\n    def calc():\n      b = nums.pop()\n      a = nums.pop()\n      op = ops.pop()\n      if op == '+':\n        nums.append(a + b)\n      elif op == '-':\n        nums.append(a - b)\n      elif op == '*':\n        nums.append(a * b)\n      else:  # op == '/'\n        nums.append(int(a / b))\n\n    def precedes(prev: str, curr: str) -> bool:\n      \"\"\"\n      Returns True if the previous character is a operator and the priority of\n      the previous operator >= the priority of the current character (operator).\n      \"\"\"\n      if prev == '(':\n        return False\n      return prev in '*/' or curr in '+-'\n\n    i = 0\n    hasPrevNum = False\n\n    while i < len(s):\n      c = s[i]\n      if c.isdigit():\n        num = int(c)\n        while i + 1 < len(s) and s[i + 1].isdigit():\n          num = num * 10 + int(s[i + 1])\n          i += 1\n        nums.append(num)\n        hasPrevNum = True\n      elif c == '(':\n        ops.append('(')\n        hasPrevNum = False\n      elif c == ')':\n        while ops[-1] != '(':\n          calc()\n        ops.pop()  # Pop '('\n      elif c in '+-*/':\n        if not hasPrevNum:  # Handle input like \"-1-(-1)\"\n          num.append(0)\n        while ops and precedes(ops[-1], c):\n          calc()\n        ops.append(c)\n      i += 1\n\n    while ops:\n      calc()\n\n    return nums.pop()\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 760, "slug": "find-anagram-mappings", "solutions": ["class Solution:\n    def anagramMappings(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        mapper = defaultdict(set)\n        for i, num in enumerate(nums2):\n            mapper[num].add(i)\n        return [mapper[num].pop() for num in nums1]\n", "class Solution:\n  def anagramMappings(self, nums1: list[int], nums2: list[int]) -> list[int]:\n    numToIndices = collections.defaultdict(list)\n\n    for i, num in enumerate(nums2):\n      numToIndices[num].append(i)\n\n    return [numToIndices[num].pop() for num in nums1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 755, "slug": "pour-water", "solutions": ["class Solution:\n    def pourWater(self, heights: List[int], volume: int, k: int) -> List[int]:\n        for _ in range(volume):\n            for d in (-1, 1):\n                i = j = k\n                while 0 <= i + d < len(heights) and heights[i + d] <= heights[i]:\n                    if heights[i + d] < heights[i]:\n                        j = i + d\n                    i += d\n                if j != k:\n                    heights[j] += 1\n                    break\n            else:\n                heights[k] += 1\n        return heights\n", "class Solution:\n  def pourWater(self, heights: list[int], volume: int, k: int) -> list[int]:\n    i = k\n\n    while volume > 0:\n      volume -= 1\n      while i > 0 and heights[i] >= heights[i - 1]:\n        i -= 1\n      while i + 1 < len(heights) and heights[i] >= heights[i + 1]:\n        i += 1\n      while i > k and heights[i] == heights[i - 1]:\n        i -= 1\n      heights[i] += 1\n\n    return heights\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 742, "slug": "closest-leaf-in-a-binary-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findClosestLeaf(self, root: Optional[TreeNode], k: int) -> int:\n        def dfs(root: Optional[TreeNode], fa: Optional[TreeNode]):\n            if root:\n                g[root].append(fa)\n                g[fa].append(root)\n                dfs(root.left, root)\n                dfs(root.right, root)\n\n        g = defaultdict(list)\n        dfs(root, None)\n        q = deque(node for node in g if node and node.val == k)\n        vis = set(q)\n        while 1:\n            node = q.popleft()\n            if node:\n                if node.left == node.right:\n                    return node.val\n                for nxt in g[node]:\n                    if nxt not in vis:\n                        vis.add(nxt)\n                        q.append(nxt)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 706, "slug": "design-hashmap", "solutions": ["class MyHashMap:\n    def __init__(self):\n        self.data = [-1] * 1000001\n\n    def put(self, key: int, value: int) -> None:\n        self.data[key] = value\n\n    def get(self, key: int) -> int:\n        return self.data[key]\n\n    def remove(self, key: int) -> None:\n        self.data[key] = -1\n\n\n# Your MyHashMap object will be instantiated and called as such:\n# obj = MyHashMap()\n# obj.put(key,value)\n# param_2 = obj.get(key)\n# obj.remove(key)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 705, "slug": "design-hashset", "solutions": ["class MyHashSet:\n    def __init__(self):\n        self.data = [False] * 1000001\n\n    def add(self, key: int) -> None:\n        self.data[key] = True\n\n    def remove(self, key: int) -> None:\n        self.data[key] = False\n\n    def contains(self, key: int) -> bool:\n        return self.data[key]\n\n\n# Your MyHashSet object will be instantiated and called as such:\n# obj = MyHashSet()\n# obj.add(key)\n# obj.remove(key)\n# param_3 = obj.contains(key)\n", "class MyHashSet:\n  def __init__(self):\n    self.set = [False] * 1000001\n\n  def add(self, key: int) -> None:\n    self.set[key] = True\n\n  def remove(self, key: int) -> None:\n    self.set[key] = False\n\n  def contains(self, key: int) -> bool:\n    return self.set[key]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 739, "slug": "daily-temperatures", "solutions": ["class Solution:\n    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:\n        stk = []\n        n = len(temperatures)\n        ans = [0] * n\n        for i in range(n - 1, -1, -1):\n            while stk and temperatures[stk[-1]] <= temperatures[i]:\n                stk.pop()\n            if stk:\n                ans[i] = stk[-1] - i\n            stk.append(i)\n        return ans\n", "class Solution:\n  def dailyTemperatures(self, temperatures: list[int]) -> list[int]:\n    ans = [0] * len(temperatures)\n    stack = []  # a decreasing stack\n\n    for i, temperature in enumerate(temperatures):\n      while stack and temperature > temperatures[stack[-1]]:\n        index = stack.pop()\n        ans[index] = i - index\n      stack.append(i)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 777, "slug": "swap-adjacent-in-lr-string", "solutions": ["class Solution:\n    def canTransform(self, start: str, end: str) -> bool:\n        n = len(start)\n        i = j = 0\n        while 1:\n            while i < n and start[i] == 'X':\n                i += 1\n            while j < n and end[j] == 'X':\n                j += 1\n            if i >= n and j >= n:\n                return True\n            if i >= n or j >= n or start[i] != end[j]:\n                return False\n            if start[i] == 'L' and i < j:\n                return False\n            if start[i] == 'R' and i > j:\n                return False\n            i, j = i + 1, j + 1\n", "class Solution:\n  def canTransform(self, start: str, end: str) -> bool:\n    if start.replace('X', '') != end.replace('X', ''):\n      return False\n\n    i = 0  # start's index\n    j = 0  # end's index\n\n    while i < len(start) and j < len(end):\n      while i < len(start) and start[i] == 'X':\n        i += 1\n      while j < len(end) and end[j] == 'X':\n        j += 1\n      if i == len(start) and j == len(end):\n        return True\n      if i == len(start) or j == len(end):\n        return False\n      # L can only move to left.\n      if start[i] == 'L' and i < j:\n        return False\n      # R can only move to right.\n      if start[i] == 'R' and i > j:\n        return False\n      i += 1\n      j += 1\n\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 789, "slug": "escape-the-ghosts", "solutions": ["class Solution:\n    def escapeGhosts(self, ghosts: List[List[int]], target: List[int]) -> bool:\n        tx, ty = target\n        return all(abs(tx - x) + abs(ty - y) > abs(tx) + abs(ty) for x, y in ghosts)\n", "class Solution:\n  def escapeGhosts(self, ghosts: list[list[int]], target: list[int]) -> bool:\n    ghostSteps = min(abs(x - target[0]) +\n                     abs(y - target[1]) for x, y in ghosts)\n\n    return abs(target[0]) + abs(target[1]) < ghostSteps\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 747, "slug": "largest-number-at-least-twice-of-others", "solutions": ["class Solution:\n    def dominantIndex(self, nums: List[int]) -> int:\n        x, y = nlargest(2, nums)\n        return nums.index(x) if x >= 2 * y else -1\n", "class Solution:\n  def dominantIndex(self, nums: list[int]) -> int:\n    mx = 0\n    secondMax = 0\n\n    for i, num in enumerate(nums):\n      if num > mx:\n        secondMax = mx\n        mx = num\n        ans = i\n      elif num > secondMax:\n        secondMax = num\n\n    return ans if mx >= 2 * secondMax else -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 796, "slug": "rotate-string", "solutions": ["class Solution:\n    def rotateString(self, s: str, goal: str) -> bool:\n        return len(s) == len(goal) and goal in s + s\n", "class Solution:\n  def rotateString(self, s: str, goal: str) -> bool:\n    return len(s) == len(goal) and goal in s + s\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 757, "slug": "set-intersection-size-at-least-two", "solutions": ["class Solution:\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key=lambda x: (x[1], -x[0]))\n        s = e = -1\n        ans = 0\n        for a, b in intervals:\n            if a <= s:\n                continue\n            if a > e:\n                ans += 2\n                s, e = b - 1, b\n            else:\n                ans += 1\n                s, e = e, b\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 785, "slug": "is-graph-bipartite", "solutions": ["class Solution:\n    def isBipartite(self, graph: List[List[int]]) -> bool:\n        def dfs(a: int, c: int) -> bool:\n            color[a] = c\n            for b in graph[a]:\n                if color[b] == c or (color[b] == 0 and not dfs(b, -c)):\n                    return False\n            return True\n\n        n = len(graph)\n        color = [0] * n\n        for i in range(n):\n            if color[i] == 0 and not dfs(i, 1):\n                return False\n        return True\n", "from enum import Enum\n\n\nclass Color(Enum):\n  WHITE = 0\n  RED = 1\n  GREEN = 2\n\n\nclass Solution:\n  def isBipartite(self, graph: list[list[int]]) -> bool:\n    colors = [Color.WHITE] * len(graph)\n\n    for i in range(len(graph)):\n      # This node has been colored, so do nothing.\n      if colors[i] != Color.WHITE:\n        continue\n      # Always paint red for a white node.\n      colors[i] = Color.RED\n      # BFS.\n      q = collections.deque([i])\n      while q:\n        for _ in range(len(q)):\n          u = q.popleft()\n          for v in graph[u]:\n            if colors[v] == colors[u]:\n              return False\n            if colors[v] == Color.WHITE:\n              colors[v] = Color.RED if colors[u] == Color.GREEN else Color.GREEN\n              q.append(v)\n\n    return True\n", "from enum import Enum\n\n\nclass Color(Enum):\n  WHITE = 0\n  RED = 1\n  GREEN = 2\n\n\nclass Solution:\n  def isBipartite(self, graph: list[list[int]]) -> bool:\n    colors = [Color.WHITE] * len(graph)\n\n    def isValidColor(u: int, color: Color) -> bool:\n      # The painted color should be same as `color`.\n      if colors[u] != Color.WHITE:\n        return colors[u] == color\n\n      colors[u] = color\n\n      # All the children should have valid colors.\n      childrenColor = Color.RED if colors[u] == Color.GREEN else Color.GREEN\n      return all(isValidColor(v, childrenColor) for v in graph[u])\n\n    return all(colors[i] != Color.WHITE or isValidColor(i, Color.RED)\n               for i in range(len(graph)))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 774, "slug": "minimize-max-distance-to-gas-station", "solutions": ["class Solution:\n    def minmaxGasDist(self, stations: List[int], k: int) -> float:\n        def check(x):\n            return sum(int((b - a) / x) for a, b in pairwise(stations)) <= k\n\n        left, right = 0, 1e8\n        while right - left > 1e-6:\n            mid = (left + right) / 2\n            if check(mid):\n                right = mid\n            else:\n                left = mid\n        return left\n", "class Solution:\n  def minmaxGasDist(self, stations: list[int], k: int) -> float:\n    ERR = 1e-6\n    l = 0\n    r = stations[-1] - stations[0]\n\n    def possible(k: int, m: float) -> bool:\n      \"\"\"\n      Returns True if can use <= k gas stations to ensure that each adjacent\n      distance between gas stations <= m.\n      \"\"\"\n      for a, b in zip(stations, stations[1:]):\n        diff = b - a\n        if diff > m:\n          k -= math.ceil(diff / m) - 1\n          if k < 0:\n            return False\n      return True\n\n    while r - l > ERR:\n      m = (l + r) / 2\n      if possible(k, m):\n        r = m\n      else:\n        l = m\n\n    return l\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 708, "slug": "insert-into-a-sorted-circular-linked-list", "solutions": ["\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val=None, next=None):\n        self.val = val\n        self.next = next\n\"\"\"\n\n\nclass Solution:\n    def insert(self, head: 'Optional[Node]', insertVal: int) -> 'Node':\n        node = Node(insertVal)\n        if head is None:\n            node.next = node\n            return node\n        prev, curr = head, head.next\n        while curr != head:\n            if prev.val <= insertVal <= curr.val or (\n                prev.val > curr.val and (insertVal >= prev.val or insertVal <= curr.val)\n            ):\n                break\n            prev, curr = curr, curr.next\n        prev.next = node\n        node.next = curr\n        return head\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 711, "slug": "number-of-distinct-islands-ii", "solutions": ["class Solution:\n    def numDistinctIslands2(self, grid: List[List[int]]) -> int:\n        def dfs(i, j, shape):\n            shape.append([i, j])\n            grid[i][j] = 0\n            for a, b in [[1, 0], [-1, 0], [0, 1], [0, -1]]:\n                x, y = i + a, j + b\n                if 0 <= x < m and 0 <= y < n and grid[x][y] == 1:\n                    dfs(x, y, shape)\n\n        def normalize(shape):\n            shapes = [[] for _ in range(8)]\n            for i, j in shape:\n                shapes[0].append([i, j])\n                shapes[1].append([i, -j])\n                shapes[2].append([-i, j])\n                shapes[3].append([-i, -j])\n                shapes[4].append([j, i])\n                shapes[5].append([j, -i])\n                shapes[6].append([-j, i])\n                shapes[7].append([-j, -i])\n            for e in shapes:\n                e.sort()\n                for i in range(len(e) - 1, -1, -1):\n                    e[i][0] -= e[0][0]\n                    e[i][1] -= e[0][1]\n            shapes.sort()\n            return tuple(tuple(e) for e in shapes[0])\n\n        m, n = len(grid), len(grid[0])\n        s = set()\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]:\n                    shape = []\n                    dfs(i, j, shape)\n                    s.add(normalize(shape))\n        return len(s)\n", "class Solution:\n  def numDistinctIslands2(self, grid: list[list[int]]) -> int:\n    seen = set()\n\n    def dfs(i: int, j: int):\n      if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]):\n        return\n      if grid[i][j] == 0 or (i, j) in seen:\n        return\n\n      seen.add((i, j))\n      island.append((i, j))\n      dfs(i + 1, j)\n      dfs(i - 1, j)\n      dfs(i, j + 1)\n      dfs(i, j - 1)\n\n    def normalize(island: list[tuple]) -> list[tuple]:\n      # points[i] := 8 different rotations/reflections of an island\n      points = [[] for _ in range(8)]\n\n      for i, j in island:\n        points[0].append((i, j))\n        points[1].append((i, -j))\n        points[2].append((-i, j))\n        points[3].append((-i, -j))\n        points[4].append((j, i))\n        points[5].append((j, -i))\n        points[6].append((-j, i))\n        points[7].append((-j, -i))\n\n      points = [sorted(p) for p in points]\n\n      # Normalize each p by substracting p[1..7] with p[0].\n      for p in points:\n        for i in range(1, len(island)):\n          p[i] = (p[i][0] - p[0][0],\n                  p[i][1] - p[0][1])\n        p[0] = (0, 0)\n\n      return sorted(points)[0]\n\n    islands = set()  # all the islands with different shapes\n\n    for i in range(len(grid)):\n      for j in range(len(grid[0])):\n        island = []\n        dfs(i, j)\n        if island:\n          islands.add(frozenset(normalize(island)))\n\n    return len(islands)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 714, "slug": "best-time-to-buy-and-sell-stock-with-transaction-fee", "solutions": ["class Solution:\n    def maxProfit(self, prices: List[int], fee: int) -> int:\n        @cache\n        def dfs(i: int, j: int) -> int:\n            if i >= len(prices):\n                return 0\n            ans = dfs(i + 1, j)\n            if j:\n                ans = max(ans, prices[i] + dfs(i + 1, 0) - fee)\n            else:\n                ans = max(ans, -prices[i] + dfs(i + 1, 1))\n            return ans\n\n        return dfs(0, 0)\n", "class Solution:\n  def maxProfit(self, prices: list[int], fee: int) -> int:\n    sell = 0\n    hold = -math.inf\n\n    for price in prices:\n      sell = max(sell, hold + price)\n      hold = max(hold, sell - price - fee)\n\n    return sell\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 704, "slug": "binary-search", "solutions": ["class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums) - 1\n        while l < r:\n            mid = (l + r) >> 1\n            if nums[mid] >= target:\n                r = mid\n            else:\n                l = mid + 1\n        return l if nums[l] == target else -1\n", "class Solution:\n  def search(self, nums: list[int], target: int) -> int:\n    i = bisect.bisect_left(nums, target)\n    return -1 if i == len(nums) or nums[i] != target else i\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 743, "slug": "network-delay-time", "solutions": ["class Solution:\n    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:\n        g = [[inf] * n for _ in range(n)]\n        for u, v, w in times:\n            g[u - 1][v - 1] = w\n        dist = [inf] * n\n        dist[k - 1] = 0\n        vis = [False] * n\n        for _ in range(n):\n            t = -1\n            for j in range(n):\n                if not vis[j] and (t == -1 or dist[t] > dist[j]):\n                    t = j\n            vis[t] = True\n            for j in range(n):\n                dist[j] = min(dist[j], dist[t] + g[t][j])\n        ans = max(dist)\n        return -1 if ans == inf else ans\n", "class Solution:\n  def networkDelayTime(self, times: list[list[int]], n: int, k: int) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in times:\n      graph[u - 1].append((v - 1, w))\n\n    return self._dijkstra(graph, k - 1)\n\n  def _dijkstra(self, graph: list[list[tuple[int, int]]], src: int) -> int:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    maxDist = max(dist)\n    return maxDist if maxDist != math.inf else -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 782, "slug": "transform-to-chessboard", "solutions": ["class Solution:\n    def movesToChessboard(self, board: List[List[int]]) -> int:\n        def f(mask, cnt):\n            ones = mask.bit_count()\n            if n & 1:\n                if abs(n - 2 * ones) != 1 or abs(n - 2 * cnt) != 1:\n                    return -1\n                if ones == n // 2:\n                    return n // 2 - (mask & 0xAAAAAAAA).bit_count()\n                return (n + 1) // 2 - (mask & 0x55555555).bit_count()\n            else:\n                if ones != n // 2 or cnt != n // 2:\n                    return -1\n                cnt0 = n // 2 - (mask & 0xAAAAAAAA).bit_count()\n                cnt1 = n // 2 - (mask & 0x55555555).bit_count()\n                return min(cnt0, cnt1)\n\n        n = len(board)\n        mask = (1 << n) - 1\n        rowMask = colMask = 0\n        for i in range(n):\n            rowMask |= board[0][i] << i\n            colMask |= board[i][0] << i\n        revRowMask = mask ^ rowMask\n        revColMask = mask ^ colMask\n        sameRow = sameCol = 0\n        for i in range(n):\n            curRowMask = curColMask = 0\n            for j in range(n):\n                curRowMask |= board[i][j] << j\n                curColMask |= board[j][i] << j\n            if curRowMask not in (rowMask, revRowMask) or curColMask not in (\n                colMask,\n                revColMask,\n            ):\n                return -1\n            sameRow += curRowMask == rowMask\n            sameCol += curColMask == colMask\n        t1 = f(rowMask, sameRow)\n        t2 = f(colMask, sameCol)\n        return -1 if t1 == -1 or t2 == -1 else t1 + t2\n", "class Solution:\n  def movesToChessboard(self, board: list[list[int]]) -> int:\n    n = len(board)\n\n    if any(board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]\n           for i in range(n) for j in range(n)):\n      return -1\n\n    rowSum = sum(board[0])\n    colSum = sum(board[i][0] for i in range(n))\n\n    if rowSum != n // 2 and rowSum != (n + 1) // 2:\n      return -1\n    if colSum != n // 2 and colSum != (n + 1) // 2:\n      return -1\n\n    rowSwaps = sum(board[i][0] == (i & 1) for i in range(n))\n    colSwaps = sum(board[0][i] == (i & 1) for i in range(n))\n\n    if n % 2 == 1:\n      if rowSwaps % 2 == 1:\n        rowSwaps = n - rowSwaps\n      if colSwaps % 2 == 1:\n        colSwaps = n - colSwaps\n    else:\n      rowSwaps = min(rowSwaps, n - rowSwaps)\n      colSwaps = min(colSwaps, n - colSwaps)\n\n    return (rowSwaps + colSwaps) // 2\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 731, "slug": "my-calendar-ii", "solutions": ["class MyCalendarTwo:\n    def __init__(self):\n        self.sd = SortedDict()\n\n    def book(self, startTime: int, endTime: int) -> bool:\n        self.sd[startTime] = self.sd.get(startTime, 0) + 1\n        self.sd[endTime] = self.sd.get(endTime, 0) - 1\n        s = 0\n        for v in self.sd.values():\n            s += v\n            if s > 2:\n                self.sd[startTime] -= 1\n                self.sd[endTime] += 1\n                return False\n        return True\n\n\n# Your MyCalendarTwo object will be instantiated and called as such:\n# obj = MyCalendarTwo()\n# param_1 = obj.book(startTime,endTime)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 776, "slug": "split-bst", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def splitBST(\n        self, root: Optional[TreeNode], target: int\n    ) -> List[Optional[TreeNode]]:\n        def dfs(root):\n            if root is None:\n                return [None, None]\n            if root.val <= target:\n                l, r = dfs(root.right)\n                root.right = l\n                return [root, r]\n            else:\n                l, r = dfs(root.left)\n                root.left = r\n                return [l, root]\n\n        return dfs(root)\n", "class Solution:\n  def splitBST(self, root: TreeNode | None, target: int) -> list[TreeNode | None]:\n    if not root:\n      return None, None\n    if root.val > target:\n      left, right = self.splitBST(root.left, target)\n      root.left = right\n      return left, root\n    else:  # root.val <= target\n      left, right = self.splitBST(root.right, target)\n      root.right = left\n      return root, right\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 710, "slug": "random-pick-with-blacklist", "solutions": ["class Solution:\n    def __init__(self, n: int, blacklist: List[int]):\n        self.k = n - len(blacklist)\n        self.d = {}\n        i = self.k\n        black = set(blacklist)\n        for b in blacklist:\n            if b < self.k:\n                while i in black:\n                    i += 1\n                self.d[b] = i\n                i += 1\n\n    def pick(self) -> int:\n        x = randrange(self.k)\n        return self.d.get(x, x)\n\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution(n, blacklist)\n# param_1 = obj.pick()\n", "class Solution:\n  def __init__(self, n: int, blacklist: list[int]):\n    self.validRange = n - len(blacklist)\n    self.dict = {}\n\n    maxAvailable = n - 1\n\n    for b in blacklist:\n      self.dict[b] = -1\n\n    for b in blacklist:\n      if b < self.validRange:\n        # Find the slot that haven't been used.\n        while maxAvailable in self.dict:\n          maxAvailable -= 1\n        self.dict[b] = maxAvailable\n        maxAvailable -= 1\n\n  def pick(self) -> int:\n    value = random.randint(0, self.validRange - 1)\n\n    if value in self.dict:\n      return self.dict[value]\n\n    return value\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 745, "slug": "prefix-and-suffix-search", "solutions": ["class WordFilter:\n    def __init__(self, words: List[str]):\n        self.d = {}\n        for k, w in enumerate(words):\n            n = len(w)\n            for i in range(n + 1):\n                a = w[:i]\n                for j in range(n + 1):\n                    b = w[j:]\n                    self.d[(a, b)] = k\n\n    def f(self, pref: str, suff: str) -> int:\n        return self.d.get((pref, suff), -1)\n\n\n# Your WordFilter object will be instantiated and called as such:\n# obj = WordFilter(words)\n# param_1 = obj.f(pref,suff)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 765, "slug": "couples-holding-hands", "solutions": ["class Solution:\n    def minSwapsCouples(self, row: List[int]) -> int:\n        def find(x: int) -> int:\n            if p[x] != x:\n                p[x] = find(p[x])\n            return p[x]\n\n        n = len(row) >> 1\n        p = list(range(n))\n        for i in range(0, len(row), 2):\n            a, b = row[i] >> 1, row[i + 1] >> 1\n            p[find(a)] = find(b)\n        return n - sum(i == find(i) for i in range(n))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 741, "slug": "cherry-pickup", "solutions": ["class Solution:\n    def cherryPickup(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        f = [[[-inf] * n for _ in range(n)] for _ in range((n << 1) - 1)]\n        f[0][0][0] = grid[0][0]\n        for k in range(1, (n << 1) - 1):\n            for i1 in range(n):\n                for i2 in range(n):\n                    j1, j2 = k - i1, k - i2\n                    if (\n                        not 0 <= j1 < n\n                        or not 0 <= j2 < n\n                        or grid[i1][j1] == -1\n                        or grid[i2][j2] == -1\n                    ):\n                        continue\n                    t = grid[i1][j1]\n                    if i1 != i2:\n                        t += grid[i2][j2]\n                    for x1 in range(i1 - 1, i1 + 1):\n                        for x2 in range(i2 - 1, i2 + 1):\n                            if x1 >= 0 and x2 >= 0:\n                                f[k][i1][i2] = max(f[k][i1][i2], f[k - 1][x1][x2] + t)\n        return max(0, f[-1][-1][-1])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 749, "slug": "contain-virus", "solutions": ["class Solution:\n    def containVirus(self, isInfected: List[List[int]]) -> int:\n        def dfs(i, j):\n            vis[i][j] = True\n            areas[-1].append((i, j))\n            for a, b in [[0, -1], [0, 1], [-1, 0], [1, 0]]:\n                x, y = i + a, j + b\n                if 0 <= x < m and 0 <= y < n:\n                    if isInfected[x][y] == 1 and not vis[x][y]:\n                        dfs(x, y)\n                    elif isInfected[x][y] == 0:\n                        c[-1] += 1\n                        boundaries[-1].add((x, y))\n\n        m, n = len(isInfected), len(isInfected[0])\n        ans = 0\n        while 1:\n            vis = [[False] * n for _ in range(m)]\n            areas = []\n            c = []\n            boundaries = []\n            for i, row in enumerate(isInfected):\n                for j, v in enumerate(row):\n                    if v == 1 and not vis[i][j]:\n                        areas.append([])\n                        boundaries.append(set())\n                        c.append(0)\n                        dfs(i, j)\n            if not areas:\n                break\n            idx = boundaries.index(max(boundaries, key=len))\n            ans += c[idx]\n            for k, area in enumerate(areas):\n                if k == idx:\n                    for i, j in area:\n                        isInfected[i][j] = -1\n                else:\n                    for i, j in area:\n                        for a, b in [[0, -1], [0, 1], [-1, 0], [1, 0]]:\n                            x, y = i + a, j + b\n                            if 0 <= x < m and 0 <= y < n and isInfected[x][y] == 0:\n                                isInfected[x][y] = 1\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 788, "slug": "rotated-digits", "solutions": ["class Solution:\n    def rotatedDigits(self, n: int) -> int:\n        def check(x):\n            y, t = 0, x\n            k = 1\n            while t:\n                v = t % 10\n                if d[v] == -1:\n                    return False\n                y = d[v] * k + y\n                k *= 10\n                t //= 10\n            return x != y\n\n        d = [0, 1, 5, -1, -1, 2, 9, -1, 8, 6]\n        return sum(check(i) for i in range(1, n + 1))\n", "class Solution:\n  def rotatedDigits(self, n: int) -> int:\n    def isGoodNumber(i: int) -> bool:\n      isRotated = False\n\n      for c in str(i):\n        if c == '0' or c == '1' or c == '8':\n          continue\n        if c == '2' or c == '5' or c == '6' or c == '9':\n          isRotated = True\n        else:\n          return False\n\n      return isRotated\n\n    return sum(isGoodNumber(i) for i in range(1, n + 1))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 722, "slug": "remove-comments", "solutions": ["class Solution:\n    def removeComments(self, source: List[str]) -> List[str]:\n        ans = []\n        t = []\n        block_comment = False\n        for s in source:\n            i, m = 0, len(s)\n            while i < m:\n                if block_comment:\n                    if i + 1 < m and s[i : i + 2] == \"*/\":\n                        block_comment = False\n                        i += 1\n                else:\n                    if i + 1 < m and s[i : i + 2] == \"/*\":\n                        block_comment = True\n                        i += 1\n                    elif i + 1 < m and s[i : i + 2] == \"//\":\n                        break\n                    else:\n                        t.append(s[i])\n                i += 1\n            if not block_comment and t:\n                ans.append(\"\".join(t))\n                t.clear()\n        return ans\n", "class Solution:\n  def removeComments(self, source: list[str]) -> list[str]:\n    ans = []\n    commenting = False\n    modified = ''\n\n    for line in source:\n      i = 0\n      while i < len(line):\n        if i + 1 == len(line):\n          if not commenting:\n            modified += line[i]\n          i += 1\n          break\n        twoChars = line[i:i + 2]\n        if twoChars == '/*' and not commenting:\n          commenting = True\n          i += 2\n        elif twoChars == '*/' and commenting:\n          commenting = False\n          i += 2\n        elif twoChars == '//':\n          if not commenting:\n            break\n          else:\n            i += 2\n        else:\n          if not commenting:\n            modified += line[i]\n          i += 1\n      if modified and not commenting:\n        ans.append(modified)\n        modified = ''\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1796, "slug": "second-largest-digit-in-a-string", "solutions": ["class Solution:\n    def secondHighest(self, s: str) -> int:\n        a = b = -1\n        for c in s:\n            if c.isdigit():\n                v = int(c)\n                if v > a:\n                    a, b = v, a\n                elif b < v < a:\n                    b = v\n        return b\n", "class Solution:\n  def secondHighest(self, s: str) -> int:\n    maxDigit = -1\n    secondMaxDigit = -1\n\n    for c in s:\n      if c.isdigit():\n        d = int(c)\n        if d > maxDigit:\n          secondMaxDigit = maxDigit\n          maxDigit = d\n        elif maxDigit > d > secondMaxDigit:\n          secondMaxDigit = d\n\n    return secondMaxDigit\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1756, "slug": "design-most-recently-used-queue", "solutions": ["class MRUQueue:\n    def __init__(self, n: int):\n        self.q = list(range(1, n + 1))\n\n    def fetch(self, k: int) -> int:\n        ans = self.q[k - 1]\n        self.q[k - 1 : k] = []\n        self.q.append(ans)\n        return ans\n\n\n# Your MRUQueue object will be instantiated and called as such:\n# obj = MRUQueue(n)\n# param_1 = obj.fetch(k)\n", "from sortedcontainers import SortedList\n\n\nclass MRUQueue:\n  def __init__(self, n: int):\n    # [(priority value, actual value)]\n    self.q = SortedList((i, i) for i in range(1, n + 1))\n\n  def fetch(self, k: int) -> int:\n    _, num = self.q.pop(k - 1)\n    if self.q:\n      maxPriority = self.q[-1][0]\n      self.q.add((maxPriority + 1, num))\n    else:\n      self.q.add((0, num))\n    return num\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1776, "slug": "car-fleet-ii", "solutions": ["class Solution:\n    def getCollisionTimes(self, cars: List[List[int]]) -> List[float]:\n        stk = []\n        n = len(cars)\n        ans = [-1] * n\n        for i in range(n - 1, -1, -1):\n            while stk:\n                j = stk[-1]\n                if cars[i][1] > cars[j][1]:\n                    t = (cars[j][0] - cars[i][0]) / (cars[i][1] - cars[j][1])\n                    if ans[j] == -1 or t <= ans[j]:\n                        ans[i] = t\n                        break\n                stk.pop()\n            stk.append(i)\n        return ans\n", "class Solution:\n  def getCollisionTimes(self, cars: list[list[int]]) -> list[float]:\n    ans = []\n    stack = []  # (pos, speed, collisionTime)\n\n    def getCollisionTime(\n            car: tuple[int, int, int],\n            pos: int, speed: int) -> float:\n      return (car[0] - pos) / (speed - car[1])\n\n    for pos, speed in reversed(cars):\n      while stack and (\n              speed <= stack[-1][1] or getCollisionTime(stack[-1],\n                                                        pos, speed) >=\n              stack[-1][2]):\n        stack.pop()\n      if stack:\n        collisionTime = getCollisionTime(stack[-1], pos, speed)\n        stack.append((pos, speed, collisionTime))\n        ans.append(collisionTime)\n      else:\n        stack.append((pos, speed, math.inf))\n        ans.append(-1)\n\n    return ans[::-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1757, "slug": "recyclable-and-low-fat-products", "solutions": ["import pandas as pd\n\n\ndef find_products(products: pd.DataFrame) -> pd.DataFrame:\n    rs = products[(products[\"low_fats\"] == \"Y\") & (products[\"recyclable\"] == \"Y\")]\n    rs = rs[[\"product_id\"]]\n    return rs\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1731, "slug": "the-number-of-employees-which-report-to-each-employee", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1791, "slug": "find-center-of-star-graph", "solutions": ["class Solution:\n    def findCenter(self, edges: List[List[int]]) -> int:\n        return edges[0][0] if edges[0][0] in edges[1] else edges[0][1]\n", "class Solution:\n  def findCenter(self, edges: list[list[int]]) -> int:\n    if edges[0][0] in edges[1]:\n      return edges[0][0]\n    return edges[0][1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1721, "slug": "swapping-nodes-in-a-linked-list", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        fast = slow = head\n        for _ in range(k - 1):\n            fast = fast.next\n        p = fast\n        while fast.next:\n            fast, slow = fast.next, slow.next\n        q = slow\n        p.val, q.val = q.val, p.val\n        return head\n", "class Solution:\n  def swapNodes(self, head: ListNode | None, k: int) -> ListNode | None:\n    p = None  # Points the k-th node from the beginning.\n    q = None  # Points the k-th node from the end.\n\n    curr = head\n    while curr:\n      if q:\n        q = q.next\n      k -= 1\n      if k == 0:\n        p = curr\n        q = head\n      curr = curr.next\n\n    p.val, q.val = q.val, p.val\n    return head\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1709, "slug": "biggest-window-between-visits", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1781, "slug": "sum-of-beauty-of-all-substrings", "solutions": ["class Solution:\n    def beautySum(self, s: str) -> int:\n        ans, n = 0, len(s)\n        for i in range(n):\n            cnt = Counter()\n            for j in range(i, n):\n                cnt[s[j]] += 1\n                ans += max(cnt.values()) - min(cnt.values())\n        return ans\n", "class Solution:\n  def beautySum(self, s: str) -> int:\n    ans = 0\n\n    for i in range(len(s)):\n      count = collections.Counter()\n      for j in range(i, len(s)):\n        count[s[j]] += 1\n        ans += max(count.values()) - min(count.values())\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1707, "slug": "maximum-xor-with-an-element-from-array", "solutions": ["class Trie:\n    __slots__ = [\"children\"]\n\n    def __init__(self):\n        self.children = [None] * 2\n\n    def insert(self, x: int):\n        node = self\n        for i in range(30, -1, -1):\n            v = x >> i & 1\n            if node.children[v] is None:\n                node.children[v] = Trie()\n            node = node.children[v]\n\n    def search(self, x: int) -> int:\n        node = self\n        ans = 0\n        for i in range(30, -1, -1):\n            v = x >> i & 1\n            if node.children[v ^ 1]:\n                ans |= 1 << i\n                node = node.children[v ^ 1]\n            elif node.children[v]:\n                node = node.children[v]\n            else:\n                return -1\n        return ans\n\n\nclass Solution:\n    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        trie = Trie()\n        nums.sort()\n        j, n = 0, len(queries)\n        ans = [-1] * n\n        for i, (x, m) in sorted(zip(range(n), queries), key=lambda x: x[1][1]):\n            while j < len(nums) and nums[j] <= m:\n                trie.insert(nums[j])\n                j += 1\n            ans[i] = trie.search(x)\n        return ans\n", "from dataclasses import dataclass\n\n\nclass TrieNode:\n  def __init__(self):\n    self.children: list[TrieNode | None] = [None] * 2\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n\n  def getMaxXor(self, num: int) -> int:\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      toggleBit = bit ^ 1\n      if node.children[toggleBit]:\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:  # There's nothing in the Bit Trie.\n        return 0\n    return maxXor\n\n\n@dataclass(frozen=True)\nclass IndexedQuery:\n  queryIndex: int\n  x: int\n  m: int\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.x\n    yield self.m\n\n\nclass Solution:\n  def maximizeXor(self, nums: list[int], queries: list[list[int]]) -> list[int]:\n    ans = [-1] * len(queries)\n    maxBit = int(math.log2(max(max(nums), max(x for x, _ in queries))))\n    bitTrie = BitTrie(maxBit)\n\n    nums.sort()\n\n    i = 0  # nums' index\n    for queryIndex, x, m in sorted([IndexedQuery(i, x, m)\n                                    for i, (x, m) in enumerate(queries)],\n                                   key=lambda x: x.m):\n      while i < len(nums) and nums[i] <= m:\n        bitTrie.insert(nums[i])\n        i += 1\n      if i > 0 and nums[i - 1] <= m:\n        ans[queryIndex] = bitTrie.getMaxXor(x)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1770, "slug": "maximum-score-from-performing-multiplication-operations", "solutions": ["class Solution:\n    def maximumScore(self, nums: List[int], multipliers: List[int]) -> int:\n        @cache\n        def f(i, j, k):\n            if k >= m or i >= n or j < 0:\n                return 0\n            a = f(i + 1, j, k + 1) + nums[i] * multipliers[k]\n            b = f(i, j - 1, k + 1) + nums[j] * multipliers[k]\n            return max(a, b)\n\n        n = len(nums)\n        m = len(multipliers)\n        return f(0, n - 1, 0)\n", "class Solution:\n  def maximumScore(self, nums: list[int], multipliers: list[int]) -> int:\n    @functools.lru_cache(2000)\n    def dp(s: int, i: int) -> int:\n      \"\"\"Returns the maximum score of nums[s..e] and multipliers[i].\"\"\"\n      if i == len(multipliers):\n        return 0\n\n      # The number of nums picked on the start side is s.\n      # The number of nums picked on the end side is i - s.\n      # So, e = n - (i - s) - 1.\n      e = len(nums) - (i - s) - 1\n      pickStart = nums[s] * multipliers[i] + dp(s + 1, i + 1)\n      pickEnd = nums[e] * multipliers[i] + dp(s, i + 1)\n      return max(pickStart, pickEnd)\n\n    return dp(0, 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1746, "slug": "maximum-subarray-sum-after-one-operation", "solutions": ["class Solution:\n    def maxSumAfterOperation(self, nums: List[int]) -> int:\n        f = g = 0\n        ans = -inf\n        for x in nums:\n            ff = max(f, 0) + x\n            gg = max(max(f, 0) + x * x, g + x)\n            f, g = ff, gg\n            ans = max(ans, f, g)\n        return ans\n", "class Solution:\n  def maxSumAfterOperation(self, nums: list[int]) -> int:\n    ans = -math.inf\n    regular = 0\n    squared = 0\n\n    for num in nums:\n      squared = max(num**2, regular + num**2, squared + num)\n      regular = max(num, regular + num)\n      ans = max(ans, squared)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1792, "slug": "maximum-average-pass-ratio", "solutions": ["class Solution:\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\n        h = [(a / b - (a + 1) / (b + 1), a, b) for a, b in classes]\n        heapify(h)\n        for _ in range(extraStudents):\n            _, a, b = heappop(h)\n            a, b = a + 1, b + 1\n            heappush(h, (a / b - (a + 1) / (b + 1), a, b))\n        return sum(v[1] / v[2] for v in h) / len(classes)\n", "class Solution:\n  def maxAverageRatio(\n      self,\n      classes: list[list[int]],\n      extraStudents: int,\n  ) -> float:\n    def extraPassRatio(pas: int, total: int) -> float:\n      \"\"\"Returns the extra pass ratio if a brilliant student joins.\"\"\"\n      return (pas + 1) / (total + 1) - pas / total\n\n    maxHeap = [(-extraPassRatio(pas, total), pas, total)\n               for pas, total in classes]\n    heapq.heapify(maxHeap)\n\n    for _ in range(extraStudents):\n      _, pas, total = heapq.heappop(maxHeap)\n      heapq.heappush(\n          maxHeap, (-extraPassRatio(pas + 1, total + 1), pas + 1, total + 1))\n\n    return sum(pas / total for _, pas, total in maxHeap) / len(maxHeap)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1753, "slug": "maximum-score-from-removing-stones", "solutions": ["class Solution:\n    def maximumScore(self, a: int, b: int, c: int) -> int:\n        s = sorted([a, b, c])\n        ans = 0\n        while s[1]:\n            ans += 1\n            s[1] -= 1\n            s[2] -= 1\n            s.sort()\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1774, "slug": "closest-dessert-cost", "solutions": ["class Solution:\n    def closestCost(\n        self, baseCosts: List[int], toppingCosts: List[int], target: int\n    ) -> int:\n        def dfs(i, t):\n            if i >= len(toppingCosts):\n                arr.append(t)\n                return\n            dfs(i + 1, t)\n            dfs(i + 1, t + toppingCosts[i])\n\n        arr = []\n        dfs(0, 0)\n        arr.sort()\n        d = ans = inf\n\n        # \n        for x in baseCosts:\n            # \n            for y in arr:\n                # \n                i = bisect_left(arr, target - x - y)\n                for j in (i, i - 1):\n                    if 0 <= j < len(arr):\n                        t = abs(x + y + arr[j] - target)\n                        if d > t or (d == t and ans > x + y + arr[j]):\n                            d = t\n                            ans = x + y + arr[j]\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1701, "slug": "average-waiting-time", "solutions": ["class Solution:\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\n        tot = t = 0\n        for a, b in customers:\n            t = max(t, a) + b\n            tot += t - a\n        return tot / len(customers)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1728, "slug": "cat-and-mouse-ii", "solutions": ["class Solution:\n    def canMouseWin(self, grid: List[str], catJump: int, mouseJump: int) -> bool:\n        m, n = len(grid), len(grid[0])\n        cat_start = mouse_start = food = 0\n        dirs = (-1, 0, 1, 0, -1)\n        g_mouse = [[] for _ in range(m * n)]\n        g_cat = [[] for _ in range(m * n)]\n\n        for i, row in enumerate(grid):\n            for j, c in enumerate(row):\n                if c == \"#\":\n                    continue\n                v = i * n + j\n                if c == \"C\":\n                    cat_start = v\n                elif c == \"M\":\n                    mouse_start = v\n                elif c == \"F\":\n                    food = v\n                for a, b in pairwise(dirs):\n                    for k in range(mouseJump + 1):\n                        x, y = i + k * a, j + k * b\n                        if not (0 <= x < m and 0 <= y < n and grid[x][y] != \"#\"):\n                            break\n                        g_mouse[v].append(x * n + y)\n                    for k in range(catJump + 1):\n                        x, y = i + k * a, j + k * b\n                        if not (0 <= x < m and 0 <= y < n and grid[x][y] != \"#\"):\n                            break\n                        g_cat[v].append(x * n + y)\n        return self.calc(g_mouse, g_cat, mouse_start, cat_start, food) == 1\n\n    def calc(\n        self,\n        g_mouse: List[List[int]],\n        g_cat: List[List[int]],\n        mouse_start: int,\n        cat_start: int,\n        hole: int,\n    ) -> int:\n        def get_prev_states(state):\n            m, c, t = state\n            pt = t ^ 1\n            pre = []\n            if pt == 1:\n                for pc in g_cat[c]:\n                    if ans[m][pc][1] == 0:\n                        pre.append((m, pc, pt))\n            else:\n                for pm in g_mouse[m]:\n                    if ans[pm][c][0] == 0:\n                        pre.append((pm, c, 0))\n            return pre\n\n        n = len(g_mouse)\n        degree = [[[0, 0] for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                degree[i][j][0] = len(g_mouse[i])\n                degree[i][j][1] = len(g_cat[j])\n\n        ans = [[[0, 0] for _ in range(n)] for _ in range(n)]\n        q = deque()\n        for i in range(n):\n            ans[hole][i][1] = 1\n            ans[i][hole][0] = 2\n            ans[i][i][1] = ans[i][i][0] = 2\n            q.append((hole, i, 1))\n            q.append((i, hole, 0))\n            q.append((i, i, 0))\n            q.append((i, i, 1))\n        while q:\n            state = q.popleft()\n            t = ans[state[0]][state[1]][state[2]]\n            for prev_state in get_prev_states(state):\n                pm, pc, pt = prev_state\n                if pt == t - 1:\n                    ans[pm][pc][pt] = t\n                    q.append(prev_state)\n                else:\n                    degree[pm][pc][pt] -= 1\n                    if degree[pm][pc][pt] == 0:\n                        ans[pm][pc][pt] = t\n                        q.append(prev_state)\n        return ans[mouse_start][cat_start][0]\n", "class Solution:\n  def canMouseWin(self, grid: list[str], catJump: int, mouseJump: int) -> bool:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    nFloors = 0\n    cat = 0  # cat's position\n    mouse = 0  # mouse's position\n\n    def hash(i: int, j: int) -> int:\n      return i * n + j\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] != '#':\n          nFloors += 1\n        if grid[i][j] == 'C':\n          cat = hash(i, j)\n        elif grid[i][j] == 'M':\n          mouse = hash(i, j)\n\n    @functools.lru_cache(None)\n    def dp(cat: int, mouse: int, turn: int) -> bool:\n      \"\"\"\n      Returns True if the mouse can win, where the cat is on (i / 8, i % 8), the\n      mouse is on (j / 8, j % 8), and the turns is k.\n      \"\"\"\n      # We already search the whole touchable grid.\n      if turn == nFloors * 2:\n        return False\n\n      if turn % 2 == 0:\n        # the mouse's turn\n        i = mouse // n\n        j = mouse % n\n        for dx, dy in DIRS:\n          for jump in range(mouseJump + 1):\n            x = i + dx * jump\n            y = j + dy * jump\n            if x < 0 or x == m or y < 0 or y == n:\n              break\n            if grid[x][y] == '#':\n              break\n            # The mouse eats the food, so the mouse wins.\n            if grid[x][y] == 'F':\n              return True\n            if dp(cat, hash(x, y), turn + 1):\n              return True\n        # The mouse can't win, so the mouse loses.\n        return False\n      else:\n        # the cat's turn\n        i = cat // n\n        j = cat % n\n        for dx, dy in DIRS:\n          for jump in range(catJump + 1):\n            x = i + dx * jump\n            y = j + dy * jump\n            if x < 0 or x == m or y < 0 or y == n:\n              break\n            if grid[x][y] == '#':\n              break\n            # The cat eats the food, so the mouse loses.\n            if grid[x][y] == 'F':\n              return False\n            nextCat = hash(x, y)\n            # The cat catches the mouse, so the mouse loses.\n            if nextCat == mouse:\n              return False\n            if not dp(nextCat, mouse, turn + 1):\n              return False\n        # The cat can't win, so the mouse wins.\n        return True\n\n    return dp(cat, mouse, 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1793, "slug": "maximum-score-of-a-good-subarray", "solutions": ["class Solution:\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        left = [-1] * n\n        right = [n] * n\n        stk = []\n        for i, v in enumerate(nums):\n            while stk and nums[stk[-1]] >= v:\n                stk.pop()\n            if stk:\n                left[i] = stk[-1]\n            stk.append(i)\n        stk = []\n        for i in range(n - 1, -1, -1):\n            v = nums[i]\n            while stk and nums[stk[-1]] > v:\n                stk.pop()\n            if stk:\n                right[i] = stk[-1]\n            stk.append(i)\n        ans = 0\n        for i, v in enumerate(nums):\n            if left[i] + 1 <= k <= right[i] - 1:\n                ans = max(ans, v * (right[i] - left[i] - 1))\n        return ans\n", "class Solution:\n  # Similar to 84. Largest Rectangle in Histogram\n  def maximumScore(self, nums: list[int], k: int) -> int:\n    ans = 0\n    stack = []\n\n    for i in range(len(nums) + 1):\n      while stack and (i == len(nums) or nums[stack[-1]] > nums[i]):\n        h = nums[stack.pop()]\n        w = i - stack[-1] - 1 if stack else i\n        if (not stack or stack[-1] + 1 <= k) and i - 1 >= k:\n          ans = max(ans, h * w)\n      stack.append(i)\n\n    return ans\n", "class Solution:\n  def maximumScore(self, nums: list[int], k: int) -> int:\n    n = len(nums)\n    ans = nums[k]\n    mn = nums[k]\n    i = k\n    j = k\n\n    # Greedily expand the window and decrease the minimum as slow as possible.\n    while i > 0 or j < n - 1:\n      if i == 0:\n        j += 1\n      elif j == n - 1:\n        i -= 1\n      elif nums[i - 1] < nums[j + 1]:\n        j += 1\n      else:\n        i -= 1\n      mn = min(mn, nums[i], nums[j])\n      ans = max(ans, mn * (j - i + 1))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1764, "slug": "form-array-by-concatenating-subarrays-of-another-array", "solutions": ["class Solution:\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\n        n, m = len(groups), len(nums)\n        i = j = 0\n        while i < n and j < m:\n            g = groups[i]\n            if g == nums[j : j + len(g)]:\n                j += len(g)\n                i += 1\n            else:\n                j += 1\n        return i == n\n", "class Solution:\n  def canChoose(self, groups: list[list[int]], nums: list[int]) -> bool:\n    i = 0  # groups' index\n    j = 0  # nums' index\n\n    while i < len(groups) and j < len(nums):\n      if self._isMatch(groups[i], nums, j):\n        j += len(groups[i])\n        i += 1\n      else:\n        j += 1\n\n    return i == len(groups)\n\n  # Returns True if group == nums[j..j + |group|].\n  def _isMatch(self, group: list[int], nums: list[int], j: int) -> bool:\n    if j + |group | > len(nums):\n      return False\n    for i, g in enumerate(group):\n      if g != nums[j + i]:\n        return False\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1769, "slug": "minimum-number-of-operations-to-move-all-balls-to-each-box", "solutions": ["class Solution:\n    def minOperations(self, boxes: str) -> List[int]:\n        n = len(boxes)\n        left = [0] * n\n        right = [0] * n\n        cnt = 0\n        for i in range(1, n):\n            if boxes[i - 1] == '1':\n                cnt += 1\n            left[i] = left[i - 1] + cnt\n        cnt = 0\n        for i in range(n - 2, -1, -1):\n            if boxes[i + 1] == '1':\n                cnt += 1\n            right[i] = right[i + 1] + cnt\n        return [a + b for a, b in zip(left, right)]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1788, "slug": "maximize-the-beauty-of-the-garden", "solutions": ["class Solution:\n    def maximumBeauty(self, flowers: List[int]) -> int:\n        s = [0] * (len(flowers) + 1)\n        d = {}\n        ans = -inf\n        for i, v in enumerate(flowers):\n            if v in d:\n                ans = max(ans, s[i] - s[d[v] + 1] + v * 2)\n            else:\n                d[v] = i\n            s[i + 1] = s[i] + max(v, 0)\n        return ans\n", "class Solution:\n  def maximumBeauty(self, flowers: list[int]) -> int:\n    ans = -math.inf\n    prefix = 0\n    flowerToPrefix = collections.defaultdict(int)\n\n    for flower in flowers:\n      if flower in flowerToPrefix:\n        ans = max(ans, prefix - flowerToPrefix[flower] + flower * 2)\n      prefix += max(0, flower)\n      flowerToPrefix.setdefault(flower, prefix)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1763, "slug": "longest-nice-substring", "solutions": ["class Solution:\n    def longestNiceSubstring(self, s: str) -> str:\n        n = len(s)\n        ans = ''\n        for i in range(n):\n            ss = set()\n            for j in range(i, n):\n                ss.add(s[j])\n                if (\n                    all(c.lower() in ss and c.upper() in ss for c in ss)\n                    and len(ans) < j - i + 1\n                ):\n                    ans = s[i : j + 1]\n        return ans\n", "class Solution:\n  def longestNiceSubstring(self, s: str) -> str:\n    if len(s) < 2:\n      return ''\n\n    seen = set(s)\n\n    for i, c in enumerate(s):\n      # If both upper and lower case letters exists in the string, keep moving,\n      # else take the erroneous character as a partition and check for its left\n      # and right parts to be nice strings.\n      if c.swapcase() not in seen:\n        prefix = self.longestNiceSubstring(s[:i])\n        suffix = self.longestNiceSubstring(s[i + 1:])\n        return max(prefix, suffix, key=len)\n\n    return s\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1747, "slug": "leetflex-banned-accounts", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1722, "slug": "minimize-hamming-distance-after-swap-operations", "solutions": ["class Solution:\n    def minimumHammingDistance(\n        self, source: List[int], target: List[int], allowedSwaps: List[List[int]]\n    ) -> int:\n        def find(x: int) -> int:\n            if p[x] != x:\n                p[x] = find(p[x])\n            return p[x]\n\n        n = len(source)\n        p = list(range(n))\n        for a, b in allowedSwaps:\n            p[find(a)] = find(b)\n        cnt = defaultdict(Counter)\n        for i, x in enumerate(source):\n            j = find(i)\n            cnt[j][x] += 1\n        ans = 0\n        for i, x in enumerate(target):\n            j = find(i)\n            cnt[j][x] -= 1\n            ans += cnt[j][x] < 0\n        return ans\n", "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def minimumHammingDistance(\n      self,\n      source: list[int],\n      target: list[int],\n      allowedSwaps: list[list[int]],\n  ) -> int:\n    n = len(source)\n    ans = 0\n    uf = UnionFind(n)\n    groupIdToCount = [collections.Counter() for _ in range(n)]\n\n    for a, b in allowedSwaps:\n      uf.unionByRank(a, b)\n\n    for i in range(n):\n      groupIdToCount[uf.find(i)][source[i]] += 1\n\n    for i in range(n):\n      groupId = uf.find(i)\n      count = groupIdToCount[groupId]\n      if target[i] not in count:\n        ans += 1\n      else:\n        count[target[i]] -= 1\n        if count[target[i]] == 0:\n          del count[target[i]]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1745, "slug": "palindrome-partitioning-iv", "solutions": ["class Solution:\n    def checkPartitioning(self, s: str) -> bool:\n        n = len(s)\n        f = [[True] * n for _ in range(n)]\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                f[i][j] = s[i] == s[j] and (i + 1 == j or f[i + 1][j - 1])\n        for i in range(n - 2):\n            for j in range(i + 1, n - 1):\n                if f[0][i] and f[i + 1][j] and f[j + 1][-1]:\n                    return True\n        return False\n", "class Solution:\n  def checkPartitioning(self, s: str) -> bool:\n    n = len(s)\n    # dp[i][j] := true if s[i..j] is a palindrome\n    dp = [[False] * n for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i] = True\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        if s[i] == s[j]:\n          dp[i][j] = i + 1 > j - 1 or dp[i + 1][j - 1]\n\n    for i in range(n):\n      for j in range(i + 1, n):\n        if dp[0][i] and dp[i + 1][j] and dp[j + 1][n - 1]:\n          return True\n\n    return False\n", "class Solution:\n  def checkPartitioning(self, s: str) -> bool:\n    @functools.lru_cache(None)\n    def isPalindrome(i: int, j: int) -> bool:\n      \"\"\"Returns True if s[i..j] is a palindrome.\"\"\"\n      if i > j:\n        return True\n      if s[i] == s[j]:\n        return isPalindrome(i + 1, j - 1)\n      return False\n\n    n = len(s)\n    return any(isPalindrome(0, i) and\n               isPalindrome(i + 1, j) and\n               isPalindrome(j + 1, n - 1)\n               for i in range(n)\n               for j in range(i + 1, n - 1))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1797, "slug": "design-authentication-manager", "solutions": ["class AuthenticationManager:\n    def __init__(self, timeToLive: int):\n        self.t = timeToLive\n        self.d = defaultdict(int)\n\n    def generate(self, tokenId: str, currentTime: int) -> None:\n        self.d[tokenId] = currentTime + self.t\n\n    def renew(self, tokenId: str, currentTime: int) -> None:\n        if self.d[tokenId] <= currentTime:\n            return\n        self.d[tokenId] = currentTime + self.t\n\n    def countUnexpiredTokens(self, currentTime: int) -> int:\n        return sum(exp > currentTime for exp in self.d.values())\n\n\n# Your AuthenticationManager object will be instantiated and called as such:\n# obj = AuthenticationManager(timeToLive)\n# obj.generate(tokenId,currentTime)\n# obj.renew(tokenId,currentTime)\n# param_3 = obj.countUnexpiredTokens(currentTime)\n", "from sortedcontainers import SortedSet\n\n\nclass AuthenticationManager:\n  def __init__(self, timeToLive: int):\n    self.timeToLive = timeToLive\n    self.tokenIdToExpiryTime = {}\n    self.times = SortedSet()\n\n  def generate(self, tokenId: str, currentTime: int) -> None:\n    self.tokenIdToExpiryTime[tokenId] = currentTime\n    self.times.add(currentTime)\n\n  def renew(self, tokenId: str, currentTime: int) -> None:\n    if (tokenId not in self.tokenIdToExpiryTime or\n            currentTime >= self.tokenIdToExpiryTime[tokenId] + self.timeToLive):\n      return\n    self.times.remove(self.tokenIdToExpiryTime[tokenId])\n    self.tokenIdToExpiryTime[tokenId] = currentTime\n    self.times.add(currentTime)\n\n  def countUnexpiredTokens(self, currentTime: int) -> int:\n    i = self.times.bisect_left(currentTime - self.timeToLive + 1)\n    # Remove expired tokens.\n    for _ in range(i):\n      self.times.remove(self.times[0])\n    return len(self.times)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1780, "slug": "check-if-number-is-a-sum-of-powers-of-three", "solutions": ["class Solution:\n    def checkPowersOfThree(self, n: int) -> bool:\n        while n:\n            if n % 3 > 1:\n                return False\n            n //= 3\n        return True\n", "class Solution:\n  def checkPowersOfThree(self, n: int) -> bool:\n    while n > 1:\n      n, r = divmod(n, 3)\n      if r == 2:\n        return False\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1775, "slug": "equal-sum-arrays-with-minimum-number-of-operations", "solutions": ["class Solution:\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\n        s1, s2 = sum(nums1), sum(nums2)\n        if s1 == s2:\n            return 0\n        if s1 > s2:\n            return self.minOperations(nums2, nums1)\n        arr = [6 - v for v in nums1] + [v - 1 for v in nums2]\n        d = s2 - s1\n        for i, v in enumerate(sorted(arr, reverse=True), 1):\n            d -= v\n            if d <= 0:\n                return i\n        return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1703, "slug": "minimum-adjacent-swaps-for-k-consecutive-ones", "solutions": ["class Solution:\n    def minMoves(self, nums: List[int], k: int) -> int:\n        arr = [i for i, x in enumerate(nums) if x]\n        s = list(accumulate(arr, initial=0))\n        ans = inf\n        x = (k + 1) // 2\n        y = k - x\n        for i in range(x - 1, len(arr) - y):\n            j = arr[i]\n            ls = s[i + 1] - s[i + 1 - x]\n            rs = s[i + 1 + y] - s[i + 1]\n            a = (j + j - x + 1) * x // 2 - ls\n            b = rs - (j + 1 + j + y) * y // 2\n            ans = min(ans, a + b)\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1750, "slug": "minimum-length-of-string-after-deleting-similar-ends", "solutions": ["class Solution:\n    def minimumLength(self, s: str) -> int:\n        i, j = 0, len(s) - 1\n        while i < j and s[i] == s[j]:\n            while i + 1 < j and s[i] == s[i + 1]:\n                i += 1\n            while i < j - 1 and s[j - 1] == s[j]:\n                j -= 1\n            i, j = i + 1, j - 1\n        return max(0, j - i + 1)\n", "class Solution:\n  def minimumLength(self, s: str) -> int:\n    i = 0\n    j = len(s) - 1\n\n    while i < j and s[i] == s[j]:\n      c = s[i]\n      while i <= j and s[i] == c:\n        i += 1\n      while i <= j and s[j] == c:\n        j -= 1\n\n    return j - i + 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1740, "slug": "find-distance-in-a-binary-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findDistance(self, root: Optional[TreeNode], p: int, q: int) -> int:\n        def lca(root, p, q):\n            if root is None or root.val in [p, q]:\n                return root\n            left = lca(root.left, p, q)\n            right = lca(root.right, p, q)\n            if left is None:\n                return right\n            if right is None:\n                return left\n            return root\n\n        def dfs(root, v):\n            if root is None:\n                return -1\n            if root.val == v:\n                return 0\n            left, right = dfs(root.left, v), dfs(root.right, v)\n            if left == right == -1:\n                return -1\n            return 1 + max(left, right)\n\n        g = lca(root, p, q)\n        return dfs(g, p) + dfs(g, q)\n", "class Solution:\n  def findDistance(self, root: TreeNode, p: int, q: int) -> int:\n    def getLCA(root, p, q):\n      if not root or root.val == p or root.val == q:\n        return root\n\n      l = getLCA(root.left, p, q)\n      r = getLCA(root.right, p, q)\n\n      if l and r:\n        return root\n      return l or r\n\n    def dist(lca, target):\n      if not lca:\n        return 10000\n      if lca.val == target:\n        return 0\n      return 1 + min(dist(lca.left, target), dist(lca.right, target))\n\n    lca = getLCA(root, p, q)\n    return dist(lca, p) + dist(lca, q)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1794, "slug": "count-pairs-of-equal-substrings-with-minimum-difference", "solutions": ["class Solution:\n    def countQuadruples(self, firstString: str, secondString: str) -> int:\n        last = {c: i for i, c in enumerate(secondString)}\n        ans, mi = 0, inf\n        for i, c in enumerate(firstString):\n            if c in last:\n                t = i - last[c]\n                if mi > t:\n                    mi = t\n                    ans = 1\n                elif mi == t:\n                    ans += 1\n        return ans\n", "class Solution:\n  def countQuadruples(self, s1: str, s2: str) -> int:\n    # To minimize j - a, the length of the substring should be 1. This is\n    # because for substrings with a size greater than 1, a will decrease,\n    # causing j - a to become larger.\n    ans = 0\n    diff = math.inf  # diff := j - a\n    firstJ = {}\n    lastA = {}\n\n    for j in range(len(s1) - 1, -1, -1):\n      firstJ[s1[j]] = j\n\n    for a in range(len(s2)):\n      lastA[s2[a]] = a\n\n    for c in string.ascii_lowercase:\n      if c not in firstJ or c not in lastA:\n        continue\n      if firstJ[c] - lastA[c] < diff:\n        diff = firstJ[c] - lastA[c]\n        ans = 0\n      if firstJ[c] - lastA[c] == diff:\n        ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1778, "slug": "shortest-path-in-a-hidden-grid", "solutions": ["# \"\"\"\n# This is GridMaster's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# class GridMaster(object):\n#    def canMove(self, direction: str) -> bool:\n#\n#\n#    def move(self, direction: str) -> bool:\n#\n#\n#    def isTarget(self) -> None:\n#\n#\n\n\nclass Solution(object):\n    def findShortestPath(self, master: \"GridMaster\") -> int:\n        def dfs(i: int, j: int):\n            if master.isTarget():\n                nonlocal target\n                target = (i, j)\n                return\n            for k, c in enumerate(s):\n                x, y = i + dirs[k], j + dirs[k + 1]\n                if master.canMove(c) and (x, y) not in vis:\n                    vis.add((x, y))\n                    master.move(c)\n                    dfs(x, y)\n                    master.move(s[(k + 2) % 4])\n\n        s = \"URDL\"\n        dirs = (-1, 0, 1, 0, -1)\n        target = None\n        vis = set()\n        dfs(0, 0)\n        if target is None:\n            return -1\n        vis.discard((0, 0))\n        q = deque([(0, 0)])\n        ans = -1\n        while q:\n            ans += 1\n            for _ in range(len(q)):\n                i, j = q.popleft()\n                if (i, j) == target:\n                    return ans\n                for a, b in pairwise(dirs):\n                    x, y = i + a, j + b\n                    if (x, y) in vis:\n                        vis.remove((x, y))\n                        q.append((x, y))\n        return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1789, "slug": "primary-department-for-each-employee", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1724, "slug": "checking-existence-of-edge-length-limited-paths-ii", "solutions": ["class PersistentUnionFind:\n    def __init__(self, n):\n        self.rank = [0] * n\n        self.p = list(range(n))\n        self.version = [inf] * n\n\n    def find(self, x, t=inf):\n        if self.p[x] == x or self.version[x] >= t:\n            return x\n        return self.find(self.p[x], t)\n\n    def union(self, a, b, t):\n        pa, pb = self.find(a), self.find(b)\n        if pa == pb:\n            return False\n        if self.rank[pa] > self.rank[pb]:\n            self.version[pb] = t\n            self.p[pb] = pa\n        else:\n            self.version[pa] = t\n            self.p[pa] = pb\n            if self.rank[pa] == self.rank[pb]:\n                self.rank[pb] += 1\n        return True\n\n\nclass DistanceLimitedPathsExist:\n    def __init__(self, n: int, edgeList: List[List[int]]):\n        self.puf = PersistentUnionFind(n)\n        edgeList.sort(key=lambda x: x[2])\n        for u, v, dis in edgeList:\n            self.puf.union(u, v, dis)\n\n    def query(self, p: int, q: int, limit: int) -> bool:\n        return self.puf.find(p, limit) == self.puf.find(q, limit)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1743, "slug": "restore-the-array-from-adjacent-pairs", "solutions": ["class Solution:\n    def restoreArray(self, adjacentPairs: List[List[int]]) -> List[int]:\n        g = defaultdict(list)\n        for a, b in adjacentPairs:\n            g[a].append(b)\n            g[b].append(a)\n        n = len(adjacentPairs) + 1\n        ans = [0] * n\n        for i, v in g.items():\n            if len(v) == 1:\n                ans[0] = i\n                ans[1] = v[0]\n                break\n        for i in range(2, n):\n            v = g[ans[i - 1]]\n            ans[i] = v[0] if v[1] == ans[i - 2] else v[1]\n        return ans\n", "class Solution:\n  def restoreArray(self, adjacentPairs: list[list[int]]) -> list[int]:\n    ans = []\n    numToAdjs = collections.defaultdict(list)\n\n    for a, b in adjacentPairs:\n      numToAdjs[a].append(b)\n      numToAdjs[b].append(a)\n\n    for num, adjs in numToAdjs.items():\n      if len(adjs) == 1:\n        ans.append(num)\n        ans.append(adjs[0])\n        break\n\n    while len(ans) < len(adjacentPairs) + 1:\n      tail = ans[-1]\n      prev = ans[-2]\n      adjs = numToAdjs[tail]\n      if adjs[0] == prev:  # adjs[0] is already used\n        ans.append(adjs[1])\n      else:\n        ans.append(adjs[0])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1741, "slug": "find-total-time-spent-by-each-employee", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1716, "slug": "calculate-money-in-leetcode-bank", "solutions": ["class Solution:\n    def totalMoney(self, n: int) -> int:\n        a, b = divmod(n, 7)\n        return (28 + 28 + 7 * (a - 1)) * a // 2 + (a * 2 + b + 1) * b // 2\n", "class Solution:\n  def totalMoney(self, n: int) -> int:\n    def trapezoid(a: int, b: int) -> int:\n      \"\"\"Returns sum(a..b).\"\"\"\n      return (a + b) * (b - a + 1) // 2\n\n    weeks = n // 7\n    firstWeek = trapezoid(1, 7)\n    lastFullWeek = trapezoid(1 + weeks - 1, 7 + weeks - 1)\n    remainingDays = trapezoid(1 + weeks, n % 7 + weeks)\n    return (firstWeek + lastFullWeek) * weeks // 2 + remainingDays\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1719, "slug": "number-of-ways-to-reconstruct-a-tree", "solutions": ["class Solution:\n    def checkWays(self, pairs: List[List[int]]) -> int:\n        g = [[False] * 510 for _ in range(510)]\n        v = defaultdict(list)\n        for x, y in pairs:\n            g[x][y] = g[y][x] = True\n            v[x].append(y)\n            v[y].append(x)\n        nodes = []\n        for i in range(510):\n            if v[i]:\n                nodes.append(i)\n                g[i][i] = True\n        nodes.sort(key=lambda x: len(v[x]))\n        equal = False\n        root = 0\n        for i, x in enumerate(nodes):\n            j = i + 1\n            while j < len(nodes) and not g[x][nodes[j]]:\n                j += 1\n            if j < len(nodes):\n                y = nodes[j]\n                if len(v[x]) == len(v[y]):\n                    equal = True\n                for z in v[x]:\n                    if not g[y][z]:\n                        return 0\n            else:\n                root += 1\n        if root > 1:\n            return 0\n        return 2 if equal else 1\n", "class Solution:\n  def checkWays(self, pairs: list[list[int]]) -> int:\n    MAX = 501\n    graph = collections.defaultdict(list)\n    degrees = [0] * MAX\n    connected = [[False] * MAX for _ in range(MAX)]\n\n    for u, v in pairs:\n      graph[u].append(v)\n      graph[v].append(u)\n      degrees[u] += 1\n      degrees[v] += 1\n      connected[u][v] = True\n      connected[v][u] = True\n\n    # For each node, sort its children by degrees in descending order.\n    for _, children in graph.items():\n      children.sort(key=lambda x: -degrees[x])\n\n    # Find the root with a degree that equals to n - 1.\n    root = next((i for i, d in enumerate(degrees) if d == len(graph) - 1), -1)\n    if root == -1:\n      return 0\n\n    hasMoreThanOneWay = False\n\n    def dfs(u: int, ancestors: list[int], seen: list[bool]) -> bool:\n      \"\"\"\n      Returns True if each node rooted at u is connected to all of its\n      ancestors.\n      \"\"\"\n      nonlocal hasMoreThanOneWay\n      seen[u] = True\n      for ancestor in ancestors:\n        if not connected[u][ancestor]:\n          return False\n      ancestors.append(u)\n      for v in graph[u]:\n        if seen[v]:\n          continue\n        if degrees[v] == degrees[u]:\n          hasMoreThanOneWay = True\n        if not dfs(v, ancestors, seen):\n          return False\n      ancestors.pop()\n      return True\n\n    if not dfs(root, [], [False] * MAX):\n      return 0\n    return 2 if hasMoreThanOneWay else 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1766, "slug": "tree-of-coprimes", "solutions": ["class Solution:\n    def getCoprimes(self, nums: List[int], edges: List[List[int]]) -> List[int]:\n        def dfs(i, fa, depth):\n            t = k = -1\n            for v in f[nums[i]]:\n                stk = stks[v]\n                if stk and stk[-1][1] > k:\n                    t, k = stk[-1]\n            ans[i] = t\n            for j in g[i]:\n                if j != fa:\n                    stks[nums[i]].append((i, depth))\n                    dfs(j, i, depth + 1)\n                    stks[nums[i]].pop()\n\n        g = defaultdict(list)\n        for u, v in edges:\n            g[u].append(v)\n            g[v].append(u)\n        f = defaultdict(list)\n        for i in range(1, 51):\n            for j in range(1, 51):\n                if gcd(i, j) == 1:\n                    f[i].append(j)\n        stks = defaultdict(list)\n        ans = [-1] * len(nums)\n        dfs(0, -1, 0)\n        return ans\n", "class Solution:\n  def getCoprimes(self, nums: list[int], edges: list[list[int]]) -> list[int]:\n    MAX = 50\n    ans = [-1] * len(nums)\n    tree = [[] for _ in range(len(nums))]\n    # stacks[i] := (node, depth)s of nodes with value i\n    stacks = [[] for _ in range(MAX + 1)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def getAncestor(u: int) -> int:\n      maxNode = -1\n      maxDepth = -1\n      for i, stack in enumerate(stacks):\n        if stack and stack[-1][1] > maxDepth and math.gcd(nums[u], i) == 1:\n          maxNode, maxDepth = stack[-1]\n      return maxNode\n\n    def dfs(u: int, prev: int, depth: int) -> int:\n      ans[u] = getAncestor(u)\n      stacks[nums[u]].append((u, depth))\n\n      for v in tree[u]:\n        if v != prev:\n          dfs(v, u, depth + 1)\n\n      stacks[nums[u]].pop()\n\n    dfs(0, -1, 0)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1739, "slug": "building-boxes", "solutions": ["class Solution:\n    def minimumBoxes(self, n: int) -> int:\n        s, k = 0, 1\n        while s + k * (k + 1) // 2 <= n:\n            s += k * (k + 1) // 2\n            k += 1\n        k -= 1\n        ans = k * (k + 1) // 2\n        k = 1\n        while s < n:\n            ans += 1\n            s += k\n            k += 1\n        return ans\n", "class Solution:\n  def minimumBoxes(self, n: int) -> int:\n    nBoxes = 0\n    nextTouchings = 0  # j\n    currLevelBoxes = 0  # 1 + 2 + ... + j\n\n    # Find the minimum j s.t. `nBoxes` = 1 + (1 + 2) + ... + (1 + 2 + ... + j)\n    # >= n\n    while nBoxes < n:\n      nextTouchings += 1\n      currLevelBoxes += nextTouchings\n      nBoxes += currLevelBoxes\n\n    # If nBoxes = n, the answer is `currLevelBoxes` = 1 + 2 + ... + j.\n    if nBoxes == n:\n      return currLevelBoxes\n\n    # Otherwise, need to remove the boxes in the current level and rebuild it.\n    nBoxes -= currLevelBoxes\n    currLevelBoxes -= nextTouchings\n    nextTouchings = 0\n\n    while nBoxes < n:\n      nextTouchings += 1\n      nBoxes += nextTouchings\n\n    return currLevelBoxes + nextTouchings\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1708, "slug": "largest-subarray-length-k", "solutions": ["class Solution:\n    def largestSubarray(self, nums: List[int], k: int) -> List[int]:\n        i = nums.index(max(nums[: len(nums) - k + 1]))\n        return nums[i : i + k]\n", "class Solution:\n  def largestSubarray(self, nums: list[int], k: int) -> list[int]:\n    mx = max(nums[:len(nums) - k + 1])\n    i = nums.index(mx)\n    return nums[i:i + k]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1720, "slug": "decode-xored-array", "solutions": ["class Solution:\n    def decode(self, encoded: List[int], first: int) -> List[int]:\n        ans = [first]\n        for x in encoded:\n            ans.append(ans[-1] ^ x)\n        return ans\n", "class Solution:\n  def decode(self, encoded: list[int], first: int) -> list[int]:\n    ans = [first]\n\n    for e in encoded:\n      ans.append(e ^ ans[-1])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1744, "slug": "can-you-eat-your-favorite-candy-on-your-favorite-day", "solutions": ["class Solution:\n    def canEat(self, candiesCount: List[int], queries: List[List[int]]) -> List[bool]:\n        s = list(accumulate(candiesCount, initial=0))\n        ans = []\n        for t, day, mx in queries:\n            least, most = day, (day + 1) * mx\n            ans.append(least < s[t + 1] and most > s[t])\n        return ans\n", "class Solution:\n  def canEat(\n      self,\n      candiesCount: list[int],\n      queries: list[list[int]]\n  ) -> list[bool]:\n    prefix = list(itertools.accumulate(candiesCount, initial=0))\n    return [prefix[t] // c <= d < prefix[t + 1] for t, d, c in queries]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1783, "slug": "grand-slam-titles", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1790, "slug": "check-if-one-string-swap-can-make-strings-equal", "solutions": ["class Solution:\n    def areAlmostEqual(self, s1: str, s2: str) -> bool:\n        cnt = 0\n        c1 = c2 = None\n        for a, b in zip(s1, s2):\n            if a != b:\n                cnt += 1\n                if cnt > 2 or (cnt == 2 and (a != c2 or b != c1)):\n                    return False\n                c1, c2 = a, b\n        return cnt != 1\n", "class Solution:\n  # Similar to 859. Buddy Strings\n  def areAlmostEqual(self, s1: str, s2: str) -> bool:\n    diffIndices = [i for i, (a, b) in enumerate(zip(s1, s2))\n                   if a != b]\n    return not diffIndices or (len(diffIndices) == 2 and\n                               s1[diffIndices[0]] == s2[diffIndices[1]] and\n                               s1[diffIndices[1]] == s2[diffIndices[0]])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1715, "slug": "count-apples-and-oranges", "solutions": ["import pandas as pd\n\n\ndef count_apples_and_oranges(boxes: pd.DataFrame, chests: pd.DataFrame) -> pd.DataFrame:\n    merged_df = boxes.merge(\n        chests, on=\"chest_id\", how=\"left\", suffixes=(\"_box\", \"_chest\")\n    )\n    apple_count = (\n        merged_df[\"apple_count_box\"].fillna(0)\n        + merged_df[\"apple_count_chest\"].fillna(0)\n    ).sum()\n    orange_count = (\n        merged_df[\"orange_count_box\"].fillna(0)\n        + merged_df[\"orange_count_chest\"].fillna(0)\n    ).sum()\n    return pd.DataFrame({\"apple_count\": [apple_count], \"orange_count\": [orange_count]})\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1717, "slug": "maximum-score-from-removing-substrings", "solutions": ["class Solution:\n    def maximumGain(self, s: str, x: int, y: int) -> int:\n        a, b = \"a\", \"b\"\n        if x < y:\n            x, y = y, x\n            a, b = b, a\n        ans = cnt1 = cnt2 = 0\n        for c in s:\n            if c == a:\n                cnt1 += 1\n            elif c == b:\n                if cnt1:\n                    ans += x\n                    cnt1 -= 1\n                else:\n                    cnt2 += 1\n            else:\n                ans += min(cnt1, cnt2) * y\n                cnt1 = cnt2 = 0\n        ans += min(cnt1, cnt2) * y\n        return ans\n", "class Solution:\n  def maximumGain(self, s: str, x: int, y: int) -> int:\n    # The assumption that gain('ab') > gain('ba') while removing 'ba' first is\n    # optimal is contradicted. Only 'b(ab)a' satisfies the condition of\n    # preventing two 'ba' removals, but after removing 'ab', we can still\n    # remove one 'ba', resulting in a higher gain. Thus, removing 'ba' first is\n    # not optimal.\n    return (self._gain(s, 'ab', x, 'ba', y) if x > y else\n            self._gain(s, 'ba', y, 'ab', x))\n\n  # Returns the points gained by first removing sub1 ('ab' | 'ba') from s with\n  # point1, then removing sub2 ('ab' | 'ba') from s with point2.\n  def _gain(self, s: str, sub1: str, point1: int, sub2: str, point2: int) -> int:\n    points = 0\n    stack1 = []\n    stack2 = []\n\n    # Remove 'sub1' from s with point1 gain.\n    for c in s:\n      if stack1 and stack1[-1] == sub1[0] and c == sub1[1]:\n        stack1.pop()\n        points += point1\n      else:\n        stack1.append(c)\n\n    # Remove 'sub2' from s with point2 gain.\n    for c in stack1:\n      if stack2 and stack2[-1] == sub2[0] and c == sub2[1]:\n        stack2.pop()\n        points += point2\n      else:\n        stack2.append(c)\n\n    return points\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1798, "slug": "maximum-number-of-consecutive-values-you-can-make", "solutions": ["class Solution:\n    def getMaximumConsecutive(self, coins: List[int]) -> int:\n        ans = 1\n        for v in sorted(coins):\n            if v > ans:\n                break\n            ans += v\n        return ans\n", "class Solution:\n  def getMaximumConsecutive(self, coins: list[int]) -> int:\n    ans = 1  # the next value we want to make\n\n    for coin in sorted(coins):\n      if coin > ans:\n        return ans\n      ans += coin\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1755, "slug": "closest-subsequence-sum", "solutions": ["class Solution:\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\n        n = len(nums)\n        left = set()\n        right = set()\n\n        self.getSubSeqSum(0, 0, nums[: n // 2], left)\n        self.getSubSeqSum(0, 0, nums[n // 2 :], right)\n\n        result = inf\n        right = sorted(right)\n        rl = len(right)\n\n        for l in left:\n            remaining = goal - l\n            idx = bisect_left(right, remaining)\n\n            if idx < rl:\n                result = min(result, abs(remaining - right[idx]))\n\n            if idx > 0:\n                result = min(result, abs(remaining - right[idx - 1]))\n\n        return result\n\n    def getSubSeqSum(self, i: int, curr: int, arr: List[int], result: Set[int]):\n        if i == len(arr):\n            result.add(curr)\n            return\n\n        self.getSubSeqSum(i + 1, curr, arr, result)\n        self.getSubSeqSum(i + 1, curr + arr[i], arr, result)\n", "class Solution:\n  def minAbsDifference(self, nums: list[int], goal: int) -> int:\n    n = len(nums) // 2\n    ans = math.inf\n    lSums = []\n    rSums = []\n\n    def dfs(arr: list[int], i: int, path: int, sums: list[int]) -> None:\n      if i == len(arr):\n        sums.append(path)\n        return\n      dfs(arr, i + 1, path + arr[i], sums)\n      dfs(arr, i + 1, path, sums)\n\n    dfs(nums[:n], 0, 0, lSums)\n    dfs(nums[n:], 0, 0, rSums)\n    rSums.sort()\n\n    for lSum in lSums:\n      i = bisect_left(rSums, goal - lSum)\n      if i < len(rSums):  # 2^n\n        ans = min(ans, abs(goal - lSum - rSums[i]))\n      if i > 0:\n        ans = min(ans, abs(goal - lSum - rSums[i - 1]))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1734, "slug": "decode-xored-permutation", "solutions": ["class Solution:\n    def decode(self, encoded: List[int]) -> List[int]:\n        n = len(encoded) + 1\n        a = b = 0\n        for i in range(0, n - 1, 2):\n            a ^= encoded[i]\n        for i in range(1, n + 1):\n            b ^= i\n        perm = [0] * n\n        perm[-1] = a ^ b\n        for i in range(n - 2, -1, -1):\n            perm[i] = encoded[i] ^ perm[i + 1]\n        return perm\n", "class Solution:\n  def decode(self, encoded: list[int]) -> list[int]:\n    # Our goal is to find the value of a1, which will allow us to decode a2, a3,\n    # ..., an. This can be achieved by performing XOR operation between each\n    # element in `encoded` and a1.\n    #\n    # e.g. n = 3, perm = [a1, a2, a3] is a permutation of [1, 2, 3].\n    #               encoded = [a1^a2, a2^a3]\n    #    accumulatedEncoded = [a1^a2, a1^a3]\n    #    a1 = (a1^a2)^(a1^a3)^(a1^a2^a3)\n    #    a2 = a1^(a1^a2)\n    #    a3 = a2^(a2^a3)\n    n = len(encoded) + 1\n    nXors = functools.reduce(operator.xor, [i for i in range(1, n + 1)])\n\n    # Instead of constructing the array, we can track of the running XOR value\n    # of `accumulatedEncoded`.\n    xors = 0  # xors(accumulatedEncoded)\n\n    for encode in encoded:\n      runningXors ^= encode\n      xors ^= runningXors\n\n    ans = [xors ^ nXors]\n\n    for encode in encoded:\n      ans.append(ans[-1] ^ encode)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1742, "slug": "maximum-number-of-balls-in-a-box", "solutions": ["class Solution:\n    def countBalls(self, lowLimit: int, highLimit: int) -> int:\n        cnt = [0] * 50\n        for x in range(lowLimit, highLimit + 1):\n            y = 0\n            while x:\n                y += x % 10\n                x //= 10\n            cnt[y] += 1\n        return max(cnt)\n", "class Solution:\n  def countBalls(self, lowLimit: int, highLimit: int) -> int:\n    maxDigitSum = 9 * 5  # 99999\n    ans = 0\n    count = [0] * (maxDigitSum + 1)\n\n    for num in range(lowLimit, highLimit + 1):\n      digitSum = self._getDigitSum(num)\n      count[digitSum] += 1\n      ans = max(ans, count[digitSum])\n\n    return ans\n\n  def _getDigitSum(self, num: int) -> int:\n    return sum(int(digit) for digit in str(num))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1749, "slug": "maximum-absolute-sum-of-any-subarray", "solutions": ["class Solution:\n    def maxAbsoluteSum(self, nums: List[int]) -> int:\n        f = g = 0\n        ans = 0\n        for x in nums:\n            f = max(f, 0) + x\n            g = min(g, 0) + x\n            ans = max(ans, f, abs(g))\n        return ans\n", "class Solution:\n  def maxAbsoluteSum(self, nums):\n    summ = 0\n    maxPrefix = 0\n    minPrefix = 0\n\n    for num in nums:\n      summ += num\n      maxPrefix = max(maxPrefix, summ)\n      minPrefix = min(minPrefix, summ)\n\n    return maxPrefix - minPrefix\n", "class Solution:\n  def maxAbsoluteSum(self, nums):\n    ans = -math.inf\n    maxSum = 0\n    minSum = 0\n\n    for num in nums:\n      maxSum = max(num, maxSum + num)\n      minSum = min(num, minSum + num)\n      ans = max(ans, maxSum, -minSum)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1735, "slug": "count-ways-to-make-array-with-product", "solutions": ["N = 10020\nMOD = 10**9 + 7\nf = [1] * N\ng = [1] * N\np = defaultdict(list)\nfor i in range(1, N):\n    f[i] = f[i - 1] * i % MOD\n    g[i] = pow(f[i], MOD - 2, MOD)\n    x = i\n    j = 2\n    while j <= x // j:\n        if x % j == 0:\n            cnt = 0\n            while x % j == 0:\n                cnt += 1\n                x //= j\n            p[i].append(cnt)\n        j += 1\n    if x > 1:\n        p[i].append(1)\n\n\ndef comb(n, k):\n    return f[n] * g[k] * g[n - k] % MOD\n\n\nclass Solution:\n    def waysToFillArray(self, queries: List[List[int]]) -> List[int]:\n        ans = []\n        for n, k in queries:\n            t = 1\n            for x in p[k]:\n                t = t * comb(x + n - 1, n - 1) % MOD\n            ans.append(t)\n        return ans\n", "class Solution:\n  def waysToFillArray(self, queries: list[list[int]]) -> list[int]:\n    MOD = 1_000_000_007\n    MAX = 10_000\n    minPrimeFactors = self._sieveEratosthenes(MAX + 1)\n\n    @functools.lru_cache(None)\n    def fact(i: int) -> int:\n      return 1 if i <= 1 else i * fact(i - 1) % MOD\n\n    @functools.lru_cache(None)\n    def inv(i: int) -> int:\n      return pow(i, MOD - 2, MOD)\n\n    @functools.lru_cache(None)\n    def nCk(n: int, k: int) -> int:\n      return fact(n) * inv(fact(k)) * inv(fact(n - k)) % MOD\n\n    ans = []\n\n    for n, k in queries:\n      res = 1\n      for freq in self._getPrimeFactorsCount(k, minPrimeFactors).values():\n        res = res * nCk(n - 1 + freq, freq) % MOD\n      ans.append(res)\n\n    return ans\n\n  def _sieveEratosthenes(self, n: int) -> list[int]:\n    \"\"\"Gets the minimum prime factor of i, where 1 < i <= n.\"\"\"\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:  # `i` is prime.\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactorsCount(self, num: int, minPrimeFactors: list[int]) -> dict[int, int]:\n    count = collections.Counter()\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      while num % divisor == 0:\n        num //= divisor\n        count[divisor] += 1\n    return count\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1785, "slug": "minimum-elements-to-add-to-form-a-given-sum", "solutions": ["class Solution:\n    def minElements(self, nums: List[int], limit: int, goal: int) -> int:\n        d = abs(sum(nums) - goal)\n        return (d + limit - 1) // limit\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1730, "slug": "shortest-path-to-get-food", "solutions": ["class Solution:\n    def getFood(self, grid: List[List[str]]) -> int:\n        m, n = len(grid), len(grid[0])\n        i, j = next((i, j) for i in range(m) for j in range(n) if grid[i][j] == '*')\n        q = deque([(i, j)])\n        dirs = (-1, 0, 1, 0, -1)\n        ans = 0\n        while q:\n            ans += 1\n            for _ in range(len(q)):\n                i, j = q.popleft()\n                for a, b in pairwise(dirs):\n                    x, y = i + a, j + b\n                    if 0 <= x < m and 0 <= y < n:\n                        if grid[x][y] == '#':\n                            return ans\n                        if grid[x][y] == 'O':\n                            grid[x][y] = 'X'\n                            q.append((x, y))\n        return -1\n", "class Solution:\n  def getFood(self, grid: list[list[str]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    q = collections.deque([self._getStartLocation(grid)])\n\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if grid[x][y] == 'X':\n            continue\n          if grid[x][y] == '#':\n            return ans + 1\n          q.append((x, y))\n          grid[x][y] = 'X'  # Mark as visited.\n      ans += 1\n\n    return -1\n\n  def _getStartLocation(self, grid: list[list[str]]) -> tuple[int, int]:\n    for i, row in enumerate(grid):\n      for j, cell in enumerate(row):\n        if cell == '*':\n          return (i, j)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1700, "slug": "number-of-students-unable-to-eat-lunch", "solutions": ["class Solution:\n    def countStudents(self, students: List[int], sandwiches: List[int]) -> int:\n        cnt = Counter(students)\n        for v in sandwiches:\n            if cnt[v] == 0:\n                return cnt[v ^ 1]\n            cnt[v] -= 1\n        return 0\n", "class Solution:\n  def countStudents(self, students: list[int], sandwiches: list[int]) -> int:\n    count = collections.Counter(students)\n\n    for i, sandwich in enumerate(sandwiches):\n      if count[sandwich] == 0:\n        return len(sandwiches) - i\n      count[sandwich] -= 1\n\n    return 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1702, "slug": "maximum-binary-string-after-change", "solutions": ["class Solution:\n    def maximumBinaryString(self, binary: str) -> str:\n        k = binary.find('0')\n        if k == -1:\n            return binary\n        k += binary[k + 1 :].count('0')\n        return '1' * k + '0' + '1' * (len(binary) - k - 1)\n", "class Solution:\n  def maximumBinaryString(self, binary: str) -> str:\n    #     e.g. binary = '100110'\n    # Do Operation 2 -> '100011'\n    # Do Operation 1 -> '111011'\n    # So, the index of the only '0' is prefixOnes + zeros - 1.\n    zeros = binary.count('0')\n    prefixOnes = binary.find('0')\n\n    # Make the entire string as 1s.\n    ans = ['1'] * len(binary)\n\n    # Make the only '0' if necessary.\n    if prefixOnes != -1:\n      ans[prefixOnes + zeros - 1] = '0'\n    return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1760, "slug": "minimum-limit-of-balls-in-a-bag", "solutions": ["class Solution:\n    def minimumSize(self, nums: List[int], maxOperations: int) -> int:\n        def check(mx: int) -> bool:\n            return sum((x - 1) // mx for x in nums) <= maxOperations\n\n        return bisect_left(range(1, max(nums) + 1), True, key=check) + 1\n", "class Solution:\n  def minimumSize(self, nums: list[int], maxOperations: int) -> int:\n    def numOperations(m: int) -> int:\n      \"\"\"Returns the number of operations required to make m penalty.\"\"\"\n      return sum((num - 1) // m for num in nums)\n    l = 1\n    r = max(nums)\n    return bisect.bisect_left(\n        range(l, r),\n        True, key=lambda m: numOperations(m) <= maxOperations) + l\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1704, "slug": "determine-if-string-halves-are-alike", "solutions": ["class Solution:\n    def halvesAreAlike(self, s: str) -> bool:\n        cnt, n = 0, len(s) >> 1\n        vowels = set('aeiouAEIOU')\n        for i in range(n):\n            cnt += s[i] in vowels\n            cnt -= s[i + n] in vowels\n        return cnt == 0\n", "class Solution:\n  def halvesAreAlike(self, s: str) -> bool:\n    VOWELS = 'aeiouAEIOU'\n    aVowelsCount = sum(c in VOWELS for c in s[:len(s) // 2])\n    bVowelsCount = sum(c in VOWELS for c in s[len(s) // 2:])\n    return aVowelsCount == bVowelsCount\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1754, "slug": "largest-merge-of-two-strings", "solutions": ["class Solution:\n    def largestMerge(self, word1: str, word2: str) -> str:\n        i = j = 0\n        ans = []\n        while i < len(word1) and j < len(word2):\n            if word1[i:] > word2[j:]:\n                ans.append(word1[i])\n                i += 1\n            else:\n                ans.append(word2[j])\n                j += 1\n        ans.append(word1[i:])\n        ans.append(word2[j:])\n        return \"\".join(ans)\n", "class Solution:\n  def largestMerge(self, word1: str, word2: str) -> str:\n    if not word1:\n      return word2\n    if not word2:\n      return word1\n    if word1 > word2:\n      return word1[0] + self.largestMerge(word1[1:], word2)\n    return word2[0] + self.largestMerge(word1, word2[1:])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1705, "slug": "maximum-number-of-eaten-apples", "solutions": ["class Solution:\n    def eatenApples(self, apples: List[int], days: List[int]) -> int:\n        n = len(days)\n        i = ans = 0\n        q = []\n        while i < n or q:\n            if i < n and apples[i]:\n                heappush(q, (i + days[i] - 1, apples[i]))\n            while q and q[0][0] < i:\n                heappop(q)\n            if q:\n                t, v = heappop(q)\n                v -= 1\n                ans += 1\n                if v and t > i:\n                    heappush(q, (t, v))\n            i += 1\n        return ans\n", "class Solution:\n  def eatenApples(self, apples: list[int], days: list[int]) -> int:\n    n = len(apples)\n    ans = 0\n    minHeap = []  # (the rotten day, the number of apples)\n\n    i = 0\n    while i < n or minHeap:\n      # Remove the rotten apples.\n      while minHeap and minHeap[0][0] <= i:\n        heapq.heappop(minHeap)\n      # Add today's apples.\n      if i < n and apples[i] > 0:\n        heapq.heappush(minHeap, (i + days[i], apples[i]))\n      # Eat one apple today.\n      if minHeap:\n        rottenDay, numApples = heapq.heappop(minHeap)\n        if numApples > 1:\n          heapq.heappush(minHeap, (rottenDay, numApples - 1))\n        ans += 1\n      i += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1759, "slug": "count-number-of-homogenous-substrings", "solutions": ["class Solution:\n    def countHomogenous(self, s: str) -> int:\n        mod = 10**9 + 7\n        i, n = 0, len(s)\n        ans = 0\n        while i < n:\n            j = i\n            while j < n and s[j] == s[i]:\n                j += 1\n            cnt = j - i\n            ans += (1 + cnt) * cnt // 2\n            ans %= mod\n            i = j\n        return ans\n", "class Solution:\n  def countHomogenous(self, s: str) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    count = 0\n    currentChar = '@'\n\n    for c in s:\n      count = count + 1 if c == currentChar else 1\n      currentChar = c\n      ans += count\n      ans %= MOD\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1732, "slug": "find-the-highest-altitude", "solutions": ["class Solution:\n    def largestAltitude(self, gain: List[int]) -> int:\n        return max(accumulate(gain, initial=0))\n", "class Solution:\n  def largestAltitude(self, gain: list[int]) -> int:\n    ans = 0\n    currAltitude = 0\n    for g in gain:\n      currAltitude += g\n      ans = max(ans, currAltitude)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1706, "slug": "where-will-the-ball-fall", "solutions": ["class Solution:\n    def findBall(self, grid: List[List[int]]) -> List[int]:\n        def dfs(i: int, j: int) -> int:\n            if i == m:\n                return j\n            if j == 0 and grid[i][j] == -1:\n                return -1\n            if j == n - 1 and grid[i][j] == 1:\n                return -1\n            if grid[i][j] == 1 and grid[i][j + 1] == -1:\n                return -1\n            if grid[i][j] == -1 and grid[i][j - 1] == 1:\n                return -1\n            return dfs(i + 1, j + 1) if grid[i][j] == 1 else dfs(i + 1, j - 1)\n\n        m, n = len(grid), len(grid[0])\n        return [dfs(0, j) for j in range(n)]\n", "class Solution:\n  def findBall(self, grid: list[list[int]]) -> list[int]:\n    m = len(grid)\n    n = len(grid[0])\n    # dp[i] := status of the i-th column\n    # -1 := empty, 0 := b0, 1 := b1, ...\n    dp = [i for i in range(n)]\n    # ans[i] := the i-th ball's final positio\n    ans = [-1] * n\n\n    for i in range(m):\n      newDp = [-1] * n\n      for j in range(n):\n        # out-of-bounds\n        if j + grid[i][j] < 0 or j + grid[i][j] == n:\n          continue\n        if (grid[i][j] == 1 and grid[i][j + 1] == -1 or\n                grid[i][j] == -1 and grid[i][j - 1] == 1):\n          continue\n        newDp[j + grid[i][j]] = dp[j]\n      dp = newDp\n\n    for i, ball in enumerate(dp):\n      if ball != -1:\n        ans[ball] = i\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1752, "slug": "check-if-array-is-sorted-and-rotated", "solutions": ["class Solution:\n    def check(self, nums: List[int]) -> bool:\n        return sum(nums[i - 1] > v for i, v in enumerate(nums)) <= 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1777, "slug": "products-price-for-each-store", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1718, "slug": "construct-the-lexicographically-largest-valid-sequence", "solutions": ["class Solution:\n    def constructDistancedSequence(self, n: int) -> List[int]:\n        def dfs(u):\n            if u == n * 2:\n                return True\n            if path[u]:\n                return dfs(u + 1)\n            for i in range(n, 1, -1):\n                if cnt[i] and u + i < n * 2 and path[u + i] == 0:\n                    cnt[i] = 0\n                    path[u] = path[u + i] = i\n                    if dfs(u + 1):\n                        return True\n                    path[u] = path[u + i] = 0\n                    cnt[i] = 2\n            if cnt[1]:\n                cnt[1], path[u] = 0, 1\n                if dfs(u + 1):\n                    return True\n                path[u], cnt[1] = 0, 1\n            return False\n\n        path = [0] * (n * 2)\n        cnt = [2] * (n * 2)\n        cnt[1] = 1\n        dfs(1)\n        return path[1:]\n", "class Solution:\n  def constructDistancedSequence(self, n: int) -> list[int]:\n    ans = [0] * (2 * n - 1)\n\n    def dfs(i: int, mask: int) -> bool:\n      if i == len(ans):\n        return True\n      if ans[i] > 0:\n        return dfs(i + 1, mask)\n\n      # Greedily fill in `ans` in descending order.\n      for num in range(n, 0, -1):\n        if (mask >> num & 1) == 1:\n          continue\n        if num == 1:\n          ans[i] = num\n          if dfs(i + 1, mask | 1 << num):\n            return True\n          ans[i] = 0\n        else:  # num in [2, n]\n          if i + num >= len(ans) or ans[i + num] > 0:\n            continue\n          ans[i] = num\n          ans[i + num] = num\n          if dfs(i + 1, mask | 1 << num):\n            return True\n          ans[i + num] = 0\n          ans[i] = 0\n\n      return False\n\n    dfs(0, 0)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1714, "slug": "sum-of-special-evenly-spaced-elements-in-array", "solutions": ["class Solution:\n    def solve(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        mod = 10**9 + 7\n        n = len(nums)\n        m = int(sqrt(n))\n        suf = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(n - 1, -1, -1):\n                suf[i][j] = suf[i][min(n, j + i)] + nums[j]\n        ans = []\n        for x, y in queries:\n            if y <= m:\n                ans.append(suf[y][x] % mod)\n            else:\n                ans.append(sum(nums[x::y]) % mod)\n        return ans\n", "class Solution:\n  def solve(self, nums: list[int], queries: list[list[int]]) -> list[int]:\n    MOD = 10**9 + 7\n    n = len(nums)\n    sqrtN = int(n**0.5)\n    # prefix[x][y] = sum(nums[x + ay]), where a >= 0 and x + ay < n\n    # Set prefix[i][j] to nums[i] to indicate the sequence starts with nums[i].\n    prefix = [[num] * sqrtN for num in nums]\n\n    for x in range(n - 1, -1, -1):\n      for y in range(1, sqrtN):\n        if x + y < n:\n          prefix[x][y] += prefix[x + y][y]\n          prefix[x][y] %= MOD\n\n    return [prefix[x][y] if y < sqrtN\n            else sum(nums[x::y]) % MOD\n            for x, y in queries]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1758, "slug": "minimum-changes-to-make-alternating-binary-string", "solutions": ["class Solution:\n    def minOperations(self, s: str) -> int:\n        cnt = sum(c != '01'[i & 1] for i, c in enumerate(s))\n        return min(cnt, len(s) - cnt)\n", "class Solution:\n  def minOperations(self, s: str) -> int:\n    # the cost to make s \"1010\"\n    cost10 = sum(int(c) == i % 2 for i, c in enumerate(s))\n    # the cost to make s \"0101\"\n    cost01 = len(s) - cost10\n    return min(cost10, cost01)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1727, "slug": "largest-submatrix-with-rearrangements", "solutions": ["class Solution:\n    def largestSubmatrix(self, matrix: List[List[int]]) -> int:\n        for i in range(1, len(matrix)):\n            for j in range(len(matrix[0])):\n                if matrix[i][j]:\n                    matrix[i][j] = matrix[i - 1][j] + 1\n        ans = 0\n        for row in matrix:\n            row.sort(reverse=True)\n            for j, v in enumerate(row, 1):\n                ans = max(ans, j * v)\n        return ans\n", "class Solution:\n  def largestSubmatrix(self, matrix: list[list[int]]) -> int:\n    ans = 0\n    hist = [0] * len(matrix[0])\n\n    for row in matrix:\n      # Accumulate the histogram if possible.\n      for i, num in enumerate(row):\n        hist[i] = 0 if num == 0 else hist[i] + 1\n\n      # Get the sorted histogram.\n      sortedHist = sorted(hist)\n\n      # Greedily calculate the answer.\n      for i, h in enumerate(sortedHist):\n        ans = max(ans, h * (len(row) - i))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1761, "slug": "minimum-degree-of-a-connected-trio-in-a-graph", "solutions": ["def min(a: int, b: int) -> int:\n    return a if a < b else b\n\n\nclass Solution:\n    def minTrioDegree(self, n: int, edges: List[List[int]]) -> int:\n        g = [[False] * n for _ in range(n)]\n        deg = [0] * n\n        for u, v in edges:\n            u, v = u - 1, v - 1\n            g[u][v] = g[v][u] = True\n            deg[u] += 1\n            deg[v] += 1\n        ans = inf\n        for i in range(n):\n            for j in range(i + 1, n):\n                if g[i][j]:\n                    for k in range(j + 1, n):\n                        if g[i][k] and g[j][k]:\n                            ans = min(ans, deg[i] + deg[j] + deg[k] - 6)\n        return -1 if ans == inf else ans\n", "class Solution:\n  def minTrioDegree(self, n: int, edges: list[list[int]]) -> int:\n    ans = math.inf\n    graph = [set() for _ in range(n)]\n    degrees = [0] * n\n\n    for u, v in edges:\n      u -= 1\n      v -= 1\n      # Store the mapping from `min(u, v)` to `max(u, v)` to speed up.\n      graph[min(u, v)].add(max(u, v))\n      degrees[u] += 1\n      degrees[v] += 1\n\n    for u in range(n):\n      for v in graph[u]:\n        for w in graph[u]:\n          if w in graph[v]:\n            ans = min(ans, degrees[u] + degrees[v] + degrees[w] - 6)\n\n    return -1 if ans == math.inf else ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1711, "slug": "count-good-meals", "solutions": ["class Solution:\n    def countPairs(self, deliciousness: List[int]) -> int:\n        mod = 10**9 + 7\n        mx = max(deliciousness) << 1\n        cnt = Counter()\n        ans = 0\n        for d in deliciousness:\n            s = 1\n            while s <= mx:\n                ans = (ans + cnt[s - d]) % mod\n                s <<= 1\n            cnt[d] += 1\n        return ans\n", "class Solution:\n  def countPairs(self, deliciousness: list[int]) -> int:\n    MOD = 10**9 + 7\n    MAX_BIT = 20 + 1\n    ans = 0\n    count = collections.Counter()\n\n    for d in deliciousness:\n      for i in range(MAX_BIT + 1):\n        power = 1 << i\n        ans += count[power - d]\n        ans %= MOD\n      count[d] += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1713, "slug": "minimum-operations-to-make-a-subsequence", "solutions": ["class BinaryIndexedTree:\n    __slots__ = \"n\", \"c\"\n\n    def __init__(self, n: int):\n        self.n = n\n        self.c = [0] * (n + 1)\n\n    def update(self, x: int, v: int):\n        while x <= self.n:\n            self.c[x] = max(self.c[x], v)\n            x += x & -x\n\n    def query(self, x: int) -> int:\n        res = 0\n        while x:\n            res = max(res, self.c[x])\n            x -= x & -x\n        return res\n\n\nclass Solution:\n    def minOperations(self, target: List[int], arr: List[int]) -> int:\n        d = {x: i for i, x in enumerate(target, 1)}\n        nums = [d[x] for x in arr if x in d]\n        m = len(target)\n        tree = BinaryIndexedTree(m)\n        ans = 0\n        for x in nums:\n            v = tree.query(x - 1) + 1\n            ans = max(ans, v)\n            tree.update(x, v)\n        return len(target) - ans\n", "class Solution:\n  def minOperations(self, target: list[int], arr: list[int]) -> int:\n    indices = []\n    numToIndex = {num: i for i, num in enumerate(target)}\n\n    for a in arr:\n      if a in numToIndex:\n        indices.append(numToIndex[a])\n\n    return len(target) - self._lengthOfLIS(indices)\n\n  # Same as 300. Longest Increasing Subsequence\n  def _lengthOfLIS(self, nums: list[int]) -> int:\n    # tails[i] := the minimum tail of all the increasing subsequences having\n    # length i + 1\n    tails = []\n    for num in nums:\n      if not tails or num > tails[-1]:\n        tails.append(num)\n      else:\n        tails[bisect.bisect_left(tails, num)] = num\n    return len(tails)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1799, "slug": "maximize-score-after-n-operations", "solutions": ["class Solution:\n    def maxScore(self, nums: List[int]) -> int:\n        m = len(nums)\n        f = [0] * (1 << m)\n        g = [[0] * m for _ in range(m)]\n        for i in range(m):\n            for j in range(i + 1, m):\n                g[i][j] = gcd(nums[i], nums[j])\n        for k in range(1 << m):\n            if (cnt := k.bit_count()) % 2 == 0:\n                for i in range(m):\n                    if k >> i & 1:\n                        for j in range(i + 1, m):\n                            if k >> j & 1:\n                                f[k] = max(\n                                    f[k],\n                                    f[k ^ (1 << i) ^ (1 << j)] + cnt // 2 * g[i][j],\n                                )\n        return f[-1]\n", "class Solution:\n  def maxScore(self, nums: list[int]) -> int:\n    n = len(nums) // 2\n\n    @functools.lru_cache(None)\n    def dp(k: int, mask: int) -> int:\n      \"\"\"\n      Returns the maximum score you can receive after performing the k to n\n      operations, where `mask` is the bitmask of the chosen numbers.\n      \"\"\"\n      if k == n + 1:\n        return 0\n\n      res = 0\n\n      for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n          chosenMask = 1 << i | 1 << j\n          if (mask & chosenMask) == 0:\n            res = max(\n                res, k * math.gcd(nums[i], nums[j]) + dp(k + 1, mask | chosenMask))\n\n      return res\n\n    return dp(1, 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1782, "slug": "count-pairs-of-nodes", "solutions": ["class Solution:\n    def countPairs(\n        self, n: int, edges: List[List[int]], queries: List[int]\n    ) -> List[int]:\n        cnt = [0] * n\n        g = defaultdict(int)\n        for a, b in edges:\n            a, b = a - 1, b - 1\n            a, b = min(a, b), max(a, b)\n            cnt[a] += 1\n            cnt[b] += 1\n            g[(a, b)] += 1\n\n        s = sorted(cnt)\n        ans = [0] * len(queries)\n        for i, t in enumerate(queries):\n            for j, x in enumerate(s):\n                k = bisect_right(s, t - x, lo=j + 1)\n                ans[i] += n - k\n            for (a, b), v in g.items():\n                if cnt[a] + cnt[b] > t and cnt[a] + cnt[b] - v <= t:\n                    ans[i] -= 1\n        return ans\n", "class Solution:\n  def countPairs(\n      self,\n      n: int,\n      edges: list[list[int]],\n      queries: list[int],\n  ) -> list[int]:\n    ans = [0] * len(queries)\n\n    # count[i] := the number of edges of node i\n    count = [0] * (n + 1)\n\n    # shared[i][j] := the number of edges incident to i or j, where i < j\n    shared = [collections.Counter() for _ in range(n + 1)]\n\n    for u, v in edges:\n      count[u] += 1\n      count[v] += 1\n      shared[min(u, v)][max(u, v)] += 1\n\n    sortedCount = sorted(count)\n\n    for k, query in enumerate(queries):\n      i = 1\n      j = n\n      while i < j:\n        if sortedCount[i] + sortedCount[j] > query:\n          # sortedCount[i] + sortedCount[j] > query\n          # sortedCount[i + 1] + sortedCount[j] > query\n          # ...\n          # sortedCount[j - 1] + sortedCount[j] > query\n          # So, there are (j - 1) - i + 1 = j - i pairs > query\n          ans[k] += j - i\n          j -= 1\n        else:\n          i += 1\n      for i in range(1, n + 1):\n        for j, sh in shared[i].items():\n          if count[i] + count[j] > query and count[i] + count[j] - sh <= query:\n            ans[k] -= 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1772, "slug": "sort-features-by-popularity", "solutions": ["class Solution:\n    def sortFeatures(self, features: List[str], responses: List[str]) -> List[str]:\n        cnt = Counter()\n        for s in responses:\n            for w in set(s.split()):\n                cnt[w] += 1\n        return sorted(features, key=lambda w: -cnt[w])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1762, "slug": "buildings-with-an-ocean-view", "solutions": ["class Solution:\n    def findBuildings(self, heights: List[int]) -> List[int]:\n        ans = []\n        mx = 0\n        for i in range(len(heights) - 1, -1, -1):\n            if heights[i] > mx:\n                ans.append(i)\n                mx = heights[i]\n        return ans[::-1]\n", "class Solution:\n  def findBuildings(self, heights: list[int]) -> list[int]:\n    stack = []\n\n    for i, height in enumerate(heights):\n      while stack and heights[stack[-1]] <= height:\n        stack.pop()\n      stack.append(i)\n\n    return stack\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1729, "slug": "find-followers-count", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1795, "slug": "rearrange-products-table", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1779, "slug": "find-nearest-point-that-has-the-same-x-or-y-coordinate", "solutions": ["class Solution:\n    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\n        ans, mi = -1, inf\n        for i, (a, b) in enumerate(points):\n            if a == x or b == y:\n                d = abs(a - x) + abs(b - y)\n                if mi > d:\n                    ans, mi = i, d\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1737, "slug": "change-minimum-characters-to-satisfy-one-of-three-conditions", "solutions": ["class Solution:\n    def minCharacters(self, a: str, b: str) -> int:\n        def f(cnt1, cnt2):\n            for i in range(1, 26):\n                t = sum(cnt1[i:]) + sum(cnt2[:i])\n                nonlocal ans\n                ans = min(ans, t)\n\n        m, n = len(a), len(b)\n        cnt1 = [0] * 26\n        cnt2 = [0] * 26\n        for c in a:\n            cnt1[ord(c) - ord('a')] += 1\n        for c in b:\n            cnt2[ord(c) - ord('a')] += 1\n        ans = m + n\n        for c1, c2 in zip(cnt1, cnt2):\n            ans = min(ans, m + n - c1 - c2)\n        f(cnt1, cnt2)\n        f(cnt2, cnt1)\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1751, "slug": "maximum-number-of-events-that-can-be-attended-ii", "solutions": ["class Solution:\n    def maxValue(self, events: List[List[int]], k: int) -> int:\n        @cache\n        def dfs(i: int, k: int) -> int:\n            if i >= len(events):\n                return 0\n            _, ed, val = events[i]\n            ans = dfs(i + 1, k)\n            if k:\n                j = bisect_right(events, ed, lo=i + 1, key=lambda x: x[0])\n                ans = max(ans, dfs(j, k - 1) + val)\n            return ans\n\n        events.sort()\n        return dfs(0, k)\n", "class Solution:\n  def maxValue(self, events: list[list[int]], k: int) -> int:\n    events.sort()\n\n    @functools.lru_cache(None)\n    def dp(i: int, k: int) -> int:\n      \"\"\"\n      Returns the maximum sum of values that you can receive by attending\n      events[i..n), where k is the maximum number of attendance.\n      \"\"\"\n      if k == 0 or i == len(events):\n        return 0\n\n      # Binary search `events` to find the first index j\n      # s.t. events[j][0] > events[i][1].\n      j = bisect.bisect(events, [events[i][1], math.inf, math.inf], i + 1)\n      return max(events[i][2] + dp(j, k - 1), dp(i + 1, k))\n\n    return dp(0, k)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1773, "slug": "count-items-matching-a-rule", "solutions": ["class Solution:\n    def countMatches(self, items: List[List[str]], ruleKey: str, ruleValue: str) -> int:\n        i = 0 if ruleKey[0] == 't' else (1 if ruleKey[0] == 'c' else 2)\n        return sum(v[i] == ruleValue for v in items)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1710, "slug": "maximum-units-on-a-truck", "solutions": ["class Solution:\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\n        ans = 0\n        for a, b in sorted(boxTypes, key=lambda x: -x[1]):\n            ans += b * min(truckSize, a)\n            truckSize -= a\n            if truckSize <= 0:\n                break\n        return ans\n", "class Solution:\n  def maximumUnits(self, boxTypes: list[list[int]], truckSize: int) -> int:\n    ans = 0\n\n    for boxes, units in sorted(boxTypes, key=lambda x: -x[1]):\n      if boxes >= truckSize:\n        return ans + truckSize * units\n      ans += boxes * units\n      truckSize -= boxes\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1723, "slug": "find-minimum-time-to-finish-all-jobs", "solutions": ["class Solution:\n    def minimumTimeRequired(self, jobs: List[int], k: int) -> int:\n        def dfs(i):\n            nonlocal ans\n            if i == len(jobs):\n                ans = min(ans, max(cnt))\n                return\n            for j in range(k):\n                if cnt[j] + jobs[i] >= ans:\n                    continue\n                cnt[j] += jobs[i]\n                dfs(i + 1)\n                cnt[j] -= jobs[i]\n                if cnt[j] == 0:\n                    break\n\n        cnt = [0] * k\n        jobs.sort(reverse=True)\n        ans = inf\n        dfs(0)\n        return ans\n", "class Solution:\n  def minimumTimeRequired(self, jobs: list[int], k: int) -> int:\n    ans = sum(jobs)\n    times = [0] * k  # times[i] := accumulate time of workers[i]\n\n    # Assign the most time-consuming job first.\n    jobs.sort(reverse=True)\n\n    def dfs(s: int) -> None:\n      nonlocal ans\n      if s == len(jobs):\n        ans = min(ans, max(times))\n        return\n      for i in range(k):\n        # There is no need to explore assigning jobs[s] to workers[i] further as\n        # it would not yield better results.\n        if times[i] + jobs[s] >= ans:\n          continue\n        times[i] += jobs[s]\n        dfs(s + 1)\n        times[i] -= jobs[s]\n        # It's always non-optimal to have a worker with no jobs.\n        if times[i] == 0:\n          return\n\n    dfs(0)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1748, "slug": "sum-of-unique-elements", "solutions": ["class Solution:\n    def sumOfUnique(self, nums: List[int]) -> int:\n        cnt = Counter(nums)\n        return sum(x for x, v in cnt.items() if v == 1)\n", "class Solution:\n  def sumOfUnique(self, nums: list[int]) -> int:\n    return sum(num\n               for num, freq in collections.Counter(nums).items()\n               if freq == 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1736, "slug": "latest-time-by-replacing-hidden-digits", "solutions": ["class Solution:\n    def maximumTime(self, time: str) -> str:\n        t = list(time)\n        if t[0] == '?':\n            t[0] = '1' if '4' <= t[1] <= '9' else '2'\n        if t[1] == '?':\n            t[1] = '3' if t[0] == '2' else '9'\n        if t[3] == '?':\n            t[3] = '5'\n        if t[4] == '?':\n            t[4] = '9'\n        return ''.join(t)\n", "class Solution:\n  def maximumTime(self, time: str) -> str:\n    ans = list(time)\n    if time[0] == '?':\n      ans[0] = '2' if time[1] == '?' or time[1] < '4' else '1'\n    if time[1] == '?':\n      ans[1] = '3' if ans[0] == '2' else '9'\n    if time[3] == '?':\n      ans[3] = '5'\n    if time[4] == '?':\n      ans[4] = '9'\n    return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1767, "slug": "find-the-subtasks-that-did-not-execute", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1786, "slug": "number-of-restricted-paths-from-first-to-last-node", "solutions": ["class Solution:\n    def countRestrictedPaths(self, n: int, edges: List[List[int]]) -> int:\n        @cache\n        def dfs(i):\n            if i == n:\n                return 1\n            ans = 0\n            for j, _ in g[i]:\n                if dist[i] > dist[j]:\n                    ans = (ans + dfs(j)) % mod\n            return ans\n\n        g = defaultdict(list)\n        for u, v, w in edges:\n            g[u].append((v, w))\n            g[v].append((u, w))\n        q = [(0, n)]\n        dist = [inf] * (n + 1)\n        dist[n] = 0\n        mod = 10**9 + 7\n        while q:\n            _, u = heappop(q)\n            for v, w in g[u]:\n                if dist[v] > dist[u] + w:\n                    dist[v] = dist[u] + w\n                    heappush(q, (dist[v], v))\n        return dfs(1)\n", "class Solution:\n  def countRestrictedPaths(self, n: int, edges: list[list[int]]) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u - 1].append((v - 1, w))\n      graph[v - 1].append((u - 1, w))\n\n    return self._dijkstra(graph, 0, n - 1)\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n      dst: int,\n  ) -> int:\n    MOD = 10**9 + 7\n    # ways[i] := the number of restricted path from i to n\n    ways = [0] * len(graph)\n    # dist[i] := the distance to the last node of i\n    dist = [math.inf] * len(graph)\n\n    ways[dst] = 1\n    dist[dst] = 0\n    minHeap = [(dist[dst], dst)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n        if dist[v] < dist[u]:\n          ways[u] += ways[v]\n          ways[u] %= MOD\n\n    return ways[src]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1768, "slug": "merge-strings-alternately", "solutions": ["class Solution:\n    def mergeAlternately(self, word1: str, word2: str) -> str:\n        return ''.join(a + b for a, b in zip_longest(word1, word2, fillvalue=''))\n", "class Solution:\n  def mergeAlternately(self, word1: str, word2: str) -> str:\n    return ''.join(a + b for a, b in zip_longest(word1, word2, fillvalue=''))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1765, "slug": "map-of-highest-peak", "solutions": ["class Solution:\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\n        m, n = len(isWater), len(isWater[0])\n        ans = [[-1] * n for _ in range(m)]\n        q = deque()\n        for i, row in enumerate(isWater):\n            for j, v in enumerate(row):\n                if v:\n                    q.append((i, j))\n                    ans[i][j] = 0\n        while q:\n            i, j = q.popleft()\n            for a, b in pairwise((-1, 0, 1, 0, -1)):\n                x, y = i + a, j + b\n                if 0 <= x < m and 0 <= y < n and ans[x][y] == -1:\n                    ans[x][y] = ans[i][j] + 1\n                    q.append((x, y))\n        return ans\n", "class Solution:\n  def highestPeak(self, isWater: list[list[int]]) -> list[list[int]]:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(isWater)\n    n = len(isWater[0])\n    ans = [[-1] * n for _ in range(m)]\n    q = collections.deque()\n\n    for i in range(m):\n      for j in range(n):\n        if isWater[i][j] == 1:\n          q.append((i, j))\n          ans[i][j] = 0\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if ans[x][y] != -1:\n          continue\n        ans[x][y] = ans[i][j] + 1\n        q.append((x, y))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1726, "slug": "tuple-with-same-product", "solutions": ["class Solution:\n    def tupleSameProduct(self, nums: List[int]) -> int:\n        cnt = defaultdict(int)\n        for i in range(1, len(nums)):\n            for j in range(i):\n                x = nums[i] * nums[j]\n                cnt[x] += 1\n        return sum(v * (v - 1) // 2 for v in cnt.values()) << 3\n", "class Solution:\n  def tupleSameProduct(self, nums: list[int]) -> int:\n    # nums of ways to arrange (a, b) = 2\n    # nums of ways to arrange (c, d) = 2\n    # nums of ways to arrange (a, b), (c, d) = 2^3 = 8\n    ans = 0\n    count = collections.Counter()\n\n    for i in range(len(nums)):\n      for j in range(i):\n        prod = nums[i] * nums[j]\n        ans += count[prod] * 8\n        count[prod] += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1784, "slug": "check-if-binary-string-has-at-most-one-segment-of-ones", "solutions": ["class Solution:\n    def checkOnesSegment(self, s: str) -> bool:\n        return '01' not in s\n", "class Solution:\n  def checkOnesSegment(self, s: str) -> bool:\n    return '01' not in s\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1712, "slug": "ways-to-split-array-into-three-subarrays", "solutions": ["class Solution:\n    def waysToSplit(self, nums: List[int]) -> int:\n        mod = 10**9 + 7\n        s = list(accumulate(nums))\n        ans, n = 0, len(nums)\n        for i in range(n - 2):\n            j = bisect_left(s, s[i] << 1, i + 1, n - 1)\n            k = bisect_right(s, (s[-1] + s[i]) >> 1, j, n - 1)\n            ans += k - j\n        return ans % mod\n", "class Solution:\n  def waysToSplit(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(nums)\n    ans = 0\n    prefix = list(itertools.accumulate(nums))\n\n    j = 0\n    k = 0\n    for i in range(n - 2):\n      # Find the first index j s.t.\n      # left = prefix[i] <= mid = prefix[j] - prefix[i]\n      j = max(j, i + 1)\n      while j < n - 1 and prefix[i] > prefix[j] - prefix[i]:\n        j += 1\n      # Find the first index k s.t.\n      # mid = prefix[k] - prefix[i] > right = prefix[-1] - prefix[k]\n      k = max(k, j)\n      while k < n - 1 and prefix[k] - prefix[i] <= prefix[-1] - prefix[k]:\n        k += 1\n      ans += k - j\n      ans %= MOD\n\n    return ans\n", "class Solution:\n  def waysToSplit(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(nums)\n    ans = 0\n    prefix = list(itertools.accumulate(nums))\n\n    def firstGreaterEqual(i: int) -> int:\n      \"\"\"Finds the first index j s.t.\n         Mid = prefix[j] - prefix[i] >= left = prefix[i]\n      \"\"\"\n      l = i + 1\n      r = n - 1\n      while l < r:\n        m = (l + r) // 2\n        if prefix[m] - prefix[i] >= prefix[i]:\n          r = m\n        else:\n          l = m + 1\n      return l\n\n    def firstGreater(i: int) -> int:\n      \"\"\"Finds the first index k s.t.\n         mid = prefix[k] - prefix[i] > right = prefix[-1] - prefix[k]\n      \"\"\"\n      l = i + 1\n      r = n - 1\n      while l < r:\n        m = (l + r) // 2\n        if prefix[m] - prefix[i] > prefix[-1] - prefix[m]:\n          r = m\n        else:\n          l = m + 1\n      return l\n\n    for i in range(n - 2):\n      j = firstGreaterEqual(i)\n      if j == n - 1:\n        break\n      mid = prefix[j] - prefix[i]\n      right = prefix[-1] - prefix[j]\n      if mid > right:\n        continue\n      k = firstGreater(i)\n      ans = (ans + k - j) % MOD\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1738, "slug": "find-kth-largest-xor-coordinate-value", "solutions": ["class Solution:\n    def kthLargestValue(self, matrix: List[List[int]], k: int) -> int:\n        m, n = len(matrix), len(matrix[0])\n        s = [[0] * (n + 1) for _ in range(m + 1)]\n        ans = []\n        for i in range(m):\n            for j in range(n):\n                s[i + 1][j + 1] = s[i + 1][j] ^ s[i][j + 1] ^ s[i][j] ^ matrix[i][j]\n                ans.append(s[i + 1][j + 1])\n        return nlargest(k, ans)[-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1771, "slug": "maximize-palindrome-length-from-subsequences", "solutions": ["class Solution:\n    def longestPalindrome(self, word1: str, word2: str) -> int:\n        s = word1 + word2\n        n = len(s)\n        f = [[0] * n for _ in range(n)]\n        for i in range(n):\n            f[i][i] = 1\n        ans = 0\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    f[i][j] = f[i + 1][j - 1] + 2\n                    if i < len(word1) <= j:\n                        ans = max(ans, f[i][j])\n                else:\n                    f[i][j] = max(f[i + 1][j], f[i][j - 1])\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1787, "slug": "make-the-xor-of-all-segments-equal-to-zero", "solutions": ["class Solution:\n    def minChanges(self, nums: List[int], k: int) -> int:\n        n = 1 << 10\n        cnt = [Counter() for _ in range(k)]\n        size = [0] * k\n        for i, v in enumerate(nums):\n            cnt[i % k][v] += 1\n            size[i % k] += 1\n        f = [inf] * n\n        f[0] = 0\n        for i in range(k):\n            g = [min(f) + size[i]] * n\n            for j in range(n):\n                for v, c in cnt[i].items():\n                    g[j] = min(g[j], f[j ^ v] + size[i] - c)\n            f = g\n        return f[0]\n", "class Solution:\n  def minChanges(self, nums: list[int], k: int) -> int:\n    MAX = 1024\n    n = len(nums)\n    # counts[i] := the counter that maps at the i-th position\n    counts = [collections.Counter() for _ in range(k)]\n    # dp[i][j] := the minimum number of elements to change s.t. XOR(nums[i..k - 1]) is j\n    dp = [[n] * MAX for _ in range(k)]\n\n    for i, num in enumerate(nums):\n      counts[i % k][num] += 1\n\n    def countAt(i: int) -> int:\n      return n // k + (1 if n % k > i else 0)\n\n    # Initialize the DP array.\n    for j in range(MAX):\n      dp[k - 1][j] = countAt(k - 1) - counts[k - 1][j]\n\n    for i in range(k - 2, -1, -1):\n      # The worst-case scenario is changing all the i-th position numbers to a\n      # non-existent value in the current bucket.\n      changeAll = countAt(i) + min(dp[i + 1])\n      for j in range(MAX):\n        dp[i][j] = changeAll\n        for num, freq in counts[i].items():\n          # the cost to change every number in the i-th position to `num`\n          cost = countAt(i) - freq\n          dp[i][j] = min(dp[i][j], dp[i + 1][j ^ num] + cost)\n\n    return dp[0][0]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1733, "slug": "minimum-number-of-people-to-teach", "solutions": ["class Solution:\n    def minimumTeachings(\n        self, n: int, languages: List[List[int]], friendships: List[List[int]]\n    ) -> int:\n        def check(u, v):\n            for x in languages[u - 1]:\n                for y in languages[v - 1]:\n                    if x == y:\n                        return True\n            return False\n\n        s = set()\n        for u, v in friendships:\n            if not check(u, v):\n                s.add(u)\n                s.add(v)\n        cnt = Counter()\n        for u in s:\n            for l in languages[u - 1]:\n                cnt[l] += 1\n        return len(s) - max(cnt.values(), default=0)\n", "class Solution:\n  def minimumTeachings(\n      self,\n      n: int,\n      languages: list[list[int]],\n      friendships: list[list[int]],\n  ) -> int:\n    languageSets = [set(languages) for languages in languages]\n    needTeach = set()\n    languageCount = collections.Counter()\n\n    # Find friends that can't communicate.\n    for u, v in friendships:\n      if not languageSets[u - 1] & languageSets[v - 1]:\n        needTeach.add(u - 1)\n        needTeach.add(v - 1)\n\n    # Find the most popular language.\n    for u in needTeach:\n      for language in languageSets[u]:\n        languageCount[language] += 1\n\n    # Teach the most popular language to people don't understand.\n    return len(needTeach) - max(languageCount.values(), default=0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1725, "slug": "number-of-rectangles-that-can-form-the-largest-square", "solutions": ["class Solution:\n    def countGoodRectangles(self, rectangles: List[List[int]]) -> int:\n        ans = mx = 0\n        for l, w in rectangles:\n            x = min(l, w)\n            if mx < x:\n                ans = 1\n                mx = x\n            elif mx == x:\n                ans += 1\n        return ans\n", "class Solution:\n  def countGoodRectangles(self, rectangles: list[list[int]]) -> int:\n    minSides = [min(x, y) for x, y in rectangles]\n    return minSides.count(max(minSides))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 207, "slug": "course-schedule", "solutions": ["class Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        g = [[] for _ in range(numCourses)]\n        indeg = [0] * numCourses\n        for a, b in prerequisites:\n            g[b].append(a)\n            indeg[a] += 1\n        q = [i for i, x in enumerate(indeg) if x == 0]\n        for i in q:\n            numCourses -= 1\n            for j in g[i]:\n                indeg[j] -= 1\n                if indeg[j] == 0:\n                    q.append(j)\n        return numCourses == 0\n", "from enum import Enum\n\n\nclass State(Enum):\n  INIT = 0\n  VISITING = 1\n  VISITED = 2\n\n\nclass Solution:\n  def canFinish(self, numCourses: int, prerequisites: list[list[int]]) -> bool:\n    graph = [[] for _ in range(numCourses)]\n    states = [State.INIT] * numCourses\n\n    for v, u in prerequisites:\n      graph[u].append(v)\n\n    def hasCycle(u: int) -> bool:\n      if states[u] == State.VISITING:\n        return True\n      if states[u] == State.VISITED:\n        return False\n      states[u] = State.VISITING\n      if any(hasCycle(v) for v in graph[u]):\n        return True\n      states[u] = State.VISITED\n      return False\n\n    return not any(hasCycle(i) for i in range(numCourses))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 276, "slug": "paint-fence", "solutions": ["class Solution:\n    def numWays(self, n: int, k: int) -> int:\n        f = [0] * n\n        g = [0] * n\n        f[0] = k\n        for i in range(1, n):\n            f[i] = (f[i - 1] + g[i - 1]) * (k - 1)\n            g[i] = f[i - 1]\n        return f[-1] + g[-1]\n", "class Solution:\n  def numWays(self, n: int, k: int) -> int:\n    if n == 0:\n      return 0\n    if n == 1:\n      return k\n    if n == 2:\n      return k * k\n\n    # dp[i] := the number of ways to pan posts with k colors\n    dp = [0] * (n + 1)\n    dp[0] = 0\n    dp[1] = k\n    dp[2] = k * k\n\n    for i in range(3, n + 1):\n      dp[i] = (dp[i - 1] + dp[i - 2]) * (k - 1)\n\n    return dp[n]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 217, "slug": "contains-duplicate", "solutions": ["class Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        return any(a == b for a, b in pairwise(sorted(nums)))\n", "class Solution:\n  def containsDuplicate(self, nums: list[int]) -> bool:\n    return len(nums) != len(set(nums))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 293, "slug": "flip-game", "solutions": ["class Solution:\n    def generatePossibleNextMoves(self, currentState: str) -> List[str]:\n        s = list(currentState)\n        ans = []\n        for i, (a, b) in enumerate(pairwise(s)):\n            if a == b == \"+\":\n                s[i] = s[i + 1] = \"-\"\n                ans.append(\"\".join(s))\n                s[i] = s[i + 1] = \"+\"\n        return ans\n", "class Solution:\n  def generatePossibleNextMoves(self, currentState: str) -> list[str]:\n    return [currentState[:i] + '--' + currentState[i + 2:]\n            for i, (a, b) in enumerate(zip(currentState, currentState[1:]))\n            if a == '+' and b == '+']\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 279, "slug": "perfect-squares", "solutions": ["class Solution:\n    def numSquares(self, n: int) -> int:\n        m = int(sqrt(n))\n        f = [[inf] * (n + 1) for _ in range(m + 1)]\n        f[0][0] = 0\n        for i in range(1, m + 1):\n            for j in range(n + 1):\n                f[i][j] = f[i - 1][j]\n                if j >= i * i:\n                    f[i][j] = min(f[i][j], f[i][j - i * i] + 1)\n        return f[m][n]\n", "class Solution:\n  def numSquares(self, n: int) -> int:\n    dp = [n] * (n + 1)  # 1^2 x n\n    dp[0] = 0  # no way\n    dp[1] = 1  # 1^2\n\n    for i in range(2, n + 1):\n      j = 1\n      while j * j <= i:\n        dp[i] = min(dp[i], dp[i - j * j] + 1)\n        j += 1\n\n    return dp[n]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 234, "slug": "palindrome-linked-list", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def isPalindrome(self, head: Optional[ListNode]) -> bool:\n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow, fast = slow.next, fast.next.next\n        pre, cur = None, slow.next\n        while cur:\n            t = cur.next\n            cur.next = pre\n            pre, cur = cur, t\n        while pre:\n            if pre.val != head.val:\n                return False\n            pre, head = pre.next, head.next\n        return True\n", "class Solution:\n  def isPalindrome(self, head: ListNode) -> bool:\n    def reverseList(head: ListNode) -> ListNode:\n      prev = None\n      curr = head\n      while curr:\n        next = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next\n      return prev\n\n    slow = head\n    fast = head\n\n    while fast and fast.next:\n      slow = slow.next\n      fast = fast.next.next\n\n    if fast:\n      slow = slow.next\n    slow = reverseList(slow)\n\n    while slow:\n      if slow.val != head.val:\n        return False\n      slow = slow.next\n      head = head.next\n\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 269, "slug": "alien-dictionary", "solutions": ["class Solution:\n    def alienOrder(self, words: List[str]) -> str:\n        g = [[False] * 26 for _ in range(26)]\n        s = [False] * 26\n        cnt = 0\n        n = len(words)\n        for i in range(n - 1):\n            for c in words[i]:\n                if cnt == 26:\n                    break\n                o = ord(c) - ord('a')\n                if not s[o]:\n                    cnt += 1\n                    s[o] = True\n            m = len(words[i])\n            for j in range(m):\n                if j >= len(words[i + 1]):\n                    return ''\n                c1, c2 = words[i][j], words[i + 1][j]\n                if c1 == c2:\n                    continue\n                o1, o2 = ord(c1) - ord('a'), ord(c2) - ord('a')\n                if g[o2][o1]:\n                    return ''\n                g[o1][o2] = True\n                break\n        for c in words[n - 1]:\n            if cnt == 26:\n                break\n            o = ord(c) - ord('a')\n            if not s[o]:\n                cnt += 1\n                s[o] = True\n\n        indegree = [0] * 26\n        for i in range(26):\n            for j in range(26):\n                if i != j and s[i] and s[j] and g[i][j]:\n                    indegree[j] += 1\n        q = deque()\n        ans = []\n        for i in range(26):\n            if s[i] and indegree[i] == 0:\n                q.append(i)\n        while q:\n            t = q.popleft()\n            ans.append(chr(t + ord('a')))\n            for i in range(26):\n                if s[i] and i != t and g[t][i]:\n                    indegree[i] -= 1\n                    if indegree[i] == 0:\n                        q.append(i)\n        return '' if len(ans) < cnt else ''.join(ans)\n", "class Solution:\n  def alienOrder(self, words: list[str]) -> str:\n    graph = {}\n    inDegrees = [0] * 26\n\n    self._buildGraph(graph, words, inDegrees)\n    return self._topology(graph, inDegrees)\n\n  def _buildGraph(\n      self,\n      graph: dict[str, set[str]],\n      words: list[str],\n      inDegrees: list[int],\n  ) -> None:\n    # Create a node for each character in each word.\n    for word in words:\n      for c in word:\n        if c not in graph:\n          graph[c] = set()\n\n    for first, second in zip(words, words[1:]):\n      length = min(len(first), len(second))\n      for j in range(length):\n        u = first[j]\n        v = second[j]\n        if u != v:\n          if v not in graph[u]:\n            graph[u].add(v)\n            inDegrees[ord(v) - ord('a')] += 1\n          break  # The order of characters after this are meaningless.\n        # First = 'ab', second = 'a' . invalid\n        if j == length - 1 and len(first) > len(second):\n          graph.clear()\n          return\n\n  def _topology(self, graph: dict[str, set[str]], inDegrees: list[int]) -> str:\n    s = ''\n    q = collections.deque()\n\n    for c in graph:\n      if inDegrees[ord(c) - ord('a')] == 0:\n        q.append(c)\n\n    while q:\n      u = q.pop()\n      s += u\n      for v in graph[u]:\n        inDegrees[ord(v) - ord('a')] -= 1\n        if inDegrees[ord(v) - ord('a')] == 0:\n          q.append(v)\n\n    # Words = ['z', 'x', 'y', 'x']\n    return s if len(s) == len(graph) else ''\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 245, "slug": "shortest-word-distance-iii", "solutions": ["class Solution:\n    def shortestWordDistance(self, wordsDict: List[str], word1: str, word2: str) -> int:\n        ans = len(wordsDict)\n        if word1 == word2:\n            j = -1\n            for i, w in enumerate(wordsDict):\n                if w == word1:\n                    if j != -1:\n                        ans = min(ans, i - j)\n                    j = i\n        else:\n            i = j = -1\n            for k, w in enumerate(wordsDict):\n                if w == word1:\n                    i = k\n                if w == word2:\n                    j = k\n                if i != -1 and j != -1:\n                    ans = min(ans, abs(i - j))\n        return ans\n", "class Solution:\n  def shortestWordDistance(\n      self,\n      wordsDict: list[str],\n      word1: str,\n      word2: str,\n  ) -> int:\n    isSame = word1 == word2\n    ans = math.inf\n    # If word1 == word2, index1 is the newest index.\n    index1 = len(wordsDict)\n    # If word1 == word2, index2 is the previous index.\n    index2 = -len(wordsDict)\n\n    for i, word in enumerate(wordsDict):\n      if word == word1:\n        if isSame:\n          index2 = index1\n        index1 = i\n      elif word == word2:\n        index2 = i\n      ans = min(ans, abs(index1 - index2))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 258, "slug": "add-digits", "solutions": ["class Solution:\n    def addDigits(self, num: int) -> int:\n        return 0 if num == 0 else (num - 1) % 9 + 1\n", "class Solution:\n  def addDigits(self, num: int) -> int:\n    return 0 if num == 0 else 1 + (num - 1) % 9\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 283, "slug": "move-zeroes", "solutions": ["class Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        k = 0\n        for i, x in enumerate(nums):\n            if x:\n                nums[k], nums[i] = nums[i], nums[k]\n                k += 1\n", "class Solution:\n  def moveZeroes(self, nums: list[int]) -> None:\n    j = 0\n    for num in nums:\n      if num != 0:\n        nums[j] = num\n        j += 1\n\n    for i in range(j, len(nums)):\n      nums[i] = 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 226, "slug": "invert-binary-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        if root is None:\n            return None\n        l, r = self.invertTree(root.left), self.invertTree(root.right)\n        root.left, root.right = r, l\n        return root\n", "class Solution:\n  def invertTree(self, root: TreeNode | None) -> TreeNode | None:\n    if not root:\n      return None\n\n    left = root.left\n    right = root.right\n    root.left = self.invertTree(right)\n    root.right = self.invertTree(left)\n    return root\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 203, "slug": "remove-linked-list-elements", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeElements(self, head: ListNode, val: int) -> ListNode:\n        dummy = ListNode(-1, head)\n        pre = dummy\n        while pre.next:\n            if pre.next.val != val:\n                pre = pre.next\n            else:\n                pre.next = pre.next.next\n        return dummy.next\n", "class Solution:\n  def removeElements(self, head: ListNode, val: int) -> ListNode:\n    dummy = ListNode(0, head)\n    prev = dummy\n\n    while head:\n      if head.val != val:\n        prev.next = head\n        prev = prev.next\n      head = head.next\n    prev.next = None\n\n    return dummy.next\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 206, "slug": "reverse-linked-list", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseList(self, head: ListNode) -> ListNode:\n        dummy = ListNode()\n        curr = head\n        while curr:\n            next = curr.next\n            curr.next = dummy.next\n            dummy.next = curr\n            curr = next\n        return dummy.next\n", "class Solution:\n  def reverseList(self, head: ListNode | None) -> ListNode | None:\n    if not head or not head.next:\n      return head\n\n    newHead = self.reverseList(head.next)\n    head.next.next = head\n    head.next = None\n    return newHead\n", "class Solution:\n  def reverseList(self, head: ListNode | None) -> ListNode | None:\n    prev = None\n    curr = head\n\n    while curr:\n      next = curr.next\n      curr.next = prev\n      prev = curr\n      curr = next\n\n    return prev\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 205, "slug": "isomorphic-strings", "solutions": ["class Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        d1 = {}\n        d2 = {}\n        for a, b in zip(s, t):\n            if (a in d1 and d1[a] != b) or (b in d2 and d2[b] != a):\n                return False\n            d1[a] = b\n            d2[b] = a\n        return True\n", "class Solution:\n  def isIsomorphic(self, s: str, t: str) -> bool:\n    return [*map(s.index, s)] == [*map(t.index, t)]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 291, "slug": "word-pattern-ii", "solutions": ["class Solution:\n    def wordPatternMatch(self, pattern: str, s: str) -> bool:\n        def dfs(i, j):\n            if i == m and j == n:\n                return True\n            if i == m or j == n or n - j < m - i:\n                return False\n            for k in range(j, n):\n                t = s[j : k + 1]\n                if d.get(pattern[i]) == t:\n                    if dfs(i + 1, k + 1):\n                        return True\n                if pattern[i] not in d and t not in vis:\n                    d[pattern[i]] = t\n                    vis.add(t)\n                    if dfs(i + 1, k + 1):\n                        return True\n                    d.pop(pattern[i])\n                    vis.remove(t)\n            return False\n\n        m, n = len(pattern), len(s)\n        d = {}\n        vis = set()\n        return dfs(0, 0)\n", "class Solution:\n  def wordPatternMatch(self, pattern: str, s: str) -> bool:\n    def isMatch(\n            i: int, j: int, charToString: dict[str, str],\n            seen: set[str]) -> bool:\n      if i == len(pattern) and j == len(s):\n        return True\n      if i == len(pattern) or j == len(s):\n        return False\n\n      c = pattern[i]\n\n      if c in charToString:\n        t = charToString[c]\n        # See if we can match t with s[j..n).\n        if t not in s[j:]:\n          return False\n\n        # If there's a match, continue to match the rest.\n        return isMatch(i + 1, j + len(t), charToString, seen)\n\n      for k in range(j, len(s)):\n        t = s[j:k + 1]\n\n        # This string is mapped by another character.\n        if t in seen:\n          continue\n\n        charToString[c] = t\n        seen.add(t)\n\n        if isMatch(i + 1, k + 1, charToString, seen):\n          return True\n\n        # Backtrack.\n        del charToString[c]\n        seen.remove(t)\n\n      return False\n\n    return isMatch(0, 0, {}, set())\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 210, "slug": "course-schedule-ii", "solutions": ["class Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        g = defaultdict(list)\n        indeg = [0] * numCourses\n        for a, b in prerequisites:\n            g[b].append(a)\n            indeg[a] += 1\n        ans = []\n        q = deque(i for i, x in enumerate(indeg) if x == 0)\n        while q:\n            i = q.popleft()\n            ans.append(i)\n            for j in g[i]:\n                indeg[j] -= 1\n                if indeg[j] == 0:\n                    q.append(j)\n        return ans if len(ans) == numCourses else []\n", "from enum import Enum\n\n\nclass State(Enum):\n  INIT = 0\n  VISITING = 1\n  VISITED = 2\n\n\nclass Solution:\n  def findOrder(\n      self,\n      numCourses: int,\n      prerequisites: list[list[int]],\n  ) -> list[int]:\n    ans = []\n    graph = [[] for _ in range(numCourses)]\n    states = [State.INIT] * numCourses\n\n    for v, u in prerequisites:\n      graph[u].append(v)\n\n    def hasCycle(u: int) -> bool:\n      if states[u] == State.VISITING:\n        return True\n      if states[u] == State.VISITED:\n        return False\n      states[u] = State.VISITING\n      if any(hasCycle(v) for v in graph[u]):\n        return True\n      states[u] = State.VISITED\n      ans.append(u)\n      return False\n\n    if any(hasCycle(i) for i in range(numCourses)):\n      return []\n\n    return ans[::-1]\n", "class Solution:\n  def findOrder(\n      self,\n      numCourses: int,\n      prerequisites: list[list[int]],\n  ) -> list[int]:\n    ans = []\n    graph = [[] for _ in range(numCourses)]\n    inDegrees = [0] * numCourses\n    q = collections.deque()\n\n    # Build the graph.\n    for v, u in prerequisites:\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    # Perform topological sorting.\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    while q:\n      u = q.popleft()\n      ans.append(u)\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    return ans if len(ans) == numCourses else []\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 286, "slug": "walls-and-gates", "solutions": ["class Solution:\n    def wallsAndGates(self, rooms: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify rooms in-place instead.\n        \"\"\"\n        m, n = len(rooms), len(rooms[0])\n        inf = 2**31 - 1\n        q = deque([(i, j) for i in range(m) for j in range(n) if rooms[i][j] == 0])\n        d = 0\n        while q:\n            d += 1\n            for _ in range(len(q)):\n                i, j = q.popleft()\n                for a, b in [[0, 1], [0, -1], [1, 0], [-1, 0]]:\n                    x, y = i + a, j + b\n                    if 0 <= x < m and 0 <= y < n and rooms[x][y] == inf:\n                        rooms[x][y] = d\n                        q.append((x, y))\n", "class Solution:\n  def wallsAndGates(self, rooms: list[list[int]]) -> None:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    INF = 2**31 - 1\n    m = len(rooms)\n    n = len(rooms[0])\n    q = collections.deque((i, j)\n                          for i in range(m)\n                          for j in range(n)\n                          if rooms[i][j] == 0)\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if rooms[x][y] != INF:\n          continue\n        rooms[x][y] = rooms[i][j] + 1\n        q.append((x, y))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 277, "slug": "find-the-celebrity", "solutions": ["# The knows API is already defined for you.\n# return a bool, whether a knows b\n# def knows(a: int, b: int) -> bool:\n\n\nclass Solution:\n    def findCelebrity(self, n: int) -> int:\n        ans = 0\n        for i in range(1, n):\n            if knows(ans, i):\n                ans = i\n        for i in range(n):\n            if ans != i:\n                if knows(ans, i) or not knows(i, ans):\n                    return -1\n        return ans\n", "# The knows API is already defined for you.\n# Returns a bool, whether a knows b\n# Def knows(a: int, b: int) -> bool:\n\n\nclass Solution:\n  def findCelebrity(self, n: int) -> int:\n    candidate = 0\n\n    # Everyone knows the celebrity.\n    for i in range(1, n):\n      if knows(candidate, i):\n        candidate = i\n\n    # The candidate knows nobody and everyone knows the celebrity.\n    for i in range(n):\n      if i < candidate and knows(candidate, i) or not knows(i, candidate):\n        return -1\n      if i > candidate and not knows(i, candidate):\n        return -1\n\n    return candidate\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 240, "slug": "search-a-2d-matrix-ii", "solutions": ["class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        for row in matrix:\n            j = bisect_left(row, target)\n            if j < len(matrix[0]) and row[j] == target:\n                return True\n        return False\n", "class Solution:\n  def searchMatrix(self, matrix: list[list[int]], target: int) -> bool:\n    r = 0\n    c = len(matrix[0]) - 1\n\n    while r < len(matrix) and c >= 0:\n      if matrix[r][c] == target:\n        return True\n      if target < matrix[r][c]:\n        c -= 1\n      else:\n        r += 1\n\n    return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 266, "slug": "palindrome-permutation", "solutions": ["class Solution:\n    def canPermutePalindrome(self, s: str) -> bool:\n        return sum(v & 1 for v in Counter(s).values()) < 2\n", "class Solution:\n  def canPermutePalindrome(self, s: str) -> bool:\n    seen = set()\n\n    for c in s:\n      if c in seen:\n        seen.remove(c)\n      else:\n        seen.add(c)\n\n    return len(seen) <= 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 282, "slug": "expression-add-operators", "solutions": ["class Solution:\n    def addOperators(self, num: str, target: int) -> List[str]:\n        ans = []\n\n        def dfs(u, prev, curr, path):\n            if u == len(num):\n                if curr == target:\n                    ans.append(path)\n                return\n            for i in range(u, len(num)):\n                if i != u and num[u] == '0':\n                    break\n                next = int(num[u : i + 1])\n                if u == 0:\n                    dfs(i + 1, next, next, path + str(next))\n                else:\n                    dfs(i + 1, next, curr + next, path + \"+\" + str(next))\n                    dfs(i + 1, -next, curr - next, path + \"-\" + str(next))\n                    dfs(\n                        i + 1,\n                        prev * next,\n                        curr - prev + prev * next,\n                        path + \"*\" + str(next),\n                    )\n\n        dfs(0, 0, 0, \"\")\n        return ans\n", "class Solution:\n  def addOperators(self, num: str, target: int) -> list[str]:\n    ans = []\n\n    def dfs(start: int, prev: int, eval: int, path: list[str]) -> None:\n      if start == len(num):\n        if eval == target:\n          ans.append(''.join(path))\n        return\n\n      for i in range(start, len(num)):\n        if i > start and num[start] == '0':\n          return\n        s = num[start:i + 1]\n        curr = int(s)\n        if start == 0:\n          path.append(s)\n          dfs(i + 1, curr, curr, path)\n          path.pop()\n        else:\n          for op in ['+', '-', '*']:\n            path.append(op + s)\n            if op == '+':\n              dfs(i + 1, curr, eval + curr, path)\n            elif op == '-':\n              dfs(i + 1, -curr, eval - curr, path)\n            else:\n              dfs(i + 1, prev * curr, eval - prev + prev * curr, path)\n            path.pop()\n\n    dfs(0, 0, 0, [])\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 292, "slug": "nim-game", "solutions": ["class Solution:\n    def canWinNim(self, n: int) -> bool:\n        return n % 4 != 0\n", "class Solution:\n  def canWinNim(self, n: int) -> bool:\n    return n % 4 != 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 241, "slug": "different-ways-to-add-parentheses", "solutions": ["class Solution:\n    def diffWaysToCompute(self, expression: str) -> List[int]:\n        @cache\n        def dfs(exp):\n            if exp.isdigit():\n                return [int(exp)]\n            ans = []\n            for i, c in enumerate(exp):\n                if c in '-+*':\n                    left, right = dfs(exp[:i]), dfs(exp[i + 1 :])\n                    for a in left:\n                        for b in right:\n                            if c == '-':\n                                ans.append(a - b)\n                            elif c == '+':\n                                ans.append(a + b)\n                            else:\n                                ans.append(a * b)\n            return ans\n\n        return dfs(expression)\n", "class Solution:\n  @functools.lru_cache(None)\n  def diffWaysToCompute(self, expression: str) -> list[int]:\n    ans = []\n\n    for i, c in enumerate(expression):\n      if c in '+-*':\n        for a in self.diffWaysToCompute(expression[:i]):\n          for b in self.diffWaysToCompute(expression[i + 1:]):\n            ans.append(eval(str(a) + c + str(b)))\n\n    return ans or [int(expression)]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 238, "slug": "product-of-array-except-self", "solutions": ["class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        ans = [0] * n\n        left = right = 1\n        for i, x in enumerate(nums):\n            ans[i] = left\n            left *= x\n        for i in range(n - 1, -1, -1):\n            ans[i] *= right\n            right *= nums[i]\n        return ans\n", "class Solution:\n  def productExceptSelf(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n    ans = [1] * n\n\n    # Use ans as the prefix product array.\n    for i in range(1, n):\n      ans[i] = ans[i - 1] * nums[i - 1]\n\n    suffix = 1  # suffix product\n    for i, num in reversed(list(enumerate(nums))):\n      ans[i] *= suffix\n      suffix *= num\n\n    return ans\n", "class Solution:\n  def productExceptSelf(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n    prefix = [1] * n  # prefix product\n    suffix = [1] * n  # suffix product\n\n    for i in range(1, n):\n      prefix[i] = prefix[i - 1] * nums[i - 1]\n\n    for i in reversed(range(n - 1)):\n      suffix[i] = suffix[i + 1] * nums[i + 1]\n\n    return [prefix[i] * suffix[i] for i in range(n)]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 218, "slug": "the-skyline-problem", "solutions": ["from queue import PriorityQueue\n\n\nclass Solution:\n    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:\n        skys, lines, pq = [], [], PriorityQueue()\n        for build in buildings:\n            lines.extend([build[0], build[1]])\n        lines.sort()\n        city, n = 0, len(buildings)\n        for line in lines:\n            while city < n and buildings[city][0] <= line:\n                pq.put([-buildings[city][2], buildings[city][0], buildings[city][1]])\n                city += 1\n            while not pq.empty() and pq.queue[0][2] <= line:\n                pq.get()\n            high = 0\n            if not pq.empty():\n                high = -pq.queue[0][0]\n            if len(skys) > 0 and skys[-1][1] == high:\n                continue\n            skys.append([line, high])\n        return skys\n", "class Solution:\n  def getSkyline(self, buildings: list[list[int]]) -> list[list[int]]:\n    n = len(buildings)\n    if n == 0:\n      return []\n    if n == 1:\n      left, right, height = buildings[0]\n      return [[left, height], [right, 0]]\n\n    left = self.getSkyline(buildings[:n // 2])\n    right = self.getSkyline(buildings[n // 2:])\n    return self._merge(left, right)\n\n  def _merge(self, left: list[list[int]],\n             right: list[list[int]]) -> list[list[int]]:\n    ans = []\n    i = 0  # left's index\n    j = 0  # right's index\n    leftY = 0\n    rightY = 0\n\n    while i < len(left) and j < len(right):\n      # Choose the powith smaller x\n      if left[i][0] < right[j][0]:\n        leftY = left[i][1]  # Update the ongoing `leftY`.\n        self._addPoint(ans, left[i][0], max(left[i][1], rightY))\n        i += 1\n      else:\n        rightY = right[j][1]  # Update the ongoing `rightY`.\n        self._addPoint(ans, right[j][0], max(right[j][1], leftY))\n        j += 1\n\n    while i < len(left):\n      self._addPoint(ans, left[i][0], left[i][1])\n      i += 1\n\n    while j < len(right):\n      self._addPoint(ans, right[j][0], right[j][1])\n      j += 1\n\n    return ans\n\n  def _addPoint(self, ans: list[list[int]], x: int, y: int) -> None:\n    if ans and ans[-1][0] == x:\n      ans[-1][1] = y\n      return\n    if ans and ans[-1][1] == y:\n      return\n    ans.append([x, y])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 294, "slug": "flip-game-ii", "solutions": ["class Solution:\n    def canWin(self, currentState: str) -> bool:\n        @cache\n        def dfs(mask):\n            for i in range(n - 1):\n                if (mask & (1 << i)) == 0 or (mask & (1 << (i + 1)) == 0):\n                    continue\n                if dfs(mask ^ (1 << i) ^ (1 << (i + 1))):\n                    continue\n                return True\n            return False\n\n        mask, n = 0, len(currentState)\n        for i, c in enumerate(currentState):\n            if c == '+':\n                mask |= 1 << i\n        return dfs(mask)\n", "class Solution:\n  @functools.lru_cache(None)\n  def canWin(self, currentState: str) -> bool:\n    # If any of currentState[i:i + 2] == \"++\" and your friend can't win after\n    # changing currentState[i:i + 2] to \"--\" (or \"-\"), then you can win.\n    return any(True\n               for i, (a, b) in enumerate(zip(currentState, currentState[1:]))\n               if a == '+' and b == '+' and\n               not self.canWin(currentState[:i] + '-' + currentState[i + 2:]))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 227, "slug": "basic-calculator-ii", "solutions": ["class Solution:\n    def calculate(self, s: str) -> int:\n        v, n = 0, len(s)\n        sign = '+'\n        stk = []\n        for i, c in enumerate(s):\n            if c.isdigit():\n                v = v * 10 + int(c)\n            if i == n - 1 or c in '+-*/':\n                match sign:\n                    case '+':\n                        stk.append(v)\n                    case '-':\n                        stk.append(-v)\n                    case '*':\n                        stk.append(stk.pop() * v)\n                    case '/':\n                        stk.append(int(stk.pop() / v))\n                sign = c\n                v = 0\n        return sum(stk)\n", "class Solution:\n  def calculate(self, s: str) -> int:\n    ans = 0\n    prevNum = 0\n    currNum = 0\n    op = '+'\n\n    for i, c in enumerate(s):\n      if c.isdigit():\n        currNum = currNum * 10 + int(c)\n      if not c.isdigit() and c != ' ' or i == len(s) - 1:\n        if op == '+' or op == '-':\n          ans += prevNum\n          prevNum = currNum if op == '+' else -currNum\n        elif op == '*':\n          prevNum = prevNum * currNum\n        elif op == '/':\n          if prevNum < 0:\n            prevNum = math.ceil(prevNum / currNum)\n          else:\n            prevNum = prevNum // currNum\n        op = c\n        currNum = 0\n\n    return ans + prevNum\n", "class Solution:\n  def calculate(self, s: str) -> int:\n    ans = 0\n    prevNum = 0\n    currNum = 0\n    op = '+'\n\n    for i, c in enumerate(s):\n      if c.isdigit():\n        currNum = currNum * 10 + int(c)\n      if not c.isdigit() and c != ' ' or i == len(s) - 1:\n        if op == '+' or op == '-':\n          ans += prevNum\n          prevNum = (currNum if op == '+' else -currNum)\n        elif op == '*':\n          prevNum *= currNum\n        elif op == '/':\n          prevNum = int(prevNum / currNum)\n        op = c\n        currNum = 0\n\n    return ans + prevNum\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 246, "slug": "strobogrammatic-number", "solutions": ["class Solution:\n    def isStrobogrammatic(self, num: str) -> bool:\n        d = [0, 1, -1, -1, -1, -1, 9, -1, 8, 6]\n        i, j = 0, len(num) - 1\n        while i <= j:\n            a, b = int(num[i]), int(num[j])\n            if d[a] != b:\n                return False\n            i, j = i + 1, j - 1\n        return True\n", "class Solution:\n  def isStrobogrammatic(self, num: str) -> bool:\n    rotated = {'0': '0', '1': '1', '6': '9', '8': '8', '9': '6'}\n    l = 0\n    r = len(num) - 1\n\n    while l <= r:\n      if num[r] not in rotated:\n        return False\n      if num[l] != rotated[num[r]]:\n        return False\n      l += 1\n      r -= 1\n\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 295, "slug": "find-median-from-data-stream", "solutions": ["class MedianFinder:\n\n    def __init__(self):\n        self.minq = []\n        self.maxq = []\n\n    def addNum(self, num: int) -> None:\n        heappush(self.minq, -heappushpop(self.maxq, -num))\n        if len(self.minq) - len(self.maxq) > 1:\n            heappush(self.maxq, -heappop(self.minq))\n\n    def findMedian(self) -> float:\n        if len(self.minq) == len(self.maxq):\n            return (self.minq[0] - self.maxq[0]) / 2\n        return self.minq[0]\n\n\n# Your MedianFinder object will be instantiated and called as such:\n# obj = MedianFinder()\n# obj.addNum(num)\n# param_2 = obj.findMedian()\n", "class MedianFinder:\n  def __init__(self):\n    self.maxHeap = []\n    self.minHeap = []\n\n  def addNum(self, num: int) -> None:\n    if not self.maxHeap or num <= -self.maxHeap[0]:\n      heapq.heappush(self.maxHeap, -num)\n    else:\n      heapq.heappush(self.minHeap, num)\n\n    # Balance the two heaps s.t.\n    # |maxHeap| >= |minHeap| and |maxHeap| - |minHeap| <= 1.\n    if len(self.maxHeap) < len(self.minHeap):\n      heapq.heappush(self.maxHeap, -heapq.heappop(self.minHeap))\n    elif len(self.maxHeap) - len(self.minHeap) > 1:\n      heapq.heappush(self.minHeap, -heapq.heappop(self.maxHeap))\n\n  def findMedian(self) -> float:\n    if len(self.maxHeap) == len(self.minHeap):\n      return (-self.maxHeap[0] + self.minHeap[0]) / 2.0\n    return -self.maxHeap[0]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 280, "slug": "wiggle-sort", "solutions": ["class Solution:\n    def wiggleSort(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        for i in range(1, len(nums)):\n            if (i % 2 == 1 and nums[i] < nums[i - 1]) or (\n                i % 2 == 0 and nums[i] > nums[i - 1]\n            ):\n                nums[i], nums[i - 1] = nums[i - 1], nums[i]\n", "class Solution:\n  def wiggleSort(self, nums: list[int]) -> None:\n    # 1. If i is even, then nums[i] <= nums[i - 1].\n    # 2. If i is odd, then nums[i] >= nums[i - 1].\n    for i in range(1, len(nums)):\n      if (i % 2 == 0 and nums[i] > nums[i - 1] or\n              i % 2 == 1 and nums[i] < nums[i - 1]):\n        nums[i], nums[i - 1] = nums[i - 1], nums[i]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 228, "slug": "summary-ranges", "solutions": ["class Solution:\n    def summaryRanges(self, nums: List[int]) -> List[str]:\n        def f(i: int, j: int) -> str:\n            return str(nums[i]) if i == j else f'{nums[i]}->{nums[j]}'\n\n        i = 0\n        n = len(nums)\n        ans = []\n        while i < n:\n            j = i\n            while j + 1 < n and nums[j + 1] == nums[j] + 1:\n                j += 1\n            ans.append(f(i, j))\n            i = j + 1\n        return ans\n", "class Solution:\n  def summaryRanges(self, nums: list[int]) -> list[str]:\n    ans = []\n\n    i = 0\n    while i < len(nums):\n      begin = nums[i]\n      while i < len(nums) - 1 and nums[i] == nums[i + 1] - 1:\n        i += 1\n      end = nums[i]\n      if begin == end:\n        ans.append(str(begin))\n      else:\n        ans.append(str(begin) + \"->\" + str(end))\n      i += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 233, "slug": "number-of-digit-one", "solutions": ["class Solution:\n    def countDigitOne(self, n: int) -> int:\n        @cache\n        def dfs(i: int, cnt: int, limit: bool) -> int:\n            if i >= len(s):\n                return cnt\n            up = int(s[i]) if limit else 9\n            ans = 0\n            for j in range(up + 1):\n                ans += dfs(i + 1, cnt + (j == 1), limit and j == up)\n            return ans\n\n        s = str(n)\n        return dfs(0, 0, True)\n", "class Solution:\n  def countDigitOne(self, n: int) -> int:\n    ans = 0\n\n    pow10 = 1\n    while pow10 <= n:\n      divisor = pow10 * 10\n      quotient = n // divisor\n      remainder = n % divisor\n      if quotient > 0:\n        ans += quotient * pow10\n      if remainder >= pow10:\n        ans += min(remainder - pow10 + 1, pow10)\n      pow10 *= 10\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 250, "slug": "count-univalue-subtrees", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def countUnivalSubtrees(self, root: Optional[TreeNode]) -> int:\n        def dfs(root):\n            if root is None:\n                return True\n            l, r = dfs(root.left), dfs(root.right)\n            if not l or not r:\n                return False\n            a = root.val if root.left is None else root.left.val\n            b = root.val if root.right is None else root.right.val\n            if a == b == root.val:\n                nonlocal ans\n                ans += 1\n                return True\n            return False\n\n        ans = 0\n        dfs(root)\n        return ans\n", "class Solution:\n  def countUnivalSubtrees(self, root: TreeNode | None) -> int:\n    ans = 0\n\n    def isUnival(root: TreeNode | None, val: int) -> bool:\n      nonlocal ans\n      if not root:\n        return True\n\n      if isUnival(root.left, root.val) & isUnival(root.right, root.val):\n        ans += 1\n        return root.val == val\n\n      return False\n\n    isUnival(root, math.inf)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 298, "slug": "binary-tree-longest-consecutive-sequence", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestConsecutive(self, root: Optional[TreeNode]) -> int:\n        def dfs(root: Optional[TreeNode]) -> int:\n            if root is None:\n                return 0\n            l = dfs(root.left) + 1\n            r = dfs(root.right) + 1\n            if root.left and root.left.val - root.val != 1:\n                l = 1\n            if root.right and root.right.val - root.val != 1:\n                r = 1\n            t = max(l, r)\n            nonlocal ans\n            ans = max(ans, t)\n            return t\n\n        ans = 0\n        dfs(root)\n        return ans\n", "class Solution:\n  def longestConsecutive(self, root: TreeNode | None) -> int:\n    if not root:\n      return 0\n\n    def dfs(root: TreeNode | None, target: int, length: int, maxLength: int) -> int:\n      if not root:\n        return maxLength\n      if root.val == target:\n        length += 1\n        maxLength = max(maxLength, length)\n      else:\n        length = 1\n      return max(dfs(root.left, root.val + 1, length, maxLength),\n                 dfs(root.right, root.val + 1, length, maxLength))\n\n    return dfs(root, root.val, 0, 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 252, "slug": "meeting-rooms", "solutions": ["class Solution:\n    def canAttendMeetings(self, intervals: List[List[int]]) -> bool:\n        intervals.sort()\n        return all(a[1] <= b[0] for a, b in pairwise(intervals))\n", "class Solution:\n  def canAttendMeetings(self, intervals: list[list[int]]) -> bool:\n    intervals.sort()\n\n    for i in range(1, len(intervals)):\n      if intervals[i - 1][1] > intervals[i][0]:\n        return False\n\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 211, "slug": "design-add-and-search-words-data-structure", "solutions": ["class Trie:\n    def __init__(self):\n        self.children = [None] * 26\n        self.is_end = False\n\n\nclass WordDictionary:\n    def __init__(self):\n        self.trie = Trie()\n\n    def addWord(self, word: str) -> None:\n        node = self.trie\n        for c in word:\n            idx = ord(c) - ord('a')\n            if node.children[idx] is None:\n                node.children[idx] = Trie()\n            node = node.children[idx]\n        node.is_end = True\n\n    def search(self, word: str) -> bool:\n        def search(word, node):\n            for i in range(len(word)):\n                c = word[i]\n                idx = ord(c) - ord('a')\n                if c != '.' and node.children[idx] is None:\n                    return False\n                if c == '.':\n                    for child in node.children:\n                        if child is not None and search(word[i + 1 :], child):\n                            return True\n                    return False\n                node = node.children[idx]\n            return node.is_end\n\n        return search(word, self.trie)\n\n\n# Your WordDictionary object will be instantiated and called as such:\n# obj = WordDictionary()\n# obj.addWord(word)\n# param_2 = obj.search(word)\n", "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.isWord = False\n\n\nclass WordDictionary:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def addWord(self, word: str) -> None:\n    node: TrieNode = self.root\n    for c in word:\n      node = node.children.setdefault(c, TrieNode())\n    node.isWord = True\n\n  def search(self, word: str) -> bool:\n    return self._dfs(word, 0, self.root)\n\n  def _dfs(self, word: str, s: int, node: TrieNode) -> bool:\n    if s == len(word):\n      return node.isWord\n    if word[s] != '.':\n      child: TrieNode = node.children.get(word[s], None)\n      return self._dfs(word, s + 1, child) if child else False\n    return any(self._dfs(word, s + 1, child) for child in node.children.values())\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 229, "slug": "majority-element-ii", "solutions": ["class Solution:\n    def majorityElement(self, nums: List[int]) -> List[int]:\n        n1 = n2 = 0\n        m1, m2 = 0, 1\n        for m in nums:\n            if m == m1:\n                n1 += 1\n            elif m == m2:\n                n2 += 1\n            elif n1 == 0:\n                m1, n1 = m, 1\n            elif n2 == 0:\n                m2, n2 = m, 1\n            else:\n                n1, n2 = n1 - 1, n2 - 1\n        return [m for m in [m1, m2] if nums.count(m) > len(nums) // 3]\n", "class Solution:\n  def majorityElement(self, nums: list[int]) -> list[int]:\n    ans1 = 0\n    ans2 = 1\n    count1 = 0\n    count2 = 0\n\n    for num in nums:\n      if num == ans1:\n        count1 += 1\n      elif num == ans2:\n        count2 += 1\n      elif count1 == 0:\n        ans1 = num\n        count1 = 1\n      elif count2 == 0:\n        ans2 = num\n        count2 = 1\n      else:\n        count1 -= 1\n        count2 -= 1\n\n    return [ans for ans in (ans1, ans2) if nums.count(ans) > len(nums) // 3]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 251, "slug": "flatten-2d-vector", "solutions": ["class Vector2D:\n    def __init__(self, vec: List[List[int]]):\n        self.i = 0\n        self.j = 0\n        self.vec = vec\n\n    def next(self) -> int:\n        self.forward()\n        ans = self.vec[self.i][self.j]\n        self.j += 1\n        return ans\n\n    def hasNext(self) -> bool:\n        self.forward()\n        return self.i < len(self.vec)\n\n    def forward(self):\n        while self.i < len(self.vec) and self.j >= len(self.vec[self.i]):\n            self.i += 1\n            self.j = 0\n\n\n# Your Vector2D object will be instantiated and called as such:\n# obj = Vector2D(vec)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()\n", "class Vector2D:\n  def __init__(self, vec: list[list[int]]):\n    self.vec = []\n    self.i = 0\n\n    for arr in vec:\n      self.vec += arr\n\n  def next(self) -> int:\n    ans = self.vec[self.i]\n    self.i += 1\n    return ans\n\n  def hasNext(self) -> bool:\n    return self.i < len(self.vec)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 201, "slug": "bitwise-and-of-numbers-range", "solutions": ["class Solution:\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\n        while left < right:\n            right &= right - 1\n        return right\n", "class Solution:\n  def rangeBitwiseAnd(self, m: int, n: int) -> int:\n    return self.rangeBitwiseAnd(m >> 1, n >> 1) << 1 if m < n else m\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 285, "slug": "inorder-successor-in-bst", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\n\nclass Solution:\n    def inorderSuccessor(self, root: TreeNode, p: TreeNode) -> Optional[TreeNode]:\n        ans = None\n        while root:\n            if root.val > p.val:\n                ans = root\n                root = root.left\n            else:\n                root = root.right\n        return ans\n", "class Solution:\n  def inorderSuccessor(\n      self,\n      root: TreeNode | None,\n      p: TreeNode | None,\n  ) -> TreeNode | None:\n    if not root:\n      return None\n    if root.val <= p.val:\n      return self.inorderSuccessor(root.right, p)\n    return self.inorderSuccessor(root.left, p) or root\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 208, "slug": "implement-trie-prefix-tree", "solutions": ["class Trie:\n    def __init__(self):\n        self.children = [None] * 26\n        self.is_end = False\n\n    def insert(self, word: str) -> None:\n        node = self\n        for c in word:\n            idx = ord(c) - ord('a')\n            if node.children[idx] is None:\n                node.children[idx] = Trie()\n            node = node.children[idx]\n        node.is_end = True\n\n    def search(self, word: str) -> bool:\n        node = self._search_prefix(word)\n        return node is not None and node.is_end\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self._search_prefix(prefix)\n        return node is not None\n\n    def _search_prefix(self, prefix: str):\n        node = self\n        for c in prefix:\n            idx = ord(c) - ord('a')\n            if node.children[idx] is None:\n                return None\n            node = node.children[idx]\n        return node\n\n\n# Your Trie object will be instantiated and called as such:\n# obj = Trie()\n# obj.insert(word)\n# param_2 = obj.search(word)\n# param_3 = obj.startsWith(prefix)\n", "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.isWord = False\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, word: str) -> None:\n    node: TrieNode = self.root\n    for c in word:\n      node = node.children.setdefault(c, TrieNode())\n    node.isWord = True\n\n  def search(self, word: str) -> bool:\n    node: TrieNode = self._find(word)\n    return node and node.isWord\n\n  def startsWith(self, prefix: str) -> bool:\n    return self._find(prefix)\n\n  def _find(self, prefix: str) -> TrieNode | None:\n    node: TrieNode = self.root\n    for c in prefix:\n      if c not in node.children:\n        return None\n      node = node.children[c]\n    return node\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 213, "slug": "house-robber-ii", "solutions": ["class Solution:\n    def rob(self, nums: List[int]) -> int:\n        def _rob(nums):\n            f = g = 0\n            for x in nums:\n                f, g = max(f, g), f + x\n            return max(f, g)\n\n        if len(nums) == 1:\n            return nums[0]\n        return max(_rob(nums[1:]), _rob(nums[:-1]))\n", "class Solution:\n  def rob(self, nums: list[int]) -> int:\n    if not nums:\n      return 0\n    if len(nums) < 2:\n      return nums[0]\n\n    def rob(l: int, r: int) -> int:\n      dp1 = 0\n      dp2 = 0\n\n      for i in range(l, r + 1):\n        temp = dp1\n        dp1 = max(dp1, dp2 + nums[i])\n        dp2 = temp\n\n      return dp1\n\n    return max(rob(0, len(nums) - 2),\n               rob(1, len(nums) - 1))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 202, "slug": "happy-number", "solutions": ["class Solution:\n    def isHappy(self, n: int) -> bool:\n        vis = set()\n        while n != 1 and n not in vis:\n            vis.add(n)\n            x = 0\n            while n:\n                n, v = divmod(n, 10)\n                x += v * v\n            n = x\n        return n == 1\n", "class Solution:\n  def isHappy(self, n: int) -> bool:\n    def squaredSum(n: int) -> bool:\n      summ = 0\n      while n > 0:\n        summ += pow(n % 10, 2)\n        n //= 10\n      return summ\n\n    slow = squaredSum(n)\n    fast = squaredSum(squaredSum(n))\n\n    while slow != fast:\n      slow = squaredSum(slow)\n      fast = squaredSum(squaredSum(fast))\n\n    return slow == 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 290, "slug": "word-pattern", "solutions": ["class Solution:\n    def wordPattern(self, pattern: str, s: str) -> bool:\n        ws = s.split()\n        if len(pattern) != len(ws):\n            return False\n        d1 = {}\n        d2 = {}\n        for a, b in zip(pattern, ws):\n            if (a in d1 and d1[a] != b) or (b in d2 and d2[b] != a):\n                return False\n            d1[a] = b\n            d2[b] = a\n        return True\n", "class Solution:\n  def wordPattern(self, pattern: str, str: str) -> bool:\n    t = str.split()\n    return [*map(pattern.index, pattern)] == [*map(t.index, t)]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 216, "slug": "combination-sum-iii", "solutions": ["class Solution:\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\n        def dfs(i: int, s: int):\n            if s == 0:\n                if len(t) == k:\n                    ans.append(t[:])\n                return\n            if i > 9 or i > s or len(t) >= k:\n                return\n            t.append(i)\n            dfs(i + 1, s - i)\n            t.pop()\n            dfs(i + 1, s)\n\n        ans = []\n        t = []\n        dfs(1, n)\n        return ans\n", "class Solution:\n  def combinationSum3(self, k: int, n: int) -> list[list[int]]:\n    ans = []\n\n    def dfs(k: int, n: int, s: int, path: list[int]) -> None:\n      if k == 0 and n == 0:\n        ans.append(path)\n        return\n      if k == 0 or n < 0:\n        return\n\n      for i in range(s, 10):\n        dfs(k - 1, n - i, i + 1, path + [i])\n\n    dfs(k, n, 1, [])\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 239, "slug": "sliding-window-maximum", "solutions": ["class Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        q = [(-v, i) for i, v in enumerate(nums[: k - 1])]\n        heapify(q)\n        ans = []\n        for i in range(k - 1, len(nums)):\n            heappush(q, (-nums[i], i))\n            while q[0][1] <= i - k:\n                heappop(q)\n            ans.append(-q[0][0])\n        return ans\n", "class Solution:\n  def maxSlidingWindow(self, nums: list[int], k: int) -> list[int]:\n    ans = []\n    maxQ = collections.deque()\n\n    for i, num in enumerate(nums):\n      while maxQ and maxQ[-1] < num:\n        maxQ.pop()\n      maxQ.append(num)\n      if i >= k and nums[i - k] == maxQ[0]:  # out-of-bounds\n        maxQ.popleft()\n      if i >= k - 1:\n        ans.append(maxQ[0])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 249, "slug": "group-shifted-strings", "solutions": ["class Solution:\n    def groupStrings(self, strings: List[str]) -> List[List[str]]:\n        g = defaultdict(list)\n        for s in strings:\n            diff = ord(s[0]) - ord(\"a\")\n            t = []\n            for c in s:\n                c = ord(c) - diff\n                if c < ord(\"a\"):\n                    c += 26\n                t.append(chr(c))\n            g[\"\".join(t)].append(s)\n        return list(g.values())\n", "class Solution:\n  def groupStrings(self, strings: list[str]) -> list[list[str]]:\n    keyToStrings = collections.defaultdict(list)\n\n    def getKey(s: str) -> str:\n      \"\"\"\n      Returns the key of 's' by pairwise calculation of differences.\n      e.g. getKey(\"abc\") -> \"1,1\" because diff(a, b) = 1 and diff(b, c) = 1.\n      \"\"\"\n      diffs = []\n\n      for i in range(1, len(s)):\n        diff = (ord(s[i]) - ord(s[i - 1]) + 26) % 26\n        diffs.append(str(diff))\n\n      return ','.join(diffs)\n\n    for s in strings:\n      keyToStrings[getKey(s)].append(s)\n\n    return keyToStrings.values()\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 296, "slug": "best-meeting-point", "solutions": ["class Solution:\n    def minTotalDistance(self, grid: List[List[int]]) -> int:\n        def f(arr, x):\n            return sum(abs(v - x) for v in arr)\n\n        rows, cols = [], []\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                if v:\n                    rows.append(i)\n                    cols.append(j)\n        cols.sort()\n        i = rows[len(rows) >> 1]\n        j = cols[len(cols) >> 1]\n        return f(rows, i) + f(cols, j)\n", "class Solution:\n  def minTotalDistance(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    # i indices s.t. grid[i][j] == 1\n    I = [i for i in range(m) for j in range(n) if grid[i][j]]\n    # j indices s.t. grid[i][j] == 1\n    J = [j for j in range(n) for i in range(m) if grid[i][j]]\n\n    def minTotalDistance(grid: list[int]) -> int:\n      summ = 0\n      i = 0\n      j = len(grid) - 1\n      while i < j:\n        summ += grid[j] - grid[i]\n        i += 1\n        j -= 1\n      return summ\n\n    # sum(i - median(I)) + sum(j - median(J))\n    return minTotalDistance(I) + minTotalDistance(J)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 254, "slug": "factor-combinations", "solutions": ["class Solution:\n    def getFactors(self, n: int) -> List[List[int]]:\n        def dfs(n, i):\n            if t:\n                ans.append(t + [n])\n            j = i\n            while j * j <= n:\n                if n % j == 0:\n                    t.append(j)\n                    dfs(n // j, j)\n                    t.pop()\n                j += 1\n\n        t = []\n        ans = []\n        dfs(n, 2)\n        return ans\n", "class Solution:\n  def getFactors(self, n: int) -> list[list[int]]:\n    ans = []\n\n    def dfs(n: int, s: int, path: list[int]) -> None:\n      if n <= 1:\n        if len(path) > 1:\n          ans.append(path.copy())\n        return\n\n      for i in range(s, n + 1):\n        if n % i == 0:\n          path.append(i)\n          dfs(n // i, i, path)\n          path.pop()\n\n    dfs(n, 2, [])  # The minimum factor is 2.\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 263, "slug": "ugly-number", "solutions": ["class Solution:\n    def isUgly(self, n: int) -> bool:\n        if n < 1:\n            return False\n        for x in [2, 3, 5]:\n            while n % x == 0:\n                n //= x\n        return n == 1\n", "class Solution:\n  def isUgly(self, n: int) -> bool:\n    if n == 0:\n      return False\n\n    for prime in 2, 3, 5:\n      while n % prime == 0:\n        n //= prime\n\n    return n == 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 220, "slug": "contains-duplicate-iii", "solutions": ["class Solution:\n    def containsNearbyAlmostDuplicate(\n        self, nums: List[int], indexDiff: int, valueDiff: int\n    ) -> bool:\n        s = SortedSet()\n        for i, v in enumerate(nums):\n            j = s.bisect_left(v - valueDiff)\n            if j < len(s) and s[j] <= v + valueDiff:\n                return True\n            s.add(v)\n            if i >= indexDiff:\n                s.remove(nums[i - indexDiff])\n        return False\n", "class Solution:\n  def containsNearbyAlmostDuplicate(\n      self,\n      nums: list[int],\n      indexDiff: int,\n      valueDiff: int,\n  ) -> bool:\n    if not nums or indexDiff <= 0 or valueDiff < 0:\n      return False\n\n    mn = min(nums)\n    diff = valueDiff + 1  # In case that `valueDiff` equals 0.\n    bucket = {}\n\n    def getKey(num: int) -> int:\n      return (num - mn) // diff\n\n    for i, num in enumerate(nums):\n      key = getKey(num)\n      if key in bucket:  # the current bucket\n        return True\n      # the left adjacent bucket\n      if key - 1 in bucket and num - bucket[key - 1] < diff:\n        return True\n      # the right adjacent bucket\n      if key + 1 in bucket and bucket[key + 1] - num < diff:\n        return True\n      bucket[key] = num\n      if i >= indexDiff:\n        del bucket[getKey(nums[i - indexDiff])]\n\n    return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 262, "slug": "trips-and-users", "solutions": ["import pandas as pd\n\n\ndef trips_and_users(trips: pd.DataFrame, users: pd.DataFrame) -> pd.DataFrame:\n    # 1) temporal filtering\n    trips = trips[trips[\"request_at\"].between(\"2013-10-01\", \"2013-10-03\")].rename(\n        columns={\"request_at\": \"Day\"}\n    )\n\n    # 2) filtering based not banned\n    # 2.1) mappning the column 'banned' to `client_id` and `driver_id`\n    df_client = (\n        pd.merge(trips, users, left_on=\"client_id\", right_on=\"users_id\", how=\"left\")\n        .drop([\"users_id\", \"role\"], axis=1)\n        .rename(columns={\"banned\": \"banned_client\"})\n    )\n    df_driver = (\n        pd.merge(trips, users, left_on=\"driver_id\", right_on=\"users_id\", how=\"left\")\n        .drop([\"users_id\", \"role\"], axis=1)\n        .rename(columns={\"banned\": \"banned_driver\"})\n    )\n    df = pd.merge(\n        df_client,\n        df_driver,\n        left_on=[\"id\", \"driver_id\", \"client_id\", \"city_id\", \"status\", \"Day\"],\n        right_on=[\"id\", \"driver_id\", \"client_id\", \"city_id\", \"status\", \"Day\"],\n        how=\"left\",\n    )\n    # 2.2) filtering based on not banned\n    df = df[(df[\"banned_client\"] == \"No\") & (df[\"banned_driver\"] == \"No\")]\n\n    # 3) counting the cancelled and total trips per day\n    df[\"status_cancelled\"] = df[\"status\"].str.contains(\"cancelled\")\n    df = df[[\"Day\", \"status_cancelled\"]]\n    df = df.groupby(\"Day\").agg(\n        {\"status_cancelled\": [(\"total_cancelled\", \"sum\"), (\"total\", \"count\")]}\n    )\n    df.columns = df.columns.droplevel()\n    df = df.reset_index()\n\n    # 4) calculating the ratio\n    df[\"Cancellation Rate\"] = (df[\"total_cancelled\"] / df[\"total\"]).round(2)\n    return df[[\"Day\", \"Cancellation Rate\"]]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 288, "slug": "unique-word-abbreviation", "solutions": ["class ValidWordAbbr:\n    def __init__(self, dictionary: List[str]):\n        self.d = defaultdict(set)\n        for s in dictionary:\n            self.d[self.abbr(s)].add(s)\n\n    def isUnique(self, word: str) -> bool:\n        s = self.abbr(word)\n        return s not in self.d or all(word == t for t in self.d[s])\n\n    def abbr(self, s: str) -> str:\n        return s if len(s) < 3 else s[0] + str(len(s) - 2) + s[-1]\n\n\n# Your ValidWordAbbr object will be instantiated and called as such:\n# obj = ValidWordAbbr(dictionary)\n# param_1 = obj.isUnique(word)\n", "class ValidWordAbbr:\n  def __init__(self, dictionary: list[str]):\n    self.dict = set(dictionary)\n    # T := unique, F := not unique\n    self.abbrUnique = {}\n\n    for word in self.dict:\n      abbr = self._getAbbr(word)\n      self.abbrUnique[abbr] = abbr not in self.abbrUnique\n\n  def isUnique(self, word: str) -> bool:\n    abbr = self._getAbbr(word)\n    return abbr not in self.abbrUnique or self.abbrUnique[abbr] and word in self.dict\n\n  def _getAbbr(self, s: str) -> str:\n    n = len(s)\n    if n <= 2:\n      return s\n    return s[0] + str(n - 2) + s[-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 273, "slug": "integer-to-english-words", "solutions": ["class Solution:\n    def numberToWords(self, num: int) -> str:\n        if num == 0:\n            return 'Zero'\n\n        lt20 = [\n            '',\n            'One',\n            'Two',\n            'Three',\n            'Four',\n            'Five',\n            'Six',\n            'Seven',\n            'Eight',\n            'Nine',\n            'Ten',\n            'Eleven',\n            'Twelve',\n            'Thirteen',\n            'Fourteen',\n            'Fifteen',\n            'Sixteen',\n            'Seventeen',\n            'Eighteen',\n            'Nineteen',\n        ]\n        tens = [\n            '',\n            'Ten',\n            'Twenty',\n            'Thirty',\n            'Forty',\n            'Fifty',\n            'Sixty',\n            'Seventy',\n            'Eighty',\n            'Ninety',\n        ]\n        thousands = ['Billion', 'Million', 'Thousand', '']\n\n        def transfer(num):\n            if num == 0:\n                return ''\n            if num < 20:\n                return lt20[num] + ' '\n            if num < 100:\n                return tens[num // 10] + ' ' + transfer(num % 10)\n            return lt20[num // 100] + ' Hundred ' + transfer(num % 100)\n\n        res = []\n        i, j = 1000000000, 0\n        while i > 0:\n            if num // i != 0:\n                res.append(transfer(num // i))\n                res.append(thousands[j])\n                res.append(' ')\n                num %= i\n            j += 1\n            i //= 1000\n        return ''.join(res).strip()\n", "class Solution:\n  def numberToWords(self, num: int) -> str:\n    if num == 0:\n      return 'Zero'\n\n    belowTwenty = ['',        'One',       'Two',      'Three',\n                   'Four',    'Five',      'Six',      'Seven',\n                   'Eight',   'Nine',      'Ten',      'Eleven',\n                   'Twelve',  'Thirteen',  'Fourteen', 'Fifteen',\n                   'Sixteen', 'Seventeen', 'Eighteen', 'Nineteen']\n    tens = ['',      'Ten',   'Twenty',  'Thirty', 'Forty',\n            'Fifty', 'Sixty', 'Seventy', 'Eighty', 'Ninety']\n\n    def helper(num: int) -> str:\n      if num < 20:\n        s = belowTwenty[num]\n      elif num < 100:\n        s = tens[num // 10] + ' ' + belowTwenty[num % 10]\n      elif num < 1000:\n        s = helper(num // 100) + ' Hundred ' + helper(num % 100)\n      elif num < 1000000:\n        s = helper(num // 1000) + ' Thousand ' + helper(num % 1000)\n      elif num < 1000000000:\n        s = helper(num // 1000000) + ' Million ' + helper(num % 1000000)\n      else:\n        s = helper(num // 1000000000) + ' Billion ' + helper(num % 1000000000)\n      return s.strip()\n\n    return helper(num)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 248, "slug": "strobogrammatic-number-iii", "solutions": ["class Solution:\n    def strobogrammaticInRange(self, low: str, high: str) -> int:\n        def dfs(u):\n            if u == 0:\n                return ['']\n            if u == 1:\n                return ['0', '1', '8']\n            ans = []\n            for v in dfs(u - 2):\n                for l, r in ('11', '88', '69', '96'):\n                    ans.append(l + v + r)\n                if u != n:\n                    ans.append('0' + v + '0')\n            return ans\n\n        a, b = len(low), len(high)\n        low, high = int(low), int(high)\n        ans = 0\n        for n in range(a, b + 1):\n            for s in dfs(n):\n                if low <= int(s) <= high:\n                    ans += 1\n        return ans\n", "class Solution:\n  def strobogrammaticInRange(self, low: str, high: str) -> int:\n    pairs = [['0', '0'], ['1', '1'], ['6', '9'], ['8', '8'], ['9', '6']]\n    ans = 0\n\n    def dfs(s: list[str], l: int, r: int) -> None:\n      nonlocal ans\n      if l > r:\n        if len(s) == len(low) and ''.join(s) < low:\n          return\n        if len(s) == len(high) and ''.join(s) > high:\n          return\n        ans += 1\n        return\n\n      for leftDigit, rightDigit in pairs:\n        if l == r and leftDigit != rightDigit:\n          continue\n        s[l] = leftDigit\n        s[r] = rightDigit\n        if len(s) > 1 and s[0] == '0':\n          continue\n        dfs(s, l + 1, r - 1)\n\n    for n in range(len(low), len(high) + 1):\n      dfs([' '] * n, 0, n - 1)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 242, "slug": "valid-anagram", "solutions": ["class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        if len(s) != len(t):\n            return False\n        cnt = Counter(s)\n        for c in t:\n            cnt[c] -= 1\n            if cnt[c] < 0:\n                return False\n        return True\n", "class Solution:\n  def isAnagram(self, s: str, t: str) -> bool:\n    if len(s) != len(t):\n      return False\n\n    count = collections.Counter(s)\n    count.subtract(collections.Counter(t))\n    return all(freq == 0 for freq in count.values())\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 223, "slug": "rectangle-area", "solutions": ["class Solution:\n    def computeArea(\n        self,\n        ax1: int,\n        ay1: int,\n        ax2: int,\n        ay2: int,\n        bx1: int,\n        by1: int,\n        bx2: int,\n        by2: int,\n    ) -> int:\n        a = (ax2 - ax1) * (ay2 - ay1)\n        b = (bx2 - bx1) * (by2 - by1)\n        width = min(ax2, bx2) - max(ax1, bx1)\n        height = min(ay2, by2) - max(ay1, by1)\n        return a + b - max(height, 0) * max(width, 0)\n", "class Solution:\n  def computeArea(self,\n                  A: int, B: int, C: int, D: int,\n                  E: int, F: int, G: int, H: int) -> int:\n    x = min(C, G) - max(A, E) if max(A, E) < min(C, G) else 0\n    y = min(D, H) - max(B, F) if max(B, F) < min(D, H) else 0\n    return (C - A) * (D - B) + (G - E) * (H - F) - x * y\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 236, "slug": "lowest-common-ancestor-of-a-binary-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\n\nclass Solution:\n    def lowestCommonAncestor(\n        self, root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n    ) -> \"TreeNode\":\n        if root in (None, p, q):\n            return root\n        left = self.lowestCommonAncestor(root.left, p, q)\n        right = self.lowestCommonAncestor(root.right, p, q)\n        return root if left and right else (left or right)\n", "class Solution:\n  def lowestCommonAncestor(\n      self,\n      root: 'TreeNode',\n      p: 'TreeNode',\n      q: 'TreeNode',\n  ) -> 'TreeNode':\n    if not root or root == p or root == q:\n      return root\n    left = self.lowestCommonAncestor(root.left, p, q)\n    right = self.lowestCommonAncestor(root.right, p, q)\n    if left and right:\n      return root\n    return left or right\n", "class Solution:\n  def lowestCommonAncestor(\n      self,\n      root: TreeNode | None,\n      p: TreeNode | None,\n      q: TreeNode | None,\n  ) -> TreeNode | None:\n    q_ = collections.deque([root])\n    parent = {root: None}\n    ancestors = set()  # p's ancestors\n\n    # Iterate until we find both p and q.\n    while p not in parent or q not in parent:\n      root = q_.popleft()\n      if root.left:\n        parent[root.left] = root\n        q_.append(root.left)\n      if root.right:\n        parent[root.right] = root\n        q_.append(root.right)\n\n    # Insert all the p's ancestors.\n    while p:\n      ancestors.add(p)\n      p = parent[p]  # `p` becomes None in the end.\n\n    # Go up from q until we meet any of p's ancestors.\n    while q not in ancestors:\n      q = parent[q]\n\n    return q\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 260, "slug": "single-number-iii", "solutions": ["class Solution:\n    def singleNumber(self, nums: List[int]) -> List[int]:\n        xs = reduce(xor, nums)\n        a = 0\n        lb = xs & -xs\n        for x in nums:\n            if x & lb:\n                a ^= x\n        b = xs ^ a\n        return [a, b]\n", "class Solution:\n  def singleNumber(self, nums: list[int]) -> list[int]:\n    xors = functools.reduce(operator.xor, nums)\n    lowbit = xors & -xors\n    ans = [0, 0]\n\n    # Seperate `nums` into two groups by `lowbit`.\n    for num in nums:\n      if num & lowbit:\n        ans[0] ^= num\n      else:\n        ans[1] ^= num\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 284, "slug": "peeking-iterator", "solutions": ["# Below is the interface for Iterator, which is already defined for you.\n#\n# class Iterator:\n#     def __init__(self, nums):\n#         \"\"\"\n#         Initializes an iterator object to the beginning of a list.\n#         :type nums: List[int]\n#         \"\"\"\n#\n#     def hasNext(self):\n#         \"\"\"\n#         Returns true if the iteration has more elements.\n#         :rtype: bool\n#         \"\"\"\n#\n#     def next(self):\n#         \"\"\"\n#         Returns the next element in the iteration.\n#         :rtype: int\n#         \"\"\"\n\n\nclass PeekingIterator:\n    def __init__(self, iterator):\n        \"\"\"\n        Initialize your data structure here.\n        :type iterator: Iterator\n        \"\"\"\n        self.iterator = iterator\n        self.has_peeked = False\n        self.peeked_element = None\n\n    def peek(self):\n        \"\"\"\n        Returns the next element in the iteration without advancing the iterator.\n        :rtype: int\n        \"\"\"\n        if not self.has_peeked:\n            self.peeked_element = self.iterator.next()\n            self.has_peeked = True\n        return self.peeked_element\n\n    def next(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if not self.has_peeked:\n            return self.iterator.next()\n        result = self.peeked_element\n        self.has_peeked = False\n        self.peeked_element = None\n        return result\n\n    def hasNext(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        return self.has_peeked or self.iterator.hasNext()\n\n\n# Your PeekingIterator object will be instantiated and called as such:\n# iter = PeekingIterator(Iterator(nums))\n# while iter.hasNext():\n#     val = iter.peek()   # Get the next element but not advance the iterator.\n#     iter.next()         # Should return the same value as [val].\n", "class PeekingIterator:\n  def __init__(self, iterator: Iterator):\n    self.iterator = iterator\n    self.buffer = self.iterator.next() if self.iterator.hasNext() else None\n\n  def peek(self) -> int:\n    \"\"\"\n    Returns the next element in the iteration without advancing the iterator.\n    \"\"\"\n    return self.buffer\n\n  def next(self) -> int:\n    next = self.buffer\n    self.buffer = self.iterator.next() if self.iterator.hasNext() else None\n    return next\n\n  def hasNext(self) -> bool:\n    return self.buffer is not None\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 259, "slug": "3sum-smaller", "solutions": ["class Solution:\n    def threeSumSmaller(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        ans, n = 0, len(nums)\n        for i in range(n - 2):\n            j, k = i + 1, n - 1\n            while j < k:\n                x = nums[i] + nums[j] + nums[k]\n                if x < target:\n                    ans += k - j\n                    j += 1\n                else:\n                    k -= 1\n        return ans\n", "class Solution:\n  def threeSumSmaller(self, nums: list[int], target: int) -> int:\n    if len(nums) < 3:\n      return 0\n\n    ans = 0\n\n    nums.sort()\n\n    for i in range(len(nums) - 2):\n      l = i + 1\n      r = len(nums) - 1\n      while l < r:\n        if nums[i] + nums[l] + nums[r] < target:\n          # (nums[i], nums[l], nums[r])\n          # (nums[i], nums[l], nums[r - 1])\n          # ...,\n          # (nums[i], nums[l], nums[l + 1])\n          ans += r - l\n          l += 1\n        else:\n          r -= 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 232, "slug": "implement-queue-using-stacks", "solutions": ["class MyQueue:\n    def __init__(self):\n        self.stk1 = []\n        self.stk2 = []\n\n    def push(self, x: int) -> None:\n        self.stk1.append(x)\n\n    def pop(self) -> int:\n        self.move()\n        return self.stk2.pop()\n\n    def peek(self) -> int:\n        self.move()\n        return self.stk2[-1]\n\n    def empty(self) -> bool:\n        return not self.stk1 and not self.stk2\n\n    def move(self):\n        if not self.stk2:\n            while self.stk1:\n                self.stk2.append(self.stk1.pop())\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n", "class MyQueue:\n  def __init__(self):\n    self.input = []\n    self.output = []\n\n  def push(self, x: int) -> None:\n    self.input.append(x)\n\n  def pop(self) -> int:\n    self.peek()\n    return self.output.pop()\n\n  def peek(self) -> int:\n    if not self.output:\n      while self.input:\n        self.output.append(self.input.pop())\n    return self.output[-1]\n\n  def empty(self) -> bool:\n    return not self.input and not self.output\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 215, "slug": "kth-largest-element-in-an-array", "solutions": ["class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        def quick_sort(l: int, r: int) -> int:\n            if l == r:\n                return nums[l]\n            i, j = l - 1, r + 1\n            x = nums[(l + r) >> 1]\n            while i < j:\n                while 1:\n                    i += 1\n                    if nums[i] >= x:\n                        break\n                while 1:\n                    j -= 1\n                    if nums[j] <= x:\n                        break\n                if i < j:\n                    nums[i], nums[j] = nums[j], nums[i]\n            if j < k:\n                return quick_sort(j + 1, r)\n            return quick_sort(l, j)\n\n        n = len(nums)\n        k = n - k\n        return quick_sort(0, n - 1)\n", "class Solution:\n  def findKthLargest(self, nums: list[int], k: int) -> int:\n    def quickSelect(l: int, r: int, k: int) -> int:\n      randIndex = random.randint(0, r - l) + l\n      nums[randIndex], nums[r] = nums[r], nums[randIndex]\n      pivot = nums[r]\n\n      nextSwapped = l\n      for i in range(l, r):\n        if nums[i] >= pivot:\n          nums[nextSwapped], nums[i] = nums[i], nums[nextSwapped]\n          nextSwapped += 1\n      nums[nextSwapped], nums[r] = nums[r], nums[nextSwapped]\n\n      count = nextSwapped - l + 1  # Number of nums >= pivot\n      if count == k:\n        return nums[nextSwapped]\n      if count > k:\n        return quickSelect(l, nextSwapped - 1, k)\n      return quickSelect(nextSwapped + 1, r, k - count)\n\n    return quickSelect(0, len(nums) - 1, k)\n", "class Solution:\n  def findKthLargest(self, nums: list[int], k: int) -> int:\n    def quickSelect(l: int, r: int, k: int) -> int:\n      pivot = nums[r]\n\n      nextSwapped = l\n      for i in range(l, r):\n        if nums[i] >= pivot:\n          nums[nextSwapped], nums[i] = nums[i], nums[nextSwapped]\n          nextSwapped += 1\n      nums[nextSwapped], nums[r] = nums[r], nums[nextSwapped]\n\n      count = nextSwapped - l + 1  # Number of nums >= pivot\n      if count == k:\n        return nums[nextSwapped]\n      if count > k:\n        return quickSelect(l, nextSwapped - 1, k)\n      return quickSelect(nextSwapped + 1, r, k - count)\n\n    return quickSelect(0, len(nums) - 1, k)\n", "class Solution:\n  def findKthLargest(self, nums: list[int], k: int) -> int:\n    minHeap = []\n\n    for num in nums:\n      heapq.heappush(minHeap, num)\n      if len(minHeap) > k:\n        heapq.heappop(minHeap)\n\n    return minHeap[0]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 255, "slug": "verify-preorder-sequence-in-binary-search-tree", "solutions": ["class Solution:\n    def verifyPreorder(self, preorder: List[int]) -> bool:\n        stk = []\n        last = -inf\n        for x in preorder:\n            if x < last:\n                return False\n            while stk and stk[-1] < x:\n                last = stk.pop()\n            stk.append(x)\n        return True\n", "class Solution:\n  def verifyPreorder(self, preorder: list[int]) -> list[int]:\n    low = -math.inf\n    stack = []\n\n    for p in preorder:\n      if p < low:\n        return False\n      while stack and stack[-1] < p:\n        low = stack.pop()\n      stack.append(p)\n\n    return True\n", "class Solution:\n  def verifyPreorder(self, preorder: list[int]) -> bool:\n    i = 0\n\n    def dfs(min: int, max: int) -> None:\n      nonlocal i\n      if i == len(preorder):\n        return\n      if preorder[i] < min or preorder[i] > max:\n        return\n\n      val = preorder[i]\n      i += 1\n      dfs(min, val)\n      dfs(val, max)\n\n    dfs(-math.inf, math.inf)\n    return i == len(preorder)\n", "class Solution:\n  def verifyPreorder(self, preorder: list[int]) -> bool:\n    low = -math.inf\n    i = -1\n\n    for p in preorder:\n      if p < low:\n        return False\n      while i >= 0 and preorder[i] < p:\n        low = preorder[i]\n        i -= 1\n      i += 1\n      preorder[i] = p\n\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 247, "slug": "strobogrammatic-number-ii", "solutions": ["class Solution:\n    def findStrobogrammatic(self, n: int) -> List[str]:\n        def dfs(u):\n            if u == 0:\n                return ['']\n            if u == 1:\n                return ['0', '1', '8']\n            ans = []\n            for v in dfs(u - 2):\n                for l, r in ('11', '88', '69', '96'):\n                    ans.append(l + v + r)\n                if u != n:\n                    ans.append('0' + v + '0')\n            return ans\n\n        return dfs(n)\n", "class Solution:\n  def findStrobogrammatic(self, n: int) -> list[str]:\n    def helper(n: int, k: int) -> list[str]:\n      if n == 0:\n        return ['']\n      if n == 1:\n        return ['0', '1', '8']\n\n      ans = []\n\n      for inner in helper(n - 2, k):\n        if n < k:\n          ans.append('0' + inner + '0')\n        ans.append('1' + inner + '1')\n        ans.append('6' + inner + '9')\n        ans.append('8' + inner + '8')\n        ans.append('9' + inner + '6')\n\n      return ans\n\n    return helper(n, n)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 287, "slug": "find-the-duplicate-number", "solutions": ["class Solution:\n    def findDuplicate(self, nums: List[int]) -> int:\n        def f(x: int) -> bool:\n            return sum(v <= x for v in nums) > x\n\n        return bisect_left(range(len(nums)), True, key=f)\n", "class Solution:\n  def findDuplicate(self, nums: list[int]) -> int:\n    slow = nums[nums[0]]\n    fast = nums[nums[nums[0]]]\n\n    while slow != fast:\n      slow = nums[slow]\n      fast = nums[nums[fast]]\n\n    slow = nums[0]\n\n    while slow != fast:\n      slow = nums[slow]\n      fast = nums[fast]\n\n    return slow\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 235, "slug": "lowest-common-ancestor-of-a-binary-search-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\n\nclass Solution:\n    def lowestCommonAncestor(\n        self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode'\n    ) -> 'TreeNode':\n        while 1:\n            if root.val < min(p.val, q.val):\n                root = root.right\n            elif root.val > max(p.val, q.val):\n                root = root.left\n            else:\n                return root\n", "class Solution:\n  def lowestCommonAncestor(\n      self,\n      root: 'TreeNode',\n      p: 'TreeNode',\n      q: 'TreeNode',\n  ) -> 'TreeNode':\n    if root.val > max(p.val, q.val):\n      return self.lowestCommonAncestor(root.left, p, q)\n    if root.val < min(p.val, q.val):\n      return self.lowestCommonAncestor(root.right, p, q)\n    return root\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 275, "slug": "h-index-ii", "solutions": ["class Solution:\n    def hIndex(self, citations: List[int]) -> int:\n        n = len(citations)\n        left, right = 0, n\n        while left < right:\n            mid = (left + right + 1) >> 1\n            if citations[n - mid] >= mid:\n                left = mid\n            else:\n                right = mid - 1\n        return left\n", "class Solution:\n  def hIndex(self, citations: list[int]) -> int:\n    n = len(citations)\n    return n - bisect.bisect_left(range(n), n,\n                                  key=lambda m: citations[m] + m)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 265, "slug": "paint-house-ii", "solutions": ["class Solution:\n    def minCostII(self, costs: List[List[int]]) -> int:\n        n, k = len(costs), len(costs[0])\n        f = costs[0][:]\n        for i in range(1, n):\n            g = costs[i][:]\n            for j in range(k):\n                t = min(f[h] for h in range(k) if h != j)\n                g[j] += t\n            f = g\n        return min(f)\n", "class Solution:\n  def minCostII(self, costs: list[list[int]]) -> int:\n    prevIndex = -1  # the previous minimum index\n    prevMin1 = 0  # the minimum cost so far\n    prevMin2 = 0  # the second minimum cost so far\n\n    for cost in costs:  # O(n)\n      # the painted index that will achieve the minimum cost after painting the\n      # current house\n      index = -1\n      # the minimum cost after painting the current house\n      min1 = math.inf\n      # the second minimum cost after painting the current house\n      min2 = math.inf\n      for i, cst in enumerate(cost):   # O(k)\n        theCost = cst + (prevMin2 if i == prevIndex else prevMin1)\n        if theCost < min1:\n          index = i\n          min2 = min1\n          min1 = theCost\n        elif theCost < min2:  # min1 <= theCost < min2\n          min2 = theCost\n\n      prevIndex = index\n      prevMin1 = min1\n      prevMin2 = min2\n\n    return prevMin1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 253, "slug": "meeting-rooms-ii", "solutions": ["class Solution:\n    def minMeetingRooms(self, intervals: List[List[int]]) -> int:\n        m = max(e[1] for e in intervals)\n        d = [0] * (m + 1)\n        for l, r in intervals:\n            d[l] += 1\n            d[r] -= 1\n        ans = s = 0\n        for v in d:\n            s += v\n            ans = max(ans, s)\n        return ans\n", "class Solution:\n  def minMeetingRooms(self, intervals: list[list[int]]) -> int:\n    n = len(intervals)\n    ans = 0\n    starts = []\n    ends = []\n\n    for start, end in intervals:\n      starts.append(start)\n      ends.append(end)\n\n    starts.sort()\n    ends.sort()\n\n    j = 0\n    for i in range(n):\n      if starts[i] < ends[j]:\n        ans += 1\n      else:\n        j += 1\n\n    return ans\n", "class Solution:\n  def minMeetingRooms(self, intervals: list[list[int]]) -> int:\n    minHeap = []  # Store the end times of each room.\n\n    for start, end in sorted(intervals):\n      # There's no overlap, so we can reuse the same room.\n      if minHeap and start >= minHeap[0]:\n        heapq.heappop(minHeap)\n      heapq.heappush(minHeap, end)\n\n    return len(minHeap)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 271, "slug": "encode-and-decode-strings", "solutions": ["class Codec:\n    def encode(self, strs: List[str]) -> str:\n        \"\"\"Encodes a list of strings to a single string.\"\"\"\n        ans = []\n        for s in strs:\n            ans.append(\"{:4}\".format(len(s)) + s)\n        return \"\".join(ans)\n\n    def decode(self, s: str) -> List[str]:\n        \"\"\"Decodes a single string to a list of strings.\"\"\"\n        ans = []\n        i, n = 0, len(s)\n        while i < n:\n            size = int(s[i : i + 4])\n            i += 4\n            ans.append(s[i : i + size])\n            i += size\n        return ans\n\n\n# Your Codec object will be instantiated and called as such:\n# codec = Codec()\n# codec.decode(codec.encode(strs))\n", "class Codec:\n  def encode(self, strs: list[str]) -> str:\n    \"\"\"Encodes a list of strings to a single string.\"\"\"\n    return ''.join(str(len(s)) + '/' + s for s in strs)\n\n  def decode(self, s: str) -> list[str]:\n    \"\"\"Decodes a single string to a list of strings.\"\"\"\n    decoded = []\n\n    i = 0\n    while i < len(s):\n      slash = s.find('/', i)\n      length = int(s[i:slash])\n      i = slash + length + 1\n      decoded.append(s[slash + 1:i])\n\n    return decoded\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 219, "slug": "contains-duplicate-ii", "solutions": ["class Solution:\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\n        d = {}\n        for i, x in enumerate(nums):\n            if x in d and i - d[x] <= k:\n                return True\n            d[x] = i\n        return False\n", "class Solution:\n  def containsNearbyDuplicate(self, nums: list[int], k: int) -> bool:\n    seen = set()\n\n    for i, num in enumerate(nums):\n      if i > k:\n        seen.remove(nums[i - k - 1])\n      if num in seen:\n        return True\n      seen.add(num)\n\n    return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 278, "slug": "first-bad-version", "solutions": ["# The isBadVersion API is already defined for you.\n# def isBadVersion(version: int) -> bool:\n\n\nclass Solution:\n    def firstBadVersion(self, n: int) -> int:\n        l, r = 1, n\n        while l < r:\n            mid = (l + r) >> 1\n            if isBadVersion(mid):\n                r = mid\n            else:\n                l = mid + 1\n        return l\n", "class Solution:\n  def firstBadVersion(self, n: int) -> int:\n    l = 1\n    r = n\n\n    while l < r:\n      m = (l + r) >> 1\n      if isBadVersion(m):\n        r = m\n      else:\n        l = m + 1\n\n    return l\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 299, "slug": "bulls-and-cows", "solutions": ["class Solution:\n    def getHint(self, secret: str, guess: str) -> str:\n        cnt1, cnt2 = Counter(), Counter()\n        x = 0\n        for a, b in zip(secret, guess):\n            if a == b:\n                x += 1\n            else:\n                cnt1[a] += 1\n                cnt2[b] += 1\n        y = sum(min(cnt1[c], cnt2[c]) for c in cnt1)\n        return f\"{x}A{y}B\"\n", "class Solution:\n  def getHint(self, secret: str, guess: str) -> str:\n    bulls = sum(map(operator.eq, secret, guess))\n    bovine = sum(min(secret.count(x), guess.count(x)) for x in set(guess))\n    return '%dA%dB' % (bulls, bovine - bulls)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 264, "slug": "ugly-number-ii", "solutions": ["class Solution:\n    def nthUglyNumber(self, n: int) -> int:\n        h = [1]\n        vis = {1}\n        ans = 1\n        for _ in range(n):\n            ans = heappop(h)\n            for v in [2, 3, 5]:\n                nxt = ans * v\n                if nxt not in vis:\n                    vis.add(nxt)\n                    heappush(h, nxt)\n        return ans\n", "class Solution:\n  def nthUglyNumber(self, n: int) -> int:\n    nums = [1]\n    i2 = 0\n    i3 = 0\n    i5 = 0\n\n    while len(nums) < n:\n      next2 = nums[i2] * 2\n      next3 = nums[i3] * 3\n      next5 = nums[i5] * 5\n      next = min(next2, next3, next5)\n      if next == next2:\n        i2 += 1\n      if next == next3:\n        i3 += 1\n      if next == next5:\n        i5 += 1\n      nums.append(next)\n\n    return nums[-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 272, "slug": "closest-binary-search-tree-value-ii", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def closestKValues(self, root: TreeNode, target: float, k: int) -> List[int]:\n        def dfs(root):\n            if root is None:\n                return\n            dfs(root.left)\n            if len(q) < k:\n                q.append(root.val)\n            else:\n                if abs(root.val - target) >= abs(q[0] - target):\n                    return\n                q.popleft()\n                q.append(root.val)\n            dfs(root.right)\n\n        q = deque()\n        dfs(root)\n        return list(q)\n", "class Solution:\n  def closestKValues(\n      self,\n      root: TreeNode | None,\n      target: float,\n      k: int,\n  ) -> list[int]:\n    dq = collections.deque()\n\n    def inorder(root: TreeNode | None) -> None:\n      if not root:\n        return\n\n      inorder(root.left)\n      dq.append(root.val)\n      inorder(root.right)\n\n    inorder(root)\n\n    while len(dq) > k:\n      if abs(dq[0] - target) > abs(dq[-1] - target):\n        dq.popleft()\n      else:\n        dq.pop()\n\n    return list(dq)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 237, "slug": "delete-node-in-a-linked-list", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\n\nclass Solution:\n    def deleteNode(self, node):\n        \"\"\"\n        :type node: ListNode\n        :rtype: void Do not return anything, modify node in-place instead.\n        \"\"\"\n        node.val = node.next.val\n        node.next = node.next.next\n", "class Solution:\n  def deleteNode(self, node):\n    node.val = node.next.val\n    node.next = node.next.next\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 224, "slug": "basic-calculator", "solutions": ["class Solution:\n    def calculate(self, s: str) -> int:\n        stk = []\n        ans, sign = 0, 1\n        i, n = 0, len(s)\n        while i < n:\n            if s[i].isdigit():\n                x = 0\n                j = i\n                while j < n and s[j].isdigit():\n                    x = x * 10 + int(s[j])\n                    j += 1\n                ans += sign * x\n                i = j - 1\n            elif s[i] == \"+\":\n                sign = 1\n            elif s[i] == \"-\":\n                sign = -1\n            elif s[i] == \"(\":\n                stk.append(ans)\n                stk.append(sign)\n                ans, sign = 0, 1\n            elif s[i] == \")\":\n                ans = stk.pop() * ans + stk.pop()\n            i += 1\n        return ans\n", "class Solution:\n  def calculate(self, s: str) -> int:\n    ans = 0\n    num = 0\n    sign = 1\n    stack = [sign]  # stack[-1]: the current environment's sign\n\n    for c in s:\n      if c.isdigit():\n        num = num * 10 + int(c)\n      elif c == '(':\n        stack.append(sign)\n      elif c == ')':\n        stack.pop()\n      elif c == '+' or c == '-':\n        ans += sign * num\n        sign = (1 if c == '+' else -1) * stack[-1]\n        num = 0\n\n    return ans + sign * num\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 244, "slug": "shortest-word-distance-ii", "solutions": ["class WordDistance:\n    def __init__(self, wordsDict: List[str]):\n        self.d = defaultdict(list)\n        for i, w in enumerate(wordsDict):\n            self.d[w].append(i)\n\n    def shortest(self, word1: str, word2: str) -> int:\n        a, b = self.d[word1], self.d[word2]\n        ans = inf\n        i = j = 0\n        while i < len(a) and j < len(b):\n            ans = min(ans, abs(a[i] - b[j]))\n            if a[i] <= b[j]:\n                i += 1\n            else:\n                j += 1\n        return ans\n\n\n# Your WordDistance object will be instantiated and called as such:\n# obj = WordDistance(wordsDict)\n# param_1 = obj.shortest(word1,word2)\n", "class WordDistance:\n  def __init__(self, wordsDict: list[str]):\n    self.wordToIndices = collections.defaultdict(list)\n    for i, word in enumerate(wordsDict):\n      self.wordToIndices[word].append(i)\n\n  def shortest(self, word1: str, word2: str) -> int:\n    indices1 = self.wordToIndices[word1]\n    indices2 = self.wordToIndices[word2]\n    ans = math.inf\n\n    i = 0\n    j = 0\n    while i < len(indices1) and j < len(indices2):\n      ans = min(ans, abs(indices1[i] - indices2[j]))\n      if indices1[i] < indices2[j]:\n        i += 1\n      else:\n        j += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 268, "slug": "missing-number", "solutions": ["class Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        return reduce(xor, (i ^ v for i, v in enumerate(nums, 1)))\n", "class Solution:\n  def missingNumber(self, nums: list[int]) -> int:\n    ans = len(nums)\n\n    for i, num in enumerate(nums):\n      ans ^= i ^ num\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 243, "slug": "shortest-word-distance", "solutions": ["class Solution:\n    def shortestDistance(self, wordsDict: List[str], word1: str, word2: str) -> int:\n        i = j = -1\n        ans = inf\n        for k, w in enumerate(wordsDict):\n            if w == word1:\n                i = k\n            if w == word2:\n                j = k\n            if i != -1 and j != -1:\n                ans = min(ans, abs(i - j))\n        return ans\n", "class Solution:\n  def shortestDistance(\n      self,\n      wordsDict: list[str],\n      word1: str,\n      word2: str,\n  ) -> int:\n    ans = len(wordsDict)\n    index1 = -1  # wordsdict[index1] == word1\n    index2 = -1  # wordsdict[index2] == word2\n\n    for i, word in enumerate(wordsDict):\n      if word == word1:\n        index1 = i\n        if index2 != -1:\n          ans = min(ans, index1 - index2)\n      if word == word2:\n        index2 = i\n        if index1 != -1:\n          ans = min(ans, index2 - index1)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 270, "slug": "closest-binary-search-tree-value", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def closestValue(self, root: Optional[TreeNode], target: float) -> int:\n        def dfs(node: Optional[TreeNode]):\n            if node is None:\n                return\n            nxt = abs(target - node.val)\n            nonlocal ans, diff\n            if nxt < diff or (nxt == diff and node.val < ans):\n                diff = nxt\n                ans = node.val\n            node = node.left if target < node.val else node.right\n            dfs(node)\n\n        ans = 0\n        diff = inf\n        dfs(root)\n        return ans\n", "class Solution:\n  def closestValue(self, root: TreeNode | None, target: float) -> int:\n    # If target < root.val, search the left subtree.\n    if target < root.val and root.left:\n      left = self.closestValue(root.left, target)\n      if abs(left - target) <= abs(root.val - target):\n        return left\n\n    # If target > root.val, search the right subtree.\n    if target > root.val and root.right:\n      right = self.closestValue(root.right, target)\n      if abs(right - target) < abs(root.val - target):\n        return right\n\n    return root.val\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 200, "slug": "number-of-islands", "solutions": ["class Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n        def dfs(i, j):\n            grid[i][j] = '0'\n            for a, b in pairwise(dirs):\n                x, y = i + a, j + b\n                if 0 <= x < m and 0 <= y < n and grid[x][y] == '1':\n                    dfs(x, y)\n\n        ans = 0\n        dirs = (-1, 0, 1, 0, -1)\n        m, n = len(grid), len(grid[0])\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '1':\n                    dfs(i, j)\n                    ans += 1\n        return ans\n", "class Solution:\n  def numIslands(self, grid: list[list[str]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n\n    def bfs(r, c):\n      q = collections.deque([(r, c)])\n      grid[r][c] = '2'  # Mark '2' as visited.\n      while q:\n        i, j = q.popleft()\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if grid[x][y] != '1':\n            continue\n          q.append((x, y))\n          grid[x][y] = '2'  # Mark '2' as visited.\n\n    ans = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == '1':\n          bfs(i, j)\n          ans += 1\n\n    return ans\n", "class Solution:\n  def numIslands(self, grid: list[list[str]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    def dfs(i: int, j: int) -> None:\n      if i < 0 or i == m or j < 0 or j == n:\n        return\n      if grid[i][j] != '1':\n        return\n\n      grid[i][j] = '2'  # Mark '2' as visited.\n      dfs(i + 1, j)\n      dfs(i - 1, j)\n      dfs(i, j + 1)\n      dfs(i, j - 1)\n\n    ans = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == '1':\n          dfs(i, j)\n          ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 261, "slug": "graph-valid-tree", "solutions": ["class Solution:\n    def validTree(self, n: int, edges: List[List[int]]) -> bool:\n        def find(x: int) -> int:\n            if p[x] != x:\n                p[x] = find(p[x])\n            return p[x]\n\n        p = list(range(n))\n        for a, b in edges:\n            pa, pb = find(a), find(b)\n            if pa == pb:\n                return False\n            p[pa] = pb\n            n -= 1\n        return n == 1\n", "class Solution:\n  def validTree(self, n: int, edges: list[list[int]]) -> bool:\n    if n == 0 or len(edges) != n - 1:\n      return False\n\n    graph = [[] for _ in range(n)]\n    q = collections.deque([0])\n    seen = {0}\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    while q:\n      u = q.popleft()\n      for v in graph[u]:\n        if v not in seen:\n          q.append(v)\n          seen.add(v)\n\n    return len(seen) == n\n", "class UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def validTree(self, n: int, edges: list[list[int]]) -> bool:\n    if n == 0 or len(edges) != n - 1:\n      return False\n\n    uf = UnionFind(n)\n\n    for u, v in edges:\n      uf.unionByRank(u, v)\n\n    return uf.count == 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 222, "slug": "count-complete-tree-nodes", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def countNodes(self, root: Optional[TreeNode]) -> int:\n        if root is None:\n            return 0\n        return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n", "class Solution:\n  def countNodes(self, root: TreeNode | None) -> int:\n    if not root:\n      return 0\n\n    left = root\n    right = root\n    heightL = 0\n    heightR = 0\n\n    while left:\n      heightL += 1\n      left = left.left\n\n    while right:\n      heightR += 1\n      right = right.right\n\n    if heightL == heightR:  # `root` is a complete tree.\n      return pow(2, heightL) - 1\n    return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n", "class Solution:\n  def countNodes(self, root: TreeNode | None) -> int:\n    if not root:\n      return 0\n    return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 221, "slug": "maximal-square", "solutions": ["class Solution:\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        mx = 0\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    dp[i + 1][j + 1] = min(dp[i][j + 1], dp[i + 1][j], dp[i][j]) + 1\n                    mx = max(mx, dp[i + 1][j + 1])\n        return mx * mx\n", "class Solution:\n  def maximalSquare(self, matrix: list[list[str]]) -> int:\n    m = len(matrix)\n    n = len(matrix[0])\n    dp = [[0] * n for _ in range(m)]\n    maxLength = 0\n\n    for i in range(m):\n      for j in range(n):\n        if i == 0 or j == 0 or matrix[i][j] == '0':\n          dp[i][j] = 1 if matrix[i][j] == '1' else 0\n        else:\n          dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1]\n                         [j], dp[i][j - 1]) + 1\n        maxLength = max(maxLength, dp[i][j])\n\n    return maxLength * maxLength\n", "class Solution:\n  def maximalSquare(self, matrix: list[list[str]]) -> int:\n    m = len(matrix)\n    n = len(matrix[0])\n    dp = [0] * n\n    maxLength = 0\n    prev = 0  # dp[i - 1][j - 1]\n\n    for i in range(m):\n      for j in range(n):\n        cache = dp[j]\n        if i == 0 or j == 0 or matrix[i][j] == '0':\n          dp[j] = 1 if matrix[i][j] == '1' else 0\n        else:\n          dp[j] = min([prev, dp[j], dp[j - 1]]) + 1\n        maxLength = max(maxLength, dp[j])\n        prev = cache\n\n    return maxLength * maxLength\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 257, "slug": "binary-tree-paths", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\n        def dfs(root: Optional[TreeNode]):\n            if root is None:\n                return\n            t.append(str(root.val))\n            if root.left is None and root.right is None:\n                ans.append(\"->\".join(t))\n            else:\n                dfs(root.left)\n                dfs(root.right)\n            t.pop()\n\n        ans = []\n        t = []\n        dfs(root)\n        return ans\n", "class Solution:\n  def binaryTreePaths(self, root: TreeNode | None) -> list[str]:\n    ans = []\n\n    def dfs(root: TreeNode | None, path: list[str]) -> None:\n      if not root:\n        return\n      if not root.left and not root.right:\n        ans.append(''.join(path) + str(root.val))\n        return\n\n      path.append(str(root.val) + '->')\n      dfs(root.left, path)\n      dfs(root.right, path)\n      path.pop()\n\n    dfs(root, [])\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 267, "slug": "palindrome-permutation-ii", "solutions": ["class Solution:\n    def generatePalindromes(self, s: str) -> List[str]:\n        def dfs(t):\n            if len(t) == len(s):\n                ans.append(t)\n                return\n            for c, v in cnt.items():\n                if v > 1:\n                    cnt[c] -= 2\n                    dfs(c + t + c)\n                    cnt[c] += 2\n\n        cnt = Counter(s)\n        mid = ''\n        for c, v in cnt.items():\n            if v & 1:\n                if mid:\n                    return []\n                mid = c\n                cnt[c] -= 1\n        ans = []\n        dfs(mid)\n        return ans\n", "class Solution:\n  def generatePalindromes(self, s: str) -> list[str]:\n    count = collections.Counter(s)\n\n    # Count odd ones.\n    odd = sum(value & 1 for value in count.values())\n\n    # Can't form any palindrome.\n    if odd > 1:\n      return []\n\n    ans = []\n    candidates = []\n    mid = ''\n\n    # Get the mid and the candidates characters.\n    for key, value in count.items():\n      if value % 2 == 1:\n        mid += key\n      for _ in range(value // 2):\n        candidates.append(key)\n\n    def dfs(used: list[bool], path: list[str]) -> None:\n      \"\"\"Generates all the unique palindromes from the candidates.\"\"\"\n      if len(path) == len(candidates):\n        ans.append(''.join(path) + mid + ''.join(reversed(path)))\n        return\n\n      for i, candidate in enumerate(candidates):\n        if used[i]:\n          continue\n        if i > 0 and candidate == candidates[i - 1] and not used[i - 1]:\n          continue\n        used[i] = True\n        path.append(candidate)\n        dfs(used, path)\n        path.pop()\n        used[i] = False\n\n    # Backtrack to generate the ans strings.\n    dfs([False] * len(candidates), [])\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 204, "slug": "count-primes", "solutions": ["class Solution:\n    def countPrimes(self, n: int) -> int:\n        primes = [True] * n\n        ans = 0\n        for i in range(2, n):\n            if primes[i]:\n                ans += 1\n                for j in range(i + i, n, i):\n                    primes[j] = False\n        return ans\n", "class Solution:\n  def countPrimes(self, n: int) -> int:\n    if n <= 2:\n      return 0\n    return sum(self._sieveEratosthenes(n))\n\n  def _sieveEratosthenes(self, n: int) -> list[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 281, "slug": "zigzag-iterator", "solutions": ["class ZigzagIterator:\n    def __init__(self, v1: List[int], v2: List[int]):\n        self.cur = 0\n        self.size = 2\n        self.indexes = [0] * self.size\n        self.vectors = [v1, v2]\n\n    def next(self) -> int:\n        vector = self.vectors[self.cur]\n        index = self.indexes[self.cur]\n        res = vector[index]\n        self.indexes[self.cur] = index + 1\n        self.cur = (self.cur + 1) % self.size\n        return res\n\n    def hasNext(self) -> bool:\n        start = self.cur\n        while self.indexes[self.cur] == len(self.vectors[self.cur]):\n            self.cur = (self.cur + 1) % self.size\n            if self.cur == start:\n                return False\n        return True\n\n\n# Your ZigzagIterator object will be instantiated and called as such:\n# i, v = ZigzagIterator(v1, v2), []\n# while i.hasNext(): v.append(i.next())\n", "class ZigzagIterator:\n  def __init__(self, v1: list[int], v2: list[int]):\n    def vals():\n      for i in itertools.count():\n        for v in v1, v2:\n          if i < len(v):\n            yield v[i]\n    self.vals = vals()\n    self.n = len(v1) + len(v2)\n\n  def next(self):\n    self.n -= 1\n    return next(self.vals)\n\n  def hasNext(self):\n    return self.n > 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 225, "slug": "implement-stack-using-queues", "solutions": ["class MyStack:\n    def __init__(self):\n        self.q1 = deque()\n        self.q2 = deque()\n\n    def push(self, x: int) -> None:\n        self.q2.append(x)\n        while self.q1:\n            self.q2.append(self.q1.popleft())\n        self.q1, self.q2 = self.q2, self.q1\n\n    def pop(self) -> int:\n        return self.q1.popleft()\n\n    def top(self) -> int:\n        return self.q1[0]\n\n    def empty(self) -> bool:\n        return len(self.q1) == 0\n\n\n# Your MyStack object will be instantiated and called as such:\n# obj = MyStack()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.top()\n# param_4 = obj.empty()\n", "class MyStack:\n  def __init__(self):\n    self.q = collections.deque()\n\n  def push(self, x: int) -> None:\n    self.q.append(x)\n    for _ in range(len(self.q) - 1):\n      self.q.append(self.q.popleft())\n\n  def pop(self) -> int:\n    return self.q.popleft()\n\n  def top(self) -> int:\n    return self.q[0]\n\n  def empty(self) -> bool:\n    return not self.q\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 256, "slug": "paint-house", "solutions": ["class Solution:\n    def minCost(self, costs: List[List[int]]) -> int:\n        a = b = c = 0\n        for ca, cb, cc in costs:\n            a, b, c = min(b, c) + ca, min(a, c) + cb, min(a, b) + cc\n        return min(a, b, c)\n", "class Solution:\n  def minCost(self, costs: list[list[int]]) -> list[list[int]]:\n    for i in range(1, len(costs)):\n      costs[i][0] += min(costs[i - 1][1], costs[i - 1][2])\n      costs[i][1] += min(costs[i - 1][0], costs[i - 1][2])\n      costs[i][2] += min(costs[i - 1][0], costs[i - 1][1])\n\n    return min(costs[-1])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 297, "slug": "serialize-and-deserialize-binary-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\n\nclass Codec:\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n\n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        if root is None:\n            return \"\"\n        q = deque([root])\n        ans = []\n        while q:\n            node = q.popleft()\n            if node:\n                ans.append(str(node.val))\n                q.append(node.left)\n                q.append(node.right)\n            else:\n                ans.append(\"#\")\n        return \",\".join(ans)\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n\n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        if not data:\n            return None\n        vals = data.split(\",\")\n        root = TreeNode(int(vals[0]))\n        q = deque([root])\n        i = 1\n        while q:\n            node = q.popleft()\n            if vals[i] != \"#\":\n                node.left = TreeNode(int(vals[i]))\n                q.append(node.left)\n            i += 1\n            if vals[i] != \"#\":\n                node.right = TreeNode(int(vals[i]))\n                q.append(node.right)\n            i += 1\n        return root\n\n\n# Your Codec object will be instantiated and called as such:\n# codec = Codec()\n# codec.deserialize(codec.serialize(root))\n", "class Codec:\n  def serialize(self, root: 'TreeNode') -> str:\n    \"\"\"Encodes a tree to a single string.\"\"\"\n    if not root:\n      return ''\n\n    s = ''\n    q = collections.deque([root])\n\n    while q:\n      node = q.popleft()\n      if node:\n        s += str(node.val) + ' '\n        q.append(node.left)\n        q.append(node.right)\n      else:\n        s += 'n '\n\n    return s\n\n  def deserialize(self, data: str) -> 'TreeNode':\n    \"\"\"Decodes your encoded data to tree.\"\"\"\n    if not data:\n      return None\n\n    vals = data.split()\n    root = TreeNode(vals[0])\n    q = collections.deque([root])\n\n    for i in range(1, len(vals), 2):\n      node = q.popleft()\n      if vals[i] != 'n':\n        node.left = TreeNode(vals[i])\n        q.append(node.left)\n      if vals[i + 1] != 'n':\n        node.right = TreeNode(vals[i + 1])\n        q.append(node.right)\n\n    return root\n", "class Codec:\n  def serialize(self, root: 'TreeNode') -> str:\n    \"\"\"Encodes a tree to a single string.\"\"\"\n    s = []\n\n    def preorder(root: 'TreeNode') -> None:\n      if not root:\n        s.append('n')\n        return\n\n      s.append(str(root.val))\n      preorder(root.left)\n      preorder(root.right)\n\n    preorder(root)\n    return ' '.join(s)\n\n  def deserialize(self, data: str) -> 'TreeNode':\n    \"\"\"Decodes your encoded data to tree.\"\"\"\n    q = collections.deque(data.split())\n\n    def preorder() -> 'TreeNode':\n      s = q.popleft()\n      if s == 'n':\n        return None\n\n      root = TreeNode(s)\n      root.left = preorder()\n      root.right = preorder()\n      return root\n\n    return preorder()\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 289, "slug": "game-of-life", "solutions": ["class Solution:\n    def gameOfLife(self, board: List[List[int]]) -> None:\n        m, n = len(board), len(board[0])\n        for i in range(m):\n            for j in range(n):\n                live = -board[i][j]\n                for x in range(i - 1, i + 2):\n                    for y in range(j - 1, j + 2):\n                        if 0 <= x < m and 0 <= y < n and board[x][y] > 0:\n                            live += 1\n                if board[i][j] and (live < 2 or live > 3):\n                    board[i][j] = 2\n                if board[i][j] == 0 and live == 3:\n                    board[i][j] = -1\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 2:\n                    board[i][j] = 0\n                elif board[i][j] == -1:\n                    board[i][j] = 1\n", "class Solution:\n  def gameOfLife(self, board: list[list[int]]) -> None:\n    m = len(board)\n    n = len(board[0])\n\n    for i in range(m):\n      for j in range(n):\n        ones = 0\n        for x in range(max(0, i - 1), min(m, i + 2)):\n          for y in range(max(0, j - 1), min(n, j + 2)):\n            ones += board[x][y] & 1\n        # Any live cell with two or three live neighbors lives on to the next\n        # generation.\n        if board[i][j] == 1 and (ones == 3 or ones == 4):\n          board[i][j] |= 0b10\n        # Any dead cell with exactly three live neighbors becomes a live cell,\n        # as if by reproduction.\n        if board[i][j] == 0 and ones == 3:\n          board[i][j] |= 0b10\n\n    for i in range(m):\n      for j in range(n):\n        board[i][j] >>= 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 212, "slug": "word-search-ii", "solutions": ["class Trie:\n    def __init__(self):\n        self.children: List[Trie | None] = [None] * 26\n        self.ref: int = -1\n\n    def insert(self, w: str, ref: int):\n        node = self\n        for c in w:\n            idx = ord(c) - ord('a')\n            if node.children[idx] is None:\n                node.children[idx] = Trie()\n            node = node.children[idx]\n        node.ref = ref\n\n\nclass Solution:\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\n        def dfs(node: Trie, i: int, j: int):\n            idx = ord(board[i][j]) - ord('a')\n            if node.children[idx] is None:\n                return\n            node = node.children[idx]\n            if node.ref >= 0:\n                ans.append(words[node.ref])\n                node.ref = -1\n            c = board[i][j]\n            board[i][j] = '#'\n            for a, b in pairwise((-1, 0, 1, 0, -1)):\n                x, y = i + a, j + b\n                if 0 <= x < m and 0 <= y < n and board[x][y] != '#':\n                    dfs(node, x, y)\n            board[i][j] = c\n\n        tree = Trie()\n        for i, w in enumerate(words):\n            tree.insert(w, i)\n        m, n = len(board), len(board[0])\n        ans = []\n        for i in range(m):\n            for j in range(n):\n                dfs(tree, i, j)\n        return ans\n", "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.word: str | None = None\n\n\nclass Solution:\n  def findWords(self, board: list[list[str]], words: list[str]) -> list[str]:\n    m = len(board)\n    n = len(board[0])\n    ans = []\n    root = TrieNode()\n\n    def insert(word: str) -> None:\n      node = root\n      for c in word:\n        node = node.children.setdefault(c, TrieNode())\n      node.word = word\n\n    for word in words:\n      insert(word)\n\n    def dfs(i: int, j: int, node: TrieNode) -> None:\n      if i < 0 or i == m or j < 0 or j == n:\n        return\n      if board[i][j] == '*':\n        return\n\n      c = board[i][j]\n      if c not in node.children:\n        return\n\n      child = node.children[c]\n      if child.word:\n        ans.append(child.word)\n        child.word = None\n\n      board[i][j] = '*'\n      dfs(i + 1, j, child)\n      dfs(i - 1, j, child)\n      dfs(i, j + 1, child)\n      dfs(i, j - 1, child)\n      board[i][j] = c\n\n    for i in range(m):\n      for j in range(n):\n        dfs(i, j, root)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 231, "slug": "power-of-two", "solutions": ["class Solution:\n    def isPowerOfTwo(self, n: int) -> bool:\n        return n > 0 and (n & (n - 1)) == 0\n", "class Solution:\n  def isPowerOfTwo(self, n: int) -> bool:\n    return n >= 0 and n.bit_count() == 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 209, "slug": "minimum-size-subarray-sum", "solutions": ["class Solution:\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\n        n = len(nums)\n        s = list(accumulate(nums, initial=0))\n        ans = n + 1\n        for i, x in enumerate(s):\n            j = bisect_left(s, x + target)\n            if j <= n:\n                ans = min(ans, j - i)\n        return ans if ans <= n else 0\n", "class Solution:\n  def minSubArrayLen(self, target: int, nums: list[int]) -> int:\n    ans = math.inf\n    summ = 0\n    j = 0\n\n    for i, num in enumerate(nums):\n      summ += num\n      while summ >= target:\n        ans = min(ans, i - j + 1)\n        summ -= nums[j]\n        j += 1\n\n    return 0 if ans == math.inf else ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 274, "slug": "h-index", "solutions": ["class Solution:\n    def hIndex(self, citations: List[int]) -> int:\n        citations.sort(reverse=True)\n        for h in range(len(citations), 0, -1):\n            if citations[h - 1] >= h:\n                return h\n        return 0\n", "class Solution:\n  def hIndex(self, citations: list[int]) -> int:\n    n = len(citations)\n\n    citations.sort()\n\n    for i, citation in enumerate(citations):\n      if citation >= n - i:\n        return n - i\n\n    return 0\n", "class Solution:\n  def hIndex(self, citations: list[int]) -> int:\n    n = len(citations)\n    accumulate = 0\n    count = [0] * (n + 1)\n\n    for citation in citations:\n      count[min(citation, n)] += 1\n\n    # To find the maximum h-index, loop from the back to the front.\n    # i := the candidate's h-index\n    for i, c in reversed(list(enumerate(count))):\n      accumulate += c\n      if accumulate >= i:\n        return i\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 214, "slug": "shortest-palindrome", "solutions": ["class Solution:\n    def shortestPalindrome(self, s: str) -> str:\n        base = 131\n        mod = 10**9 + 7\n        n = len(s)\n        prefix = suffix = 0\n        mul = 1\n        idx = 0\n        for i, c in enumerate(s):\n            prefix = (prefix * base + (ord(c) - ord('a') + 1)) % mod\n            suffix = (suffix + (ord(c) - ord('a') + 1) * mul) % mod\n            mul = (mul * base) % mod\n            if prefix == suffix:\n                idx = i + 1\n        return s if idx == n else s[idx:][::-1] + s\n", "class Solution:\n  def shortestPalindrome(self, s: str) -> str:\n    t = s[::-1]\n\n    for i in range(len(t)):\n      if s.startswith(t[i:]):\n        return t[:i] + s\n\n    return t + s\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 230, "slug": "kth-smallest-element-in-a-bst", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        stk = []\n        while root or stk:\n            if root:\n                stk.append(root)\n                root = root.left\n            else:\n                root = stk.pop()\n                k -= 1\n                if k == 0:\n                    return root.val\n                root = root.right\n", "class Solution:\n  def kthSmallest(self, root: TreeNode | None, k: int) -> int:\n    def countNodes(root: TreeNode | None) -> int:\n      if not root:\n        return 0\n      return 1 + countNodes(root.left) + countNodes(root.right)\n\n    leftCount = countNodes(root.left)\n\n    if leftCount == k - 1:\n      return root.val\n    if leftCount >= k:\n      return self.kthSmallest(root.left, k)\n    return self.kthSmallest(root.right, k - 1 - leftCount)  # leftCount < k\n", "class Solution:\n  def kthSmallest(self, root: TreeNode | None, k: int) -> int:\n    rank = 0\n    ans = 0\n\n    def traverse(root: TreeNode | None) -> None:\n      nonlocal rank\n      nonlocal ans\n      if not root:\n        return\n\n      traverse(root.left)\n      rank += 1\n      if rank == k:\n        ans = root.val\n        return\n      traverse(root.right)\n\n    traverse(root)\n    return ans\n", "class Solution:\n  def kthSmallest(self, root: TreeNode | None, k: int) -> int:\n    stack = []\n\n    while root:\n      stack.append(root)\n      root = root.left\n\n    for _ in range(k - 1):\n      root = stack.pop()\n      root = root.right\n      while root:\n        stack.append(root)\n        root = root.left\n\n    return stack[-1].val\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1293, "slug": "shortest-path-in-a-grid-with-obstacles-elimination", "solutions": ["class Solution:\n    def shortestPath(self, grid: List[List[int]], k: int) -> int:\n        m, n = len(grid), len(grid[0])\n        if k >= m + n - 3:\n            return m + n - 2\n        q = deque([(0, 0, k)])\n        vis = {(0, 0, k)}\n        ans = 0\n        while q:\n            ans += 1\n            for _ in range(len(q)):\n                i, j, k = q.popleft()\n                for a, b in [[0, -1], [0, 1], [1, 0], [-1, 0]]:\n                    x, y = i + a, j + b\n                    if 0 <= x < m and 0 <= y < n:\n                        if x == m - 1 and y == n - 1:\n                            return ans\n                        if grid[x][y] == 0 and (x, y, k) not in vis:\n                            q.append((x, y, k))\n                            vis.add((x, y, k))\n                        if grid[x][y] == 1 and k > 0 and (x, y, k - 1) not in vis:\n                            q.append((x, y, k - 1))\n                            vis.add((x, y, k - 1))\n        return -1\n", "class Solution:\n  def shortestPath(self, grid: list[list[int]], k: int) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    if m == 1 and n == 1:\n      return 0\n\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    q = collections.deque([(0, 0, k)])\n    seen = {(0, 0, k)}\n\n    step = 0\n    while q:\n      step += 1\n      for _ in range(len(q)):\n        i, j, eliminate = q.popleft()\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if x == m - 1 and y == n - 1:\n            return step\n          if grid[x][y] == 1 and eliminate == 0:\n            continue\n          newEliminate = eliminate - grid[x][y]\n          if (x, y, newEliminate) in seen:\n            continue\n          q.append((x, y, newEliminate))\n          seen.add((x, y, newEliminate))\n\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1299, "slug": "replace-elements-with-greatest-element-on-right-side", "solutions": ["class Solution:\n    def replaceElements(self, arr: List[int]) -> List[int]:\n        mx = -1\n        for i in reversed(range(len(arr))):\n            x = arr[i]\n            arr[i] = mx\n            mx = max(mx, x)\n        return arr\n", "class Solution:\n  def replaceElements(self, arr: list[int]) -> list[int]:\n    maxOfRight = -1\n    for i in reversed(range(len(arr))):\n      arr[i], maxOfRight = maxOfRight, max(maxOfRight, arr[i])\n    return arr\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1266, "slug": "minimum-time-visiting-all-points", "solutions": ["class Solution:\n    def minTimeToVisitAllPoints(self, points: List[List[int]]) -> int:\n        return sum(\n            max(abs(p1[0] - p2[0]), abs(p1[1] - p2[1])) for p1, p2 in pairwise(points)\n        )\n", "class Solution:\n  def minTimeToVisitAllPoints(self, points: list[list[int]]) -> int:\n    ans = 0\n\n    for i in range(1, len(points)):\n      ans += max(abs(points[i][0] - points[i - 1][0]),\n                 abs(points[i][1] - points[i - 1][1]))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1255, "slug": "maximum-score-words-formed-by-letters", "solutions": ["class Solution:\n    def maxScoreWords(\n        self, words: List[str], letters: List[str], score: List[int]\n    ) -> int:\n        cnt = Counter(letters)\n        n = len(words)\n        ans = 0\n        for i in range(1 << n):\n            cur = Counter(''.join([words[j] for j in range(n) if i >> j & 1]))\n            if all(v <= cnt[c] for c, v in cur.items()):\n                t = sum(v * score[ord(c) - ord('a')] for c, v in cur.items())\n                ans = max(ans, t)\n        return ans\n", "class Solution:\n  def maxScoreWords(\n      self,\n      words: list[str],\n      letters: list[str],\n      score: list[int],\n  ) -> int:\n    count = collections.Counter(letters)\n\n    def useWord(i: int) -> int:\n      isValid = True\n      earned = 0\n      for c in words[i]:\n        count[c] -= 1\n        if count[c] < 0:\n          isValid = False\n        earned += score[ord(c) - ord('a')]\n      return earned if isValid else -1\n\n    def unuseWord(i: int) -> None:\n      for c in words[i]:\n        count[c] += 1\n\n    def dfs(s: int) -> int:\n      \"\"\"Returns the maximum score you can get from words[s..n).\"\"\"\n      ans = 0\n      for i in range(s, len(words)):\n        earned = useWord(i)\n        if earned > 0:\n          ans = max(ans, earned + dfs(i + 1))\n        unuseWord(i)\n      return ans\n\n    return dfs(0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1208, "slug": "get-equal-substrings-within-budget", "solutions": ["class Solution:\n    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\n        def check(x):\n            for i in range(n):\n                j = i + mid - 1\n                if j < n and f[j + 1] - f[i] <= maxCost:\n                    return True\n            return False\n\n        n = len(s)\n        f = list(accumulate((abs(ord(a) - ord(b)) for a, b in zip(s, t)), initial=0))\n        l, r = 0, n\n        while l < r:\n            mid = (l + r + 1) >> 1\n            if check(mid):\n                l = mid\n            else:\n                r = mid - 1\n        return l\n", "class Solution:\n  def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\n    j = 0\n    for i in range(len(s)):\n      maxCost -= abs(ord(s[i]) - ord(t[i]))\n      if maxCost < 0:\n        maxCost += abs(ord(s[j]) - ord(t[j]))\n        j += 1\n\n    return len(s) - j\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1253, "slug": "reconstruct-a-2-row-binary-matrix", "solutions": ["class Solution:\n    def reconstructMatrix(\n        self, upper: int, lower: int, colsum: List[int]\n    ) -> List[List[int]]:\n        n = len(colsum)\n        ans = [[0] * n for _ in range(2)]\n        for j, v in enumerate(colsum):\n            if v == 2:\n                ans[0][j] = ans[1][j] = 1\n                upper, lower = upper - 1, lower - 1\n            if v == 1:\n                if upper > lower:\n                    upper -= 1\n                    ans[0][j] = 1\n                else:\n                    lower -= 1\n                    ans[1][j] = 1\n            if upper < 0 or lower < 0:\n                return []\n        return ans if lower == upper == 0 else []\n", "class Solution:\n  def reconstructMatrix(self, upper: int, lower: int, colsum: list[int]) -> list[list[int]]:\n    if upper + lower != sum(colsum):\n      return []\n    if min(upper, lower) < colsum.count(2):\n      return []\n\n    ans = [[0] * len(colsum) for _ in range(2)]\n\n    for j, c in enumerate(colsum):\n      if c == 2:\n        ans[0][j] = 1\n        ans[1][j] = 1\n        upper -= 1\n        lower -= 1\n\n    for j, c in enumerate(colsum):\n      if c == 1 and upper > 0:\n        ans[0][j] = 1\n        c -= 1\n        upper -= 1\n      if c == 1 and lower > 0:\n        ans[1][j] = 1\n        lower -= 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1273, "slug": "delete-tree-nodes", "solutions": ["class Solution:\n    def deleteTreeNodes(self, nodes: int, parent: List[int], value: List[int]) -> int:\n        def dfs(i):\n            s, m = value[i], 1\n            for j in g[i]:\n                t, n = dfs(j)\n                s += t\n                m += n\n            if s == 0:\n                m = 0\n            return (s, m)\n\n        g = defaultdict(list)\n        for i in range(1, nodes):\n            g[parent[i]].append(i)\n        return dfs(0)[1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1223, "slug": "dice-roll-simulation", "solutions": ["class Solution:\n    def dieSimulator(self, n: int, rollMax: List[int]) -> int:\n        @cache\n        def dfs(i, j, x):\n            if i >= n:\n                return 1\n            ans = 0\n            for k in range(1, 7):\n                if k != j:\n                    ans += dfs(i + 1, k, 1)\n                elif x < rollMax[j - 1]:\n                    ans += dfs(i + 1, j, x + 1)\n            return ans % (10**9 + 7)\n\n        return dfs(0, 0, 0)\n", "class Solution:\n  def dieSimulator(self, n: int, rollMax: list[int]) -> int:\n    MAX_ROLLS = 15\n    MOD = 1_000_000_007\n\n    dp = [[[0] * (MAX_ROLLS + 1) for j in range(6)] for i in range(n + 1)]\n\n    for num in range(6):\n      dp[1][num][1] = 1\n\n    for i in range(2, n + 1):\n      for currNum in range(6):\n        for prevNum in range(6):\n          for k in range(1, 15 + 1):\n            if prevNum != currNum:\n              dp[i][currNum][1] = (\n                  dp[i][currNum][1] + dp[i - 1][prevNum][k]) % MOD\n            elif k < rollMax[currNum]:\n              dp[i][currNum][k + 1] = dp[i - 1][currNum][k]\n\n    ans = 0\n\n    for num in range(6):\n      for k in range(1, 15 + 1):\n        ans += dp[n][num][k]\n\n    return ans % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1237, "slug": "find-positive-integer-solution-for-a-given-equation", "solutions": ["\"\"\"\n   This is the custom function interface.\n   You should not implement it, or speculate about its implementation\n   class CustomFunction:\n       # Returns f(x, y) for any given positive integers x and y.\n       # Note that f(x, y) is increasing with respect to both x and y.\n       # i.e. f(x, y) < f(x + 1, y), f(x, y) < f(x, y + 1)\n       def f(self, x, y):\n\n\"\"\"\n\n\nclass Solution:\n    def findSolution(self, customfunction: \"CustomFunction\", z: int) -> List[List[int]]:\n        ans = []\n        for x in range(1, z + 1):\n            y = 1 + bisect_left(\n                range(1, z + 1), z, key=lambda y: customfunction.f(x, y)\n            )\n            if customfunction.f(x, y) == z:\n                ans.append([x, y])\n        return ans\n", "class Solution:\n  def findSolution(self, customfunction: 'CustomFunction', z: int) -> list[list[int]]:\n    ans = []\n    x = 1\n    y = 1000\n\n    while x <= 1000 and y >= 1:\n      f = customfunction.f(x, y)\n      if f < z:\n        x += 1\n      elif f > z:\n        y -= 1\n      else:\n        ans.append([x, y])\n        x += 1\n        y -= 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1248, "slug": "count-number-of-nice-subarrays", "solutions": ["class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        cnt = Counter({0: 1})\n        ans = t = 0\n        for v in nums:\n            t += v & 1\n            ans += cnt[t - k]\n            cnt[t] += 1\n        return ans\n", "class Solution:\n  def numberOfSubarrays(self, nums: list[int], k: int) -> int:\n    def numberOfSubarraysAtMost(k: int) -> int:\n      ans = 0\n      l = 0\n      r = 0\n\n      while r <= len(nums):\n        if k >= 0:\n          ans += r - l\n          if r == len(nums):\n            break\n          if nums[r] & 1:\n            k -= 1\n          r += 1\n        else:\n          if nums[l] & 1:\n            k += 1\n          l += 1\n      return ans\n\n    return numberOfSubarraysAtMost(k) - numberOfSubarraysAtMost(k - 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1214, "slug": "two-sum-bsts", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def twoSumBSTs(\n        self, root1: Optional[TreeNode], root2: Optional[TreeNode], target: int\n    ) -> bool:\n        def dfs(root: Optional[TreeNode], i: int):\n            if root is None:\n                return\n            dfs(root.left, i)\n            nums[i].append(root.val)\n            dfs(root.right, i)\n\n        nums = [[], []]\n        dfs(root1, 0)\n        dfs(root2, 1)\n        i, j = 0, len(nums[1]) - 1\n        while i < len(nums[0]) and ~j:\n            x = nums[0][i] + nums[1][j]\n            if x == target:\n                return True\n            if x < target:\n                i += 1\n            else:\n                j -= 1\n        return False\n", "class BSTIterator:\n  def __init__(self, root: TreeNode | None, leftToRight: bool):\n    self.stack = []\n    self.leftToRight = leftToRight\n    self._pushUntilNone(root)\n\n  def hasNext(self) -> bool:\n    return len(self.stack) > 0\n\n  def next(self) -> int:\n    node = self.stack.pop()\n    if self.leftToRight:\n      self._pushUntilNone(node.right)\n    else:\n      self._pushUntilNone(node.left)\n    return node.val\n\n  def _pushUntilNone(self, root: TreeNode | None):\n    while root:\n      self.stack.append(root)\n      root = root.left if self.leftToRight else root.right\n\n\nclass Solution:\n  def twoSumBSTs(\n      self,\n      root1: TreeNode | None,\n      root2: TreeNode | None,\n      target: int,\n  ) -> bool:\n    bst1 = BSTIterator(root1, True)\n    bst2 = BSTIterator(root2, False)\n\n    l = bst1.next()\n    r = bst2.next()\n    while True:\n      summ = l + r\n      if summ == target:\n        return True\n      if summ < target:\n        if not bst1.hasNext():\n          return False\n        l = bst1.next()\n      else:\n        if not bst2.hasNext():\n          return False\n        r = bst2.next()\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1270, "slug": "all-people-report-to-the-given-manager", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1218, "slug": "longest-arithmetic-subsequence-of-given-difference", "solutions": ["class Solution:\n    def longestSubsequence(self, arr: List[int], difference: int) -> int:\n        f = defaultdict(int)\n        for x in arr:\n            f[x] = f[x - difference] + 1\n        return max(f.values())\n", "class Solution:\n  def longestSubsequence(self, arr: list[int], difference: int) -> int:\n    ans = 0\n    lengthAt = {}\n\n    for a in arr:\n      lengthAt[a] = lengthAt.get(a - difference, 0) + 1\n      ans = max(ans, lengthAt[a])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1276, "slug": "number-of-burgers-with-no-waste-of-ingredients", "solutions": ["class Solution:\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\n        k = 4 * cheeseSlices - tomatoSlices\n        y = k // 2\n        x = cheeseSlices - y\n        return [] if k % 2 or y < 0 or x < 0 else [x, y]\n", "class Solution:\n  def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> list[int]:\n    if tomatoSlices % 2 == 1 or tomatoSlices < 2 * cheeseSlices or tomatoSlices > cheeseSlices * 4:\n      return []\n\n    jumboBurgers = (tomatoSlices - 2 * cheeseSlices) // 2\n\n    return [jumboBurgers, cheeseSlices - jumboBurgers]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1234, "slug": "replace-the-substring-for-balanced-string", "solutions": ["class Solution:\n    def balancedString(self, s: str) -> int:\n        cnt = Counter(s)\n        n = len(s)\n        if all(v <= n // 4 for v in cnt.values()):\n            return 0\n        ans, j = n, 0\n        for i, c in enumerate(s):\n            cnt[c] -= 1\n            while j <= i and all(v <= n // 4 for v in cnt.values()):\n                ans = min(ans, i - j + 1)\n                cnt[s[j]] += 1\n                j += 1\n        return ans\n", "class Solution:\n  def balancedString(self, s: str) -> int:\n    ans = len(s)\n    count = collections.Counter(s)\n    j = 0\n\n    for i, c in enumerate(s):\n      count[c] -= 1\n      while j < len(s) and all(count[c] <= len(s) // 4 for c in 'QWER'):\n        ans = min(ans, i - j + 1)\n        count[s[j]] += 1\n        j += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1297, "slug": "maximum-number-of-occurrences-of-a-substring", "solutions": ["class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        ans = 0\n        cnt = Counter()\n        for i in range(len(s) - minSize + 1):\n            t = s[i : i + minSize]\n            ss = set(t)\n            if len(ss) <= maxLetters:\n                cnt[t] += 1\n                ans = max(ans, cnt[t])\n        return ans\n", "class Solution:\n  def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n    # Greedily consider strings with `minSize`, so ignore `maxSize`.\n    ans = 0\n    letters = 0\n    count = collections.Counter()\n    substringCount = collections.Counter()\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] += 1\n      if count[c] == 1:\n        letters += 1\n      while letters > maxLetters or r - l + 1 > minSize:\n        count[s[l]] -= 1\n        if count[s[l]] == 0:\n          letters -= 1\n        l += 1\n      if r - l + 1 == minSize:\n        sub = s[l:l + minSize]\n        substringCount[sub] += 1\n        ans = max(ans, substringCount[sub])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1231, "slug": "divide-chocolate", "solutions": ["class Solution:\n    def maximizeSweetness(self, sweetness: List[int], k: int) -> int:\n        def check(x: int) -> bool:\n            s = cnt = 0\n            for v in sweetness:\n                s += v\n                if s >= x:\n                    s = 0\n                    cnt += 1\n            return cnt > k\n\n        l, r = 0, sum(sweetness)\n        while l < r:\n            mid = (l + r + 1) >> 1\n            if check(mid):\n                l = mid\n            else:\n                r = mid - 1\n        return l\n", "class Solution:\n  def maximizeSweetness(self, sweetness: list[int], k: int) -> int:\n    l = len(sweetness) // (k + 1)\n    r = sum(sweetness) // (k + 1)\n\n    def canEat(m: int) -> bool:\n      \"\"\"\n      Returns True if can eat m sweetness (the minimum sweetness of each piece).\n      \"\"\"\n      pieces = 0\n      summ = 0  # the running sum\n      for s in sweetness:\n        summ += s\n        if summ >= m:\n          pieces += 1\n          summ = 0\n      return pieces > k\n\n    while l < r:\n      m = (l + r) // 2\n      if canEat(m):\n        l = m + 1\n      else:\n        r = m\n\n    return l if canEat(l) else l - 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1272, "slug": "remove-interval", "solutions": ["class Solution:\n    def removeInterval(\n        self, intervals: List[List[int]], toBeRemoved: List[int]\n    ) -> List[List[int]]:\n        x, y = toBeRemoved\n        ans = []\n        for a, b in intervals:\n            if a >= y or b <= x:\n                ans.append([a, b])\n            else:\n                if a < x:\n                    ans.append([a, x])\n                if b > y:\n                    ans.append([y, b])\n        return ans\n", "class Solution:\n  def removeInterval(self, intervals: list[list[int]],\n                     toBeRemoved: list[int]) -> list[list[int]]:\n    ans = []\n\n    for a, b in intervals:\n      if a >= toBeRemoved[1] or b <= toBeRemoved[0]:\n        ans.append([a, b])\n      else:  # a < toBeRemoved[1] and b > toBeRemoved[0]\n        if a < toBeRemoved[0]:\n          ans.append([a, toBeRemoved[0]])\n        if b > toBeRemoved[1]:\n          ans.append([toBeRemoved[1], b])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1263, "slug": "minimum-moves-to-move-a-box-to-their-target-location", "solutions": ["class Solution:\n    def minPushBox(self, grid: List[List[str]]) -> int:\n        def f(i: int, j: int) -> int:\n            return i * n + j\n\n        def check(i: int, j: int) -> bool:\n            return 0 <= i < m and 0 <= j < n and grid[i][j] != \"#\"\n\n        for i, row in enumerate(grid):\n            for j, c in enumerate(row):\n                if c == \"S\":\n                    si, sj = i, j\n                elif c == \"B\":\n                    bi, bj = i, j\n        m, n = len(grid), len(grid[0])\n        dirs = (-1, 0, 1, 0, -1)\n        q = deque([(f(si, sj), f(bi, bj), 0)])\n        vis = [[False] * (m * n) for _ in range(m * n)]\n        vis[f(si, sj)][f(bi, bj)] = True\n        while q:\n            s, b, d = q.popleft()\n            bi, bj = b // n, b % n\n            if grid[bi][bj] == \"T\":\n                return d\n            si, sj = s // n, s % n\n            for a, b in pairwise(dirs):\n                sx, sy = si + a, sj + b\n                if not check(sx, sy):\n                    continue\n                if sx == bi and sy == bj:\n                    bx, by = bi + a, bj + b\n                    if not check(bx, by) or vis[f(sx, sy)][f(bx, by)]:\n                        continue\n                    vis[f(sx, sy)][f(bx, by)] = True\n                    q.append((f(sx, sy), f(bx, by), d + 1))\n                elif not vis[f(sx, sy)][f(bi, bj)]:\n                    vis[f(sx, sy)][f(bi, bj)] = True\n                    q.appendleft((f(sx, sy), f(bi, bj), d))\n        return -1\n", "class Solution:\n  def minPushBox(self, grid: list[list[str]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 'B':\n          box = (i, j)\n        elif grid[i][j] == 'S':\n          player = (i, j)\n        elif grid[i][j] == 'T':\n          target = (i, j)\n\n    def isInvalid(playerX: int, playerY: int) -> bool:\n      return (playerX < 0 or playerX == m or playerY < 0 or playerY == n or\n              grid[playerX][playerY] == '#')\n\n    def canGoTo(\n        playerX: int,\n        playerY: int,\n        fromX: int,\n        fromY: int,\n        boxX: int,\n        boxY: int\n    ) -> bool:\n      \"\"\"Returns True if (playerX, playerY) can go to (fromX, fromY).\"\"\"\n      q = collections.deque([(playerX, playerY)])\n      seen = {(playerX, playerY)}\n\n      while q:\n        i, j = q.popleft()\n        if i == fromX and j == fromY:\n          return True\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if isInvalid(x, y):\n            continue\n          if (x, y) in seen:\n            continue\n          if x == boxX and y == boxY:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n\n      return False\n\n    # (boxX, boxY, playerX, playerY)\n    q = collections.deque([(box[0], box[1], player[0], player[1])])\n    seen = {(box[0], box[1], player[0], player[1])}\n\n    step = 0\n    while q:\n      for _ in range(len(q)):\n        boxX, boxY, playerX, playerY = q.popleft()\n        if boxX == target[0] and boxY == target[1]:\n          return step\n        for k, (dx, dy) in enumerate(DIRS):\n          nextBoxX = boxX + dx\n          nextBoxY = boxY + dy\n          if isInvalid(nextBoxX, nextBoxY):\n            continue\n          if (nextBoxX, nextBoxY, boxX, boxY) in seen:\n            continue\n          fromX = boxX + DIRS[(k + 2) % 4][0]\n          fromY = boxY + DIRS[(k + 2) % 4][1]\n          if isInvalid(fromX, fromY):\n            continue\n          if canGoTo(playerX, playerY, fromX, fromY, boxX, boxY):\n            q.append((nextBoxX, nextBoxY, boxX, boxY))\n            seen.add((nextBoxX, nextBoxY, boxX, boxY))\n      step += 1\n\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1252, "slug": "cells-with-odd-values-in-a-matrix", "solutions": ["class Solution:\n    def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:\n        g = [[0] * n for _ in range(m)]\n        for r, c in indices:\n            for i in range(m):\n                g[i][c] += 1\n            for j in range(n):\n                g[r][j] += 1\n        return sum(v % 2 for row in g for v in row)\n", "class Solution:\n  def oddCells(self, m: int, n: int, indices: list[list[int]]) -> int:\n    # rows[i] and cols[i] :=\n    #   true (flipped even times) / false (flipped odd times)\n    rows = [False] * m\n    cols = [False] * n\n\n    for r, c in indices:\n      rows[r] ^= True\n      cols[c] ^= True\n\n    return sum(rows[i] ^ cols[j]\n               for i in range(m)\n               for j in range(n))\n", "class Solution:\n  def oddCells(self, m: int, n: int, indices: list[list[int]]) -> int:\n    # rows[i] and cols[i] :=\n    #   1. True (flipped even times)\n    #   2. False (flipped odd times)\n    rows = [False] * m\n    cols = [False] * n\n\n    for r, c in indices:\n      rows[r] ^= True\n      cols[c] ^= True\n\n    oddRowsCount = rows.count(True)\n    oddColsCount = cols.count(True)\n    evenRowsCount = m - oddRowsCount\n    evenColsCount = n - oddColsCount\n    return oddRowsCount * evenColsCount + oddColsCount * evenRowsCount\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1265, "slug": "print-immutable-linked-list-in-reverse", "solutions": ["# \"\"\"\n# This is the ImmutableListNode's API interface.\n# You should not implement it, or speculate about its implementation.\n# \"\"\"\n# class ImmutableListNode:\n#     def printValue(self) -> None: # print the value of this node.\n#     def getNext(self) -> 'ImmutableListNode': # return the next node.\n\n\nclass Solution:\n    def printLinkedListInReverse(self, head: 'ImmutableListNode') -> None:\n        if head:\n            self.printLinkedListInReverse(head.getNext())\n            head.printValue()\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1249, "slug": "minimum-remove-to-make-valid-parentheses", "solutions": ["class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        stk = []\n        x = 0\n        for c in s:\n            if c == ')' and x == 0:\n                continue\n            if c == '(':\n                x += 1\n            elif c == ')':\n                x -= 1\n            stk.append(c)\n        x = 0\n        ans = []\n        for c in stk[::-1]:\n            if c == '(' and x == 0:\n                continue\n            if c == ')':\n                x += 1\n            elif c == '(':\n                x -= 1\n            ans.append(c)\n        return ''.join(ans[::-1])\n", "class Solution:\n  def minRemoveToMakeValid(self, s: str) -> str:\n    stack = []  # unpaired '(' indices\n    chars = list(s)\n\n    for i, c in enumerate(chars):\n      if c == '(':\n        stack.append(i)  # Record the unpaired '(' index.\n      elif c == ')':\n        if stack:\n          stack.pop()  # Find a pair\n        else:\n          chars[i] = '*'  # Mark the unpaired ')' as '*'.\n\n    # Mark the unpaired '(' as '*'.\n    while stack:\n      chars[stack.pop()] = '*'\n\n    return ''.join(chars).replace('*', '')\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1233, "slug": "remove-sub-folders-from-the-filesystem", "solutions": ["class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        folder.sort()\n        ans = [folder[0]]\n        for f in folder[1:]:\n            m, n = len(ans[-1]), len(f)\n            if m >= n or not (ans[-1] == f[:m] and f[m] == '/'):\n                ans.append(f)\n        return ans\n", "class Solution:\n  def removeSubfolders(self, folder: list[str]) -> list[str]:\n    ans = []\n    prev = \"\"\n\n    folder.sort()\n\n    for f in folder:\n      if len(prev) > 0 and f.startswith(prev) and f[len(prev)] == '/':\n        continue\n      ans.append(f)\n      prev = f\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1228, "slug": "missing-number-in-arithmetic-progression", "solutions": ["class Solution:\n    def missingNumber(self, arr: List[int]) -> int:\n        return (arr[0] + arr[-1]) * (len(arr) + 1) // 2 - sum(arr)\n", "class Solution:\n  def missingNumber(self, arr: list[int]) -> int:\n    n = len(arr)\n    delta = (arr[-1] - arr[0]) // n\n    l = 0\n    r = n - 1\n\n    while l < r:\n      m = (l + r) // 2\n      if arr[m] == arr[0] + m * delta:\n        l = m + 1\n      else:\n        r = m\n\n    return arr[0] + l * delta\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1250, "slug": "check-if-it-is-a-good-array", "solutions": ["class Solution:\n    def isGoodArray(self, nums: List[int]) -> bool:\n        return reduce(gcd, nums) == 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1241, "slug": "number-of-comments-per-post", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1288, "slug": "remove-covered-intervals", "solutions": ["class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key=lambda x: (x[0], -x[1]))\n        ans = 0\n        pre = -inf\n        for _, cur in intervals:\n            if cur > pre:\n                ans += 1\n                pre = cur\n        return ans\n", "class Solution:\n  def removeCoveredIntervals(self, intervals: list[list[int]]) -> int:\n    ans = 0\n    prevEnd = 0\n\n    # If the two intervals have the same `start`, put the one with a larger\n    # `end` first.\n    for _, end in sorted(intervals, key=lambda x: (x[0], -x[1])):\n      # The current interval is not covered by the previous one.\n      if prevEnd < end:\n        prevEnd = end\n        ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1210, "slug": "minimum-moves-to-reach-target-with-rotations", "solutions": ["class Solution:\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        def move(i1, j1, i2, j2):\n            if 0 <= i1 < n and 0 <= j1 < n and 0 <= i2 < n and 0 <= j2 < n:\n                a, b = i1 * n + j1, i2 * n + j2\n                status = 0 if i1 == i2 else 1\n                if (a, status) not in vis and grid[i1][j1] == 0 and grid[i2][j2] == 0:\n                    q.append((a, b))\n                    vis.add((a, status))\n\n        n = len(grid)\n        target = (n * n - 2, n * n - 1)\n        q = deque([(0, 1)])\n        vis = {(0, 0)}\n        ans = 0\n        while q:\n            for _ in range(len(q)):\n                a, b = q.popleft()\n                if (a, b) == target:\n                    return ans\n                i1, j1 = a // n, a % n\n                i2, j2 = b // n, b % n\n                # /\n                move(i1, j1 + 1, i2, j2 + 1)\n                # /\n                move(i1 + 1, j1, i2 + 1, j2)\n                #  grid[i1 + 1][j2] 90\n                if i1 == i2 and i1 + 1 < n and grid[i1 + 1][j2] == 0:\n                    move(i1, j1, i1 + 1, j1)\n                #  grid[i2][j1 + 1] 90\n                if j1 == j2 and j1 + 1 < n and grid[i2][j1 + 1] == 0:\n                    move(i1, j1, i1, j1 + 1)\n            ans += 1\n        return -1\n", "from enum import IntEnum\n\n\nclass Pos(IntEnum):\n  HORIZONTAL = 0\n  VERTICAL = 1\n\n\nclass Solution:\n  def minimumMoves(self, grid: list[list[int]]) -> int:\n    n = len(grid)\n    ans = 0\n    # the state of (x, y, pos)\n    # pos := 0 (horizontal) / 1 (vertical)\n    q = collections.deque([(0, 0, Pos.HORIZONTAL)])\n    seen = {(0, 0, Pos.HORIZONTAL)}\n\n    def canMoveRight(x: int, y: int, pos: Pos) -> bool:\n      if pos == Pos.HORIZONTAL:\n        return y + 2 < n and not grid[x][y + 2]\n      return y + 1 < n and not grid[x][y + 1] and not grid[x + 1][y + 1]\n\n    def canMoveDown(x: int, y: int, pos: Pos) -> bool:\n      if pos == Pos.VERTICAL:\n        return x + 2 < n and not grid[x + 2][y]\n      return x + 1 < n and not grid[x + 1][y] and not grid[x + 1][y + 1]\n\n    def canRotateClockwise(x: int, y: int, pos: Pos) -> bool:\n      return (pos == Pos.HORIZONTAL and x + 1 < n and\n              not grid[x + 1][y + 1] and not grid[x + 1][y])\n\n    def canRotateCounterclockwise(x: int, y: int, pos: Pos) -> bool:\n      return (pos == Pos.VERTICAL and y + 1 < n and\n              not grid[x + 1][y + 1] and not grid[x][y + 1])\n\n    while q:\n      for _ in range(len(q)):\n        x, y, pos = q.popleft()\n        if x == n - 1 and y == n - 2 and pos == Pos.HORIZONTAL:\n          return ans\n        if canMoveRight(x, y, pos) and (x, y + 1, pos) not in seen:\n          q.append((x, y + 1, pos))\n          seen.add((x, y + 1, pos))\n        if canMoveDown(x, y, pos) and (x + 1, y, pos) not in seen:\n          q.append((x + 1, y, pos))\n          seen.add((x + 1, y, pos))\n        newPos = Pos.VERTICAL if pos == Pos.HORIZONTAL else Pos.HORIZONTAL\n        if ((canRotateClockwise(x, y, pos) or\n             canRotateCounterclockwise(x, y, pos)) and\n                (x, y, newPos) not in seen):\n          q.append((x, y, newPos))\n          seen.add((x, y, newPos))\n      ans += 1\n\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1280, "slug": "students-and-examinations", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1291, "slug": "sequential-digits", "solutions": ["class Solution:\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\n        ans = []\n        for i in range(1, 9):\n            x = i\n            for j in range(i + 1, 10):\n                x = x * 10 + j\n                if low <= x <= high:\n                    ans.append(x)\n        return sorted(ans)\n", "class Solution:\n  def sequentialDigits(self, low: int, high: int) -> list[int]:\n    ans = []\n    q = collections.deque([num for num in range(1, 10)])\n\n    while q:\n      num = q.popleft()\n      if num > high:\n        return ans\n      if low <= num and num <= high:\n        ans.append(num)\n      lastDigit = num % 10\n      if lastDigit < 9:\n        q.append(num * 10 + lastDigit + 1)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1242, "slug": "web-crawler-multithreaded", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1260, "slug": "shift-2d-grid", "solutions": ["class Solution:\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\n        m, n = len(grid), len(grid[0])\n        ans = [[0] * n for _ in range(m)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                x, y = divmod((i * n + j + k) % (m * n), n)\n                ans[x][y] = v\n        return ans\n", "class Solution:\n  def shiftGrid(self, grid: list[list[int]], k: int) -> list[list[int]]:\n    m = len(grid)\n    n = len(grid[0])\n    ans = [[0] * n for _ in range(m)]\n\n    k %= m * n\n\n    for i in range(m):\n      for j in range(n):\n        index = (i * n + j + k) % (m * n)\n        x = index // n\n        y = index % n\n        ans[x][y] = grid[i][j]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1232, "slug": "check-if-it-is-a-straight-line", "solutions": ["class Solution:\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\n        x1, y1 = coordinates[0]\n        x2, y2 = coordinates[1]\n        for x, y in coordinates[2:]:\n            if (x - x1) * (y2 - y1) != (y - y1) * (x2 - x1):\n                return False\n        return True\n", "class Solution:\n  def checkStraightLine(self, coordinates: list[list[int]]) -> bool:\n    x0, y0, x1, y1 = *coordinates[0], *coordinates[1]\n    dx = x1 - x0\n    dy = y1 - y0\n\n    return all((x - x0) * dy == (y - y0) * dx for x, y in coordinates)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1281, "slug": "subtract-the-product-and-sum-of-digits-of-an-integer", "solutions": ["class Solution:\n    def subtractProductAndSum(self, n: int) -> int:\n        x, y = 1, 0\n        while n:\n            n, v = divmod(n, 10)\n            x *= v\n            y += v\n        return x - y\n", "class Solution:\n  def subtractProductAndSum(self, n: int) -> int:\n    prod = 1\n    summ = 0\n\n    while n > 0:\n      prod *= n % 10\n      summ += n % 10\n      n //= 10\n\n    return prod - summ\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1224, "slug": "maximum-equal-frequency", "solutions": ["class Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        cnt = Counter()\n        ccnt = Counter()\n        ans = mx = 0\n        for i, v in enumerate(nums, 1):\n            if v in cnt:\n                ccnt[cnt[v]] -= 1\n            cnt[v] += 1\n            mx = max(mx, cnt[v])\n            ccnt[cnt[v]] += 1\n            if mx == 1:\n                ans = i\n            elif ccnt[mx] * mx + ccnt[mx - 1] * (mx - 1) == i and ccnt[mx] == 1:\n                ans = i\n            elif ccnt[mx] * mx + 1 == i and ccnt[1] == 1:\n                ans = i\n        return ans\n", "class Solution:\n  def maxEqualFreq(self, nums: list[int]) -> int:\n    ans = 0\n    maxFreq = 0\n    count = collections.Counter()\n    freq = collections.Counter()\n\n    for i, num in enumerate(nums):\n      freq[count[num]] -= 1\n      count[num] += 1\n      freq[count[num]] += 1\n      maxFreq = max(maxFreq, count[num])\n      if maxFreq == 1 or maxFreq * freq[maxFreq] == i or (maxFreq - 1) * (\n              freq[maxFreq - 1] + 1) == i:\n        ans = i + 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1220, "slug": "count-vowels-permutation", "solutions": ["class Solution:\n    def countVowelPermutation(self, n: int) -> int:\n        f = [1] * 5\n        mod = 10**9 + 7\n        for _ in range(n - 1):\n            g = [0] * 5\n            g[0] = (f[1] + f[2] + f[4]) % mod\n            g[1] = (f[0] + f[2]) % mod\n            g[2] = (f[1] + f[3]) % mod\n            g[3] = f[2]\n            g[4] = (f[2] + f[3]) % mod\n            f = g\n        return sum(f) % mod\n", "class Solution:\n  def countVowelPermutation(self, n: int) -> int:\n    MOD = 1_000_000_007\n    dp = {'a': 1, 'e': 1, 'i': 1, 'o': 1, 'u': 1}\n\n    for _ in range(n - 1):\n      newDp = {'a': dp['e'] + dp['i'] + dp['u'],\n               'e': dp['a'] + dp['i'],\n               'i': dp['e'] + dp['o'],\n               'o': dp['i'],\n               'u': dp['i'] + dp['o']}\n      dp = newDp\n\n    return sum(dp.values()) % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1257, "slug": "smallest-common-region", "solutions": ["class Solution:\n    def findSmallestRegion(\n        self, regions: List[List[str]], region1: str, region2: str\n    ) -> str:\n        g = {}\n        for r in regions:\n            x = r[0]\n            for y in r[1:]:\n                g[y] = x\n        s = set()\n        x = region1\n        while x in g:\n            s.add(x)\n            x = g[x]\n        x = region2\n        while x in g and x not in s:\n            x = g[x]\n        return x\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1202, "slug": "smallest-string-with-swaps", "solutions": ["class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        def find(x: int) -> int:\n            if p[x] != x:\n                p[x] = find(p[x])\n            return p[x]\n\n        n = len(s)\n        p = list(range(n))\n        for a, b in pairs:\n            p[find(a)] = find(b)\n        d = defaultdict(list)\n        for i, c in enumerate(s):\n            d[find(i)].append(c)\n        for i in d.keys():\n            d[i].sort(reverse=True)\n        return \"\".join(d[find(i)].pop() for i in range(n))\n", "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def smallestStringWithSwaps(self, s: str, pairs: list[list[int]]) -> str:\n    uf = UnionFind(len(s))\n    indexToLetters = collections.defaultdict(list)\n\n    for a, b in pairs:\n      uf.unionByRank(a, b)\n\n    for i, c in enumerate(s):\n      indexToLetters[uf.find(i)].append(c)\n\n    for key in indexToLetters.keys():\n      indexToLetters[key].sort(reverse=True)\n\n    return ''.join(indexToLetters[uf.find(i)].pop()\n                   for i in range(len(s)))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1238, "slug": "circular-permutation-in-binary-representation", "solutions": ["class Solution:\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        g = [i ^ (i >> 1) for i in range(1 << n)]\n        j = g.index(start)\n        return g[j:] + g[:j]\n", "class Solution:\n  def circularPermutation(self, n: int, start: int) -> list[int]:\n    return [start ^ i ^ i >> 1 for i in range(1 << n)]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1221, "slug": "split-a-string-in-balanced-strings", "solutions": ["class Solution:\n    def balancedStringSplit(self, s: str) -> int:\n        ans = l = 0\n        for c in s:\n            if c == 'L':\n                l += 1\n            else:\n                l -= 1\n            if l == 0:\n                ans += 1\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1235, "slug": "maximum-profit-in-job-scheduling", "solutions": ["class Solution:\n    def jobScheduling(\n        self, startTime: List[int], endTime: List[int], profit: List[int]\n    ) -> int:\n        @cache\n        def dfs(i):\n            if i >= n:\n                return 0\n            _, e, p = jobs[i]\n            j = bisect_left(jobs, e, lo=i + 1, key=lambda x: x[0])\n            return max(dfs(i + 1), p + dfs(j))\n\n        jobs = sorted(zip(startTime, endTime, profit))\n        n = len(profit)\n        return dfs(0)\n", "class Solution:\n  def jobScheduling(\n      self,\n      startTime: list[int],\n      endTime: list[int],\n      profit: list[int],\n  ) -> int:\n    jobs = sorted([(s, e, p) for s, e, p in zip(startTime, endTime, profit)])\n\n    # Will use binary search to find the first available startTime\n    for i in range(len(startTime)):\n      startTime[i] = jobs[i][0]\n\n    @functools.lru_cache(None)\n    def dp(i: int) -> int:\n      \"\"\"Returns the maximum profit to schedule jobs[i..n).\"\"\"\n      if i == len(startTime):\n        return 0\n      j = bisect.bisect_left(startTime, jobs[i][1])\n      return max(jobs[i][2] + dp(j), dp(i + 1))\n\n    return dp(0)\n", "class Solution:\n  def jobScheduling(\n      self,\n      startTime: list[int],\n      endTime: list[int],\n      profit: list[int],\n  ) -> int:\n    # dp[i] := the maximum profit to schedule jobs[i..n)\n    dp = [0] * (len(startTime) + 1)\n    jobs = sorted([(s, e, p) for s, e, p in zip(startTime, endTime, profit)])\n\n    for i in range(len(startTime)):\n      startTime[i] = jobs[i][0]\n\n    for i in reversed(range(len(startTime))):\n      j = bisect.bisect_left(startTime, jobs[i][1])\n      dp[i] = max(jobs[i][2] + dp[j], dp[i + 1])\n\n    return dp[0]\n", "class Solution:\n  def jobScheduling(\n      self,\n      startTime: list[int],\n      endTime: list[int],\n      profit: list[int],\n  ) -> int:\n    maxProfit = 0\n    jobs = sorted([(s, e, p) for s, e, p in zip(startTime, endTime, profit)])\n    minHeap = []  # (endTime, profit)\n\n    # Will use binary search to find the first available startTime\n    for i in range(len(startTime)):\n      startTime[i] = jobs[i][0]\n\n    for s, e, p in jobs:\n      while minHeap and s >= minHeap[0][0]:\n        maxProfit = max(maxProfit, heapq.heappop(minHeap)[1])\n      heapq.heappush(minHeap, (e, p + maxProfit))\n\n    return max(maxProfit, max(p for _, p in minHeap))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1206, "slug": "design-skiplist", "solutions": ["class Node:\n    __slots__ = ['val', 'next']\n\n    def __init__(self, val: int, level: int):\n        self.val = val\n        self.next = [None] * level\n\n\nclass Skiplist:\n    max_level = 32\n    p = 0.25\n\n    def __init__(self):\n        self.head = Node(-1, self.max_level)\n        self.level = 0\n\n    def search(self, target: int) -> bool:\n        curr = self.head\n        for i in range(self.level - 1, -1, -1):\n            curr = self.find_closest(curr, i, target)\n            if curr.next[i] and curr.next[i].val == target:\n                return True\n        return False\n\n    def add(self, num: int) -> None:\n        curr = self.head\n        level = self.random_level()\n        node = Node(num, level)\n        self.level = max(self.level, level)\n        for i in range(self.level - 1, -1, -1):\n            curr = self.find_closest(curr, i, num)\n            if i < level:\n                node.next[i] = curr.next[i]\n                curr.next[i] = node\n\n    def erase(self, num: int) -> bool:\n        curr = self.head\n        ok = False\n        for i in range(self.level - 1, -1, -1):\n            curr = self.find_closest(curr, i, num)\n            if curr.next[i] and curr.next[i].val == num:\n                curr.next[i] = curr.next[i].next[i]\n                ok = True\n        while self.level > 1 and self.head.next[self.level - 1] is None:\n            self.level -= 1\n        return ok\n\n    def find_closest(self, curr: Node, level: int, target: int) -> Node:\n        while curr.next[level] and curr.next[level].val < target:\n            curr = curr.next[level]\n        return curr\n\n    def random_level(self) -> int:\n        level = 1\n        while level < self.max_level and random.random() < self.p:\n            level += 1\n        return level\n\n\n# Your Skiplist object will be instantiated and called as such:\n# obj = Skiplist()\n# param_1 = obj.search(target)\n# obj.add(num)\n# param_3 = obj.erase(num)\n", "from dataclasses import dataclass\n\n\n@dataclass\nclass Node:\n  val: int = -1\n  next: 'Node' = None\n  down: 'Node' = None\n\n\nclass Skiplist:\n  def __init__(self):\n    self.dummy = Node()\n\n  def search(self, target: int) -> bool:\n    node = self.dummy\n    while node:\n      while node.next and node.next.val < target:\n        node = node.next\n      if node.next and node.next.val == target:\n        return True\n      # Move to the next level\n      node = node.down\n    return False\n\n  def add(self, num: int) -> None:\n    # Collect nodes that are before the insertion point.\n    nodes = []\n    node = self.dummy\n    while node:\n      while node.next and node.next.val < num:\n        node = node.next\n      nodes.append(node)\n      # Move to the next level\n      node = node.down\n\n    shouldInsert = True\n    down = None\n    while shouldInsert and nodes:\n      node = nodes.pop()\n      node.next = Node(num, node.next, down)\n      down = node.next\n      shouldInsert = random.getrandbits(1) == 0\n\n    # Create a topmost new level dummy that points to the existing dummy.\n    if shouldInsert:\n      self.dummy = Node(-1, None, self.dummy)\n\n  def erase(self, num: int) -> bool:\n    node = self.dummy\n    found = False\n    while node:\n      while node.next and node.next.val < num:\n        node = node.next\n      if node.next and node.next.val == num:\n        # Delete the node\n        node.next = node.next.next\n        found = True\n      # Move to the next level\n      node = node.down\n    return found\n\n  # Move to the node s.t. node.next.val >= target\n  def _advance(self, node: Node, target: int) -> None:\n    while node.next and node.next.val < target:\n      node = node.next\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1284, "slug": "minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix", "solutions": ["class Solution:\n    def minFlips(self, mat: List[List[int]]) -> int:\n        m, n = len(mat), len(mat[0])\n        state = sum(1 << (i * n + j) for i in range(m) for j in range(n) if mat[i][j])\n        q = deque([state])\n        vis = {state}\n        ans = 0\n        dirs = [0, -1, 0, 1, 0, 0]\n        while q:\n            for _ in range(len(q)):\n                state = q.popleft()\n                if state == 0:\n                    return ans\n                for i in range(m):\n                    for j in range(n):\n                        nxt = state\n                        for k in range(5):\n                            x, y = i + dirs[k], j + dirs[k + 1]\n                            if not 0 <= x < m or not 0 <= y < n:\n                                continue\n                            if nxt & (1 << (x * n + y)):\n                                nxt -= 1 << (x * n + y)\n                            else:\n                                nxt |= 1 << (x * n + y)\n                        if nxt not in vis:\n                            vis.add(nxt)\n                            q.append(nxt)\n            ans += 1\n        return -1\n", "class Solution:\n  def minFlips(self, mat: list[list[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    hash = self._getHash(mat, m, n)\n    if hash == 0:\n      return 0\n\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    step = 0\n    q = collections.deque([hash])\n    seen = {hash}\n\n    while q:\n      step += 1\n      for _ in range(len(q)):\n        curr = q.popleft()\n        for i in range(m):\n          for j in range(n):\n            next = curr ^ 1 << (i * n + j)\n            # Flie the four neighbors.\n            for dx, dy in DIRS:\n              x = i + dx\n              y = j + dy\n              if x < 0 or x == m or y < 0 or y == n:\n                continue\n              next ^= 1 << (x * n + y)\n            if next == 0:\n              return step\n            if next in seen:\n              continue\n            q.append(next)\n            seen.add(next)\n\n    return -1\n\n  def _getHash(self, mat: list[list[int]], m: int, n: int) -> int:\n    hash = 0\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j]:\n          hash |= 1 << (i * n + j)\n    return hash\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1226, "slug": "the-dining-philosophers", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1227, "slug": "airplane-seat-assignment-probability", "solutions": ["class Solution:\n    def nthPersonGetsNthSeat(self, n: int) -> float:\n        return 1 if n == 1 else 0.5\n", "class Solution:\n  def nthPersonGetsNthSeat(self, n: int) -> float:\n    return 1 if n == 1 else 0.5\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1287, "slug": "element-appearing-more-than-25-in-sorted-array", "solutions": ["class Solution:\n    def findSpecialInteger(self, arr: List[int]) -> int:\n        n = len(arr)\n        for i, x in enumerate(arr):\n            if x == arr[(i + (n >> 2))]:\n                return x\n", "class Solution:\n  def findSpecialInteger(self, arr: list[int]) -> int:\n    n = len(arr)\n    quarter = n // 4\n\n    for i in range(n - quarter):\n      if arr[i] == arr[i + quarter]:\n        return arr[i]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1225, "slug": "report-contiguous-dates", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1207, "slug": "unique-number-of-occurrences", "solutions": ["class Solution:\n    def uniqueOccurrences(self, arr: List[int]) -> bool:\n        cnt = Counter(arr)\n        return len(set(cnt.values())) == len(cnt)\n", "class Solution:\n  def uniqueOccurrences(self, arr: list[int]) -> bool:\n    count = collections.Counter(arr)\n    occurrences = set()\n\n    for value in count.values():\n      if value in occurrences:\n        return False\n      occurrences.add(value)\n\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1213, "slug": "intersection-of-three-sorted-arrays", "solutions": ["class Solution:\n    def arraysIntersection(\n        self, arr1: List[int], arr2: List[int], arr3: List[int]\n    ) -> List[int]:\n        cnt = Counter(arr1 + arr2 + arr3)\n        return [x for x in arr1 if cnt[x] == 3]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1251, "slug": "average-selling-price", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1282, "slug": "group-the-people-given-the-group-size-they-belong-to", "solutions": ["class Solution:\n    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:\n        g = defaultdict(list)\n        for i, v in enumerate(groupSizes):\n            g[v].append(i)\n        return [v[j : j + i] for i, v in g.items() for j in range(0, len(v), i)]\n", "class Solution:\n  def groupThePeople(self, groupSizes: list[int]) -> list[list[int]]:\n    ans = []\n    groupSizeToIndices = defaultdict(list)\n\n    for i, groupSize in enumerate(groupSizes):\n      groupSizeToIndices[groupSize].append(i)\n\n    for groupSize, indices in groupSizeToIndices.items():\n      groupIndices = []\n      for index in indices:\n        groupIndices.append(index)\n        if len(groupIndices) == groupSize:\n          ans.append(groupIndices.copy())\n          groupIndices.clear()\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1215, "slug": "stepping-numbers", "solutions": ["class Solution:\n    def countSteppingNumbers(self, low: int, high: int) -> List[int]:\n        ans = []\n        if low == 0:\n            ans.append(0)\n        q = deque(range(1, 10))\n        while q:\n            v = q.popleft()\n            if v > high:\n                break\n            if v >= low:\n                ans.append(v)\n            x = v % 10\n            if x:\n                q.append(v * 10 + x - 1)\n            if x < 9:\n                q.append(v * 10 + x + 1)\n        return ans\n", "class Solution:\n  def countSteppingNumbers(self, low: int, high: int) -> list[int]:\n    ans = [0] if low == 0 else []\n    q = collections.deque(list(range(1, 10)))\n\n    while q:\n      curr = q.popleft()\n      if curr > high:\n        continue\n      if curr >= low:\n        ans.append(curr)\n      lastDigit = curr % 10\n      if lastDigit > 0:\n        q.append(curr * 10 + lastDigit - 1)\n      if lastDigit < 9:\n        q.append(curr * 10 + lastDigit + 1)\n\n    return ans\n", "class Solution:\n  def countSteppingNumbers(self, low: int, high: int) -> list[int]:\n    ans = [0] if low == 0 else []\n\n    def dfs(curr: int) -> None:\n      if curr > high:\n        return\n      if curr >= low:\n        ans.append(curr)\n\n      lastDigit = curr % 10\n      if lastDigit > 0:\n        dfs(curr * 10 + lastDigit - 1)\n      if lastDigit < 9:\n        dfs(curr * 10 + lastDigit + 1)\n\n    for i in range(1, 9 + 1):\n      dfs(i)\n\n    ans.sort()\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1201, "slug": "ugly-number-iii", "solutions": ["class Solution:\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\n        ab = lcm(a, b)\n        bc = lcm(b, c)\n        ac = lcm(a, c)\n        abc = lcm(a, b, c)\n        l, r = 1, 2 * 10**9\n        while l < r:\n            mid = (l + r) >> 1\n            if (\n                mid // a\n                + mid // b\n                + mid // c\n                - mid // ab\n                - mid // bc\n                - mid // ac\n                + mid // abc\n                >= n\n            ):\n                r = mid\n            else:\n                l = mid + 1\n        return l\n", "class Solution:\n  def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\n    ab = a * b // math.gcd(a, b)\n    ac = a * c // math.gcd(a, c)\n    bc = b * c // math.gcd(b, c)\n    abc = a * bc // math.gcd(a, bc)\n    return bisect.bisect_left(range(2 * 10**9), n,\n                              key=lambda m: m // a + m // b + m // c\n                              - m // ab - m // ac - m // bc\n                              + m // abc)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1230, "slug": "toss-strange-coins", "solutions": ["class Solution:\n    def probabilityOfHeads(self, prob: List[float], target: int) -> float:\n        n = len(prob)\n        f = [[0] * (target + 1) for _ in range(n + 1)]\n        f[0][0] = 1\n        for i, p in enumerate(prob, 1):\n            for j in range(min(i, target) + 1):\n                f[i][j] = (1 - p) * f[i - 1][j]\n                if j:\n                    f[i][j] += p * f[i - 1][j - 1]\n        return f[n][target]\n", "class Solution:\n  def probabilityOfHeads(self, prob: list[float], target: int) -> float:\n    # dp[j] := the probability of tossing the coins so far with j heads\n    dp = [1.0] + [0] * len(prob)\n\n    for p in prob:\n      for j in range(target, -1, -1):\n        dp[j] = (dp[j - 1] * p if j > 0 else 0) + dp[j] * (1 - p)\n\n    return dp[target]\n", "class Solution:\n  def probabilityOfHeads(self, prob: list[float], target: int) -> float:\n    # dp[i][j] := the probability of tossing the first i coins with j heads\n    dp = [[0] * (target + 1) for _ in range(len(prob) + 1)]\n    dp[0][0] = 1.0\n\n    for i in range(1, len(prob) + 1):\n      for j in range(target + 1):\n        dp[i][j] = ((dp[i - 1][j - 1] * prob[i - 1] if j > 0 else 0) +\n                    dp[i - 1][j] * (1 - prob[i - 1]))\n\n    return dp[len(prob)][target]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1271, "slug": "hexspeak", "solutions": ["class Solution:\n    def toHexspeak(self, num: str) -> str:\n        s = set('ABCDEFIO')\n        t = hex(int(num))[2:].upper().replace('0', 'O').replace('1', 'I')\n        return t if all(c in s for c in t) else 'ERROR'\n", "class Solution:\n  def toHexspeak(self, num: str) -> str:\n    s = hex(int(num)).upper()[2:].translate(str.maketrans('01', 'OI'))\n    return 'ERROR' if any(c.isdigit() for c in s) else s\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1229, "slug": "meeting-scheduler", "solutions": ["class Solution:\n    def minAvailableDuration(\n        self, slots1: List[List[int]], slots2: List[List[int]], duration: int\n    ) -> List[int]:\n        slots1.sort()\n        slots2.sort()\n        m, n = len(slots1), len(slots2)\n        i = j = 0\n        while i < m and j < n:\n            start = max(slots1[i][0], slots2[j][0])\n            end = min(slots1[i][1], slots2[j][1])\n            if end - start >= duration:\n                return [start, start + duration]\n            if slots1[i][1] < slots2[j][1]:\n                i += 1\n            else:\n                j += 1\n        return []\n", "class Solution:\n  def minAvailableDuration(\n      self,\n      slots1: list[list[int]],\n      slots2: list[list[int]],\n      duration: int,\n  ) -> list[int]:\n    slots1.sort()\n    slots2.sort()\n\n    i = 0  # slots1's index\n    j = 0  # slots2's index\n\n    while i < len(slots1) and j < len(slots2):\n      start = max(slots1[i][0], slots2[j][0])\n      end = min(slots1[i][1], slots2[j][1])\n      if start + duration <= end:\n        return [start, start + duration]\n      if slots1[i][1] < slots2[j][1]:\n        i += 1\n      else:\n        j += 1\n\n    return []\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1296, "slug": "divide-array-in-sets-of-k-consecutive-numbers", "solutions": ["class Solution:\n    def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        if len(nums) % k:\n            return False\n        cnt = Counter(nums)\n        for x in sorted(nums):\n            if cnt[x]:\n                for y in range(x, x + k):\n                    if cnt[y] == 0:\n                        return False\n                    cnt[y] -= 1\n        return True\n", "class Solution:\n  def isPossibleDivide(self, nums: list[int], k: int) -> bool:\n    count = collections.Counter(nums)\n\n    for start in sorted(count):\n      value = count[start]\n      if value > 0:\n        for i in range(start, start + k):\n          count[i] -= value\n          if count[i] < 0:\n            return False\n\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1245, "slug": "tree-diameter", "solutions": ["class Solution:\n    def treeDiameter(self, edges: List[List[int]]) -> int:\n        def dfs(i: int, fa: int, t: int):\n            for j in g[i]:\n                if j != fa:\n                    dfs(j, i, t + 1)\n            nonlocal ans, a\n            if ans < t:\n                ans = t\n                a = i\n\n        g = defaultdict(list)\n        for a, b in edges:\n            g[a].append(b)\n            g[b].append(a)\n        ans = a = 0\n        dfs(0, -1, 0)\n        dfs(a, -1, 0)\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1204, "slug": "last-person-to-fit-in-the-bus", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1264, "slug": "page-recommendations", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1203, "slug": "sort-items-by-groups-respecting-dependencies", "solutions": ["class Solution:\n    def sortItems(\n        self, n: int, m: int, group: List[int], beforeItems: List[List[int]]\n    ) -> List[int]:\n        def topo_sort(degree, graph, items):\n            q = deque(i for _, i in enumerate(items) if degree[i] == 0)\n            res = []\n            while q:\n                i = q.popleft()\n                res.append(i)\n                for j in graph[i]:\n                    degree[j] -= 1\n                    if degree[j] == 0:\n                        q.append(j)\n            return res if len(res) == len(items) else []\n\n        idx = m\n        group_items = [[] for _ in range(n + m)]\n        for i, g in enumerate(group):\n            if g == -1:\n                group[i] = idx\n                idx += 1\n            group_items[group[i]].append(i)\n\n        item_degree = [0] * n\n        group_degree = [0] * (n + m)\n        item_graph = [[] for _ in range(n)]\n        group_graph = [[] for _ in range(n + m)]\n        for i, gi in enumerate(group):\n            for j in beforeItems[i]:\n                gj = group[j]\n                if gi == gj:\n                    item_degree[i] += 1\n                    item_graph[j].append(i)\n                else:\n                    group_degree[gi] += 1\n                    group_graph[gj].append(gi)\n\n        group_order = topo_sort(group_degree, group_graph, range(n + m))\n        if not group_order:\n            return []\n        ans = []\n        for gi in group_order:\n            items = group_items[gi]\n            item_order = topo_sort(item_degree, item_graph, items)\n            if len(items) != len(item_order):\n                return []\n            ans.extend(item_order)\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1285, "slug": "find-the-start-and-end-number-of-continuous-ranges", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1295, "slug": "find-numbers-with-even-number-of-digits", "solutions": ["class Solution:\n    def findNumbers(self, nums: List[int]) -> int:\n        return sum(len(str(x)) % 2 == 0 for x in nums)\n", "class Solution:\n  def findNumbers(self, nums: list[int]) -> int:\n    ans = 0\n\n    for num in nums:\n      if 9 < num < 100 or 999 < num < 10000 or num == 100000:\n        ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1217, "slug": "minimum-cost-to-move-chips-to-the-same-position", "solutions": ["class Solution:\n    def minCostToMoveChips(self, position: List[int]) -> int:\n        a = sum(p % 2 for p in position)\n        b = len(position) - a\n        return min(a, b)\n", "class Solution:\n  def minCostToMoveChips(self, position: list[int]) -> int:\n    count = [0, 0]\n    for p in position:\n      count[p % 2] += 1\n    return min(count[0], count[1])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1256, "slug": "encode-number", "solutions": ["class Solution:\n    def encode(self, num: int) -> str:\n        return bin(num + 1)[3:]\n", "class Solution:\n  def encode(self, num: int) -> str:\n    return bin(num + 1)[3:]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1279, "slug": "traffic-light-controlled-intersection", "solutions": ["from threading import Lock\n\n\nclass TrafficLight:\n    def __init__(self):\n        self.lock = Lock()\n        self.road = 1\n\n    def carArrived(\n        self,\n        carId: int,  # ID of the car\n        # ID of the road the car travels on. Can be 1 (road A) or 2 (road B)\n        roadId: int,\n        direction: int,  # Direction of the car\n        # Use turnGreen() to turn light to green on current road\n        turnGreen: 'Callable[[], None]',\n        # Use crossCar() to make car cross the intersection\n        crossCar: 'Callable[[], None]',\n    ) -> None:\n        self.lock.acquire()\n        if self.road != roadId:\n            self.road = roadId\n            turnGreen()\n        crossCar()\n        self.lock.release()\n", "class TrafficLight:\n  def __init__(self):\n    self.canPassRoadId = 1  # 1 := road A, 2 := road B\n\n  def carArrived(\n      self,\n      # ID of the car\n      carId: int,\n      # ID of the road the car travels on. Can be 1 (road A) or 2 (road B).\n      roadId: int,\n      # direction of the car\n      direction: int,\n      # Use turnGreen() to turn light to green on current road.\n      turnGreen: Callable[[], None],\n      # Use crossCar() to make car cross the intersection.\n      crossCar: Callable[[], None]\n  ) -> None:\n    if roadId != self.canPassRoadId:\n      self.canPassRoadId = roadId\n      turnGreen()\n    crossCar()\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1262, "slug": "greatest-sum-divisible-by-three", "solutions": ["class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        n = len(nums)\n        f = [[-inf] * 3 for _ in range(n + 1)]\n        f[0][0] = 0\n        for i, x in enumerate(nums, 1):\n            for j in range(3):\n                f[i][j] = max(f[i - 1][j], f[i - 1][(j - x) % 3] + x)\n        return f[n][0]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1216, "slug": "valid-palindrome-iii", "solutions": ["class Solution:\n    def isValidPalindrome(self, s: str, k: int) -> bool:\n        n = len(s)\n        f = [[0] * n for _ in range(n)]\n        for i in range(n):\n            f[i][i] = 1\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    f[i][j] = f[i + 1][j - 1] + 2\n                else:\n                    f[i][j] = max(f[i + 1][j], f[i][j - 1])\n                if f[i][j] + k >= n:\n                    return True\n        return False\n", "class Solution:\n  def isValidPalindrome(self, s: str, k: int) -> bool:\n    return len(s) - self._longestPalindromeSubseq(s) <= k\n\n  # Same as 516. Longest Palindromic Subsequence\n  def _longestPalindromeSubseq(self, s: str) -> int:\n    n = len(s)\n    # dp[i][j] := the length of LPS(s[i..j])\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i] = 1\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        if s[i] == s[j]:\n          dp[i][j] = 2 + dp[i + 1][j - 1]\n        else:\n          dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n\n    return dp[0][n - 1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1209, "slug": "remove-all-adjacent-duplicates-in-string-ii", "solutions": ["class Solution:\n    def removeDuplicates(self, s: str, k: int) -> str:\n        t = []\n        i, n = 0, len(s)\n        while i < n:\n            j = i\n            while j < n and s[j] == s[i]:\n                j += 1\n            cnt = j - i\n            cnt %= k\n            if t and t[-1][0] == s[i]:\n                t[-1][1] = (t[-1][1] + cnt) % k\n                if t[-1][1] == 0:\n                    t.pop()\n            elif cnt:\n                t.append([s[i], cnt])\n            i = j\n        ans = [c * v for c, v in t]\n        return \"\".join(ans)\n", "class Solution:\n  def removeDuplicates(self, s: str, k: int) -> str:\n    stack = []\n\n    for c in s:\n      if not stack or stack[-1][0] != c:\n        stack.append([c, 1])\n      else:  # stack[-1][0] == c\n        stack[-1][1] += 1\n        if stack[-1][1] == k:\n          stack.pop()\n\n    return ''.join(c * count for c, count in stack)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1261, "slug": "find-elements-in-a-contaminated-binary-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass FindElements:\n\n    def __init__(self, root: Optional[TreeNode]):\n        def dfs(root: Optional[TreeNode]):\n            self.s.add(root.val)\n            if root.left:\n                root.left.val = root.val * 2 + 1\n                dfs(root.left)\n            if root.right:\n                root.right.val = root.val * 2 + 2\n                dfs(root.right)\n\n        root.val = 0\n        self.s = set()\n        dfs(root)\n\n    def find(self, target: int) -> bool:\n        return target in self.s\n\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)\n", "class FindElements:\n  def __init__(self, root: TreeNode | None):\n    self.vals = set()\n    self.dfs(root, 0)\n\n  def find(self, target: int) -> bool:\n    return target in self.vals\n\n  def dfs(self, root: TreeNode | None, val: int) -> None:\n    if not root:\n      return\n\n    root.val = val\n    self.vals.add(val)\n    self.dfs(root.left, val * 2 + 1)\n    self.dfs(root.right, val * 2 + 2)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1205, "slug": "monthly-transactions-ii", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1292, "slug": "maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold", "solutions": ["class Solution:\n    def maxSideLength(self, mat: List[List[int]], threshold: int) -> int:\n        def check(k: int) -> bool:\n            for i in range(m - k + 1):\n                for j in range(n - k + 1):\n                    v = s[i + k][j + k] - s[i][j + k] - s[i + k][j] + s[i][j]\n                    if v <= threshold:\n                        return True\n            return False\n\n        m, n = len(mat), len(mat[0])\n        s = [[0] * (n + 1) for _ in range(m + 1)]\n        for i, row in enumerate(mat, 1):\n            for j, x in enumerate(row, 1):\n                s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + x\n        l, r = 0, min(m, n)\n        while l < r:\n            mid = (l + r + 1) >> 1\n            if check(mid):\n                l = mid\n            else:\n                r = mid - 1\n        return l\n", "class Solution:\n  def maxSideLength(self, mat: list[list[int]], threshold: int) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    ans = 0\n    prefix = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m):\n      for j in range(n):\n        prefix[i + 1][j + 1] = (mat[i][j] + prefix[i][j + 1] +\n                                prefix[i + 1][j] - prefix[i][j])\n\n    def squareSum(r1: int, c1: int, r2: int, c2: int) -> int:\n      return prefix[r2 + 1][c2 + 1] - prefix[r1][c2 + 1] - prefix[r2 + 1][c1] + prefix[r1][c1]\n\n    for i in range(m):\n      for j in range(n):\n        for length in range(ans, min(m - i, n - j)):\n          if squareSum(i, j, i + length, j + length) > threshold:\n            break\n          ans = max(ans, length + 1)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1289, "slug": "minimum-falling-path-sum-ii", "solutions": ["class Solution:\n    def minFallingPathSum(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        f = [0] * n\n        for row in grid:\n            g = row[:]\n            for i in range(n):\n                g[i] += min((f[j] for j in range(n) if j != i), default=0)\n            f = g\n        return min(f)\n", "class Solution:\n  def minFallingPathSum(self, grid: list[list[int]]) -> int:\n    n = len(grid)\n\n    for i in range(1, n):\n      (firstMinNum, firstMinIndex), (secondMinNum, _) = sorted(\n          {(a, i) for i, a in enumerate(grid[i - 1])})[:2]\n      for j in range(n):\n        if j == firstMinIndex:\n          grid[i][j] += secondMinNum\n        else:\n          grid[i][j] += firstMinNum\n\n    return min(grid[-1])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1244, "slug": "design-a-leaderboard", "solutions": ["class Leaderboard:\n    def __init__(self):\n        self.d = defaultdict(int)\n        self.rank = SortedList()\n\n    def addScore(self, playerId: int, score: int) -> None:\n        if playerId not in self.d:\n            self.d[playerId] = score\n            self.rank.add(score)\n        else:\n            self.rank.remove(self.d[playerId])\n            self.d[playerId] += score\n            self.rank.add(self.d[playerId])\n\n    def top(self, K: int) -> int:\n        return sum(self.rank[-K:])\n\n    def reset(self, playerId: int) -> None:\n        self.rank.remove(self.d.pop(playerId))\n\n\n# Your Leaderboard object will be instantiated and called as such:\n# obj = Leaderboard()\n# obj.addScore(playerId,score)\n# param_2 = obj.top(K)\n# obj.reset(playerId)\n", "class Leaderboard:\n  def __init__(self):\n    self.idToScore = collections.Counter()\n\n  def addScore(self, playerId: int, score: int) -> None:\n    self.idToScore[playerId] += score\n\n  def top(self, K: int) -> int:\n    return sum(score for _, score in self.idToScore.most_common(K))\n\n  def reset(self, playerId: int) -> None:\n    del self.idToScore[playerId]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1240, "slug": "tiling-a-rectangle-with-the-fewest-squares", "solutions": ["class Solution:\n    def tilingRectangle(self, n: int, m: int) -> int:\n        def dfs(i: int, j: int, t: int):\n            nonlocal ans\n            if j == m:\n                i += 1\n                j = 0\n            if i == n:\n                ans = t\n                return\n            if filled[i] >> j & 1:\n                dfs(i, j + 1, t)\n            elif t + 1 < ans:\n                r = c = 0\n                for k in range(i, n):\n                    if filled[k] >> j & 1:\n                        break\n                    r += 1\n                for k in range(j, m):\n                    if filled[i] >> k & 1:\n                        break\n                    c += 1\n                mx = r if r < c else c\n                for w in range(1, mx + 1):\n                    for k in range(w):\n                        filled[i + w - 1] |= 1 << (j + k)\n                        filled[i + k] |= 1 << (j + w - 1)\n                    dfs(i, j + w, t + 1)\n                for x in range(i, i + mx):\n                    for y in range(j, j + mx):\n                        filled[x] ^= 1 << y\n\n        ans = n * m\n        filled = [0] * n\n        dfs(0, 0, 0)\n        return ans\n", "class Solution:\n  def tilingRectangle(self, n: int, m: int) -> int:\n    @functools.lru_cache(None)\n    def dp(heights: int) -> int:\n      minHeight = min(heights)\n      if minHeight == n:  # All filled.\n        return 0\n\n      ans = m * n\n      heightsList = list(heights)\n      start = heightsList.index(minHeight)\n\n      # Try to put square of different size that doesn't exceed the width/height.\n      for sz in range(1, min(m - start + 1, n - minHeight + 1)):\n        # heights[start..start + sz) must has the same height.\n        if heights[start + sz - 1] != minHeight:\n          break\n        # Put a square of size `sz` to cover heights[start..start + sz).\n        heightslist[start:start + sz] = [minHeight + sz] * sz\n        ans = min(ans, dp(tuple(heightsList)))\n\n      return 1 + ans\n\n    return dp(tuple([0] * m))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1298, "slug": "maximum-candies-you-can-get-from-boxes", "solutions": ["class Solution:\n    def maxCandies(\n        self,\n        status: List[int],\n        candies: List[int],\n        keys: List[List[int]],\n        containedBoxes: List[List[int]],\n        initialBoxes: List[int],\n    ) -> int:\n        q = deque([i for i in initialBoxes if status[i] == 1])\n        ans = sum(candies[i] for i in initialBoxes if status[i] == 1)\n        has = set(initialBoxes)\n        took = {i for i in initialBoxes if status[i] == 1}\n\n        while q:\n            i = q.popleft()\n            for k in keys[i]:\n                status[k] = 1\n                if k in has and k not in took:\n                    ans += candies[k]\n                    took.add(k)\n                    q.append(k)\n            for j in containedBoxes[i]:\n                has.add(j)\n                if status[j] and j not in took:\n                    ans += candies[j]\n                    took.add(j)\n                    q.append(j)\n        return ans\n", "class Solution:\n  def maxCandies(\n      self,\n      status: list[int],\n      candies: list[int],\n      keys: list[list[int]],\n      containedBoxes: list[list[int]],\n      initialBoxes: list[int],\n  ) -> int:\n    ans = 0\n    q = collections.deque()\n    reachedClosedBoxes = [0] * len(status)\n\n    def pushBoxesIfPossible(boxes: list[int]) -> None:\n      for box in boxes:\n        if status[box]:\n          q.append(box)\n        else:\n          reachedClosedBoxes[box] = True\n\n    pushBoxesIfPossible(initialBoxes)\n\n    while q:\n      currBox = q.popleft()\n\n      # Add the candies.\n      ans += candies[currBox]\n\n      # Push `reachedClosedBoxes` by `key` obtained in this turn and change\n      # their statuses.\n      for key in keys[currBox]:\n        if not status[key] and reachedClosedBoxes[key]:\n          q.append(key)\n        status[key] = 1  # boxes[key] is now open\n\n      # Push the boxes contained in `currBox`.\n      pushBoxesIfPossible(containedBoxes[currBox])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1294, "slug": "weather-type-in-each-country", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1277, "slug": "count-square-submatrices-with-all-ones", "solutions": ["class Solution:\n    def countSquares(self, matrix: List[List[int]]) -> int:\n        m, n = len(matrix), len(matrix[0])\n        f = [[0] * n for _ in range(m)]\n        ans = 0\n        for i, row in enumerate(matrix):\n            for j, v in enumerate(row):\n                if v == 0:\n                    continue\n                if i == 0 or j == 0:\n                    f[i][j] = 1\n                else:\n                    f[i][j] = min(f[i - 1][j - 1], f[i - 1][j], f[i][j - 1]) + 1\n                ans += f[i][j]\n        return ans\n", "class Solution:\n  def countSquares(self, matrix: list[list[int]]) -> int:\n    for i in range(len(matrix)):\n      for j in range(len(matrix[0])):\n        if matrix[i][j] == 1 and i > 0 and j > 0:\n          matrix[i][j] += min(matrix[i - 1][j - 1],\n                              matrix[i - 1][j], matrix[i][j - 1])\n    return sum(map(sum, matrix))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1222, "slug": "queens-that-can-attack-the-king", "solutions": ["class Solution:\n    def queensAttacktheKing(\n        self, queens: List[List[int]], king: List[int]\n    ) -> List[List[int]]:\n        n = 8\n        s = {(i, j) for i, j in queens}\n        ans = []\n        for a in range(-1, 2):\n            for b in range(-1, 2):\n                if a or b:\n                    x, y = king\n                    while 0 <= x + a < n and 0 <= y + b < n:\n                        x, y = x + a, y + b\n                        if (x, y) in s:\n                            ans.append([x, y])\n                            break\n        return ans\n", "class Solution:\n  def queensAttacktheKing(self, queens: list[list[int]],\n                          king: list[int]) -> list[list[int]]:\n    ans = []\n    queens = {(i, j) for i, j in queens}\n\n    for d in [\n        [-1, -1],\n        [-1, 0],\n        [-1, 1],\n        [0, -1],\n        [0, 1],\n        [1, -1],\n        [1, 0],\n            [1, 1]]:\n      i = king[0] + d[0]\n      j = king[1] + d[1]\n      while 0 <= i < 8 and 0 <= j < 8:\n        if (i, j) in queens:\n          ans.append([i, j])\n          break\n        i += d[0]\n        j += d[1]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1278, "slug": "palindrome-partitioning-iii", "solutions": ["class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        n = len(s)\n        g = [[0] * n for _ in range(n)]\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                g[i][j] = int(s[i] != s[j])\n                if i + 1 < j:\n                    g[i][j] += g[i + 1][j - 1]\n\n        f = [[0] * (k + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, min(i, k) + 1):\n                if j == 1:\n                    f[i][j] = g[0][i - 1]\n                else:\n                    f[i][j] = inf\n                    for h in range(j - 1, i):\n                        f[i][j] = min(f[i][j], f[h][j - 1] + g[h][i - 1])\n        return f[n][k]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1267, "slug": "count-servers-that-communicate", "solutions": ["class Solution:\n    def countServers(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        row = [0] * m\n        col = [0] * n\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]:\n                    row[i] += 1\n                    col[j] += 1\n        return sum(\n            grid[i][j] and (row[i] > 1 or col[j] > 1)\n            for i in range(m)\n            for j in range(n)\n        )\n", "class Solution:\n  def countServers(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    rows = [0] * m\n    cols = [0] * n\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1:\n          rows[i] += 1\n          cols[j] += 1\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1 and (rows[i] > 1 or cols[j] > 1):\n          ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1286, "slug": "iterator-for-combination", "solutions": ["class CombinationIterator:\n    def __init__(self, characters: str, combinationLength: int):\n        def dfs(i):\n            if len(t) == combinationLength:\n                cs.append(''.join(t))\n                return\n            if i == n:\n                return\n            t.append(characters[i])\n            dfs(i + 1)\n            t.pop()\n            dfs(i + 1)\n\n        cs = []\n        n = len(characters)\n        t = []\n        dfs(0)\n        self.cs = cs\n        self.idx = 0\n\n    def next(self) -> str:\n        ans = self.cs[self.idx]\n        self.idx += 1\n        return ans\n\n    def hasNext(self) -> bool:\n        return self.idx < len(self.cs)\n\n\n# Your CombinationIterator object will be instantiated and called as such:\n# obj = CombinationIterator(characters, combinationLength)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1200, "slug": "minimum-absolute-difference", "solutions": ["class Solution:\n    def minimumAbsDifference(self, arr: List[int]) -> List[List[int]]:\n        arr.sort()\n        mi = min(b - a for a, b in pairwise(arr))\n        return [[a, b] for a, b in pairwise(arr) if b - a == mi]\n", "class Solution:\n  def minimumAbsDifference(self, arr: list[int]) -> list[list[int]]:\n    ans = []\n    mn = math.inf\n\n    arr.sort()\n\n    for a, b in itertools.pairwise(arr):\n      diff = b - a\n      if diff < mn:\n        mn = diff\n        ans = []\n      if diff == mn:\n        ans.append([a, b])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1274, "slug": "number-of-ships-in-a-rectangle", "solutions": ["# \"\"\"\n# This is Sea's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# class Sea:\n#    def hasShips(self, topRight: 'Point', bottomLeft: 'Point') -> bool:\n#\n# class Point:\n# \tdef __init__(self, x: int, y: int):\n# \t\tself.x = x\n# \t\tself.y = y\n\n\nclass Solution:\n    def countShips(self, sea: \"Sea\", topRight: \"Point\", bottomLeft: \"Point\") -> int:\n        def dfs(topRight, bottomLeft):\n            x1, y1 = bottomLeft.x, bottomLeft.y\n            x2, y2 = topRight.x, topRight.y\n            if x1 > x2 or y1 > y2:\n                return 0\n            if not sea.hasShips(topRight, bottomLeft):\n                return 0\n            if x1 == x2 and y1 == y2:\n                return 1\n            midx = (x1 + x2) >> 1\n            midy = (y1 + y2) >> 1\n            a = dfs(topRight, Point(midx + 1, midy + 1))\n            b = dfs(Point(midx, y2), Point(x1, midy + 1))\n            c = dfs(Point(midx, midy), bottomLeft)\n            d = dfs(Point(x2, midy), Point(midx + 1, y1))\n            return a + b + c + d\n\n        return dfs(topRight, bottomLeft)\n", "# \"\"\"\n# This is Sea's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# class Sea(object):\n#   def hasShips(self, topRight: 'Point', bottomLeft: 'Point') -> bool:\n#     pass\n#\n# class Point(object):\n# def __init__(self, x: int, y: int):\n# self.x = x\n# self.y = y\n\nclass Solution(object):\n  def countShips(\n      self,\n      sea: 'Sea',\n      topRight: 'Point',\n      bottomLeft: 'Point',\n  ) -> int:\n    if topRight.x < bottomLeft.x or topRight.y < bottomLeft.y:\n      return 0\n    if not sea.hasShips(topRight, bottomLeft):\n      return 0\n\n    # sea.hashShips(topRight, bottomLeft) == True\n    if topRight.x == bottomLeft.x and topRight.y == bottomLeft.y:\n      return 1\n\n    mx = (topRight.x + bottomLeft.x) // 2\n    my = (topRight.y + bottomLeft.y) // 2\n    ans = 0\n    # the top-right\n    ans += self.countShips(sea, topRight, Point(mx + 1, my + 1))\n    # the bottom-right\n    ans += self.countShips(sea, Point(topRight.x, my),\n                           Point(mx + 1, bottomLeft.y))\n    # the top-left\n    ans += self.countShips(sea, Point(mx, topRight.y),\n                           Point(bottomLeft.x, my + 1))\n    # the bottom-left\n    ans += self.countShips(sea, Point(mx, my), bottomLeft)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1259, "slug": "handshakes-that-dont-cross", "solutions": ["class Solution:\n    def numberOfWays(self, numPeople: int) -> int:\n        @cache\n        def dfs(i: int) -> int:\n            if i < 2:\n                return 1\n            ans = 0\n            for l in range(0, i, 2):\n                r = i - l - 2\n                ans += dfs(l) * dfs(r)\n                ans %= mod\n            return ans\n\n        mod = 10**9 + 7\n        return dfs(numPeople)\n", "class Solution:\n  def numberOfWays(self, numPeople: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i] := the number of ways i handshakes could occure s.t. none of the\n    # handshakes cross\n    dp = [1] + [0] * (numPeople // 2)\n\n    for i in range(1, numPeople // 2 + 1):\n      for j in range(i):\n        dp[i] += dp[j] * dp[i - 1 - j]\n        dp[i] %= MOD\n\n    return dp[numPeople // 2]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1247, "slug": "minimum-swaps-to-make-strings-equal", "solutions": ["class Solution:\n    def minimumSwap(self, s1: str, s2: str) -> int:\n        xy = yx = 0\n        for a, b in zip(s1, s2):\n            xy += a < b\n            yx += a > b\n        if (xy + yx) % 2:\n            return -1\n        return xy // 2 + yx // 2 + xy % 2 + yx % 2\n", "class Solution:\n  def minimumSwap(self, s1: str, s2: str) -> int:\n    # ('xx', 'yy') = (2 'xy's) . 1 swap\n    # ('yy', 'xx') = (2 'yx's) . 1 swap\n    # ('xy', 'yx') = (1 'xy' and 1 'yx') . 2 swaps\n    xy = 0  # the number of indices i's s.t. s1[i] = 'x' and s2[i] 'y'\n    yx = 0  # the number of indices i's s.t. s1[i] = 'y' and s2[i] 'x'\n\n    for a, b in zip(s1, s2):\n      if a == b:\n        continue\n      if a == 'x':\n        xy += 1\n      else:\n        yx += 1\n\n    if (xy + yx) % 2 == 1:\n      return -1\n    return xy // 2 + yx // 2 + (0 if xy % 2 == 0 else 2)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1236, "slug": "web-crawler", "solutions": ["# \"\"\"\n# This is HtmlParser's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# class HtmlParser(object):\n#    def getUrls(self, url):\n#        \"\"\"\n#        :type url: str\n#        :rtype List[str]\n#        \"\"\"\n\n\nclass Solution:\n    def crawl(self, startUrl: str, htmlParser: 'HtmlParser') -> List[str]:\n        def host(url):\n            url = url[7:]\n            return url.split('/')[0]\n\n        def dfs(url):\n            if url in ans:\n                return\n            ans.add(url)\n            for next in htmlParser.getUrls(url):\n                if host(url) == host(next):\n                    dfs(next)\n\n        ans = set()\n        dfs(startUrl)\n        return list(ans)\n", "# \"\"\"\n# This is HtmlParser's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# Class HtmlParser(object):\n#   def getUrls(self, url: str) -> list[str]:\n\nclass Solution:\n  def crawl(self, startUrl: str, htmlParser: 'HtmlParser') -> list[str]:\n    q = collections.deque([startUrl])\n    seen = {startUrl}\n    hostname = startUrl.split('/')[2]\n\n    while q:\n      currUrl = q.popleft()\n      for url in htmlParser.getUrls(currUrl):\n        if url in seen:\n          continue\n        if hostname in url:\n          q.append(url)\n          seen.add(url)\n\n    return seen\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1258, "slug": "synonymous-sentences", "solutions": ["class UnionFind:\n    def __init__(self, n):\n        self.p = list(range(n))\n        self.size = [1] * n\n\n    def find(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n\n    def union(self, a, b):\n        pa, pb = self.find(a), self.find(b)\n        if pa != pb:\n            if self.size[pa] > self.size[pb]:\n                self.p[pb] = pa\n                self.size[pa] += self.size[pb]\n            else:\n                self.p[pa] = pb\n                self.size[pb] += self.size[pa]\n\n\nclass Solution:\n    def generateSentences(self, synonyms: List[List[str]], text: str) -> List[str]:\n        def dfs(i):\n            if i >= len(sentence):\n                ans.append(' '.join(t))\n                return\n            if sentence[i] not in d:\n                t.append(sentence[i])\n                dfs(i + 1)\n                t.pop()\n            else:\n                root = uf.find(d[sentence[i]])\n                for j in g[root]:\n                    t.append(words[j])\n                    dfs(i + 1)\n                    t.pop()\n\n        words = list(set(chain.from_iterable(synonyms)))\n        d = {w: i for i, w in enumerate(words)}\n        uf = UnionFind(len(d))\n        for a, b in synonyms:\n            uf.union(d[a], d[b])\n        g = defaultdict(list)\n        for i in range(len(words)):\n            g[uf.find(i)].append(i)\n        for k in g.keys():\n            g[k].sort(key=lambda i: words[i])\n        sentence = text.split()\n        ans = []\n        t = []\n        dfs(0)\n        return ans\n", "from sortedcontainers import SortedSet\n\n\nclass Solution:\n  def generateSentences(\n      self,\n      synonyms: list[list[str]],\n      text: str,\n  ) -> list[str]:\n    ans = SortedSet()\n    graph = collections.defaultdict(list)\n    q = collections.deque([text])\n\n    for s, t in synonyms:\n      graph[s].append(t)\n      graph[t].append(s)\n\n    while q:\n      u = q.popleft()\n      ans.add(u)\n      words = u.split()\n      for i, word in enumerate(words):\n        for synonym in graph[word]:\n          # Replace words[i] with its synonym.\n          words[i] = synonym\n          newText = ' '.join(words)\n          if newText not in ans:\n            q.append(newText)\n\n    return list(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1290, "slug": "convert-binary-number-in-a-linked-list-to-integer", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def getDecimalValue(self, head: ListNode) -> int:\n        ans = 0\n        while head:\n            ans = ans << 1 | head.val\n            head = head.next\n        return ans\n", "class Solution:\n  def getDecimalValue(self, head: ListNode) -> int:\n    ans = 0\n\n    while head:\n      ans = ans * 2 + head.val\n      head = head.next\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1275, "slug": "find-winner-on-a-tic-tac-toe-game", "solutions": ["class Solution:\n    def tictactoe(self, moves: List[List[int]]) -> str:\n        n = len(moves)\n        cnt = [0] * 8\n        for k in range(n - 1, -1, -2):\n            i, j = moves[k]\n            cnt[i] += 1\n            cnt[j + 3] += 1\n            if i == j:\n                cnt[6] += 1\n            if i + j == 2:\n                cnt[7] += 1\n            if any(v == 3 for v in cnt):\n                return \"B\" if k & 1 else \"A\"\n        return \"Draw\" if n == 9 else \"Pending\"\n", "class Solution:\n  def tictactoe(self, moves: list[list[int]]) -> str:\n    row = [[0] * 3 for _ in range(2)]\n    col = [[0] * 3 for _ in range(2)]\n    diag1 = [0] * 2\n    diag2 = [0] * 2\n    i = 0\n\n    for r, c in moves:\n      row[i][r] += 1\n      col[i][c] += 1\n      diag1[i] += r == c\n      diag2[i] += r + c == 2\n      if 3 in (row[i][r], col[i][c], diag1[i], diag2[i]):\n        return 'A' if i == 0 else 'B'\n      i ^= 1\n\n    return 'Draw' if len(moves) == 9 else 'Pending'\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1211, "slug": "queries-quality-and-percentage", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1254, "slug": "number-of-closed-islands", "solutions": ["class Solution:\n    def closedIsland(self, grid: List[List[int]]) -> int:\n        def dfs(i: int, j: int) -> int:\n            res = int(0 < i < m - 1 and 0 < j < n - 1)\n            grid[i][j] = 1\n            for a, b in pairwise(dirs):\n                x, y = i + a, j + b\n                if 0 <= x < m and 0 <= y < n and grid[x][y] == 0:\n                    res &= dfs(x, y)\n            return res\n\n        m, n = len(grid), len(grid[0])\n        dirs = (-1, 0, 1, 0, -1)\n        return sum(grid[i][j] == 0 and dfs(i, j) for i in range(m) for j in range(n))\n", "class Solution:\n  def closedIsland(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    def dfs(i: int, j: int) -> None:\n      if i < 0 or i == m or j < 0 or j == n:\n        return\n      if grid[i][j] == 1:\n        return\n      grid[i][j] = 1\n      dfs(i + 1, j)\n      dfs(i - 1, j)\n      dfs(i, j + 1)\n      dfs(i, j - 1)\n\n    # Remove the lands connected to the edge.\n    for i in range(m):\n      for j in range(n):\n        if i * j == 0 or i == m - 1 or j == n - 1:\n          if grid[i][j] == 0:\n            dfs(i, j)\n\n    ans = 0\n\n    # Reduce to 200. Number of Islands\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 0:\n          dfs(i, j)\n          ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1268, "slug": "search-suggestions-system", "solutions": ["class Trie:\n    def __init__(self):\n        self.children: List[Union[Trie, None]] = [None] * 26\n        self.v: List[int] = []\n\n    def insert(self, w, i):\n        node = self\n        for c in w:\n            idx = ord(c) - ord('a')\n            if node.children[idx] is None:\n                node.children[idx] = Trie()\n            node = node.children[idx]\n            if len(node.v) < 3:\n                node.v.append(i)\n\n    def search(self, w):\n        node = self\n        ans = [[] for _ in range(len(w))]\n        for i, c in enumerate(w):\n            idx = ord(c) - ord('a')\n            if node.children[idx] is None:\n                break\n            node = node.children[idx]\n            ans[i] = node.v\n        return ans\n\n\nclass Solution:\n    def suggestedProducts(\n        self, products: List[str], searchWord: str\n    ) -> List[List[str]]:\n        products.sort()\n        trie = Trie()\n        for i, w in enumerate(products):\n            trie.insert(w, i)\n        return [[products[i] for i in v] for v in trie.search(searchWord)]\n", "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.word: str | None = None\n\n\nclass Solution:\n  def suggestedProducts(self, products: list[str],\n                        searchWord: str) -> list[list[str]]:\n    ans = []\n    root = TrieNode()\n\n    def insert(word: str) -> None:\n      node = root\n      for c in word:\n        node = node.children.setdefault(c, TrieNode())\n      node.word = word\n\n    def search(node: TrieNode | None) -> list[str]:\n      res: list[str] = []\n      dfs(node, res)\n      return res\n\n    def dfs(node: TrieNode | None, res: list[str]) -> None:\n      if len(res) == 3:\n        return\n      if not node:\n        return\n      if node.word:\n        res.append(node.word)\n      for c in string.ascii_lowercase:\n        if c in node.children:\n          dfs(node.children[c], res)\n\n    for product in products:\n      insert(product)\n\n    node = root\n\n    for c in searchWord:\n      if not node or c not in node.children:\n        node = None\n        ans.append([])\n        continue\n      node = node.children[c]\n      ans.append(search(node))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1283, "slug": "find-the-smallest-divisor-given-a-threshold", "solutions": ["class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        def f(v: int) -> bool:\n            v += 1\n            return sum((x + v - 1) // v for x in nums) <= threshold\n\n        return bisect_left(range(max(nums)), True, key=f) + 1\n", "class Solution:\n  def smallestDivisor(self, nums: list[int], threshold: int) -> int:\n    l = 1\n    r = max(nums)\n\n    while l < r:\n      m = (l + r) // 2\n      if sum((num - 1) // m + 1 for num in nums) <= threshold:\n        r = m\n      else:\n        l = m + 1\n\n    return l\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1212, "slug": "team-scores-in-football-tournament", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1239, "slug": "maximum-length-of-a-concatenated-string-with-unique-characters", "solutions": ["class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        s = [0]\n        for t in arr:\n            x = 0\n            for b in map(lambda c: ord(c) - 97, t):\n                if x >> b & 1:\n                    x = 0\n                    break\n                x |= 1 << b\n            if x:\n                s.extend((x | y) for y in s if (x & y) == 0)\n        return max(x.bit_count() for x in s)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1269, "slug": "number-of-ways-to-stay-in-the-same-place-after-some-steps", "solutions": ["class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        @cache\n        def dfs(i, j):\n            if i > j or i >= arrLen or i < 0 or j < 0:\n                return 0\n            if i == 0 and j == 0:\n                return 1\n            ans = 0\n            for k in range(-1, 2):\n                ans += dfs(i + k, j - 1)\n                ans %= mod\n            return ans\n\n        mod = 10**9 + 7\n        return dfs(0, steps)\n", "class Solution:\n  def numWays(self, steps: int, arrLen: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i] := the number of ways to stay at index i\n    dp = [0] * min(steps // 2 + 1, arrLen)\n    dp[0] = 1\n\n    for _ in range(steps):\n      newDp = [0] * min(steps // 2 + 1, arrLen)\n      for i, ways in enumerate(dp):\n        if ways > 0:\n          for dx in (-1, 0, 1):\n            nextIndex = i + dx\n            if 0 <= nextIndex < len(dp):\n              newDp[nextIndex] += ways\n              newDp[nextIndex] %= MOD\n      dp = newDp\n\n    return dp[0]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1219, "slug": "path-with-maximum-gold", "solutions": ["class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def dfs(i: int, j: int) -> int:\n            if not (0 <= i < m and 0 <= j < n and grid[i][j]):\n                return 0\n            v = grid[i][j]\n            grid[i][j] = 0\n            ans = max(dfs(i + a, j + b) for a, b in pairwise(dirs)) + v\n            grid[i][j] = v\n            return ans\n\n        m, n = len(grid), len(grid[0])\n        dirs = (-1, 0, 1, 0, -1)\n        return max(dfs(i, j) for i in range(m) for j in range(n))\n", "class Solution:\n  def getMaximumGold(self, grid: list[list[int]]) -> int:\n    def dfs(i: int, j: int) -> int:\n      if i < 0 or j < 0 or i == len(grid) or j == len(grid[0]):\n        return 0\n      if grid[i][j] == 0:\n        return 0\n\n      gold = grid[i][j]\n      grid[i][j] = 0  # Mark as visited.\n      maxPath = max(dfs(i + 1, j), dfs(i - 1, j),\n                    dfs(i, j + 1), dfs(i, j - 1))\n      grid[i][j] = gold\n      return gold + maxPath\n\n    return max(dfs(i, j)\n               for i in range(len(grid))\n               for j in range(len(grid[0])))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1243, "slug": "array-transformation", "solutions": ["class Solution:\n    def transformArray(self, arr: List[int]) -> List[int]:\n        f = True\n        while f:\n            f = False\n            t = arr[:]\n            for i in range(1, len(t) - 1):\n                if t[i] > t[i - 1] and t[i] > t[i + 1]:\n                    arr[i] -= 1\n                    f = True\n                if t[i] < t[i - 1] and t[i] < t[i + 1]:\n                    arr[i] += 1\n                    f = True\n        return arr\n", "class Solution:\n  def transformArray(self, arr: list[int]) -> list[int]:\n    if len(arr) < 3:\n      return arr\n\n    ans = []\n\n    while ans != arr:\n      ans = arr[:]\n      for i in range(1, len(arr) - 1):\n        if ans[i - 1] > ans[i] < ans[i + 1]:\n          arr[i] += 1\n        elif ans[i - 1] < ans[i] > ans[i + 1]:\n          arr[i] -= 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1246, "slug": "palindrome-removal", "solutions": ["class Solution:\n    def minimumMoves(self, arr: List[int]) -> int:\n        n = len(arr)\n        f = [[0] * n for _ in range(n)]\n        for i in range(n):\n            f[i][i] = 1\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 1, n):\n                if i + 1 == j:\n                    f[i][j] = 1 if arr[i] == arr[j] else 2\n                else:\n                    t = f[i + 1][j - 1] if arr[i] == arr[j] else inf\n                    for k in range(i, j):\n                        t = min(t, f[i][k] + f[k + 1][j])\n                    f[i][j] = t\n        return f[0][n - 1]\n", "class Solution:\n  def minimumMoves(self, arr: list[int]) -> int:\n    n = len(arr)\n    # dp[i][j] := the minimum number of moves to remove all numbers from arr[i..j]\n    dp = [[n] * n for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i] = 1\n\n    for i in range(n - 1):\n      dp[i][i + 1] = 1 if arr[i] == arr[i + 1] else 2\n\n    for d in range(2, n):\n      for i in range(n - d):\n        j = i + d\n        # Remove arr[i] and arr[j] within the move of removing\n        # arr[i + 1..j - 1]\n        if arr[i] == arr[j]:\n          dp[i][j] = dp[i + 1][j - 1]\n        # Try all the possible partitions.\n        for k in range(i, j):\n          dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j])\n\n    return dp[0][n - 1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 908, "slug": "smallest-range-i", "solutions": ["class Solution:\n    def smallestRangeI(self, nums: List[int], k: int) -> int:\n        mx, mi = max(nums), min(nums)\n        return max(0, mx - mi - k * 2)\n", "class Solution:\n  def smallestRangeI(self, nums: list[int], k: int) -> int:\n    return max(0, max(nums) - min(nums) - 2 * k)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 932, "slug": "beautiful-array", "solutions": ["class Solution:\n    def beautifulArray(self, n: int) -> List[int]:\n        if n == 1:\n            return [1]\n        left = self.beautifulArray((n + 1) >> 1)\n        right = self.beautifulArray(n >> 1)\n        left = [x * 2 - 1 for x in left]\n        right = [x * 2 for x in right]\n        return left + right\n", "class Solution:\n  def beautifulArray(self, n: int) -> list[int]:\n    arr = [i for i in range(1, n + 1)]\n\n    def partition(l: int, r: int, mask: int) -> int:\n      nextSwapped = l\n      for i in range(l, r + 1):\n        if arr[i] & mask:\n          arr[i], arr[nextSwapped] = arr[nextSwapped], arr[i]\n          nextSwapped += 1\n      return nextSwapped - 1\n\n    def divide(l: int, r: int, mask: int) -> None:\n      if l >= r:\n        return\n      m = partition(l, r, mask)\n      divide(l, m, mask << 1)\n      divide(m + 1, r, mask << 1)\n\n    divide(0, n - 1, 1)\n    return arr\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 911, "slug": "online-election", "solutions": ["class TopVotedCandidate:\n\n    def __init__(self, persons: List[int], times: List[int]):\n        cnt = Counter()\n        self.times = times\n        self.wins = []\n        cur = 0\n        for p in persons:\n            cnt[p] += 1\n            if cnt[cur] <= cnt[p]:\n                cur = p\n            self.wins.append(cur)\n\n    def q(self, t: int) -> int:\n        i = bisect_right(self.times, t) - 1\n        return self.wins[i]\n\n\n# Your TopVotedCandidate object will be instantiated and called as such:\n# obj = TopVotedCandidate(persons, times)\n# param_1 = obj.q(t)\n", "class TopVotedCandidate:\n  def __init__(self, persons: list[int], times: list[int]):\n    self.times = times\n    self.timeToLead = {}\n    count = collections.Counter()  # {person: voted}\n    lead = -1\n\n    for person, time in zip(persons, times):\n      count[person] += 1\n      if count[person] >= count[lead]:\n        lead = person\n      self.timeToLead[time] = lead\n\n  def q(self, t: int) -> int:\n    i = bisect_right(self.times, t)\n    return self.timeToLead[self.times[i - 1]]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 980, "slug": "unique-paths-iii", "solutions": ["class Solution:\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\n        def dfs(i: int, j: int, k: int) -> int:\n            if grid[i][j] == 2:\n                return int(k == cnt + 1)\n            ans = 0\n            for a, b in pairwise(dirs):\n                x, y = i + a, j + b\n                if 0 <= x < m and 0 <= y < n and (x, y) not in vis and grid[x][y] != -1:\n                    vis.add((x, y))\n                    ans += dfs(x, y, k + 1)\n                    vis.remove((x, y))\n            return ans\n\n        m, n = len(grid), len(grid[0])\n        start = next((i, j) for i in range(m) for j in range(n) if grid[i][j] == 1)\n        dirs = (-1, 0, 1, 0, -1)\n        cnt = sum(row.count(0) for row in grid)\n        vis = {start}\n        return dfs(*start, 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 989, "slug": "add-to-array-form-of-integer", "solutions": ["class Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        ans = []\n        i = len(num) - 1\n        while i >= 0 or k:\n            k += 0 if i < 0 else num[i]\n            k, x = divmod(k, 10)\n            ans.append(x)\n            i -= 1\n        return ans[::-1]\n", "class Solution:\n  def addToArrayForm(self, num: list[int], k: int) -> list[int]:\n    for i in reversed(range(len(num))):\n      k, num[i] = divmod(num[i] + k, 10)\n\n    while k > 0:\n      num = [k % 10] + num\n      k //= 10\n\n    return num\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 941, "slug": "valid-mountain-array", "solutions": ["class Solution:\n    def validMountainArray(self, arr: List[int]) -> bool:\n        n = len(arr)\n        if n < 3:\n            return False\n        i, j = 0, n - 1\n        while i + 1 < n - 1 and arr[i] < arr[i + 1]:\n            i += 1\n        while j - 1 > 0 and arr[j - 1] > arr[j]:\n            j -= 1\n        return i == j\n", "class Solution:\n  def validMountainArray(self, arr: list[int]) -> bool:\n    if len(arr) < 3:\n      return False\n\n    l = 0\n    r = len(arr) - 1\n\n    while l + 1 < len(arr) and arr[l] < arr[l + 1]:\n      l += 1\n    while r > 0 and arr[r] < arr[r - 1]:\n      r -= 1\n\n    return l > 0 and r < len(arr) - 1 and l == r\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 950, "slug": "reveal-cards-in-increasing-order", "solutions": ["class Solution:\n    def deckRevealedIncreasing(self, deck: List[int]) -> List[int]:\n        q = deque()\n        for v in sorted(deck, reverse=True):\n            if q:\n                q.appendleft(q.pop())\n            q.appendleft(v)\n        return list(q)\n", "class Solution:\n  def deckRevealedIncreasing(self, deck: list[int]) -> list[int]:\n    dq = collections.deque()\n\n    for card in reversed(sorted(deck)):\n      dq.rotate()\n      dq.appendleft(card)\n\n    return list(dq)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 968, "slug": "binary-tree-cameras", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minCameraCover(self, root: Optional[TreeNode]) -> int:\n        def dfs(root):\n            if root is None:\n                return inf, 0, 0\n            la, lb, lc = dfs(root.left)\n            ra, rb, rc = dfs(root.right)\n            a = min(la, lb, lc) + min(ra, rb, rc) + 1\n            b = min(la + rb, lb + ra, la + ra)\n            c = lb + rb\n            return a, b, c\n\n        a, b, _ = dfs(root)\n        return min(a, b)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 922, "slug": "sort-array-by-parity-ii", "solutions": ["class Solution:\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\n        n, j = len(nums), 1\n        for i in range(0, n, 2):\n            if nums[i] % 2:\n                while nums[j] % 2:\n                    j += 2\n                nums[i], nums[j] = nums[j], nums[i]\n        return nums\n", "class Solution:\n  def sortArrayByParityII(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n\n    i = 0\n    j = 1\n    while i < n:\n      while i < n and nums[i] % 2 == 0:\n        i += 2\n      while j < n and nums[j] % 2 == 1:\n        j += 2\n      if i < n:\n        nums[i], nums[j] = nums[j], nums[i]\n\n    return nums\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 990, "slug": "satisfiability-of-equality-equations", "solutions": ["class Solution:\n    def equationsPossible(self, equations: List[str]) -> bool:\n        def find(x):\n            if p[x] != x:\n                p[x] = find(p[x])\n            return p[x]\n\n        p = list(range(26))\n        for e in equations:\n            a, b = ord(e[0]) - ord('a'), ord(e[-1]) - ord('a')\n            if e[1] == '=':\n                p[find(a)] = find(b)\n        for e in equations:\n            a, b = ord(e[0]) - ord('a'), ord(e[-1]) - ord('a')\n            if e[1] == '!' and find(a) == find(b):\n                return False\n        return True\n", "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n\n  def union(self, u: int, v: int) -> None:\n    self.id[self.find(u)] = self.find(v)\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def equationsPossible(self, equations: list[str]) -> bool:\n    uf = UnionFind(26)\n\n    for x, op, _, y in equations:\n      if op == '=':\n        uf.union(ord(x) - ord('a'),\n                 ord(y) - ord('a'))\n\n    return all(\n        uf.find(ord(x) - ord('a')) !=\n        uf.find(ord(y) - ord('a'))\n        for x, op, _, y in equations\n        if op == '!')\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 938, "slug": "range-sum-of-bst", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\n        def dfs(root: Optional[TreeNode]) -> int:\n            if root is None:\n                return 0\n            x = root.val\n            ans = x if low <= x <= high else 0\n            if x > low:\n                ans += dfs(root.left)\n            if x < high:\n                ans += dfs(root.right)\n            return ans\n\n        return dfs(root)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 959, "slug": "regions-cut-by-slashes", "solutions": ["class Solution:\n    def regionsBySlashes(self, grid: List[str]) -> int:\n        def find(x):\n            if p[x] != x:\n                p[x] = find(p[x])\n            return p[x]\n\n        def union(a, b):\n            pa, pb = find(a), find(b)\n            if pa != pb:\n                p[pa] = pb\n                nonlocal size\n                size -= 1\n\n        n = len(grid)\n        size = n * n * 4\n        p = list(range(size))\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                k = i * n + j\n                if i < n - 1:\n                    union(4 * k + 2, (k + n) * 4)\n                if j < n - 1:\n                    union(4 * k + 1, (k + 1) * 4 + 3)\n                if v == '/':\n                    union(4 * k, 4 * k + 3)\n                    union(4 * k + 1, 4 * k + 2)\n                elif v == '\\\\':\n                    union(4 * k, 4 * k + 1)\n                    union(4 * k + 2, 4 * k + 3)\n                else:\n                    union(4 * k, 4 * k + 1)\n                    union(4 * k + 1, 4 * k + 2)\n                    union(4 * k + 2, 4 * k + 3)\n        return size\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 902, "slug": "numbers-at-most-n-given-digit-set", "solutions": ["class Solution:\n    def atMostNGivenDigitSet(self, digits: List[str], n: int) -> int:\n        @cache\n        def dfs(i: int, lead: int, limit: bool) -> int:\n            if i >= len(s):\n                return lead ^ 1\n\n            up = int(s[i]) if limit else 9\n            ans = 0\n            for j in range(up + 1):\n                if j == 0 and lead:\n                    ans += dfs(i + 1, 1, limit and j == up)\n                elif j in nums:\n                    ans += dfs(i + 1, 0, limit and j == up)\n            return ans\n\n        s = str(n)\n        nums = {int(x) for x in digits}\n        return dfs(0, 1, True)\n", "class Solution:\n  def atMostNGivenDigitSet(self, digits: list[str], n: int) -> int:\n    ans = 0\n    num = str(n)\n\n    for i in range(1, len(num)):\n      ans += pow(len(digits), i)\n\n    for i, c in enumerate(num):\n      dHasSameNum = False\n      for digit in digits:\n        if digit[0] < c:\n          ans += pow(len(digits), len(num) - i - 1)\n        elif digit[0] == c:\n          dHasSameNum = True\n      if not dHasSameNum:\n        return ans\n\n    return ans + 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 933, "slug": "number-of-recent-calls", "solutions": ["class RecentCounter:\n    def __init__(self):\n        self.q = deque()\n\n    def ping(self, t: int) -> int:\n        self.q.append(t)\n        while self.q[0] < t - 3000:\n            self.q.popleft()\n        return len(self.q)\n\n\n# Your RecentCounter object will be instantiated and called as such:\n# obj = RecentCounter()\n# param_1 = obj.ping(t)\n", "class RecentCounter:\n  def __init__(self):\n    self.q = collections.deque()\n\n  def ping(self, t: int) -> int:\n    self.q.append(t)\n    while self.q[0] < t - 3000:\n      self.q.popleft()\n    return len(self.q)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 939, "slug": "minimum-area-rectangle", "solutions": ["class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        d = defaultdict(list)\n        for x, y in points:\n            d[x].append(y)\n        pos = {}\n        ans = inf\n        for x in sorted(d):\n            ys = d[x]\n            ys.sort()\n            n = len(ys)\n            for i, y1 in enumerate(ys):\n                for y2 in ys[i + 1 :]:\n                    if (y1, y2) in pos:\n                        ans = min(ans, (x - pos[(y1, y2)]) * (y2 - y1))\n                    pos[(y1, y2)] = x\n        return 0 if ans == inf else ans\n", "class Solution:\n  def minAreaRect(self, points: list[list[int]]) -> int:\n    ans = math.inf\n    xToYs = collections.defaultdict(set)\n\n    for x, y in points:\n      xToYs[x].add(y)\n\n    for i in range(len(points)):\n      for j in range(i):\n        x1, y1 = points[i]\n        x2, y2 = points[j]\n        if x1 == x2 or y1 == y2:\n          continue\n        if y2 in xToYs[x1] and y1 in xToYs[x2]:\n          ans = min(ans, abs(x1 - x2) * abs(y1 - y2))\n\n    return ans if ans < math.inf else 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 979, "slug": "distribute-coins-in-binary-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def distributeCoins(self, root: Optional[TreeNode]) -> int:\n        def dfs(root):\n            if root is None:\n                return 0\n            left, right = dfs(root.left), dfs(root.right)\n            nonlocal ans\n            ans += abs(left) + abs(right)\n            return left + right + root.val - 1\n\n        ans = 0\n        dfs(root)\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 910, "slug": "smallest-range-ii", "solutions": ["class Solution:\n    def smallestRangeII(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        ans = nums[-1] - nums[0]\n        for i in range(1, len(nums)):\n            mi = min(nums[0] + k, nums[i] - k)\n            mx = max(nums[i - 1] + k, nums[-1] - k)\n            ans = min(ans, mx - mi)\n        return ans\n", "class Solution:\n  def smallestRangeII(self, nums: list[int], k: int) -> int:\n    nums.sort()\n\n    ans = nums[-1] - nums[0]\n    left = nums[0] + k\n    right = nums[-1] - k\n\n    for a, b in itertools.pairwise(nums):\n      mn = min(left, b - k)\n      mx = max(right, a + k)\n      ans = min(ans, mx - mn)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 960, "slug": "delete-columns-to-make-sorted-iii", "solutions": ["class Solution:\n    def minDeletionSize(self, strs: List[str]) -> int:\n        n = len(strs[0])\n        f = [1] * n\n        for i in range(n):\n            for j in range(i):\n                if all(s[j] <= s[i] for s in strs):\n                    f[i] = max(f[i], f[j] + 1)\n        return n - max(f)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 978, "slug": "longest-turbulent-subarray", "solutions": ["class Solution:\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\n        ans = f = g = 1\n        for a, b in pairwise(arr):\n            ff = g + 1 if a < b else 1\n            gg = f + 1 if a > b else 1\n            f, g = ff, gg\n            ans = max(ans, f, g)\n        return ans\n", "class Solution:\n  def maxTurbulenceSize(self, arr: list[int]) -> int:\n    ans = 1\n    increasing = 1\n    decreasing = 1\n\n    for i in range(1, len(arr)):\n      if arr[i] > arr[i - 1]:\n        increasing = decreasing + 1\n        decreasing = 1\n      elif arr[i] < arr[i - 1]:\n        decreasing = increasing + 1\n        increasing = 1\n      else:\n        increasing = 1\n        decreasing = 1\n      ans = max(ans, max(increasing, decreasing))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 956, "slug": "tallest-billboard", "solutions": ["class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        @cache\n        def dfs(i: int, j: int) -> int:\n            if i >= len(rods):\n                return 0 if j == 0 else -inf\n            ans = max(dfs(i + 1, j), dfs(i + 1, j + rods[i]))\n            ans = max(ans, dfs(i + 1, abs(rods[i] - j)) + min(j, rods[i]))\n            return ans\n\n        return dfs(0, 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 984, "slug": "string-without-aaa-or-bbb", "solutions": ["class Solution:\n    def strWithout3a3b(self, a: int, b: int) -> str:\n        ans = []\n        while a and b:\n            if a > b:\n                ans.append('aab')\n                a, b = a - 2, b - 1\n            elif a < b:\n                ans.append('bba')\n                a, b = a - 1, b - 2\n            else:\n                ans.append('ab')\n                a, b = a - 1, b - 1\n        if a:\n            ans.append('a' * a)\n        if b:\n            ans.append('b' * b)\n        return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 901, "slug": "online-stock-span", "solutions": ["class StockSpanner:\n    def __init__(self):\n        self.stk = []\n\n    def next(self, price: int) -> int:\n        cnt = 1\n        while self.stk and self.stk[-1][0] <= price:\n            cnt += self.stk.pop()[1]\n        self.stk.append((price, cnt))\n        return cnt\n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n", "class StockSpanner:\n  def __init__(self):\n    self.stack = []  # (price, span)\n\n  def next(self, price: int) -> int:\n    span = 1\n    while self.stack and self.stack[-1][0] <= price:\n      span += self.stack.pop()[1]\n    self.stack.append((price, span))\n    return span\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 973, "slug": "k-closest-points-to-origin", "solutions": ["class Solution:\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\n        points.sort(key=lambda p: hypot(p[0], p[1]))\n        return points[:k]\n", "class Solution:\n  def kClosest(self, points: list[list[int]], k: int) -> list[list[int]]:\n    def squareDist(p: list[int]) -> int:\n      return p[0] * p[0] + p[1] * p[1]\n\n    def quickSelect(l: int, r: int, k: int) -> None:\n      pivot = points[r]\n\n      nextSwapped = l\n      for i in range(l, r):\n        if squareDist(points[i]) <= squareDist(pivot):\n          points[nextSwapped], points[i] = points[i], points[nextSwapped]\n          nextSwapped += 1\n      points[nextSwapped], points[r] = points[r], points[nextSwapped]\n\n      count = nextSwapped - l + 1  the number of points <= pivot\n      if count == k:\n        return\n      if count > k:\n        quickSelect(l, nextSwapped - 1, k)\n      else:\n        quickSelect(nextSwapped + 1, r, k - count)\n\n    quickSelect(0, len(points) - 1, k)\n    return points[0:k]\n", "class Solution:\n  def kClosest(self, points: list[list[int]], k: int) -> list[list[int]]:\n    maxHeap = []\n\n    for x, y in points:\n      heapq.heappush(maxHeap, (- x * x - y * y, [x, y]))\n      if len(maxHeap) > k:\n        heapq.heappop(maxHeap)\n\n    return [pair[1] for pair in maxHeap]\n", "class Solution:\n  def kClosest(self, points: list[list[int]], k: int) -> list[list[int]]:\n    def squareDist(p: list[int]) -> int:\n      return p[0] * p[0] + p[1] * p[1]\n\n    def quickSelect(l: int, r: int, k: int) -> None:\n      randIndex = random.randint(0, r - l + 1) + l\n      points[randIndex], points[r] = points[r], points[randIndex]\n      pivot = points[r]\n\n      nextSwapped = l\n      for i in range(l, r):\n        if squareDist(points[i]) <= squareDist(pivot):\n          points[nextSwapped], points[i] = points[i], points[nextSwapped]\n          nextSwapped += 1\n      points[nextSwapped], points[r] = points[r], points[nextSwapped]\n\n      count = nextSwapped - l + 1  the number of points <= pivot\n      if count == k:\n        return\n      if count > k:\n        quickSelect(l, nextSwapped - 1, k)\n      else:\n        quickSelect(nextSwapped + 1, r, k - count)\n\n    quickSelect(0, len(points) - 1, k)\n    return points[0:k]\n\n\nclass Solution:\n  def kClosest(self, points: list[list[int]], k: int) -> list[list[int]]:\n    def squareDist(p: list[int]) -> int:\n      return p[0] * p[0] + p[1] * p[1]\n\n    def quickSelect(l: int, r: int, k: int) -> None:\n      pivot = points[r]\n\n      nextSwapped = l\n      for i in range(l, r):\n        if squareDist(points[i]) <= squareDist(pivot):\n          points[nextSwapped], points[i] = points[i], points[nextSwapped]\n          nextSwapped += 1\n      points[nextSwapped], points[r] = points[r], points[nextSwapped]\n\n      count = nextSwapped - l + 1  the number of points <= pivot\n      if count == k:\n        return\n      if count > k:\n        quickSelect(l, nextSwapped - 1, k)\n      else:\n        quickSelect(nextSwapped + 1, r, k - count)\n\n    quickSelect(0, len(points) - 1, k)\n    return points[0:k]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 996, "slug": "number-of-squareful-arrays", "solutions": ["class Solution:\n    def numSquarefulPerms(self, nums: List[int]) -> int:\n        n = len(nums)\n        f = [[0] * n for _ in range(1 << n)]\n        for j in range(n):\n            f[1 << j][j] = 1\n        for i in range(1 << n):\n            for j in range(n):\n                if i >> j & 1:\n                    for k in range(n):\n                        if (i >> k & 1) and k != j:\n                            s = nums[j] + nums[k]\n                            t = int(sqrt(s))\n                            if t * t == s:\n                                f[i][j] += f[i ^ (1 << j)][k]\n\n        ans = sum(f[(1 << n) - 1][j] for j in range(n))\n        for v in Counter(nums).values():\n            ans //= factorial(v)\n        return ans\n", "class Solution:\n  def numSquarefulPerms(self, nums: list[int]) -> int:\n    ans = 0\n    used = [False] * len(nums)\n\n    def isSquare(num: int) -> bool:\n      root = math.isqrt(num)\n      return root * root == num\n\n    def dfs(path: list[int]) -> None:\n      nonlocal ans\n      if len(path) > 1 and not isSquare(path[-1] + path[-2]):\n        return\n      if len(path) == len(nums):\n        ans += 1\n        return\n\n      for i, a in enumerate(nums):\n        if used[i]:\n          continue\n        if i > 0 and nums[i] == nums[i - 1] and not used[i - 1]:\n          continue\n        used[i] = True\n        dfs(path + [a])\n        used[i] = False\n\n    nums.sort()\n    dfs([])\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 915, "slug": "partition-array-into-disjoint-intervals", "solutions": ["class Solution:\n    def partitionDisjoint(self, nums: List[int]) -> int:\n        n = len(nums)\n        mi = [inf] * (n + 1)\n        for i in range(n - 1, -1, -1):\n            mi[i] = min(nums[i], mi[i + 1])\n        mx = 0\n        for i, v in enumerate(nums, 1):\n            mx = max(mx, v)\n            if mx <= mi[i]:\n                return i\n", "class Solution:\n  def partitionDisjoint(self, nums: list[int]) -> int:\n    n = len(nums)\n    mn = [0] * (n - 1) + [nums[-1]]\n    mx = -math.inf\n\n    for i in range(n - 2, - 1, -1):\n      mn[i] = min(mn[i + 1], nums[i])\n\n    for i, num in enumerate(nums):\n      mx = max(mx, num)\n      if mx <= mn[i + 1]:\n        return i + 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 992, "slug": "subarrays-with-k-different-integers", "solutions": ["class Solution:\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\n        def f(k):\n            pos = [0] * len(nums)\n            cnt = Counter()\n            j = 0\n            for i, x in enumerate(nums):\n                cnt[x] += 1\n                while len(cnt) > k:\n                    cnt[nums[j]] -= 1\n                    if cnt[nums[j]] == 0:\n                        cnt.pop(nums[j])\n                    j += 1\n                pos[i] = j\n            return pos\n\n        return sum(a - b for a, b in zip(f(k - 1), f(k)))\n", "class Solution:\n  def subarraysWithKDistinct(self, nums: list[int], k: int) -> int:\n    def subarraysWithAtMostKDistinct(k: int) -> int:\n      res = 0\n      count = collections.Counter()\n\n      l = 0\n      for r, num in enumerate(nums):\n        count[num] += 1\n        if count[num] == 1:\n          k -= 1\n        while k < 0:\n          count[nums[l]] -= 1\n          if count[nums[l]] == 0:\n            k += 1\n          l += 1\n        res += r - l + 1  # nums[l..r], nums[l + 1..r], ..., nums[r]\n\n      return res\n\n    return subarraysWithAtMostKDistinct(k) - subarraysWithAtMostKDistinct(k - 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 994, "slug": "rotting-oranges", "solutions": ["class Solution:\n    def orangesRotting(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        cnt = 0\n        q = deque()\n        for i, row in enumerate(grid):\n            for j, x in enumerate(row):\n                if x == 2:\n                    q.append((i, j))\n                elif x == 1:\n                    cnt += 1\n        ans = 0\n        dirs = (-1, 0, 1, 0, -1)\n        while q and cnt:\n            ans += 1\n            for _ in range(len(q)):\n                i, j = q.popleft()\n                for a, b in pairwise(dirs):\n                    x, y = i + a, j + b\n                    if 0 <= x < m and 0 <= y < n and grid[x][y] == 1:\n                        grid[x][y] = 2\n                        q.append((x, y))\n                        cnt -= 1\n                        if cnt == 0:\n                            return ans\n        return -1 if cnt else 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 909, "slug": "snakes-and-ladders", "solutions": ["class Solution:\n    def snakesAndLadders(self, board: List[List[int]]) -> int:\n        n = len(board)\n        q = deque([1])\n        vis = {1}\n        ans = 0\n        m = n * n\n        while q:\n            for _ in range(len(q)):\n                x = q.popleft()\n                if x == m:\n                    return ans\n                for y in range(x + 1, min(x + 6, m) + 1):\n                    i, j = divmod(y - 1, n)\n                    if i & 1:\n                        j = n - j - 1\n                    i = n - i - 1\n                    z = y if board[i][j] == -1 else board[i][j]\n                    if z not in vis:\n                        vis.add(z)\n                        q.append(z)\n            ans += 1\n        return -1\n", "class Solution:\n  def snakesAndLadders(self, board: list[list[int]]) -> int:\n    n = len(board)\n    q = collections.deque([1])\n    seen = set()\n    arr = [0] * (1 + n * n)  # 2D -> 1D\n\n    for i in range(n):\n      for j in range(n):\n        arr[(n - 1 - i) * n + (n - j if (n - i) % 2 == 0 else j + 1)] = board[i][j]\n\n    step = 1\n    while q:\n      for _ in range(len(q)):\n        curr = q.popleft()\n        for next in range(curr + 1, min(curr + 6, n * n) + 1):\n          dest = arr[next] if arr[next] > 0 else next\n          if dest == n * n:\n            return step\n          if dest in seen:\n            continue\n          q.append(dest)\n          seen.add(dest)\n      step += 1\n\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 964, "slug": "least-operators-to-express-number", "solutions": ["class Solution:\n    def leastOpsExpressTarget(self, x: int, target: int) -> int:\n        @cache\n        def dfs(v: int) -> int:\n            if x >= v:\n                return min(v * 2 - 1, 2 * (x - v))\n            k = 2\n            while x**k < v:\n                k += 1\n            if x**k - v < v:\n                return min(k + dfs(x**k - v), k - 1 + dfs(v - x ** (k - 1)))\n            return k - 1 + dfs(v - x ** (k - 1))\n\n        return dfs(target)\n", "class Solution:\n  def leastOpsExpressTarget(self, x: int, target: int) -> int:\n    @functools.lru_cache(None)\n    def dfs(target):\n      if x > target:\n        return min(2 * target - 1, 2 * (x - target))\n      if x == target:\n        return 0\n\n      prod = x\n      n = 0\n      while prod < target:\n        prod *= x\n        n += 1\n      if prod == target:\n        return n\n\n      ans = dfs(target - prod // x) + n\n      if prod < 2 * target:\n        ans = min(ans, dfs(prod - target) + n + 1)\n      return ans\n\n    return dfs(target)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 935, "slug": "knight-dialer", "solutions": ["class Solution:\n    def knightDialer(self, n: int) -> int:\n        f = [1] * 10\n        for _ in range(n - 1):\n            g = [0] * 10\n            g[0] = f[4] + f[6]\n            g[1] = f[6] + f[8]\n            g[2] = f[7] + f[9]\n            g[3] = f[4] + f[8]\n            g[4] = f[0] + f[3] + f[9]\n            g[6] = f[0] + f[1] + f[7]\n            g[7] = f[2] + f[6]\n            g[8] = f[1] + f[3]\n            g[9] = f[2] + f[4]\n            f = g\n        return sum(f) % (10**9 + 7)\n", "class Solution:\n  def knightDialer(self, n: int) -> int:\n    DIRS = ((1, 2), (2, 1), (2, -1), (1, -2),\n            (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n    MOD = 1_000_000_007\n\n    # dp[i][j] := the number of ways stand on (i, j)\n    dp = [[1] * 3 for _ in range(4)]\n    dp[3][0] = dp[3][2] = 0\n\n    for _ in range(n - 1):\n      newDp = [[0] * 3 for _ in range(4)]\n      for i in range(4):\n        for j in range(3):\n          if (i, j) in ((3, 0), (3, 2)):\n            continue\n          for dx, dy in DIRS:\n            x = i + dx\n            y = j + dy\n            if x < 0 or x >= 4 or y < 0 or y >= 3:\n              continue\n            if (x, y) in ((3, 0), (3, 2)):\n              continue\n            newDp[x][y] = (newDp[x][y] + dp[i][j]) % MOD\n      dp = newDp\n\n    return sum(map(sum, dp)) % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 931, "slug": "minimum-falling-path-sum", "solutions": ["class Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        n = len(matrix)\n        f = [0] * n\n        for row in matrix:\n            g = [0] * n\n            for j, x in enumerate(row):\n                l, r = max(0, j - 1), min(n, j + 2)\n                g[j] = min(f[l:r]) + x\n            f = g\n        return min(f)\n", "class Solution:\n  def minFallingPathSum(self, A: list[list[int]]) -> int:\n    n = len(A)\n\n    for i in range(1, n):\n      for j in range(n):\n        mn = math.inf\n        for k in range(max(0, j - 1), min(n, j + 2)):\n          mn = min(mn, A[i - 1][k])\n        A[i][j] += mn\n\n    return min(A[-1])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 982, "slug": "triples-with-bitwise-and-equal-to-zero", "solutions": ["class Solution:\n    def countTriplets(self, nums: List[int]) -> int:\n        cnt = Counter(x & y for x in nums for y in nums)\n        return sum(v for xy, v in cnt.items() for z in nums if xy & z == 0)\n", "class Solution:\n  def countTriplets(self, nums: list[int]) -> int:\n    MAX = 1 << 16\n    ans = 0\n    count = [0] * MAX  # {nums[i] & nums[j]: times}\n\n    for a in nums:\n      for b in nums:\n        count[a & b] += 1\n\n    for num in nums:\n      for i in range(MAX):\n        if (num & i) == 0:\n          ans += count[i]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 976, "slug": "largest-perimeter-triangle", "solutions": ["class Solution:\n    def largestPerimeter(self, nums: List[int]) -> int:\n        nums.sort()\n        for i in range(len(nums) - 1, 1, -1):\n            if (c := nums[i - 1] + nums[i - 2]) > nums[i]:\n                return c + nums[i]\n        return 0\n", "class Solution:\n  def largestPerimeter(self, nums: list[int]) -> int:\n    nums = sorted(nums)\n\n    for i in range(len(nums) - 1, 1, -1):\n      if nums[i - 2] + nums[i - 1] > nums[i]:\n        return nums[i - 2] + nums[i - 1] + nums[i]\n\n    return 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 918, "slug": "maximum-sum-circular-subarray", "solutions": ["class Solution:\n    def maxSubarraySumCircular(self, nums: List[int]) -> int:\n        pmi, pmx = 0, -inf\n        ans, s, smi = -inf, 0, inf\n        for x in nums:\n            s += x\n            ans = max(ans, s - pmi)\n            smi = min(smi, s - pmx)\n            pmi = min(pmi, s)\n            pmx = max(pmx, s)\n        return max(ans, s - smi)\n", "class Solution:\n  def maxSubarraySumCircular(self, nums: list[int]) -> int:\n    totalSum = 0\n    currMaxSum = 0\n    currMinSum = 0\n    maxSum = -math.inf\n    minSum = math.inf\n\n    for num in nums:\n      totalSum += num\n      currMaxSum = max(currMaxSum + num, num)\n      currMinSum = min(currMinSum + num, num)\n      maxSum = max(maxSum, currMaxSum)\n      minSum = min(minSum, currMinSum)\n\n    return maxSum if maxSum < 0 else max(maxSum, totalSum - minSum)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 993, "slug": "cousins-in-binary-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isCousins(self, root: Optional[TreeNode], x: int, y: int) -> bool:\n        q = deque([(root, None)])\n        depth = 0\n        p1 = p2 = None\n        d1 = d2 = None\n        while q:\n            for _ in range(len(q)):\n                node, parent = q.popleft()\n                if node.val == x:\n                    p1, d1 = parent, depth\n                elif node.val == y:\n                    p2, d2 = parent, depth\n                if node.left:\n                    q.append((node.left, node))\n                if node.right:\n                    q.append((node.right, node))\n            depth += 1\n        return p1 != p2 and d1 == d2\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 995, "slug": "minimum-number-of-k-consecutive-bit-flips", "solutions": ["class Solution:\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        d = [0] * (n + 1)\n        ans = s = 0\n        for i, x in enumerate(nums):\n            s += d[i]\n            if s % 2 == x:\n                if i + k > n:\n                    return -1\n                d[i] += 1\n                d[i + k] -= 1\n                s += 1\n                ans += 1\n        return ans\n", "class Solution:\n  def minKBitFlips(self, nums: list[int], k: int) -> int:\n    ans = 0\n    flippedTime = 0\n\n    for i, num in enumerate(nums):\n      if i >= k and nums[i - k] == 2:\n        flippedTime -= 1\n      if flippedTime % 2 == num:\n        if i + k > len(nums):\n          return -1\n        ans += 1\n        flippedTime += 1\n        nums[i] = 2\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 975, "slug": "odd-even-jump", "solutions": ["class Solution:\n    def oddEvenJumps(self, arr: List[int]) -> int:\n        @cache\n        def dfs(i: int, k: int) -> bool:\n            if i == n - 1:\n                return True\n            if g[i][k] == -1:\n                return False\n            return dfs(g[i][k], k ^ 1)\n\n        n = len(arr)\n        g = [[0] * 2 for _ in range(n)]\n        sd = SortedDict()\n        for i in range(n - 1, -1, -1):\n            j = sd.bisect_left(arr[i])\n            g[i][1] = sd.values()[j] if j < len(sd) else -1\n            j = sd.bisect_right(arr[i]) - 1\n            g[i][0] = sd.values()[j] if j >= 0 else -1\n            sd[arr[i]] = i\n        return sum(dfs(i, 1) for i in range(n))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 961, "slug": "n-repeated-element-in-size-2n-array", "solutions": ["class Solution:\n    def repeatedNTimes(self, nums: List[int]) -> int:\n        s = set()\n        for x in nums:\n            if x in s:\n                return x\n            s.add(x)\n", "class Solution:\n  def repeatedNTimes(self, nums: list[int]) -> int:\n    for i in range(len(nums) - 2):\n      if nums[i] == nums[i + 1] or nums[i] == nums[i + 2]:\n        return nums[i]\n    return nums[-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 900, "slug": "rle-iterator", "solutions": ["class RLEIterator:\n    def __init__(self, encoding: List[int]):\n        self.encoding = encoding\n        self.i = 0\n        self.j = 0\n\n    def next(self, n: int) -> int:\n        while self.i < len(self.encoding):\n            if self.encoding[self.i] - self.j < n:\n                n -= self.encoding[self.i] - self.j\n                self.i += 2\n                self.j = 0\n            else:\n                self.j += n\n                return self.encoding[self.i + 1]\n        return -1\n\n\n# Your RLEIterator object will be instantiated and called as such:\n# obj = RLEIterator(encoding)\n# param_1 = obj.next(n)\n", "class RLEIterator:\n  def __init__(self, encoding: list[int]):\n    self.encoding = encoding\n    self.index = 0\n\n  def next(self, n: int) -> int:\n    while self.index < len(self.encoding) and self.encoding[self.index] < n:\n      n -= self.encoding[self.index]\n      self.index += 2\n\n    if self.index == len(self.encoding):\n      return -1\n\n    self.encoding[self.index] -= n\n    return self.encoding[self.index + 1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 970, "slug": "powerful-integers", "solutions": ["class Solution:\n    def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:\n        ans = set()\n        a = 1\n        while a <= bound:\n            b = 1\n            while a + b <= bound:\n                ans.add(a + b)\n                b *= y\n                if y == 1:\n                    break\n            if x == 1:\n                break\n            a *= x\n        return list(ans)\n", "class Solution:\n  def powerfulIntegers(self, x: int, y: int, bound: int) -> list[int]:\n    xs = {x**i for i in range(20) if x**i < bound}\n    ys = {y**i for i in range(20) if y**i < bound}\n    return list({i + j for i in xs for j in ys if i + j <= bound})\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 945, "slug": "minimum-increment-to-make-array-unique", "solutions": ["class Solution:\n    def minIncrementForUnique(self, nums: List[int]) -> int:\n        nums.sort()\n        ans, y = 0, -1\n        for x in nums:\n            y = max(y + 1, x)\n            ans += y - x\n        return ans\n", "class Solution:\n  def minIncrementForUnique(self, nums: list[int]) -> int:\n    ans = 0\n    minAvailable = 0\n\n    for num in sorted(nums):\n      ans += max(minAvailable - num, 0)\n      minAvailable = max(minAvailable, num) + 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 952, "slug": "largest-component-size-by-common-factor", "solutions": ["class UnionFind:\n    def __init__(self, n):\n        self.p = list(range(n))\n\n    def union(self, a, b):\n        pa, pb = self.find(a), self.find(b)\n        if pa != pb:\n            self.p[pa] = pb\n\n    def find(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n\n\nclass Solution:\n    def largestComponentSize(self, nums: List[int]) -> int:\n        uf = UnionFind(max(nums) + 1)\n        for v in nums:\n            i = 2\n            while i <= v // i:\n                if v % i == 0:\n                    uf.union(v, i)\n                    uf.union(v, v // i)\n                i += 1\n        return max(Counter(uf.find(v) for v in nums).values())\n", "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def largestComponentSize(self, nums: list[int]) -> int:\n    ans = 0\n    uf = UnionFind(max(nums) + 1)\n    count = collections.Counter()\n\n    for num in nums:\n      for x in range(2, math.isqrt(num) + 1):\n        if num % x == 0:\n          uf.unionByRank(num, x)\n          uf.unionByRank(num, num // x)\n\n    for num in nums:\n      numRoot = uf.find(num)\n      count[numRoot] += 1\n      ans = max(ans, count[numRoot])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 972, "slug": "equal-rational-numbers", "solutions": ["class Solution:\n  def isRationalEqual(self, s: str, t: str) -> bool:\n    ratios = [1, 1 / 9, 1 / 99, 1 / 999, 1 / 9999]\n\n    def valueOf(s: str) -> float:\n      if s.find('(') == -1:\n        return float(s)\n\n      # Get the indices.\n      leftParenIndex = s.find('(')\n      rightParenIndex = s.find(')')\n      dotIndex = s.find('.')\n\n      # integerAndNonRepeating := <IntegerPart><.><NonRepeatingPart>\n      integerAndNonRepeating = float(s[:leftParenIndex])\n      nonRepeatingLength = leftParenIndex - dotIndex - 1\n\n      # repeating := <RepeatingPart>\n      repeating = int(s[leftParenIndex + 1:rightParenIndex])\n      repeatingLength = rightParenIndex - leftParenIndex - 1\n      return integerAndNonRepeating + repeating * 0.1**nonRepeatingLength * ratios[repeatingLength]\n\n    return abs(valueOf(s) - valueOf(t)) < 1e-9\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 997, "slug": "find-the-town-judge", "solutions": ["class Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        cnt1 = [0] * (n + 1)\n        cnt2 = [0] * (n + 1)\n        for a, b in trust:\n            cnt1[a] += 1\n            cnt2[b] += 1\n        for i in range(1, n + 1):\n            if cnt1[i] == 0 and cnt2[i] == n - 1:\n                return i\n        return -1\n", "class Solution:\n  def findJudge(self, n: int, trust: list[list[int]]) -> int:\n    count = [0] * (n + 1)\n\n    for a, b in trust:\n      count[a] -= 1\n      count[b] += 1\n\n    for i in range(1, n + 1):\n      if count[i] == n - 1:\n        return i\n\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 948, "slug": "bag-of-tokens", "solutions": ["class Solution:\n    def bagOfTokensScore(self, tokens: List[int], power: int) -> int:\n        tokens.sort()\n        ans = score = 0\n        i, j = 0, len(tokens) - 1\n        while i <= j:\n            if power >= tokens[i]:\n                power -= tokens[i]\n                score, i = score + 1, i + 1\n                ans = max(ans, score)\n            elif score:\n                power += tokens[j]\n                score, j = score - 1, j - 1\n            else:\n                break\n        return ans\n", "class Solution:\n  def bagOfTokensScore(self, tokens: list[int], power: int) -> int:\n    ans = 0\n    score = 0\n    q = collections.deque(sorted(tokens))\n\n    while q and (power >= q[0] or score):\n      while q and power >= q[0]:\n        # Play the smallest face up.\n        power -= q.popleft()\n        score += 1\n      ans = max(ans, score)\n      if q and score:\n        # Play the largest face down.\n        power += q.pop()\n        score -= 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 998, "slug": "maximum-binary-tree-ii", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def insertIntoMaxTree(\n        self, root: Optional[TreeNode], val: int\n    ) -> Optional[TreeNode]:\n        if root is None or root.val < val:\n            return TreeNode(val, root)\n        root.right = self.insertIntoMaxTree(root.right, val)\n        return root\n", "class Solution:\n  def insertIntoMaxTree(\n      self,\n      root: TreeNode | None,\n      val: int,\n  ) -> TreeNode | None:\n    if root.val < val:\n      return TreeNode(val, root, None)\n    curr = root\n    while curr.right and curr.right.val > val:\n      curr = curr.right\n    inserted = TreeNode(val, curr.right, None)\n    curr.right = inserted\n    return root\n", "class Solution:\n  def insertIntoMaxTree(\n      self,\n      root: TreeNode | None,\n      val: int,\n  ) -> TreeNode | None:\n    if not root:\n      return TreeNode(val)\n    if root.val < val:\n      return TreeNode(val, root, None)\n    root.right = self.insertIntoMaxTree(root.right, val)\n    return root\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 924, "slug": "minimize-malware-spread", "solutions": ["class UnionFind:\n    __slots__ = \"p\", \"size\"\n\n    def __init__(self, n: int):\n        self.p = list(range(n))\n        self.size = [1] * n\n\n    def find(self, x: int) -> int:\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n\n    def union(self, a: int, b: int) -> bool:\n        pa, pb = self.find(a), self.find(b)\n        if pa == pb:\n            return False\n        if self.size[pa] > self.size[pb]:\n            self.p[pb] = pa\n            self.size[pa] += self.size[pb]\n        else:\n            self.p[pa] = pb\n            self.size[pb] += self.size[pa]\n        return True\n\n    def get_size(self, root: int) -> int:\n        return self.size[root]\n\n\nclass Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        n = len(graph)\n        uf = UnionFind(n)\n        for i in range(n):\n            for j in range(i + 1, n):\n                graph[i][j] and uf.union(i, j)\n        cnt = Counter(uf.find(x) for x in initial)\n        ans, mx = n, 0\n        for x in initial:\n            root = uf.find(x)\n            if cnt[root] > 1:\n                continue\n            sz = uf.get_size(root)\n            if sz > mx or (sz == mx and x < ans):\n                ans = x\n                mx = sz\n        return min(initial) if ans == n else ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 944, "slug": "delete-columns-to-make-sorted", "solutions": ["class Solution:\n    def minDeletionSize(self, strs: List[str]) -> int:\n        m, n = len(strs[0]), len(strs)\n        ans = 0\n        for j in range(m):\n            for i in range(1, n):\n                if strs[i][j] < strs[i - 1][j]:\n                    ans += 1\n                    break\n        return ans\n", "class Solution:\n  def minDeletionSize(self, strs: list[str]) -> int:\n    ans = 0\n\n    for j in range(len(strs[0])):\n      for i in range(len(strs) - 1):\n        if strs[i][j] > strs[i + 1][j]:\n          ans += 1\n          break\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 928, "slug": "minimize-malware-spread-ii", "solutions": ["class UnionFind:\n    __slots__ = \"p\", \"size\"\n\n    def __init__(self, n: int):\n        self.p = list(range(n))\n        self.size = [1] * n\n\n    def find(self, x: int) -> int:\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n\n    def union(self, a: int, b: int) -> bool:\n        pa, pb = self.find(a), self.find(b)\n        if pa == pb:\n            return False\n        if self.size[pa] > self.size[pb]:\n            self.p[pb] = pa\n            self.size[pa] += self.size[pb]\n        else:\n            self.p[pa] = pb\n            self.size[pb] += self.size[pa]\n        return True\n\n    def get_size(self, root: int) -> int:\n        return self.size[root]\n\n\nclass Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        n = len(graph)\n        s = set(initial)\n        uf = UnionFind(n)\n        for i in range(n):\n            if i not in s:\n                for j in range(i + 1, n):\n                    graph[i][j] and j not in s and uf.union(i, j)\n\n        g = defaultdict(set)\n        cnt = Counter()\n        for i in initial:\n            for j in range(n):\n                if j not in s and graph[i][j]:\n                    g[i].add(uf.find(j))\n            for root in g[i]:\n                cnt[root] += 1\n\n        ans, mx = 0, -1\n        for i in initial:\n            t = sum(uf.get_size(root) for root in g[i] if cnt[root] == 1)\n            if t > mx or (t == mx and i < ans):\n                ans, mx = i, t\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 913, "slug": "cat-and-mouse", "solutions": ["HOLE, MOUSE_START, CAT_START = 0, 1, 2\nMOUSE_TURN, CAT_TURN = 0, 1\nMOUSE_WIN, CAT_WIN, TIE = 1, 2, 0\n\n\nclass Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        def get_prev_states(state):\n            m, c, t = state\n            pt = t ^ 1\n            pre = []\n            if pt == CAT_TURN:\n                for pc in graph[c]:\n                    if pc != HOLE:\n                        pre.append((m, pc, pt))\n            else:\n                for pm in graph[m]:\n                    pre.append((pm, c, pt))\n            return pre\n\n        n = len(graph)\n        ans = [[[0, 0] for _ in range(n)] for _ in range(n)]\n        degree = [[[0, 0] for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            for j in range(1, n):\n                degree[i][j][MOUSE_TURN] = len(graph[i])\n                degree[i][j][CAT_TURN] = len(graph[j])\n            for j in graph[HOLE]:\n                degree[i][j][CAT_TURN] -= 1\n        q = deque()\n        for j in range(1, n):\n            ans[0][j][MOUSE_TURN] = ans[0][j][CAT_TURN] = MOUSE_WIN\n            q.append((0, j, MOUSE_TURN))\n            q.append((0, j, CAT_TURN))\n        for i in range(1, n):\n            ans[i][i][MOUSE_TURN] = ans[i][i][CAT_TURN] = CAT_WIN\n            q.append((i, i, MOUSE_TURN))\n            q.append((i, i, CAT_TURN))\n        while q:\n            state = q.popleft()\n            t = ans[state[0]][state[1]][state[2]]\n            for prev_state in get_prev_states(state):\n                pm, pc, pt = prev_state\n                if ans[pm][pc][pt] == TIE:\n                    win = (t == MOUSE_WIN and pt == MOUSE_TURN) or (\n                        t == CAT_WIN and pt == CAT_TURN\n                    )\n                    if win:\n                        ans[pm][pc][pt] = t\n                        q.append(prev_state)\n                    else:\n                        degree[pm][pc][pt] -= 1\n                        if degree[pm][pc][pt] == 0:\n                            ans[pm][pc][pt] = t\n                            q.append(prev_state)\n        return ans[MOUSE_START][CAT_START][MOUSE_TURN]\n", "from enum import IntEnum\n\n\nclass State(IntEnum):\n  DRAW = 0\n  MOUSE_WIN = 1\n  CAT_WIN = 2\n\n\nclass Solution:\n  def catMouseGame(self, graph: list[list[int]]) -> int:\n    n = len(graph)\n    # result of (cat, mouse, move)\n    # move := 0 (mouse) // 1 (cat)\n    states = [[[0] * 2 for _ in range(n)] for _ in range(n)]\n    outDegree = [[[0] * 2 for _ in range(n)] for _ in range(n)]\n    q = collections.deque()  # (cat, mouse, move, state)\n\n    for cat in range(n):\n      for mouse in range(n):\n        outDegree[cat][mouse][0] = len(graph[mouse])\n        outDegree[cat][mouse][1] = len(graph[cat]) - graph[cat].count(0)\n\n    # Start from the states s.t. the winner can be determined.\n    for cat in range(1, n):\n      for move in range(2):\n        # Mouse is in the hole.\n        states[cat][0][move] = int(State.MOUSE_WIN)\n        q.append((cat, 0, move, int(State.MOUSE_WIN)))\n        # Cat catches mouse.\n        states[cat][cat][move] = int(State.CAT_WIN)\n        q.append((cat, cat, move, int(State.CAT_WIN)))\n\n    while q:\n      cat, mouse, move, state = q.popleft()\n      if cat == 2 and mouse == 1 and move == 0:\n        return state\n      prevMove = move ^ 1\n      for prev in graph[cat if prevMove else mouse]:\n        prevCat = prev if prevMove else cat\n        if prevCat == 0:  # invalid\n          continue\n        prevMouse = mouse if prevMove else prev\n        # The state has been determined.\n        if states[prevCat][prevMouse][prevMove]:\n          continue\n        if (prevMove == 0 and state == int(State.MOUSE_WIN) or\n                prevMove == 1 and state == int(State.CAT_WIN)):\n          states[prevCat][prevMouse][prevMove] = state\n          q.append((prevCat, prevMouse, prevMove, state))\n        else:\n          outDegree[prevCat][prevMouse][prevMove] -= 1\n          if outDegree[prevCat][prevMouse][prevMove] == 0:\n            states[prevCat][prevMouse][prevMove] = state\n            q.append((prevCat, prevMouse, prevMove, state))\n\n    return states[2][1][0]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 903, "slug": "valid-permutations-for-di-sequence", "solutions": ["class Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mod = 10**9 + 7\n        n = len(s)\n        f = [[0] * (n + 1) for _ in range(n + 1)]\n        f[0][0] = 1\n        for i, c in enumerate(s, 1):\n            if c == \"D\":\n                for j in range(i + 1):\n                    for k in range(j, i):\n                        f[i][j] = (f[i][j] + f[i - 1][k]) % mod\n            else:\n                for j in range(i + 1):\n                    for k in range(j):\n                        f[i][j] = (f[i][j] + f[i - 1][k]) % mod\n        return sum(f[n][j] for j in range(n + 1)) % mod\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 987, "slug": "vertical-order-traversal-of-a-binary-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def dfs(root: Optional[TreeNode], i: int, j: int):\n            if root is None:\n                return\n            nodes.append((j, i, root.val))\n            dfs(root.left, i + 1, j - 1)\n            dfs(root.right, i + 1, j + 1)\n\n        nodes = []\n        dfs(root, 0, 0)\n        nodes.sort()\n        ans = []\n        prev = -2000\n        for j, _, val in nodes:\n            if prev != j:\n                ans.append([])\n                prev = j\n            ans[-1].append(val)\n        return ans\n", "class Solution:\n  def verticalTraversal(self, root: TreeNode | None) -> list[list[int]]:\n    ans = []\n    xToNodes = collections.defaultdict(list)\n\n    def dfs(node: TreeNode | None, x: int, y: int) -> None:\n      if not node:\n        return\n      xToNodes[x].append((-y, node.val))\n      dfs(node.left, x - 1, y - 1)\n      dfs(node.right, x + 1, y - 1)\n\n    dfs(root, 0, 0)\n\n    for _, nodes in sorted(xToNodes.items(), key=lambda x: x[0]):\n      ans.append([val for _, val in sorted(nodes)])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 988, "slug": "smallest-string-starting-from-leaf", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def smallestFromLeaf(self, root: TreeNode) -> str:\n        ans = chr(ord('z') + 1)\n\n        def dfs(root, path):\n            nonlocal ans\n            if root:\n                path.append(chr(ord('a') + root.val))\n                if root.left is None and root.right is None:\n                    ans = min(ans, ''.join(reversed(path)))\n                dfs(root.left, path)\n                dfs(root.right, path)\n                path.pop()\n\n        dfs(root, [])\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 967, "slug": "numbers-with-same-consecutive-differences", "solutions": ["class Solution:\n    def numsSameConsecDiff(self, n: int, k: int) -> List[int]:\n        def dfs(x: int):\n            if x >= boundary:\n                ans.append(x)\n                return\n            last = x % 10\n            if last + k <= 9:\n                dfs(x * 10 + last + k)\n            if last - k >= 0 and k != 0:\n                dfs(x * 10 + last - k)\n\n        ans = []\n        boundary = 10 ** (n - 1)\n        for i in range(1, 10):\n            dfs(i)\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 921, "slug": "minimum-add-to-make-parentheses-valid", "solutions": ["class Solution:\n    def minAddToMakeValid(self, s: str) -> int:\n        stk = []\n        for c in s:\n            if c == ')' and stk and stk[-1] == '(':\n                stk.pop()\n            else:\n                stk.append(c)\n        return len(stk)\n", "class Solution:\n  def minAddToMakeValid(self, s: str) -> int:\n    l = 0\n    r = 0\n\n    for c in s:\n      if c == '(':\n        l += 1\n      else:\n        if l == 0:\n          r += 1\n        else:\n          l -= 1\n\n    return l + r\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 974, "slug": "subarray-sums-divisible-by-k", "solutions": ["class Solution:\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\n        cnt = Counter({0: 1})\n        ans = s = 0\n        for x in nums:\n            s = (s + x) % k\n            ans += cnt[s]\n            cnt[s] += 1\n        return ans\n", "class Solution:\n  def subarraysDivByK(self, nums: list[int], k: int) -> int:\n    ans = 0\n    prefix = 0\n    count = [0] * k\n    count[0] = 1\n\n    for num in nums:\n      prefix = (prefix + num % k + k) % k\n      ans += count[prefix]\n      count[prefix] += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 906, "slug": "super-palindromes", "solutions": ["ps = []\nfor i in range(1, 10**5 + 1):\n    s = str(i)\n    t1 = s[::-1]\n    t2 = s[:-1][::-1]\n    ps.append(int(s + t1))\n    ps.append(int(s + t2))\n\n\nclass Solution:\n    def superpalindromesInRange(self, left: str, right: str) -> int:\n        def is_palindrome(x: int) -> bool:\n            y, t = 0, x\n            while t:\n                y = y * 10 + t % 10\n                t //= 10\n            return x == y\n\n        l, r = int(left), int(right)\n        return sum(l <= x <= r and is_palindrome(x) for x in map(lambda x: x * x, ps))\n", "class Solution:\n  def superpalindromesInRange(self, left: str, right: str) -> int:\n    def nextPalindrome(num: int) -> int:\n      s = str(num)\n      n = len(s)\n\n      half = s[0:(n + 1) // 2]\n      reversedHalf = half[:n // 2][::-1]\n      candidate = int(half + reversedHalf)\n      if candidate >= num:\n        return candidate\n\n      half = str(int(half) + 1)\n      reversedHalf = half[:n // 2][::-1]\n      return int(half + reversedHalf)\n\n    def isPalindrome(num: int) -> bool:\n      s = str(num)\n      l = 0\n      r = len(s) - 1\n\n      while l < r:\n        if s[l] != s[r]:\n          return False\n        l += 1\n        r -= 1\n\n      return True\n\n    ans = 0\n    l = int(left)\n    r = int(right)\n    i = math.isqrt(l)\n\n    while i * i <= r:\n      palindrome = nextPalindrome(i)\n      squared = palindrome**2\n      if squared <= r and isPalindrome(squared):\n        ans += 1\n      i = palindrome + 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 919, "slug": "complete-binary-tree-inserter", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass CBTInserter:\n\n    def __init__(self, root: Optional[TreeNode]):\n        self.tree = []\n        q = deque([root])\n        while q:\n            for _ in range(len(q)):\n                node = q.popleft()\n                self.tree.append(node)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n\n    def insert(self, val: int) -> int:\n        p = self.tree[(len(self.tree) - 1) // 2]\n        node = TreeNode(val)\n        self.tree.append(node)\n        if p.left is None:\n            p.left = node\n        else:\n            p.right = node\n        return p.val\n\n    def get_root(self) -> Optional[TreeNode]:\n        return self.tree[0]\n\n\n# Your CBTInserter object will be instantiated and called as such:\n# obj = CBTInserter(root)\n# param_1 = obj.insert(val)\n# param_2 = obj.get_root()\n", "class CBTInserter:\n  def __init__(self, root: TreeNode | None):\n    self.tree = [root]\n    for node in self.tree:\n      if node.left:\n        self.tree.append(node.left)\n      if node.right:\n        self.tree.append(node.right)\n\n  def insert(self, v: int) -> int:\n    n = len(self.tree)\n    self.tree.append(TreeNode(v))\n    parent = self.tree[(n - 1) // 2]\n    if n % 2 == 1:\n      parent.left = self.tree[-1]\n    else:\n      parent.right = self.tree[-1]\n    return parent.val\n\n  def get_root(self) -> TreeNode | None:\n    return self.tree[0]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 904, "slug": "fruit-into-baskets", "solutions": ["class Solution:\n    def totalFruit(self, fruits: List[int]) -> int:\n        cnt = Counter()\n        ans = j = 0\n        for i, x in enumerate(fruits):\n            cnt[x] += 1\n            while len(cnt) > 2:\n                y = fruits[j]\n                cnt[y] -= 1\n                if cnt[y] == 0:\n                    cnt.pop(y)\n                j += 1\n            ans = max(ans, i - j + 1)\n        return ans\n", "class Solution:\n  def totalFruit(self, fruits: list[int]) -> int:\n    ans = 0\n    count = collections.defaultdict(int)\n\n    l = 0\n    for r, fruit in enumerate(fruits):\n      count[fruit] += 1\n      while len(count) > 2:\n        count[fruits[l]] -= 1\n        if count[fruits[l]] == 0:\n          del count[fruits[l]]\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 914, "slug": "x-of-a-kind-in-a-deck-of-cards", "solutions": ["class Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        cnt = Counter(deck)\n        return reduce(gcd, cnt.values()) >= 2\n", "class Solution:\n  def hasGroupsSizeX(self, deck: list[int]) -> bool:\n    count = collections.Counter(deck)\n    return functools.reduce(math.gcd, count.values()) >= 2\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 947, "slug": "most-stones-removed-with-same-row-or-column", "solutions": ["class UnionFind:\n    def __init__(self, n):\n        self.p = list(range(n))\n        self.size = [1] * n\n\n    def find(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n\n    def union(self, a, b):\n        pa, pb = self.find(a), self.find(b)\n        if pa == pb:\n            return False\n        if self.size[pa] > self.size[pb]:\n            self.p[pb] = pa\n            self.size[pa] += self.size[pb]\n        else:\n            self.p[pa] = pb\n            self.size[pb] += self.size[pa]\n        return True\n\n\nclass Solution:\n    def removeStones(self, stones: List[List[int]]) -> int:\n        uf = UnionFind(len(stones))\n        ans = 0\n        for i, (x1, y1) in enumerate(stones):\n            for j, (x2, y2) in enumerate(stones[:i]):\n                if x1 == x2 or y1 == y2:\n                    ans += uf.union(i, j)\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 920, "slug": "number-of-music-playlists", "solutions": ["class Solution:\n    def numMusicPlaylists(self, n: int, goal: int, k: int) -> int:\n        mod = 10**9 + 7\n        f = [[0] * (n + 1) for _ in range(goal + 1)]\n        f[0][0] = 1\n        for i in range(1, goal + 1):\n            for j in range(1, n + 1):\n                f[i][j] = f[i - 1][j - 1] * (n - j + 1)\n                if j > k:\n                    f[i][j] += f[i - 1][j] * (j - k)\n                f[i][j] %= mod\n        return f[goal][n]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 963, "slug": "minimum-area-rectangle-ii", "solutions": ["class Solution:\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\n        s = {(x, y) for x, y in points}\n        n = len(points)\n        ans = inf\n        for i in range(n):\n            x1, y1 = points[i]\n            for j in range(n):\n                if j != i:\n                    x2, y2 = points[j]\n                    for k in range(j + 1, n):\n                        if k != i:\n                            x3, y3 = points[k]\n                            x4 = x2 - x1 + x3\n                            y4 = y2 - y1 + y3\n                            if (x4, y4) in s:\n                                v21 = (x2 - x1, y2 - y1)\n                                v31 = (x3 - x1, y3 - y1)\n                                if v21[0] * v31[0] + v21[1] * v31[1] == 0:\n                                    w = sqrt(v21[0] ** 2 + v21[1] ** 2)\n                                    h = sqrt(v31[0] ** 2 + v31[1] ** 2)\n                                    ans = min(ans, w * h)\n        return 0 if ans == inf else ans\n", "class Solution:\n  def minAreaFreeRect(self, points: list[list[int]]) -> float:\n    ans = math.inf\n    # For each A, B pair points, {hash(A, B): (ax, ay, bx, by)}.\n    centerToPoints = collections.defaultdict(list)\n\n    for ax, ay in points:\n      for bx, by in points:\n        center = ((ax + bx) / 2, (ay + by) / 2)\n        centerToPoints[center].append((ax, ay, bx, by))\n\n    def dist(px: int, py: int, qx: int, qy: int) -> float:\n      return (px - qx)**2 + (py - qy)**2\n\n    # For all pair points \"that share the same center\".\n    for points in centerToPoints.values():\n      for ax, ay, _, _ in points:\n        for cx, cy, dx, dy in points:\n          # AC is perpendicular to AD.\n          # AC dot AD = (cx - ax, cy - ay) dot (dx - ax, dy - ay) == 0.\n          if (cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0:\n            squaredArea = dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy)\n            if squaredArea > 0:\n              ans = min(ans, squaredArea)\n\n    return 0 if ans == math.inf else math.sqrt(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 983, "slug": "minimum-cost-for-tickets", "solutions": ["class Solution:\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\n        @cache\n        def dfs(i: int) -> int:\n            if i >= n:\n                return 0\n            ans = inf\n            for c, v in zip(costs, valid):\n                j = bisect_left(days, days[i] + v)\n                ans = min(ans, c + dfs(j))\n            return ans\n\n        n = len(days)\n        valid = [1, 7, 30]\n        return dfs(0)\n", "class Solution:\n  def mincostTickets(self, days: list[int], costs: list[int]) -> int:\n    ans = 0\n    last7 = collections.deque()\n    last30 = collections.deque()\n\n    for day in days:\n      while last7 and last7[0][0] + 7 <= day:\n        last7.popleft()\n      while last30 and last30[0][0] + 30 <= day:\n        last30.popleft()\n      last7.append([day, ans + costs[1]])\n      last30.append([day, ans + costs[2]])\n      ans = min(ans + costs[0], last7[0][1], last30[0][1])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 977, "slug": "squares-of-a-sorted-array", "solutions": ["class Solution:\n    def sortedSquares(self, nums: List[int]) -> List[int]:\n        ans = []\n        i, j = 0, len(nums) - 1\n        while i <= j:\n            a = nums[i] * nums[i]\n            b = nums[j] * nums[j]\n            if a > b:\n                ans.append(a)\n                i += 1\n            else:\n                ans.append(b)\n                j -= 1\n        return ans[::-1]\n", "class Solution:\n  def sortedSquares(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n    l = 0\n    r = n - 1\n    ans = [0] * n\n\n    while n:\n      n -= 1\n      if abs(nums[l]) > abs(nums[r]):\n        ans[n] = nums[l] * nums[l]\n        l += 1\n      else:\n        ans[n] = nums[r] * nums[r]\n        r -= 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 940, "slug": "distinct-subsequences-ii", "solutions": ["class Solution:\n    def distinctSubseqII(self, s: str) -> int:\n        mod = 10**9 + 7\n        n = len(s)\n        dp = [[0] * 26 for _ in range(n + 1)]\n        for i, c in enumerate(s, 1):\n            k = ord(c) - ord('a')\n            for j in range(26):\n                if j == k:\n                    dp[i][j] = sum(dp[i - 1]) % mod + 1\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        return sum(dp[-1]) % mod\n", "class Solution:\n  def distinctSubseqII(self, s: str) -> int:\n    MOD = 1_000_000_007\n    # endsIn[i] := the number of subsequence that end in ('a' + i)\n    endsIn = [0] * 26\n\n    for c in s:\n      endsIn[ord(c) - ord('a')] = (sum(endsIn) + 1) % MOD\n\n    return sum(endsIn) % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 971, "slug": "flip-binary-tree-to-match-preorder-traversal", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def flipMatchVoyage(self, root: Optional[TreeNode], voyage: List[int]) -> List[int]:\n        def dfs(root):\n            nonlocal i, ok\n            if root is None or not ok:\n                return\n            if root.val != voyage[i]:\n                ok = False\n                return\n            i += 1\n            if root.left is None or root.left.val == voyage[i]:\n                dfs(root.left)\n                dfs(root.right)\n            else:\n                ans.append(root.val)\n                dfs(root.right)\n                dfs(root.left)\n\n        ans = []\n        i = 0\n        ok = True\n        dfs(root)\n        return ans if ok else [-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 916, "slug": "word-subsets", "solutions": ["class Solution:\n    def wordSubsets(self, words1: List[str], words2: List[str]) -> List[str]:\n        cnt = Counter()\n        for b in words2:\n            t = Counter(b)\n            for c, v in t.items():\n                cnt[c] = max(cnt[c], v)\n        ans = []\n        for a in words1:\n            t = Counter(a)\n            if all(v <= t[c] for c, v in cnt.items()):\n                ans.append(a)\n        return ans\n", "class Solution:\n  def wordSubsets(self, A: list[str], B: list[str]) -> list[str]:\n    count = collections.Counter()\n\n    for b in B:\n      count = count | collections.Counter(b)\n\n    return [a for a in A if collections.Counter(a) & count == count]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 923, "slug": "3sum-with-multiplicity", "solutions": ["class Solution:\n    def threeSumMulti(self, arr: List[int], target: int) -> int:\n        mod = 10**9 + 7\n        cnt = Counter(arr)\n        ans = 0\n        for j, b in enumerate(arr):\n            cnt[b] -= 1\n            for a in arr[:j]:\n                c = target - a - b\n                ans = (ans + cnt[c]) % mod\n        return ans\n", "class Solution:\n  def threeSumMulti(self, arr: list[int], target: int) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    count = collections.Counter(arr)\n\n    for i, x in count.items():\n      for j, y in count.items():\n        k = target - i - j\n        if k not in count:\n          continue\n        if i == j and j == k:\n          ans = (ans + x * (x - 1) * (x - 2) // 6) % MOD\n        elif i == j and j != k:\n          ans = (ans + x * (x - 1) // 2 * count[k]) % MOD\n        elif i < j and j < k:\n          ans = (ans + x * y * count[k]) % MOD\n\n    return ans % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 929, "slug": "unique-email-addresses", "solutions": ["class Solution:\n    def numUniqueEmails(self, emails: List[str]) -> int:\n        s = set()\n        for email in emails:\n            local, domain = email.split(\"@\")\n            t = []\n            for c in local:\n                if c == \".\":\n                    continue\n                if c == \"+\":\n                    break\n                t.append(c)\n            s.add(\"\".join(t) + \"@\" + domain)\n        return len(s)\n", "class Solution:\n  def numUniqueEmails(self, emails: list[str]) -> int:\n    seen = set()\n\n    for email in emails:\n      local, domain = email.split('@')\n      local = local.split('+')[0].replace('.', '')\n      seen.add(local + '@' + domain)\n\n    return len(seen)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 936, "slug": "stamping-the-sequence", "solutions": ["class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        m, n = len(stamp), len(target)\n        indeg = [m] * (n - m + 1)\n        q = deque()\n        g = [[] for _ in range(n)]\n        for i in range(n - m + 1):\n            for j, c in enumerate(stamp):\n                if target[i + j] == c:\n                    indeg[i] -= 1\n                    if indeg[i] == 0:\n                        q.append(i)\n                else:\n                    g[i + j].append(i)\n        ans = []\n        vis = [False] * n\n        while q:\n            i = q.popleft()\n            ans.append(i)\n            for j in range(m):\n                if not vis[i + j]:\n                    vis[i + j] = True\n                    for k in g[i + j]:\n                        indeg[k] -= 1\n                        if indeg[k] == 0:\n                            q.append(k)\n        return ans[::-1] if all(vis) else []\n", "class Solution:\n  def movesToStamp(self, stamp: str, target: str) -> list[int]:\n    def stampify(s: int) -> int:\n      \"\"\"\n      Stamps target[i..i + |stamp|) and returns the number of newly stamped\n      characters.\n      e.g. stampify(\"abc\", \"ababc\", 2) returns 3 because target becomes \"ab***\".\n      \"\"\"\n      stampified = len(stamp)\n\n      for i, st in enumerate(stamp):\n        if target[s + i] == '*':  # It's already been stamped.\n          stampified -= 1\n        elif target[s + i] != st:  # We can't stamp on the index i.\n          return 0\n\n      for i in range(s, s + len(stamp)):\n        target[i] = '*'\n\n      return stampified\n\n    ans = []\n    target = list(target)\n    # stamped[i] := True if we already stamped target by stamping on index i\n    stamped = [False] * len(target)\n    stampedCount = 0  # Our goal is to make stampedCount = |target|.\n\n    while stampedCount < len(target):\n      isStamped = False\n      # Try to stamp target[i..i + |stamp|) for each index.\n      for i in range(len(target) - len(stamp) + 1):\n        if stamped[i]:\n          continue\n        stampified = stampify(i)\n        if stampified == 0:\n          continue\n        stampedCount += stampified\n        isStamped = True\n        stamped[i] = True\n        ans.append(i)\n      # After trying to stamp on each index, we can't find a valid stamp.\n      if not isStamped:\n        return []\n\n    return ans[::-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 930, "slug": "binary-subarrays-with-sum", "solutions": ["class Solution:\n    def numSubarraysWithSum(self, nums: List[int], goal: int) -> int:\n        cnt = Counter({0: 1})\n        ans = s = 0\n        for v in nums:\n            s += v\n            ans += cnt[s - goal]\n            cnt[s] += 1\n        return ans\n", "class Solution:\n  def numSubarraysWithSum(self, nums: list[int], goal: int) -> int:\n    def numSubarraysWithSumAtMost(goal: int) -> int:\n      res = 0\n      count = 0\n      l = 0\n      r = 0\n\n      while r < len(nums):\n        count += nums[r]\n        r += 1\n        while l < r and count > goal:\n          count -= nums[l]\n          l += 1\n        # nums[l..r), nums[l + 1..r), ..., nums[r - 1]\n        res += r - l\n\n      return res\n\n    return numSubarraysWithSumAtMost(goal) - numSubarraysWithSumAtMost(goal - 1)\n", "class Solution:\n  def numSubarraysWithSum(self, nums: list[int], goal: int) -> int:\n    ans = 0\n    prefix = 0\n    # {prefix: number of occurrence}\n    count = collections.Counter({0: 1})\n\n    for num in nums:\n      prefix += num\n      ans += count[prefix - goal]\n      count[prefix] += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 953, "slug": "verifying-an-alien-dictionary", "solutions": ["class Solution:\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\n        m = {c: i for i, c in enumerate(order)}\n        for i in range(20):\n            prev = -1\n            valid = True\n            for x in words:\n                curr = -1 if i >= len(x) else m[x[i]]\n                if prev > curr:\n                    return False\n                if prev == curr:\n                    valid = False\n                prev = curr\n            if valid:\n                return True\n        return True\n", "class Solution:\n  def isAlienSorted(self, words: list[str], order: str) -> bool:\n    dict = {c: i for i, c in enumerate(order)}\n    words = [[dict[c] for c in word] for word in words]\n    return all(w1 <= w2 for w1, w2 in zip(words, words[1:]))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 951, "slug": "flip-equivalent-binary-trees", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def flipEquiv(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:\n        def dfs(root1, root2):\n            if root1 == root2 or (root1 is None and root2 is None):\n                return True\n            if root1 is None or root2 is None or root1.val != root2.val:\n                return False\n            return (dfs(root1.left, root2.left) and dfs(root1.right, root2.right)) or (\n                dfs(root1.left, root2.right) and dfs(root1.right, root2.left)\n            )\n\n        return dfs(root1, root2)\n", "class Solution:\n  def flipEquiv(self, root1: TreeNode | None, root2: TreeNode | None) -> bool:\n    if not root1:\n      return not root2\n    if not root2:\n      return not root1\n    if root1.val != root2.val:\n      return False\n    return (self.flipEquiv(root1.left, root2.left) and\n            self.flipEquiv(root1.right, root2.right) or\n            self.flipEquiv(root1.left, root2.right) and\n            self.flipEquiv(root1.right, root2.left))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 925, "slug": "long-pressed-name", "solutions": ["class Solution:\n    def isLongPressedName(self, name: str, typed: str) -> bool:\n        m, n = len(name), len(typed)\n        i = j = 0\n        while i < m and j < n:\n            if name[i] != typed[j]:\n                return False\n            x = i + 1\n            while x < m and name[x] == name[i]:\n                x += 1\n            y = j + 1\n            while y < n and typed[y] == typed[j]:\n                y += 1\n            if x - i > y - j:\n                return False\n            i, j = x, y\n        return i == m and j == n\n", "class Solution:\n  def isLongPressedName(self, name: str, typed: str) -> bool:\n    i = 0\n\n    for j, t in enumerate(typed):\n      if i < len(name) and name[i] == t:\n        i += 1\n      elif j == 0 or t != typed[j - 1]:\n        return False\n\n    return i == len(name)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 966, "slug": "vowel-spellchecker", "solutions": ["class Solution:\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\n        def f(w):\n            t = []\n            for c in w:\n                t.append(\"*\" if c in \"aeiou\" else c)\n            return \"\".join(t)\n\n        s = set(wordlist)\n        low, pat = {}, {}\n        for w in wordlist:\n            t = w.lower()\n            low.setdefault(t, w)\n            pat.setdefault(f(t), w)\n\n        ans = []\n        for q in queries:\n            if q in s:\n                ans.append(q)\n                continue\n            q = q.lower()\n            if q in low:\n                ans.append(low[q])\n                continue\n            q = f(q)\n            if q in pat:\n                ans.append(pat[q])\n                continue\n            ans.append(\"\")\n        return ans\n", "class Solution:\n  def spellchecker(self, wordlist: list[str], queries: list[str]) -> list[str]:\n    def lowerKey(word: str) -> str:\n      return '$' + ''.join([c.lower() for c in word])\n\n    def vowelKey(word: str) -> str:\n      return ''.join(['*' if c.lower() in 'aeiou' else c.lower() for c in word])\n\n    ans = []\n    dict = {}\n\n    for word in wordlist:\n      dict.setdefault(word, word)\n      dict.setdefault(lowerKey(word), word)\n      dict.setdefault(vowelKey(word), word)\n\n    for query in queries:\n      if query in dict:\n        ans.append(dict[query])\n      elif lowerKey(query) in dict:\n        ans.append(dict[lowerKey(query)])\n      elif vowelKey(query) in dict:\n        ans.append(dict[vowelKey(query)])\n      else:\n        ans.append('')\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 965, "slug": "univalued-binary-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isUnivalTree(self, root: Optional[TreeNode]) -> bool:\n        def dfs(root: Optional[TreeNode]) -> bool:\n            if root is None:\n                return True\n            return root.val == x and dfs(root.left) and dfs(root.right)\n\n        x = root.val\n        return dfs(root)\n", "class Solution:\n  def isUnivalTree(self, root: TreeNode | None) -> bool:\n    if not root:\n      return True\n    if root.left and root.left.val != root.val:\n      return False\n    if root.right and root.right.val != root.val:\n      return False\n    return self.isUnivalTree(root.left) and self.isUnivalTree(root.right)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 957, "slug": "prison-cells-after-n-days", "solutions": ["class Solution:\n  def prisonAfterNDays(self, cells: list[int], n: int) -> list[int]:\n    nextDayCells = [0] * len(cells)\n    day = 0\n\n    while n > 0:\n      n -= 1\n      for i in range(1, len(cells) - 1):\n        nextDayCells[i] = 1 if cells[i - 1] == cells[i + 1] else 0\n      if day == 0:\n        firstDayCells = nextDayCells.copy()\n      elif nextDayCells == firstDayCells:\n        n %= day\n      cells = nextDayCells.copy()\n      day += 1\n\n    return cells\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 986, "slug": "interval-list-intersections", "solutions": ["class Solution:\n    def intervalIntersection(\n        self, firstList: List[List[int]], secondList: List[List[int]]\n    ) -> List[List[int]]:\n        i = j = 0\n        ans = []\n        while i < len(firstList) and j < len(secondList):\n            s1, e1, s2, e2 = *firstList[i], *secondList[j]\n            l, r = max(s1, s2), min(e1, e2)\n            if l <= r:\n                ans.append([l, r])\n            if e1 < e2:\n                i += 1\n            else:\n                j += 1\n        return ans\n", "class Solution:\n  def intervalIntersection(self, firstList: list[list[int]],\n                           secondList: list[list[int]]) -> list[list[int]]:\n    ans = []\n    i = 0\n    j = 0\n\n    while i < len(firstList) and j < len(secondList):\n      # lo := the start of the intersection\n      # hi := the end of the intersection\n      lo = max(firstlist[i][0], secondlist[j][0])\n      hi = min(firstlist[i][1], secondlist[j][1])\n      if lo <= hi:\n        ans.append([lo, hi])\n      if firstlist[i][1] < secondlist[j][1]:\n        i += 1\n      else:\n        j += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 981, "slug": "time-based-key-value-store", "solutions": ["class TimeMap:\n    def __init__(self):\n        self.ktv = defaultdict(list)\n\n    def set(self, key: str, value: str, timestamp: int) -> None:\n        self.ktv[key].append((timestamp, value))\n\n    def get(self, key: str, timestamp: int) -> str:\n        if key not in self.ktv:\n            return ''\n        tv = self.ktv[key]\n        i = bisect_right(tv, (timestamp, chr(127)))\n        return tv[i - 1][1] if i else ''\n\n\n# Your TimeMap object will be instantiated and called as such:\n# obj = TimeMap()\n# obj.set(key,value,timestamp)\n# param_2 = obj.get(key,timestamp)\n", "class TimeMap:\n  def __init__(self):\n    self.values = collections.defaultdict(list)\n    self.timestamps = collections.defaultdict(list)\n\n  def set(self, key: str, value: str, timestamp: int) -> None:\n    self.values[key].append(value)\n    self.timestamps[key].append(timestamp)\n\n  def get(self, key: str, timestamp: int) -> str:\n    if key not in self.timestamps:\n      return ''\n    i = bisect.bisect(self.timestamps[key], timestamp)\n    return self.values[key][i - 1] if i > 0 else ''\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 907, "slug": "sum-of-subarray-minimums", "solutions": ["class Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        n = len(arr)\n        left = [-1] * n\n        right = [n] * n\n        stk = []\n        for i, v in enumerate(arr):\n            while stk and arr[stk[-1]] >= v:\n                stk.pop()\n            if stk:\n                left[i] = stk[-1]\n            stk.append(i)\n\n        stk = []\n        for i in range(n - 1, -1, -1):\n            while stk and arr[stk[-1]] > arr[i]:\n                stk.pop()\n            if stk:\n                right[i] = stk[-1]\n            stk.append(i)\n        mod = 10**9 + 7\n        return sum((i - left[i]) * (right[i] - i) * v for i, v in enumerate(arr)) % mod\n", "class Solution:\n  def sumSubarrayMins(self, arr: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(arr)\n    ans = 0\n    # prevMin[i] := index k s.t. arr[k] is the previous minimum in arr[:i]\n    prevMin = [-1] * n\n    # nextMin[i] := index k s.t. arr[k] is the next minimum in arr[i + 1:]\n    nextMin = [n] * n\n    stack = []\n\n    for i, a in enumerate(arr):\n      while stack and arr[stack[-1]] > a:\n        index = stack.pop()\n        nextMin[index] = i\n      if stack:\n        prevMin[i] = stack[-1]\n      stack.append(i)\n\n    for i, a in enumerate(arr):\n      ans += a * (i - prevMin[i]) * (nextMin[i] - i)\n      ans %= MOD\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 937, "slug": "reorder-data-in-log-files", "solutions": ["class Solution:\n    def reorderLogFiles(self, logs: List[str]) -> List[str]:\n        def f(log: str):\n            id_, rest = log.split(\" \", 1)\n            return (0, rest, id_) if rest[0].isalpha() else (1,)\n\n        return sorted(logs, key=f)\n", "class Solution:\n  def reorderLogFiles(self, logs: list[str]) -> list[str]:\n    digitLogs = []\n    letterLogs = []\n\n    for log in logs:\n      i = log.index(' ')\n      if log[i + 1].isdigit():\n        digitLogs.append(log)\n      else:\n        letterLogs.append((log[:i], log[i + 1:]))\n\n    letterLogs.sort(key=lambda x: (x[1], x[0]))\n    return [identifier + ' ' + letters for identifier, letters in letterLogs] + digitLogs\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 943, "slug": "find-the-shortest-superstring", "solutions": ["class Solution:\n    def shortestSuperstring(self, words: List[str]) -> str:\n        n = len(words)\n        g = [[0] * n for _ in range(n)]\n        for i, a in enumerate(words):\n            for j, b in enumerate(words):\n                if i != j:\n                    for k in range(min(len(a), len(b)), 0, -1):\n                        if a[-k:] == b[:k]:\n                            g[i][j] = k\n                            break\n        dp = [[0] * n for _ in range(1 << n)]\n        p = [[-1] * n for _ in range(1 << n)]\n        for i in range(1 << n):\n            for j in range(n):\n                if (i >> j) & 1:\n                    pi = i ^ (1 << j)\n                    for k in range(n):\n                        if (pi >> k) & 1:\n                            v = dp[pi][k] + g[k][j]\n                            if v > dp[i][j]:\n                                dp[i][j] = v\n                                p[i][j] = k\n        j = 0\n        for i in range(n):\n            if dp[-1][i] > dp[-1][j]:\n                j = i\n        arr = [j]\n        i = (1 << n) - 1\n        while p[i][j] != -1:\n            i, j = i ^ (1 << j), p[i][j]\n            arr.append(j)\n        arr = arr[::-1]\n        vis = set(arr)\n        arr.extend([j for j in range(n) if j not in vis])\n        ans = [words[arr[0]]] + [words[j][g[i][j] :] for i, j in pairwise(arr)]\n        return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 985, "slug": "sum-of-even-numbers-after-queries", "solutions": ["class Solution:\n    def sumEvenAfterQueries(\n        self, nums: List[int], queries: List[List[int]]\n    ) -> List[int]:\n        s = sum(x for x in nums if x % 2 == 0)\n        ans = []\n        for v, i in queries:\n            if nums[i] % 2 == 0:\n                s -= nums[i]\n            nums[i] += v\n            if nums[i] % 2 == 0:\n                s += nums[i]\n            ans.append(s)\n        return ans\n", "class Solution:\n  def sumEvenAfterQueries(\n      self,\n      nums: list[int],\n      queries: list[list[int]],\n  ) -> list[int]:\n    ans = []\n    summ = sum(a for a in nums if a % 2 == 0)\n\n    for val, index in queries:\n      if nums[index] % 2 == 0:\n        summ -= nums[index]\n      nums[index] += val\n      if nums[index] % 2 == 0:\n        summ += nums[index]\n      ans.append(summ)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 958, "slug": "check-completeness-of-a-binary-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isCompleteTree(self, root: TreeNode) -> bool:\n        q = deque([root])\n        while q:\n            node = q.popleft()\n            if node is None:\n                break\n            q.append(node.left)\n            q.append(node.right)\n        return all(node is None for node in q)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 962, "slug": "maximum-width-ramp", "solutions": ["class Solution:\n    def maxWidthRamp(self, nums: List[int]) -> int:\n        stk = []\n        for i, v in enumerate(nums):\n            if not stk or nums[stk[-1]] > v:\n                stk.append(i)\n        ans = 0\n        for i in range(len(nums) - 1, -1, -1):\n            while stk and nums[stk[-1]] <= nums[i]:\n                ans = max(ans, i - stk.pop())\n            if not stk:\n                break\n        return ans\n", "class Solution:\n  def maxWidthRamp(self, nums: list[int]) -> int:\n    ans = 0\n    stack = []\n\n    for i, num in enumerate(nums):\n      if stack == [] or num <= nums[stack[-1]]:\n        stack.append(i)\n\n    for i, num in reversed(list(enumerate(nums))):\n      while stack and num >= nums[stack[-1]]:\n        ans = max(ans, i - stack.pop())\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 955, "slug": "delete-columns-to-make-sorted-ii", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 946, "slug": "validate-stack-sequences", "solutions": ["class Solution:\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\n        stk = []\n        i = 0\n        for x in pushed:\n            stk.append(x)\n            while stk and stk[-1] == popped[i]:\n                stk.pop()\n                i += 1\n        return i == len(popped)\n", "class Solution:\n  def validateStackSequences(\n      self,\n      pushed: list[int],\n      popped: list[int],\n  ) -> bool:\n    stack = []\n    i = 0  # popped's index\n\n    for x in pushed:\n      stack.append(x)\n      while stack and stack[-1] == popped[i]:\n        stack.pop()\n        i += 1\n\n    return not stack\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 926, "slug": "flip-string-to-monotone-increasing", "solutions": ["class Solution:\n    def minFlipsMonoIncr(self, s: str) -> int:\n        tot = s.count(\"0\")\n        ans, cur = tot, 0\n        for i, c in enumerate(s, 1):\n            cur += int(c == \"0\")\n            ans = min(ans, i - cur + tot - cur)\n        return ans\n", "class Solution:\n  def minFlipsMonoIncr(self, s: str) -> int:\n    # the number of characters to be flilpped to make the substring so far\n    # monotone increasing\n    dp = 0\n    count1 = 0\n\n    for c in s:\n      if c == '0':\n        # 1. Flip '0'.\n        # 2. Keep '0' and flip all the previous 1s.\n        dp = min(dp + 1, count1)\n      else:\n        count1 += 1\n\n    return dp\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 969, "slug": "pancake-sorting", "solutions": ["class Solution:\n    def pancakeSort(self, arr: List[int]) -> List[int]:\n        def reverse(arr, j):\n            i = 0\n            while i < j:\n                arr[i], arr[j] = arr[j], arr[i]\n                i, j = i + 1, j - 1\n\n        n = len(arr)\n        ans = []\n        for i in range(n - 1, 0, -1):\n            j = i\n            while j > 0 and arr[j] != i + 1:\n                j -= 1\n            if j < i:\n                if j > 0:\n                    ans.append(j + 1)\n                    reverse(arr, j)\n                ans.append(i + 1)\n                reverse(arr, i)\n        return ans\n", "class Solution:\n  def pancakeSort(self, arr: list[int]) -> list[int]:\n    ans = []\n\n    for target in range(len(arr), 0, -1):\n      index = arr.index(target)\n      arr[:index + 1] = arr[:index + 1][::-1]\n      arr[:target] = arr[:target][::-1]\n      ans.append(index + 1)\n      ans.append(target)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 949, "slug": "largest-time-for-given-digits", "solutions": ["class Solution:\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\n        cnt = [0] * 10\n        for v in arr:\n            cnt[v] += 1\n        for h in range(23, -1, -1):\n            for m in range(59, -1, -1):\n                t = [0] * 10\n                t[h // 10] += 1\n                t[h % 10] += 1\n                t[m // 10] += 1\n                t[m % 10] += 1\n                if cnt == t:\n                    return f'{h:02}:{m:02}'\n        return ''\n", "class Solution:\n  def largestTimeFromDigits(self, arr: list[int]) -> str:\n    for time in itertools.permutations(sorted(arr, reverse=True)):\n      if time[:2] < (2, 4) and time[2] < 6:\n        return '%d%d:%d%d' % time\n    return ''\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 927, "slug": "three-equal-parts", "solutions": ["class Solution:\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\n        def find(x):\n            s = 0\n            for i, v in enumerate(arr):\n                s += v\n                if s == x:\n                    return i\n\n        n = len(arr)\n        cnt, mod = divmod(sum(arr), 3)\n        if mod:\n            return [-1, -1]\n        if cnt == 0:\n            return [0, n - 1]\n\n        i, j, k = find(1), find(cnt + 1), find(cnt * 2 + 1)\n        while k < n and arr[i] == arr[j] == arr[k]:\n            i, j, k = i + 1, j + 1, k + 1\n        return [i - 1, j] if k == n else [-1, -1]\n", "class Solution:\n  def threeEqualParts(self, arr: list[int]) -> list[int]:\n    ones = sum(a == 1 for a in arr)\n\n    if ones == 0:\n      return [0, len(arr) - 1]\n    if ones % 3 != 0:\n      return [-1, -1]\n\n    k = ones // 3\n    i = 0\n\n    for i in range(len(arr)):\n      if arr[i] == 1:\n        first = i\n        break\n\n    gapOnes = k\n\n    for j in range(i + 1, len(arr)):\n      if arr[j] == 1:\n        gapOnes -= 1\n        if gapOnes == 0:\n          second = j\n          break\n\n    gapOnes = k\n\n    for i in range(j + 1, len(arr)):\n      if arr[i] == 1:\n        gapOnes -= 1\n        if gapOnes == 0:\n          third = i\n          break\n\n    while third < len(arr) and arr[first] == arr[second] == arr[third]:\n      first += 1\n      second += 1\n      third += 1\n\n    if third == len(arr):\n      return [first - 1, second]\n    return [-1, -1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 934, "slug": "shortest-bridge", "solutions": ["class Solution:\n    def shortestBridge(self, grid: List[List[int]]) -> int:\n        def dfs(i, j):\n            q.append((i, j))\n            grid[i][j] = 2\n            for a, b in pairwise(dirs):\n                x, y = i + a, j + b\n                if 0 <= x < n and 0 <= y < n and grid[x][y] == 1:\n                    dfs(x, y)\n\n        n = len(grid)\n        dirs = (-1, 0, 1, 0, -1)\n        q = deque()\n        i, j = next((i, j) for i in range(n) for j in range(n) if grid[i][j])\n        dfs(i, j)\n        ans = 0\n        while 1:\n            for _ in range(len(q)):\n                i, j = q.popleft()\n                for a, b in pairwise(dirs):\n                    x, y = i + a, j + b\n                    if 0 <= x < n and 0 <= y < n:\n                        if grid[x][y] == 1:\n                            return ans\n                        if grid[x][y] == 0:\n                            grid[x][y] = 2\n                            q.append((x, y))\n            ans += 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 905, "slug": "sort-array-by-parity", "solutions": ["class Solution:\n    def sortArrayByParity(self, nums: List[int]) -> List[int]:\n        i, j = 0, len(nums) - 1\n        while i < j:\n            if nums[i] % 2 == 0:\n                i += 1\n            elif nums[j] % 2 == 1:\n                j -= 1\n            else:\n                nums[i], nums[j] = nums[j], nums[i]\n                i, j = i + 1, j - 1\n        return nums\n", "class Solution:\n  def sortArrayByParity(self, nums: list[int]) -> list[int]:\n    l = 0\n    r = len(nums) - 1\n\n    while l < r:\n      if nums[l] % 2 == 1 and nums[r] % 2 == 0:\n        nums[l], nums[r] = nums[r], nums[l]\n      if nums[l] % 2 == 0:\n        l += 1\n      if nums[r] % 2 == 1:\n        r -= 1\n\n    return nums\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 912, "slug": "sort-an-array", "solutions": ["class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        def quick_sort(l, r):\n            if l >= r:\n                return\n            x = nums[randint(l, r)]\n            i, j, k = l - 1, r + 1, l\n            while k < j:\n                if nums[k] < x:\n                    nums[i + 1], nums[k] = nums[k], nums[i + 1]\n                    i, k = i + 1, k + 1\n                elif nums[k] > x:\n                    j -= 1\n                    nums[j], nums[k] = nums[k], nums[j]\n                else:\n                    k = k + 1\n            quick_sort(l, i)\n            quick_sort(j, r)\n\n        quick_sort(0, len(nums) - 1)\n        return nums\n", "class Solution:\n  def sortArray(self, nums: list[int]) -> list[int]:\n    self._heapSort(nums)\n    return nums\n\n  def _heapSort(self, nums: list[int]) -> None:\n    def maxHeapify(nums: list[int], i: int, heapSize: int) -> None:\n      l = 2 * i + 1\n      r = 2 * i + 2\n      largest = i\n      if l < heapSize and nums[largest] < nums[l]:\n        largest = l\n      if r < heapSize and nums[largest] < nums[r]:\n        largest = r\n      if largest != i:\n        nums[largest], nums[i] = nums[i], nums[largest]\n        maxHeapify(nums, largest, heapSize)\n\n    def buildMaxHeap(nums: list[int]) -> None:\n      for i in range(len(nums) // 2, -1, -1):\n        maxHeapify(nums, i, len(nums))\n\n    buildMaxHeap(nums)\n    heapSize = len(nums)\n    for i in reversed(range(1, len(nums))):\n      nums[i], nums[0] = nums[0], nums[i]\n      heapSize -= 1\n      maxHeapify(nums, 0, heapSize)\n", "class Solution:\n  def sortArray(self, nums: list[int]) -> list[int]:\n    self._quickSort(nums, 0, len(nums) - 1)\n    return nums\n\n  def _quickSort(self, nums: list[int], l: int, r: int) -> None:\n    if l >= r:\n      return\n\n    def partition(nums: list[int], l: int, r: int) -> int:\n      randIndex = random.randint(0, r - l) + l\n      nums[randIndex], nums[r] = nums[r], nums[randIndex]\n      pivot = nums[r]\n      nextSwapped = l\n      for i in range(l, r):\n        if nums[i] <= pivot:\n          nums[nextSwapped], nums[i] = nums[i], nums[nextSwapped]\n          nextSwapped += 1\n      nums[nextSwapped], nums[r] = nums[r], nums[nextSwapped]\n      return nextSwapped\n\n    m = partition(nums, l, r)\n    self._quickSort(nums, l, m - 1)\n    self._quickSort(nums, m + 1, r)\n", "class Solution:\n  def sortArray(self, nums: list[int]) -> list[int]:\n    self._mergeSort(nums, 0, len(nums) - 1)\n    return nums\n\n  def _mergeSort(self, nums: list[int], l: int, r: int) -> None:\n    if l >= r:\n      return\n\n    def merge(nums: list[int], l: int, m: int, r: int) -> None:\n      sorted = [0] * (r - l + 1)\n      k = 0  # sorted's index\n      i = l  # left's index\n      j = m + 1  # right's index\n\n      while i <= m and j <= r:\n        if nums[i] < nums[j]:\n          sorted[k] = nums[i]\n          k += 1\n          i += 1\n        else:\n          sorted[k] = nums[j]\n          k += 1\n          j += 1\n\n      # Put the possible remaining left part into the sorted array.\n      while i <= m:\n        sorted[k] = nums[i]\n        k += 1\n        i += 1\n\n      # Put the possible remaining right part into the sorted array.\n      while j <= r:\n        sorted[k] = nums[j]\n        k += 1\n        j += 1\n\n      nums[l:l + len(sorted)] = sorted\n\n    m = (l + r) // 2\n    self._mergeSort(nums, l, m)\n    self._mergeSort(nums, m + 1, r)\n    merge(nums, l, m, r)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 991, "slug": "broken-calculator", "solutions": ["class Solution:\n    def brokenCalc(self, startValue: int, target: int) -> int:\n        ans = 0\n        while startValue < target:\n            if target & 1:\n                target += 1\n            else:\n                target >>= 1\n            ans += 1\n        ans += startValue - target\n        return ans\n", "class Solution:\n  def brokenCalc(self, startValue: int, target: int) -> int:\n    ops = 0\n\n    while startValue < target:\n      if target % 2 == 0:\n        target //= 2\n      else:\n        target += 1\n      ops += 1\n\n    return ops + startValue - target\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 954, "slug": "array-of-doubled-pairs", "solutions": ["class Solution:\n    def canReorderDoubled(self, arr: List[int]) -> bool:\n        freq = Counter(arr)\n        if freq[0] & 1:\n            return False\n        for x in sorted(freq, key=abs):\n            if freq[x << 1] < freq[x]:\n                return False\n            freq[x << 1] -= freq[x]\n        return True\n", "class Solution:\n  def canReorderDoubled(self, arr: list[int]) -> bool:\n    count = collections.Counter(arr)\n\n    for key in sorted(count, key=abs):\n      if count[key] > count[2 * key]:\n        return False\n      count[2 * key] -= count[key]\n\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 999, "slug": "available-captures-for-rook", "solutions": ["class Solution:\n    def numRookCaptures(self, board: List[List[str]]) -> int:\n        dirs = (-1, 0, 1, 0, -1)\n        n = len(board)\n        for i in range(n):\n            for j in range(n):\n                if board[i][j] == \"R\":\n                    ans = 0\n                    for a, b in pairwise(dirs):\n                        x, y = i + a, j + b\n                        while 0 <= x < n and 0 <= y < n and board[x][y] != \"B\":\n                            if board[x][y] == \"p\":\n                                ans += 1\n                                break\n                            x, y = x + a, y + b\n                    return ans\n", "class Solution:\n  def numRookCaptures(self, board: list[list[str]]) -> int:\n    ans = 0\n\n    for i in range(8):\n      for j in range(8):\n        if board[i][j] == 'R':\n          i0 = i\n          j0 = j\n\n    for d in [[1, 0], [0, 1], [-1, 0], [0, -1]]:\n      i = i0 + d[0]\n      j = j0 + d[1]\n      while 0 <= i < 8 and 0 <= j < 8:\n        if board[i][j] == 'p':\n          ans += 1\n        if board[i][j] != '.':\n          break\n        i += d[0]\n        j += d[1]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 942, "slug": "di-string-match", "solutions": ["class Solution:\n    def diStringMatch(self, s: str) -> List[int]:\n        low, high = 0, len(s)\n        ans = []\n        for c in s:\n            if c == \"I\":\n                ans.append(low)\n                low += 1\n            else:\n                ans.append(high)\n                high -= 1\n        ans.append(low)\n        return ans\n", "class Solution:\n  def diStringMatch(self, s: str) -> list[int]:\n    ans = []\n    mn = 0\n    mx = len(s)\n\n    for c in s:\n      if c == 'I':\n        ans.append(mn)\n        mn += 1\n      else:\n        ans.append(mx)\n        mx -= 1\n\n    return ans + [mn]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 917, "slug": "reverse-only-letters", "solutions": ["class Solution:\n    def reverseOnlyLetters(self, s: str) -> str:\n        cs = list(s)\n        i, j = 0, len(cs) - 1\n        while i < j:\n            while i < j and not cs[i].isalpha():\n                i += 1\n            while i < j and not cs[j].isalpha():\n                j -= 1\n            if i < j:\n                cs[i], cs[j] = cs[j], cs[i]\n                i, j = i + 1, j - 1\n        return \"\".join(cs)\n", "class Solution:\n  def reverseOnlyLetters(self, s: str) -> str:\n    ans = list(s)\n    i = 0\n    j = len(s) - 1\n\n    while i < j:\n      while i < j and not s[i].isalpha():\n        i += 1\n      while i < j and not s[j].isalpha():\n        j -= 1\n      ans[i], ans[j] = ans[j], ans[i]\n      i += 1\n      j -= 1\n\n    return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1982, "slug": "find-array-given-subset-sums", "solutions": ["class Solution:\n    def recoverArray(self, n: int, sums: List[int]) -> List[int]:\n        m = -min(sums)\n        sl = SortedList(x + m for x in sums)\n        sl.remove(0)\n        ans = [sl[0]]\n        for i in range(1, n):\n            for j in range(1 << i):\n                if j >> (i - 1) & 1:\n                    s = sum(ans[k] for k in range(i) if j >> k & 1)\n                    sl.remove(s)\n            ans.append(sl[0])\n        for i in range(1 << n):\n            s = sum(ans[j] for j in range(n) if i >> j & 1)\n            if s == m:\n                for j in range(n):\n                    if i >> j & 1:\n                        ans[j] *= -1\n                break\n        return ans\n", "class Solution:\n  def recoverArray(self, n: int, sums: list[int]) -> list[int]:\n    def recover(sums: list[int]) -> list[int]:\n      if len(sums) == 1:\n        return []\n\n      count = collections.Counter(sums)\n      # Either num or -num must be in the final array.\n      #  num + sumsExcludingNum = sumsIncludingNum\n      # -num + sumsIncludingNum = sumsExcludingNum\n      num = sums[1] - sums[0]\n      sumsExcludingNum = []\n      sumsIncludingNum = []\n      chooseSumsExcludingNum = True\n\n      for summ in sums:\n        if count[summ] == 0:\n          continue\n        count[summ] -= 1\n        count[summ + num] -= 1\n        sumsExcludingNum.append(summ)\n        sumsIncludingNum.append(summ + num)\n        if summ + num == 0:\n          chooseSumsExcludingNum = False\n\n      # Choose `sumsExludingNum` by default since we want to gradually strip\n      # `num` from each sum in `sums` to have the final array. However, we should\n      # always choose the group of sums with 0 since it's a must-have.\n      return ([num] + recover(sumsExcludingNum) if chooseSumsExcludingNum else\n              [-num] + recover(sumsIncludingNum))\n\n    return recover(sorted(sums))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1943, "slug": "describe-the-painting", "solutions": ["class Solution:\n    def splitPainting(self, segments: List[List[int]]) -> List[List[int]]:\n        d = defaultdict(int)\n        for l, r, c in segments:\n            d[l] += c\n            d[r] -= c\n        s = sorted([[k, v] for k, v in d.items()])\n        n = len(s)\n        for i in range(1, n):\n            s[i][1] += s[i - 1][1]\n        return [[s[i][0], s[i + 1][0], s[i][1]] for i in range(n - 1) if s[i][1]]\n", "from sortedcontainers import SortedDict\n\n\nclass Solution:\n  def splitPainting(self, segments: list[list[int]]) -> list[list[int]]:\n    ans = []\n    prevIndex = 0\n    runningMix = 0\n    timeline = SortedDict()\n\n    for start, end, color in segments:\n      timeline[start] = timeline.get(start, 0) + color\n      timeline[end] = timeline.get(end, 0) - color\n\n    for i, mix in timeline.items():\n      if runningMix > 0:\n        ans.append([prevIndex, i, runningMix])\n      runningMix += mix\n      prevIndex = i\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1952, "slug": "three-divisors", "solutions": ["class Solution:\n    def isThree(self, n: int) -> bool:\n        return sum(n % i == 0 for i in range(2, n)) == 1\n", "class Solution:\n  def isThree(self, n: int) -> bool:\n    if n == 1:\n      return False\n    # The numbers with exactly three divisors are perfect squares of a prime\n    # number.\n    root = math.isqrt(n)\n    return (root**2 == n and\n            all(root % i != 0\n                for i in range(2, math.isqrt(root) + 1)))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1966, "slug": "binary-searchable-numbers-in-an-unsorted-array", "solutions": ["class Solution:\n    def binarySearchableNumbers(self, nums: List[int]) -> int:\n        n = len(nums)\n        ok = [1] * n\n        mx, mi = -1000000, 1000000\n        for i, x in enumerate(nums):\n            if x < mx:\n                ok[i] = 0\n            else:\n                mx = x\n        for i in range(n - 1, -1, -1):\n            if nums[i] > mi:\n                ok[i] = 0\n            else:\n                mi = nums[i]\n        return sum(ok)\n", "class Solution:\n  def binarySearchableNumbers(self, nums: list[int]) -> int:\n    n = len(nums)\n    # prefixMaxs[i] := max(nums[0..i))\n    prefixMaxs = [0] * n\n    # suffixMins[i] := min(nums[i + 1..n))\n    suffixMins = [0] * n\n\n    # Fill in `prefixMaxs`.\n    prefixMaxs[0] = -math.inf\n    for i in range(1, n):\n      prefixMaxs[i] = max(prefixMaxs[i - 1], nums[i - 1])\n\n    # Fill in `suffixMins`.\n    suffixMins[n - 1] = math.inf\n    for i in range(n - 2, -1, -1):\n      suffixMins[i] = min(suffixMins[i + 1], nums[i + 1])\n\n    return sum(prefixMaxs[i] < nums[i] < suffixMins[i] for i in range(n))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1922, "slug": "count-good-numbers", "solutions": ["class Solution:\n    def countGoodNumbers(self, n: int) -> int:\n        mod = 10**9 + 7\n        return pow(5, (n + 1) >> 1, mod) * pow(4, n >> 1, mod) % mod\n", "class Solution:\n  def countGoodNumbers(self, n: int) -> int:\n    MOD = 1_000_000_007\n\n    def modPow(x: int, n: int) -> int:\n      if n == 0:\n        return 1\n      if n % 2 == 1:\n        return x * modPow(x, n - 1) % MOD\n      return modPow(x * x % MOD, n // 2)\n\n    return modPow(4 * 5, n // 2) * (1 if n % 2 == 0 else 5) % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1932, "slug": "merge-bsts-to-create-single-bst", "solutions": ["class Solution:\n  def canMerge(self, trees: list[TreeNode]) -> TreeNode | None:\n    valToNode = {}  # {val: node}\n    count = collections.Counter()  # {val: freq}\n\n    for tree in trees:\n      valToNode[tree.val] = tree\n      count[tree.val] += 1\n      if tree.left:\n        count[tree.left.val] += 1\n      if tree.right:\n        count[tree.right.val] += 1\n\n    def isValidBST(tree: TreeNode | None, minNode: TreeNode | None,\n                   maxNode: TreeNode | None) -> bool:\n      if not tree:\n        return True\n      if minNode and tree.val <= minNode.val:\n        return False\n      if maxNode and tree.val >= maxNode.val:\n        return False\n      if not tree.left and not tree.right and tree.val in valToNode:\n        val = tree.val\n        tree.left = valToNode[val].left\n        tree.right = valToNode[val].right\n        del valToNode[val]\n\n      return isValidBST(\n          tree.left, minNode, tree) and isValidBST(\n          tree.right, tree, maxNode)\n\n    for tree in trees:\n      if count[tree.val] == 1:\n        if isValidBST(tree, None, None) and len(valToNode) <= 1:\n          return tree\n        return None\n\n    return None\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1918, "slug": "kth-smallest-subarray-sum", "solutions": ["class Solution:\n    def kthSmallestSubarraySum(self, nums: List[int], k: int) -> int:\n        def f(s):\n            t = j = 0\n            cnt = 0\n            for i, x in enumerate(nums):\n                t += x\n                while t > s:\n                    t -= nums[j]\n                    j += 1\n                cnt += i - j + 1\n            return cnt >= k\n\n        l, r = min(nums), sum(nums)\n        return l + bisect_left(range(l, r + 1), True, key=f)\n", "class Solution:\n  def kthSmallestSubarraySum(self, nums: list[int], k: int) -> int:\n    def numSubarrayLessThan(m: int) -> int:\n      res = 0\n      summ = 0\n      l = 0\n      for r, num in enumerate(nums):\n        summ += num\n        while summ > m:\n          summ -= nums[l]\n          l += 1\n        res += r - l + 1\n      return res\n\n    return bisect.bisect_left(range(sum(nums)), k, key=numSubarrayLessThan)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1901, "slug": "find-a-peak-element-ii", "solutions": ["class Solution:\n    def findPeakGrid(self, mat: List[List[int]]) -> List[int]:\n        l, r = 0, len(mat) - 1\n        while l < r:\n            mid = (l + r) >> 1\n            j = mat[mid].index(max(mat[mid]))\n            if mat[mid][j] > mat[mid + 1][j]:\n                r = mid\n            else:\n                l = mid + 1\n        return [l, mat[l].index(max(mat[l]))]\n", "class Solution:\n  def findPeakGrid(self, mat: list[list[int]]) -> list[int]:\n    l = 0\n    r = len(mat) - 1\n\n    while l < r:\n      m = (l + r) // 2\n      if max(mat[m]) >= max(mat[m + 1]):\n        r = m\n      else:\n        l = m + 1\n\n    return [l, mat[l].index(max(mat[l]))]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1957, "slug": "delete-characters-to-make-fancy-string", "solutions": ["class Solution:\n    def makeFancyString(self, s: str) -> str:\n        ans = []\n        for c in s:\n            if len(ans) < 2 or ans[-1] != c or ans[-2] != c:\n                ans.append(c)\n        return \"\".join(ans)\n", "class Solution:\n  def makeFancyString(self, s: str) -> str:\n    ans = []\n    for c in s:\n      if len(ans) < 2 or ans[-1] != c or ans[-2] != c:\n        ans.append(c)\n    return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1954, "slug": "minimum-garden-perimeter-to-collect-enough-apples", "solutions": ["class Solution:\n    def minimumPerimeter(self, neededApples: int) -> int:\n        x = 1\n        while 2 * x * (x + 1) * (2 * x + 1) < neededApples:\n            x += 1\n        return x * 8\n", "class Solution:\n  def minimumPerimeter(self, neededApples: int) -> int:\n    def numApples(k: int) -> int:\n      \"\"\"Returns the number of apples at the k-th level.\n\n         k := the level making perimeter = 8k\n      p(k) := the number of apples at the k-th level on the perimeter\n      n(k) := the number of apples at the k-th level not no the perimeter\n\n      p(1) =             1 + 2\n      p(2) =         3 + 2 + 3 + 4\n      p(3) =     5 + 4 + 3 + 4 + 5 + 6\n      p(4) = 7 + 6 + 5 + 4 + 5 + 6 + 7 + 8\n      p(k) = k + 2(k+1) + 2(k+2) + ... + 2(k+k-1) + 2k\n          = k + 2k^2 + 2*k(k-1)//2\n          = k + 2k^2 + k^2 - k = 3k^2\n\n      n(k) = p(1) + p(2) + p(3) + ... + p(k)\n          = 3*1  + 3*4  + 3*9  + ... + 3*k^2\n          = 3 * (1 + 4 + 9 + ... + k^2)\n          = 3 * k(k+1)(2k+1)//6 = k(k+1)(2k+1)//2\n      So, the number of apples at the k-th level should be\n        k(k+1)(2k+1)//2 * 4 = 2k(k+1)(2k+1)\n      \"\"\"\n      return 2 * k * (k + 1) * (2 * k + 1)\n\n    return bisect.bisect_left(range(100_000), neededApples,\n                              key=numApples) * 8\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1927, "slug": "sum-game", "solutions": ["class Solution:\n    def sumGame(self, num: str) -> bool:\n        n = len(num)\n        cnt1 = num[: n // 2].count(\"?\")\n        cnt2 = num[n // 2 :].count(\"?\")\n        s1 = sum(int(x) for x in num[: n // 2] if x != \"?\")\n        s2 = sum(int(x) for x in num[n // 2 :] if x != \"?\")\n        return (cnt1 + cnt2) % 2 == 1 or s1 - s2 != 9 * (cnt2 - cnt1) // 2\n", "class Solution:\n  def sumGame(self, num: str) -> bool:\n    n = len(num)\n    ans = 0.0\n\n    def getExpectation(c: str) -> float:\n      return 4.5 if c == '?' else int(c)\n\n    for i in range(n // 2):\n      ans += getExpectation(num[i])\n\n    for i in range(n // 2, n):\n      ans -= getExpectation(num[i])\n\n    return ans != 0.0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1935, "slug": "maximum-number-of-words-you-can-type", "solutions": ["class Solution:\n    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\n        s = set(brokenLetters)\n        return sum(all(c not in s for c in w) for w in text.split())\n", "class Solution:\n  def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\n    ans = 0\n    broken = set(brokenLetters)\n\n    for word in text.split():\n      ans += all(c not in broken for c in word)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1995, "slug": "count-special-quadruplets", "solutions": ["class Solution:\n    def countQuadruplets(self, nums: List[int]) -> int:\n        ans, n = 0, len(nums)\n        for a in range(n - 3):\n            for b in range(a + 1, n - 2):\n                for c in range(b + 1, n - 1):\n                    for d in range(c + 1, n):\n                        if nums[a] + nums[b] + nums[c] == nums[d]:\n                            ans += 1\n        return ans\n", "class Solution:\n  def countQuadruplets(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = 0\n    count = collections.Counter()\n\n    for c in range(n - 1, 1, -1):  # `c` also represents `d`.\n      for b in range(c - 1, 0, -1):\n        for a in range(b - 1, -1, -1):\n          ans += count[nums[a] + nums[b] + nums[c]]\n      count[nums[c]] += 1  # c := d\n\n    return ans\n", "class Solution:\n  def countQuadruplets(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = 0\n    count = collections.Counter()\n\n    #    nums[a] + nums[b] + nums[c] == nums[d]\n    # => nums[a] + nums[b] == nums[d] - nums[c]\n    for b in range(n - 1, 0, -1):  # `b` also represents `c`.\n      for a in range(b - 1, -1, -1):\n        ans += count[nums[a] + nums[b]]\n      for d in range(n - 1, b, -1):\n        count[nums[d] - nums[b]] += 1  # b := c\n\n    return ans\n", "class Solution:\n  def countQuadruplets(self, nums: list[int]) -> int:\n    n = len(nums)\n    return sum(nums[a] + nums[b] + nums[c] == nums[d]\n               for a in range(n)\n               for b in range(a + 1, n)\n               for c in range(b + 1, n)\n               for d in range(c + 1, n))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1925, "slug": "count-square-sum-triples", "solutions": ["class Solution:\n    def countTriples(self, n: int) -> int:\n        ans = 0\n        for a in range(1, n):\n            for b in range(1, n):\n                x = a * a + b * b\n                c = int(sqrt(x))\n                if c <= n and c * c == x:\n                    ans += 1\n        return ans\n", "class Solution:\n  def countTriples(self, n: int) -> int:\n    ans = 0\n    squared = set()\n\n    for i in range(1, n + 1):\n      squared.add(i * i)\n\n    for a in squared:\n      for b in squared:\n        if a + b in squared:\n          ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1949, "slug": "strong-friendship", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1908, "slug": "game-of-nim", "solutions": ["class Solution:\n    def nimGame(self, piles: List[int]) -> bool:\n        @cache\n        def dfs(st):\n            lst = list(st)\n            for i, x in enumerate(lst):\n                for j in range(1, x + 1):\n                    lst[i] -= j\n                    if not dfs(tuple(lst)):\n                        return True\n                    lst[i] += j\n            return False\n\n        return dfs(tuple(piles))\n", "class Solution:\n  def nimGame(self, piles: list[int]) -> bool:\n    return functools.reduce(operator.xor, piles) > 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1996, "slug": "the-number-of-weak-characters-in-the-game", "solutions": ["class Solution:\n    def numberOfWeakCharacters(self, properties: List[List[int]]) -> int:\n        properties.sort(key=lambda x: (-x[0], x[1]))\n        ans = mx = 0\n        for _, x in properties:\n            ans += x < mx\n            mx = max(mx, x)\n        return ans\n", "class Solution:\n  def numberOfWeakCharacters(self, properties: list[list[int]]) -> int:\n    ans = 0\n    maxDefense = 0\n\n    # Sort properties by `attack` in descending order, then by `defense` in\n    # ascending order.\n    for _, defense in sorted(properties, key=lambda x: (-x[0], x[1])):\n      if defense < maxDefense:\n        ans += 1\n      maxDefense = max(maxDefense, defense)\n\n    return ans\n", "class Solution:\n  def numberOfWeakCharacters(self, properties: list[list[int]]) -> int:\n    ans = 0\n    maxAttack = max(attack for attack, _ in properties)\n    # maxDefenses[i] := the maximum defense for the i-th attack\n    maxDefenses = [0] * (maxAttack + 2)\n\n    for attack, defense in properties:\n      maxDefenses[attack] = max(maxDefenses[attack], defense)\n\n    for i in range(maxAttack, 0, -1):\n      maxDefenses[i] = max(maxDefenses[i], maxDefenses[i + 1])\n\n    for attack, defense in properties:\n      if maxDefenses[attack + 1] > defense:\n        ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1987, "slug": "number-of-unique-good-subsequences", "solutions": ["class Solution:\n    def numberOfUniqueGoodSubsequences(self, binary: str) -> int:\n        f = g = 0\n        ans = 0\n        mod = 10**9 + 7\n        for c in binary:\n            if c == \"0\":\n                g = (g + f) % mod\n                ans = 1\n            else:\n                f = (f + g + 1) % mod\n        ans = (ans + f + g) % mod\n        return ans\n", "class Solution:\n  # Similar to 940. Distinct Subsequences II\n  def numberOfUniqueGoodSubsequences(self, binary: str) -> int:\n    MOD = 1_000_000_007\n    # endsIn[i] := the number of subsequence that end in ('0' + i)\n    endsIn = {'0': 0, '1': 0}\n\n    for c in binary:\n      endsIn[c] = sum(endsIn.values()) % MOD\n      # Don't count '0' since we want to avoid the leading zeros case.\n      # However, we can always count '1'.\n      if c == '1':\n        endsIn['1'] += 1\n\n    # Count '0' in the end.\n    return (sum(endsIn.values()) + ('0' in binary)) % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1909, "slug": "remove-one-element-to-make-the-array-strictly-increasing", "solutions": ["class Solution:\n    def canBeIncreasing(self, nums: List[int]) -> bool:\n        def check(k: int) -> bool:\n            pre = -inf\n            for i, x in enumerate(nums):\n                if i == k:\n                    continue\n                if pre >= x:\n                    return False\n                pre = x\n            return True\n\n        i = 0\n        while i + 1 < len(nums) and nums[i] < nums[i + 1]:\n            i += 1\n        return check(i) or check(i + 1)\n", "class Solution:\n  def canBeIncreasing(self, nums: list[int]) -> bool:\n    removed = False\n\n    for i in range(1, len(nums)):\n      if nums[i - 1] >= nums[i]:\n        if removed:\n          return False\n        removed = True  # Remove nums[i - 1].\n        if i > 1 and nums[i - 2] >= nums[i]:\n          nums[i] = nums[i - 1]  # Remove nums[i] instead.\n\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1970, "slug": "last-day-where-you-can-still-cross", "solutions": ["class Solution:\n    def latestDayToCross(self, row: int, col: int, cells: List[List[int]]) -> int:\n        def check(k: int) -> bool:\n            g = [[0] * col for _ in range(row)]\n            for i, j in cells[:k]:\n                g[i - 1][j - 1] = 1\n            q = [(0, j) for j in range(col) if g[0][j] == 0]\n            for x, y in q:\n                if x == row - 1:\n                    return True\n                for a, b in pairwise(dirs):\n                    nx, ny = x + a, y + b\n                    if 0 <= nx < row and 0 <= ny < col and g[nx][ny] == 0:\n                        q.append((nx, ny))\n                        g[nx][ny] = 1\n            return False\n\n        n = row * col\n        l, r = 1, n\n        dirs = (-1, 0, 1, 0, -1)\n        while l < r:\n            mid = (l + r + 1) >> 1\n            if check(mid):\n                l = mid\n            else:\n                r = mid - 1\n        return l\n", "class Solution:\n  def latestDayToCross(self, row: int, col: int, cells: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n\n    def canWalk(day: int) -> bool:\n      matrix = [[0] * col for _ in range(row)]\n      for i in range(day):\n        x, y = cells[i]\n        matrix[x - 1][y - 1] = 1\n\n      q = collections.deque()\n\n      for j in range(col):\n        if matrix[0][j] == 0:\n          q.append((0, j))\n          matrix[0][j] = 1\n\n      while q:\n        i, j = q.popleft()\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == row or y < 0 or y == col:\n            continue\n          if matrix[x][y] == 1:\n            continue\n          if x == row - 1:\n            return True\n          q.append((x, y))\n          matrix[x][y] = 1\n\n      return False\n\n    ans = 0\n    l = 1\n    r = len(cells) - 1\n\n    while l <= r:\n      m = (l + r) // 2\n      if canWalk(m):\n        ans = m\n        l = m + 1\n      else:\n        r = m - 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1915, "slug": "number-of-wonderful-substrings", "solutions": ["class Solution:\n    def wonderfulSubstrings(self, word: str) -> int:\n        cnt = Counter({0: 1})\n        ans = st = 0\n        for c in word:\n            st ^= 1 << (ord(c) - ord(\"a\"))\n            ans += cnt[st]\n            for i in range(10):\n                ans += cnt[st ^ (1 << i)]\n            cnt[st] += 1\n        return ans\n", "class Solution:\n  def wonderfulSubstrings(self, word: str) -> int:\n    ans = 0\n    prefix = 0  # the binary prefix\n    count = [0] * 1024  # the binary prefix count\n    count[0] = 1  # the empty string \"\"\n\n    for c in word:\n      prefix ^= 1 << ord(c) - ord('a')\n      # All the letters occur even number of times.\n      ans += count[prefix]\n      # `c` occurs odd number of times.\n      ans += sum(count[prefix ^ 1 << i] for i in range(10))\n      count[prefix] += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1979, "slug": "find-greatest-common-divisor-of-array", "solutions": ["class Solution:\n    def findGCD(self, nums: List[int]) -> int:\n        return gcd(max(nums), min(nums))\n", "class Solution:\n  def findGCD(self, nums: list[int]) -> int:\n    return math.gcd(min(nums), max(nums))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1967, "slug": "number-of-strings-that-appear-as-substrings-in-word", "solutions": ["class Solution:\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\n        return sum(p in word for p in patterns)\n", "class Solution:\n  def numOfStrings(self, patterns: list[str], word: str) -> int:\n    return sum(pattern in word for pattern in patterns)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1988, "slug": "find-cutoff-score-for-each-school", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1974, "slug": "minimum-time-to-type-word-using-special-typewriter", "solutions": ["class Solution:\n    def minTimeToType(self, word: str) -> int:\n        ans, a = len(word), ord(\"a\")\n        for c in map(ord, word):\n            d = abs(c - a)\n            ans += min(d, 26 - d)\n            a = c\n        return ans\n", "class Solution:\n  def minTimeToType(self, word: str) -> int:\n    moves = 0\n    letter = 'a'\n\n    for c in word:\n      diff = abs(ord(c) - ord(letter))\n      moves += min(diff, 26 - diff)\n      letter = c\n\n    return moves + len(word)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1905, "slug": "count-sub-islands", "solutions": ["class Solution:\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\n        def dfs(i: int, j: int) -> int:\n            ok = grid1[i][j]\n            grid2[i][j] = 0\n            for a, b in pairwise(dirs):\n                x, y = i + a, j + b\n                if 0 <= x < m and 0 <= y < n and grid2[x][y] and not dfs(x, y):\n                    ok = 0\n            return ok\n\n        m, n = len(grid1), len(grid1[0])\n        dirs = (-1, 0, 1, 0, -1)\n        return sum(dfs(i, j) for i in range(m) for j in range(n) if grid2[i][j])\n", "class Solution:\n  def countSubIslands(\n      self,\n      grid1: list[list[int]],\n      grid2: list[list[int]],\n  ) -> int:\n    m = len(grid2)\n    n = len(grid2[0])\n\n    def dfs(i: int, j: int) -> int:\n      if i < 0 or i == m or j < 0 or j == n:\n        return 1\n      if grid2[i][j] != 1:\n        return 1\n\n      grid2[i][j] = 2  # Mark 2 as visited.\n\n      return (dfs(i + 1, j) & dfs(i - 1, j) &\n              dfs(i, j + 1) & dfs(i, j - 1) & grid1[i][j])\n\n    ans = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid2[i][j] == 1:\n          ans += dfs(i, j)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1939, "slug": "users-that-actively-request-confirmation-messages", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1973, "slug": "count-nodes-equal-to-sum-of-descendants", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def equalToDescendants(self, root: Optional[TreeNode]) -> int:\n        def dfs(root):\n            if root is None:\n                return 0\n            l, r = dfs(root.left), dfs(root.right)\n            if l + r == root.val:\n                nonlocal ans\n                ans += 1\n            return root.val + l + r\n\n        ans = 0\n        dfs(root)\n        return ans\n", "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass T:\n  summ: int\n  count: int\n\n\nclass Solution:\n  def equalToDescendants(self, root: TreeNode | None) -> int:\n    def dfs(root: TreeNode | None) -> T:\n      if not root:\n        return T(0, 0)\n      left = dfs(root.left)\n      right = dfs(root.right)\n      return T(root.val + left.summ + right.summ,\n               left.count + right.count +\n               (1 if root.val == left.summ + right.summ else 0))\n\n    return dfs(root).count\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1926, "slug": "nearest-exit-from-entrance-in-maze", "solutions": ["class Solution:\n    def nearestExit(self, maze: List[List[str]], entrance: List[int]) -> int:\n        m, n = len(maze), len(maze[0])\n        i, j = entrance\n        q = deque([(i, j)])\n        maze[i][j] = \"+\"\n        ans = 0\n        while q:\n            ans += 1\n            for _ in range(len(q)):\n                i, j = q.popleft()\n                for a, b in [[0, -1], [0, 1], [-1, 0], [1, 0]]:\n                    x, y = i + a, j + b\n                    if 0 <= x < m and 0 <= y < n and maze[x][y] == \".\":\n                        if x == 0 or x == m - 1 or y == 0 or y == n - 1:\n                            return ans\n                        q.append((x, y))\n                        maze[x][y] = \"+\"\n        return -1\n", "class Solution:\n  def nearestExit(self, maze: list[list[str]], entrance: list[int]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(maze)\n    n = len(maze[0])\n    q = collections.deque([(entrance[0], entrance[1])])\n    seen = {(entrance[0], entrance[1])}\n\n    step = 1\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if (x, y) in seen or maze[x][y] == '+':\n            continue\n          if x == 0 or x == m - 1 or y == 0 or y == n - 1:\n            return step\n          q.append((x, y))\n          seen.add((x, y))\n      step += 1\n\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1992, "slug": "find-all-groups-of-farmland", "solutions": ["class Solution:\n    def findFarmland(self, land: List[List[int]]) -> List[List[int]]:\n        m, n = len(land), len(land[0])\n        ans = []\n        for i in range(m):\n            for j in range(n):\n                if (\n                    land[i][j] == 0\n                    or (j > 0 and land[i][j - 1] == 1)\n                    or (i > 0 and land[i - 1][j] == 1)\n                ):\n                    continue\n                x, y = i, j\n                while x + 1 < m and land[x + 1][j] == 1:\n                    x += 1\n                while y + 1 < n and land[x][y + 1] == 1:\n                    y += 1\n                ans.append([i, j, x, y])\n        return ans\n", "class Solution:\n  def findFarmland(self, land: list[list[int]]) -> list[list[int]]:\n    ans = []\n\n    def dfs(i: int, j: int, cell: list[int]) -> None:\n      if i < 0 or i == len(land) or j < 0 or j == len(land[0]):\n        return\n      if land[i][j] != 1:\n        return\n      land[i][j] = 2  # Mark as visited.\n      cell[0] = max(cell[0], i)\n      cell[1] = max(cell[1], j)\n      dfs(i + 1, j, cell)\n      dfs(i, j + 1, cell)\n\n    for i in range(len(land)):\n      for j in range(len(land[0])):\n        if land[i][j] == 1:\n          cell = [i, j]\n          dfs(i, j, cell)\n          ans.append([i, j, *cell])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1900, "slug": "the-earliest-and-latest-rounds-where-players-compete", "solutions": ["class Solution:\n    def earliestAndLatest(\n        self, n: int, firstPlayer: int, secondPlayer: int\n    ) -> List[int]:\n        # dp[i][j][k] := (earliest, latest) pair w/ firstPlayer is i-th player from\n        # Front, secondPlayer is j-th player from end, and there're k people\n        @functools.lru_cache(None)\n        def dp(l: int, r: int, k: int) -> List[int]:\n            if l == r:\n                return [1, 1]\n            if l > r:\n                return dp(r, l, k)\n\n            a = math.inf\n            b = -math.inf\n\n            # Enumerate all possible positions\n            for i in range(1, l + 1):\n                for j in range(l - i + 1, r - i + 1):\n                    if not l + r - k // 2 <= i + j <= (k + 1) // 2:\n                        continue\n                    x, y = dp(i, j, (k + 1) // 2)\n                    a = min(a, x + 1)\n                    b = max(b, y + 1)\n\n            return [a, b]\n\n        return dp(firstPlayer, n - secondPlayer + 1, n)\n", "class Solution:\n  def earliestAndLatest(self, n: int,\n                        firstPlayer: int, secondPlayer: int) -> list[int]:\n    @functools.lru_cache(None)\n    def dp(l: int, r: int, k: int) -> list[int]:\n      \"\"\"\n      Returns the (earliest, latest) pair, the first player is the l-th player\n      from the front, the second player is the r-th player from the end, and\n      there're k people.\n      \"\"\"\n      if l == r:\n        return [1, 1]\n      if l > r:\n        return dp(r, l, k)\n\n      a = math.inf\n      b = -math.inf\n\n      # Enumerate all the possible positions.\n      for i in range(1, l + 1):\n        for j in range(l - i + 1, r - i + 1):\n          if not l + r - k // 2 <= i + j <= (k + 1) // 2:\n            continue\n          x, y = dp(i, j, (k + 1) // 2)\n          a = min(a, x + 1)\n          b = max(b, y + 1)\n\n      return [a, b]\n\n    return dp(firstPlayer, n - secondPlayer + 1, n)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1977, "slug": "number-of-ways-to-separate-numbers", "solutions": ["class Solution:\n    def numberOfCombinations(self, num: str) -> int:\n        def cmp(i, j, k):\n            x = lcp[i][j]\n            return x >= k or num[i + x] >= num[j + x]\n\n        mod = 10**9 + 7\n        n = len(num)\n        lcp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                if num[i] == num[j]:\n                    lcp[i][j] = 1 + lcp[i + 1][j + 1]\n\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n        for i in range(1, n + 1):\n            for j in range(1, i + 1):\n                v = 0\n                if num[i - j] != '0':\n                    if i - j - j >= 0 and cmp(i - j, i - j - j, j):\n                        v = dp[i - j][j]\n                    else:\n                        v = dp[i - j][min(j - 1, i - j)]\n                dp[i][j] = (dp[i][j - 1] + v) % mod\n        return dp[n][n]\n", "class Solution:\n  def numberOfCombinations(self, num: str) -> int:\n    if num[0] == '0':\n      return 0\n\n    MOD = 1_000_000_007\n    n = len(num)\n    # dp[i][k] := the number of possible lists of integers ending in num[i]\n    # with the length of the last number being 1..k\n    dp = [[0] * (n + 1) for _ in range(n)]\n    # lcs[i][j] := the number of the same digits in num[i..n) and num[j..n)\n    lcs = [[0] * (n + 1) for _ in range(n + 1)]\n\n    for i in range(n - 1, -1, -1):\n      for j in range(i + 1, n):\n        if num[i] == num[j]:\n          lcs[i][j] = lcs[i + 1][j + 1] + 1\n\n    for i in range(n):\n      for k in range(1, i + 2):\n        dp[i][k] += dp[i][k - 1]\n        dp[i][k] %= MOD\n        # The last number is num[s..i].\n        s = i - k + 1\n        if num[s] == '0':\n          # the number of possible lists of integers ending in num[i] with the\n          # length of the last number being k\n          continue\n        if s == 0:  # the whole string\n          dp[i][k] += 1\n          continue\n        if s < k:\n          # The length k is not enough, so add the number of possible lists of\n          # integers in num[0..s - 1].\n          dp[i][k] += dp[s - 1][s]\n          continue\n        l = lcs[s - k][s]\n        if l >= k or num[s - k + l] <= num[s + l]:\n          # Have enough length k and num[s - k..s - 1] <= num[j..i].\n          dp[i][k] += dp[s - 1][k]\n        else:\n          # Have enough length k but num[s - k..s - 1] > num[j..i].\n          dp[i][k] += dp[s - 1][k - 1]\n\n    return dp[n - 1][n] % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1906, "slug": "minimum-absolute-difference-queries", "solutions": ["class Solution:\n    def minDifference(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        m, n = len(nums), len(queries)\n        pre_sum = [[0] * 101 for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, 101):\n                t = 1 if nums[i - 1] == j else 0\n                pre_sum[i][j] = pre_sum[i - 1][j] + t\n\n        ans = []\n        for i in range(n):\n            left, right = queries[i][0], queries[i][1] + 1\n            t = inf\n            last = -1\n            for j in range(1, 101):\n                if pre_sum[right][j] - pre_sum[left][j] > 0:\n                    if last != -1:\n                        t = min(t, j - last)\n                    last = j\n            if t == inf:\n                t = -1\n            ans.append(t)\n        return ans\n", "class Solution:\n  def minDifference(\n      self,\n      nums: list[int],\n      queries: list[list[int]],\n  ) -> list[int]:\n    numToIndices = [[] for _ in range(101)]\n\n    for i, num in enumerate(nums):\n      numToIndices[num].append(i)\n\n    if len(numToIndices[nums[0]]) == len(nums):\n      return [-1] * len(queries)\n\n    ans = []\n\n    for l, r in queries:\n      prevNum = -1\n      minDiff = 101\n      for num in range(1, 101):\n        indices = numToIndices[num]\n        i = bisect_left(indices, l)\n        if i == len(indices) or indices[i] > r:\n          continue\n        if prevNum != -1:\n          minDiff = min(minDiff, num - prevNum)\n        prevNum = num\n      ans.append(-1 if minDiff == 101 else minDiff)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1917, "slug": "leetcodify-friends-recommendations", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1990, "slug": "count-the-number-of-experiments", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1931, "slug": "painting-a-grid-with-three-different-colors", "solutions": ["class Solution:\n    def colorTheGrid(self, m: int, n: int) -> int:\n        def f1(x: int) -> bool:\n            last = -1\n            for _ in range(m):\n                if x % 3 == last:\n                    return False\n                last = x % 3\n                x //= 3\n            return True\n\n        def f2(x: int, y: int) -> bool:\n            for _ in range(m):\n                if x % 3 == y % 3:\n                    return False\n                x, y = x // 3, y // 3\n            return True\n\n        mod = 10**9 + 7\n        mx = 3**m\n        valid = {i for i in range(mx) if f1(i)}\n        d = defaultdict(list)\n        for x in valid:\n            for y in valid:\n                if f2(x, y):\n                    d[x].append(y)\n        f = [int(i in valid) for i in range(mx)]\n        for _ in range(n - 1):\n            g = [0] * mx\n            for i in valid:\n                for j in d[i]:\n                    g[i] = (g[i] + f[j]) % mod\n            f = g\n        return sum(f) % mod\n", "class Solution:\n  def colorTheGrid(self, m: int, n: int) -> int:\n    def getColor(mask: int, r: int) -> int:\n      return mask >> r * 2 & 3\n\n    def setColor(mask: int, r: int, color: int) -> int:\n      return mask | color << r * 2\n\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def dp(r: int, c: int, prevColMask: int, currColMask: int) -> int:\n      if c == n:\n        return 1\n      if r == m:\n        return dp(0, c + 1, currColMask, 0)\n\n      ans = 0\n\n      # 1 := red, 2 := green, 3 := blue\n      for color in range(1, 4):\n        if getColor(prevColMask, r) == color:\n          continue\n        if r > 0 and getColor(currColMask, r - 1) == color:\n          continue\n        ans += dp(r + 1, c, prevColMask, setColor(currColMask, r, color))\n        ans %= MOD\n\n      return ans\n\n    return dp(0, 0, 0, 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1945, "slug": "sum-of-digits-of-string-after-convert", "solutions": ["class Solution:\n    def getLucky(self, s: str, k: int) -> int:\n        s = ''.join(str(ord(c) - ord('a') + 1) for c in s)\n        for _ in range(k):\n            t = sum(int(c) for c in s)\n            s = str(t)\n        return int(s)\n", "class Solution:\n  def getLucky(self, s: str, k: int) -> int:\n    ans = self._convert(s)\n    for _ in range(k):\n      ans = self._getDigitSum(ans)\n    return ans\n\n  def _convert(self, s: str) -> int:\n    return int(''.join(str(ord(c) - ord('a') + 1) for c in s))\n\n  def _getDigitSum(self, num: int) -> int:\n    return sum(int(digit) for digit in str(num))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1929, "slug": "concatenation-of-array", "solutions": ["class Solution:\n    def getConcatenation(self, nums: List[int]) -> List[int]:\n        return nums + nums\n", "class Solution:\n  def getConcatenation(self, nums: list[int]) -> list[int]:\n    return nums * 2\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1962, "slug": "remove-stones-to-minimize-the-total", "solutions": ["class Solution:\n    def minStoneSum(self, piles: List[int], k: int) -> int:\n        pq = [-x for x in piles]\n        heapify(pq)\n        for _ in range(k):\n            heapreplace(pq, pq[0] // 2)\n        return -sum(pq)\n", "class Solution:\n  def minStoneSum(self, piles: list[int], k: int) -> int:\n    maxHeap = [-pile for pile in piles]\n    heapq.heapify(maxHeap)\n\n    for _ in range(k):\n      heapq.heapreplace(maxHeap, maxHeap[0] // 2)\n\n    return -sum(maxHeap)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1989, "slug": "maximum-number-of-people-that-can-be-caught-in-tag", "solutions": ["class Solution:\n    def catchMaximumAmountofPeople(self, team: List[int], dist: int) -> int:\n        ans = j = 0\n        n = len(team)\n        for i, x in enumerate(team):\n            if x:\n                while j < n and (team[j] or i - j > dist):\n                    j += 1\n                if j < n and abs(i - j) <= dist:\n                    ans += 1\n                    j += 1\n        return ans\n", "class Solution:\n  def catchMaximumAmountofPeople(self, team: list[int], dist: int) -> int:\n    ans = 0\n    i = 0  # 0s index\n    j = 0  # 1s index\n\n    while i < len(team) and j < len(team):\n      if i + dist < j or team[i] != 0:\n        # Find the next 0 that can be caught by 1.\n        i += 1\n      elif j + dist < i or team[j] != 1:\n        # Find the next 1 that can catch 0.\n        j += 1\n      else:\n        # team[j] catches team[i], so move both.\n        ans += 1\n        i += 1\n        j += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1999, "slug": "smallest-greater-multiple-made-of-two-digits", "solutions": ["class Solution:\n    def findInteger(self, k: int, digit1: int, digit2: int) -> int:\n        if digit1 == 0 and digit2 == 0:\n            return -1\n        if digit1 > digit2:\n            return self.findInteger(k, digit2, digit1)\n        q = deque([0])\n        while 1:\n            x = q.popleft()\n            if x > 2**31 - 1:\n                return -1\n            if x > k and x % k == 0:\n                return x\n            q.append(x * 10 + digit1)\n            if digit1 != digit2:\n                q.append(x * 10 + digit2)\n", "class Solution:\n  def findInteger(self, k: int, digit1: int, digit2: int) -> int:\n    minDigit = min(digit1, digit2)\n    maxDigit = max(digit1, digit2)\n    digits = [minDigit] if minDigit == maxDigit else [minDigit, maxDigit]\n    q = collections.deque()\n\n    for digit in digits:\n      q.append(digit)\n\n    while q:\n      u = q.popleft()\n      if u > k and u % k == 0:\n        return u\n      if u == 0:\n        continue\n      for digit in digits:\n        nextNum = u * 10 + digit\n        if nextNum > 2**31 - 1:\n          continue\n        q.append(nextNum)\n\n    return -1\n", "class Solution:\n  def findInteger(self, k: int, digit1: int, digit2: int) -> int:\n    def dfs(x: int) -> int:\n      if x > 2**31 - 1:\n        return -1\n      if x > k and x % k == 0:\n        return x\n      # Skip if digit1/digit2 and x are zero.\n      a = -1 if x + digit1 == 0 else dfs(x * 10 + digit1)\n      b = -1 if x + digit2 == 0 else dfs(x * 10 + digit2)\n      if a == -1:\n        return b\n      if b == -1:\n        return a\n      return min(a, b)\n\n    return dfs(0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1928, "slug": "minimum-cost-to-reach-destination-in-time", "solutions": ["class Solution:\n    def minCost(\n        self, maxTime: int, edges: List[List[int]], passingFees: List[int]\n    ) -> int:\n        m, n = maxTime, len(passingFees)\n        f = [[inf] * n for _ in range(m + 1)]\n        f[0][0] = passingFees[0]\n        for i in range(1, m + 1):\n            for x, y, t in edges:\n                if t <= i:\n                    f[i][x] = min(f[i][x], f[i - t][y] + passingFees[x])\n                    f[i][y] = min(f[i][y], f[i - t][x] + passingFees[y])\n        ans = min(f[i][n - 1] for i in range(m + 1))\n        return ans if ans < inf else -1\n", "class Solution:\n  def minCost(\n      self,\n      maxTime: int,\n      edges: list[list[int]],\n      passingFees: list[int],\n  ) -> int:\n    n = len(passingFees)\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, n - 1, maxTime, passingFees)\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n      dst: int,\n      maxTime: int,\n      passingFees: list[int],\n  ) -> int:\n    # cost[i] := the minimum cost to reach the i-th city\n    cost = [math.inf] * len(graph)\n    # dist[i] := the minimum time to reach the i-th city\n    dist = [maxTime + 1] * len(graph)\n\n    cost[src] = passingFees[src]\n    dist[src] = 0\n    minHeap = [(cost[src], dist[src], src)]  # (cost[u], dist[u], u)\n\n    while minHeap:\n      currCost, d, u = heapq.heappop(minHeap)\n      if u == dst:\n        return cost[dst]\n      if d > dist[u] and currCost > cost[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w > maxTime:\n          continue\n        # Go from u -> v.\n        if currCost + passingFees[v] < cost[v]:\n          cost[v] = currCost + passingFees[v]\n          dist[v] = d + w\n          heapq.heappush(minHeap, (cost[v], dist[v], v))\n        elif d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (currCost + passingFees[v], dist[v], v))\n\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1910, "slug": "remove-all-occurrences-of-a-substring", "solutions": ["class Solution:\n    def removeOccurrences(self, s: str, part: str) -> str:\n        while part in s:\n            s = s.replace(part, '', 1)\n        return s\n", "class Solution:\n  def removeOccurrences(self, s: str, part: str) -> str:\n    n = len(s)\n    k = len(part)\n\n    t = [' '] * n\n    j = 0  # t's index\n\n    for i, c in enumerate(s):\n      t[j] = c\n      j += 1\n      if j >= k and ''.join(t[j - k:j]) == part:\n        j -= k\n\n    return ''.join(t[:j])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1920, "slug": "build-array-from-permutation", "solutions": ["class Solution:\n    def buildArray(self, nums: List[int]) -> List[int]:\n        return [nums[num] for num in nums]\n", "class Solution:\n  def buildArray(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n\n    for i, num in enumerate(nums):\n      nums[i] += n * (nums[num] % n)\n\n    for i in range(n):\n      nums[i] //= n\n\n    return nums\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1950, "slug": "maximum-of-minimum-values-in-all-subarrays", "solutions": ["class Solution:\n    def findMaximums(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        left = [-1] * n\n        right = [n] * n\n        stk = []\n        for i, x in enumerate(nums):\n            while stk and nums[stk[-1]] >= x:\n                stk.pop()\n            if stk:\n                left[i] = stk[-1]\n            stk.append(i)\n        stk = []\n        for i in range(n - 1, -1, -1):\n            while stk and nums[stk[-1]] >= nums[i]:\n                stk.pop()\n            if stk:\n                right[i] = stk[-1]\n            stk.append(i)\n        ans = [0] * n\n        for i in range(n):\n            m = right[i] - left[i] - 1\n            ans[m - 1] = max(ans[m - 1], nums[i])\n        for i in range(n - 2, -1, -1):\n            ans[i] = max(ans[i], ans[i + 1])\n        return ans\n", "class Solution:\n  # Similar to 1950. Maximum of Minimum Values in All Subarrays\n  def findMaximums(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n    ans = [0] * n\n    # prevMin[i] := the index k s.t.\n    # nums[k] is the previous minimum in nums[0..n)\n    prevMin = [-1] * n\n    # nextMin[i] := the index k s.t.\n    # nums[k] is the next minimum innums[i + 1..n)\n    nextMin = [n] * n\n    stack = []\n\n    for i, num in enumerate(nums):\n      while stack and nums[stack[-1]] > nums[i]:\n        index = stack.pop()\n        nextMin[index] = i\n      if stack:\n        prevMin[i] = stack[-1]\n      stack.append(i)\n\n    # For each nums[i], let l = nextMin[i] + 1 and r = nextMin[i] - 1.\n    # nums[i] is the minimum in nums[l..r].\n    # So, the ans[r - l + 1] will be at least nums[i].\n    for num, l, r in zip(nums, prevMin, nextMin):\n      sz = r - l - 1\n      ans[sz - 1] = max(ans[sz - 1], num)\n\n    # ans[i] should always >= ans[i + 1..n).\n    for i in range(n - 2, -1, -1):\n      ans[i] = max(ans[i], ans[i + 1])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1968, "slug": "array-with-elements-not-equal-to-average-of-neighbors", "solutions": ["class Solution:\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\n        nums.sort()\n        n = len(nums)\n        m = (n + 1) // 2\n        ans = []\n        for i in range(m):\n            ans.append(nums[i])\n            if i + m < n:\n                ans.append(nums[i + m])\n        return ans\n", "class Solution:\n  def rearrangeArray(self, nums: list[int]) -> list[int]:\n    nums.sort()\n    for i in range(1, len(nums), 2):\n      nums[i], nums[i - 1] = nums[i - 1], nums[i]\n    return nums\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1993, "slug": "operations-on-tree", "solutions": ["class LockingTree:\n    def __init__(self, parent: List[int]):\n        n = len(parent)\n        self.locked = [-1] * n\n        self.parent = parent\n        self.children = [[] for _ in range(n)]\n        for son, fa in enumerate(parent[1:], 1):\n            self.children[fa].append(son)\n\n    def lock(self, num: int, user: int) -> bool:\n        if self.locked[num] == -1:\n            self.locked[num] = user\n            return True\n        return False\n\n    def unlock(self, num: int, user: int) -> bool:\n        if self.locked[num] == user:\n            self.locked[num] = -1\n            return True\n        return False\n\n    def upgrade(self, num: int, user: int) -> bool:\n        def dfs(x: int):\n            nonlocal find\n            for y in self.children[x]:\n                if self.locked[y] != -1:\n                    self.locked[y] = -1\n                    find = True\n                dfs(y)\n\n        x = num\n        while x != -1:\n            if self.locked[x] != -1:\n                return False\n            x = self.parent[x]\n\n        find = False\n        dfs(num)\n        if not find:\n            return False\n        self.locked[num] = user\n        return True\n\n\n# Your LockingTree object will be instantiated and called as such:\n# obj = LockingTree(parent)\n# param_1 = obj.lock(num,user)\n# param_2 = obj.unlock(num,user)\n# param_3 = obj.upgrade(num,user)\n", "class Node:\n  def __init__(self):\n    self.children: list[int] = []\n    self.lockedBy = -1\n\n\nclass LockingTree:\n  def __init__(self, parent: list[int]):\n    self.parent = parent\n    self.nodes = [Node() for _ in range(len(parent))]\n    for i in range(1, len(parent)):\n      self.nodes[parent[i]].children.append(i)\n\n  def lock(self, num: int, user: int) -> bool:\n    if self.nodes[num].lockedBy != -1:\n      return False\n    self.nodes[num].lockedBy = user\n    return True\n\n  def unlock(self, num: int, user: int) -> bool:\n    if self.nodes[num].lockedBy != user:\n      return False\n    self.nodes[num].lockedBy = -1\n    return True\n\n  def upgrade(self, num: int, user: int) -> bool:\n    if self.nodes[num].lockedBy != -1:\n      return False\n    if not self._anyLockedDescendant(num):\n      return False\n\n    # Walk up the hierarchy to ensure that there are no locked ancestors.\n    i = num\n    while i != -1:\n      if self.nodes[i].lockedBy != -1:\n        return False\n      i = self.parent[i]\n\n    self._unlockDescendants(num)\n    self.nodes[num].lockedBy = user\n    return True\n\n  def _anyLockedDescendant(self, i: int) -> bool:\n    return (self.nodes[i].lockedBy != -1 or\n            any(self._anyLockedDescendant(child)\n            for child in self.nodes[i].children))\n\n  def _unlockDescendants(self, i: int) -> None:\n    self.nodes[i].lockedBy = -1\n    for child in self.nodes[i].children:\n      self._unlockDescendants(child)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1981, "slug": "minimize-the-difference-between-target-and-chosen-elements", "solutions": ["class Solution:\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\n        f = {0}\n        for row in mat:\n            f = set(a + b for a in f for b in row)\n        return min(abs(v - target) for v in f)\n", "class Solution:\n  def minimizeTheDifference(self, mat: list[list[int]], target: int) -> int:\n    minSum = sum(min(row) for row in mat)\n    if minSum >= target:  # No need to consider any larger combination.\n      return minSum - target\n\n    @functools.lru_cache(None)\n    def dp(i: int, summ: int) -> int:\n      if i == len(mat):\n        return abs(summ - target)\n      return min(dp(i + 1, summ + num) for num in mat[i])\n\n    return dp(0, 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1903, "slug": "largest-odd-number-in-string", "solutions": ["class Solution:\n    def largestOddNumber(self, num: str) -> str:\n        for i in range(len(num) - 1, -1, -1):\n            if (int(num[i]) & 1) == 1:\n                return num[: i + 1]\n        return ''\n", "class Solution:\n  def largestOddNumber(self, num: str) -> str:\n    for i, n in reversed(list(enumerate(num))):\n      if int(n) % 2 == 1:\n        return num[:i + 1]\n    return ''\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1913, "slug": "maximum-product-difference-between-two-pairs", "solutions": ["class Solution:\n    def maxProductDifference(self, nums: List[int]) -> int:\n        nums.sort()\n        return nums[-1] * nums[-2] - nums[0] * nums[1]\n", "class Solution:\n  def maxProductDifference(self, nums: list[int]) -> int:\n    max1 = -math.inf\n    max2 = -math.inf\n    min1 = math.inf\n    min2 = math.inf\n\n    for num in nums:\n      if num > max1:\n        max2 = max1\n        max1 = num\n      elif num > max2:\n        max2 = num\n      if num < min1:\n        min2 = min1\n        min1 = num\n      elif num < min2:\n        min2 = num\n\n    return max1 * max2 - min1 * min2\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1919, "slug": "leetcodify-similar-friends", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1904, "slug": "the-number-of-full-rounds-you-have-played", "solutions": ["class Solution:\n    def numberOfRounds(self, loginTime: str, logoutTime: str) -> int:\n        def f(s: str) -> int:\n            return int(s[:2]) * 60 + int(s[3:])\n\n        a, b = f(loginTime), f(logoutTime)\n        if a > b:\n            b += 1440\n        a, b = (a + 14) // 15, b // 15\n        return max(0, b - a)\n", "class Solution:\n  def numberOfRounds(self, loginTime: str, logoutTime: str) -> int:\n    start = self._getMinutes(loginTime)\n    finish = self._getMinutes(logoutTime)\n    if start > finish:\n      finish += 60 * 24\n\n    return max(0, finish // 15 - (start + 14) // 15)\n\n  def _getMinutes(self, time: str) -> int:\n    h, m = map(int, time.split(':'))\n    return 60 * h + m\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1964, "slug": "find-the-longest-valid-obstacle-course-at-each-position", "solutions": ["class BinaryIndexedTree:\n    __slots__ = [\"n\", \"c\"]\n\n    def __init__(self, n: int):\n        self.n = n\n        self.c = [0] * (n + 1)\n\n    def update(self, x: int, v: int):\n        while x <= self.n:\n            self.c[x] = max(self.c[x], v)\n            x += x & -x\n\n    def query(self, x: int) -> int:\n        s = 0\n        while x:\n            s = max(s, self.c[x])\n            x -= x & -x\n        return s\n\n\nclass Solution:\n    def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -> List[int]:\n        nums = sorted(set(obstacles))\n        n = len(nums)\n        tree = BinaryIndexedTree(n)\n        ans = []\n        for x in obstacles:\n            i = bisect_left(nums, x) + 1\n            ans.append(tree.query(i) + 1)\n            tree.update(i, ans[-1])\n        return ans\n", "class Solution:\n  # Similar to 300. Longest Increasing Subsequence\n  def longestObstacleCourseAtEachPosition(\n      self, obstacles: list[int],\n  ) -> list[int]:\n    ans = []\n    # tails[i] := the minimum tail of all the increasing subsequences having\n    # length i + 1\n    tails = []\n\n    for obstacle in obstacles:\n      if not tails or obstacle >= tails[-1]:\n        tails.append(obstacle)\n        ans.append(len(tails))\n      else:\n        index = bisect.bisect_right(tails, obstacle)\n        tails[index] = obstacle\n        ans.append(index + 1)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1948, "slug": "delete-duplicate-folders-in-system", "solutions": ["class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = collections.defaultdict(TrieNode)\n    self.deleted = False\n\n\nclass Solution:\n  def deleteDuplicateFolder(self, paths: list[list[str]]) -> list[list[str]]:\n    ans = []\n    root = TrieNode()\n    subtreeToNodes: dict[str, list[TrieNode]] = collections.defaultdict(list)\n\n    # Construct the Trie\n    for path in sorted(paths):\n      node = root\n      for s in path:\n        node = node.children[s]\n\n    # For each subtree, fill in the {subtree encoding: [root]} hash table\n    def buildSubtreeToRoots(node: TrieNode) -> str:\n      subtree = '(' + ''.join(s + buildSubtreeToRoots(node.children[s])\n                              for s in node.children) + ')'\n      if subtree != '()':\n        subtreeToNodes[subtree].append(node)\n      return subtree\n\n    buildSubtreeToRoots(root)\n\n    # Mark nodes that should be deleted\n    for nodes in subtreeToNodes.values():\n      if len(nodes) > 1:\n        for node in nodes:\n          node.deleted = True\n\n    # Construct the answer array for nodes that haven't been deleted\n    def constructPath(node: TrieNode, path: list[str]) -> None:\n      for s, child in node.children.items():\n        if not child.deleted:\n          constructPath(child, path + [s])\n      if path:\n        ans.append(path)\n\n    constructPath(root, [])\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1924, "slug": "erect-the-fence-ii", "solutions": ["from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass Point:\n  x: float\n  y: float\n\n\n@dataclass(frozen=True)\nclass Disk:\n  center: Point\n  radius: float\n\n\nclass Solution:\n  def outerTrees(self, trees: list[list[int]]) -> list[float]:\n    points = [Point(x, y) for x, y in trees]\n    disk = self._welzl(points, 0, [])\n    return [disk.center.x, disk.center.y, disk.radius]\n\n  def _welzl(\n      self,\n      points: list[Point],\n      i: int,\n      planePoints: list[Point],\n  ) -> Disk:\n    \"\"\"Returns the smallest disk that encloses points[i..n).\n\n    https://en.wikipedia.org/wiki/Smallest-disk_problem#Welzl's_algorithm\n    \"\"\"\n    if i == len(points) or len(planePoints) == 3:\n      return self._trivial(planePoints)\n    disk = self._welzl(points, i + 1, planePoints)\n    if self._inside(disk, points[i]):\n      return disk\n    return self._welzl(points, i + 1, planePoints + [points[i]])\n\n  def _trivial(self, planePoints: list[Point]) -> Disk:\n    \"\"\"Returns the smallest disk that encloses `planePoints`.\"\"\"\n    if len(planePoints) == 0:\n      return Disk(Point(0, 0), 0)\n    if len(planePoints) == 1:\n      return Disk(Point(planePoints[0].x, planePoints[0].y), 0)\n    if len(planePoints) == 2:\n      return self._getDisk(planePoints[0], planePoints[1])\n\n    disk01 = self._getDisk(planePoints[0], planePoints[1])\n    if self._inside(disk01, planePoints[2]):\n      return disk01\n\n    disk02 = self._getDisk(planePoints[0], planePoints[2])\n    if self._inside(disk02, planePoints[1]):\n      return disk02\n\n    disk12 = self._getDisk(planePoints[1], planePoints[2])\n    if self._inside(disk12, planePoints[0]):\n      return disk12\n\n    return self._getDiskFromThree(\n        planePoints[0],\n        planePoints[1],\n        planePoints[2])\n\n  def _getDisk(self, A: Point, B: Point) -> Disk:\n    \"\"\"Returns the smallest disk that encloses the points A and B.\"\"\"\n    x = (A.x + B.x) / 2\n    y = (A.y + B.y) / 2\n    return Disk(Point(x, y), self._distance(A, B) / 2)\n\n  def _getDiskFromThree(self, A: Point, B: Point, C: Point) -> Disk:\n    \"\"\"Returns the smallest disk that encloses the points A, B, and C.\"\"\"\n    # Calculate midpoints.\n    mAB = Point((A.x + B.x) / 2, (A.y + B.y) / 2)\n    mBC = Point((B.x + C.x) / 2, (B.y + C.y) / 2)\n\n    # Calculate the slopes and the perpendicular slopes.\n    slopeAB = math.inf if B.x == A.x else (B.y - A.y) / (B.x - A.x)\n    slopeBC = math.inf if C.x == B.x else (C.y - B.y) / (C.x - B.x)\n    perpSlopeAB = math.inf if slopeAB == 0 else -1 / slopeAB\n    perpSlopeBC = math.inf if slopeBC == 0 else -1 / slopeBC\n\n    # Calculate the center.\n    x = (perpSlopeBC * mBC.x - perpSlopeAB * mAB.x +\n         mAB.y - mBC.y) / (perpSlopeBC - perpSlopeAB)\n    y = perpSlopeAB * (x - mAB.x) + mAB.y\n    center = Point(x, y)\n    return Disk(center, self._distance(center, A))\n\n  def _inside(self, disk: Disk, point: Point) -> bool:\n    \"\"\"Returns True if the point is inside the disk.\"\"\"\n    return disk.radius > 0 and self._distance(disk.center, point) <= disk.radius\n\n  def _distance(self, A: Point, B: Point) -> float:\n    dx = A.x - B.x\n    dy = A.y - B.y\n    return math.sqrt(dx**2 + dy**2)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1971, "slug": "find-if-path-exists-in-graph", "solutions": ["class Solution:\n    def validPath(\n        self, n: int, edges: List[List[int]], source: int, destination: int\n    ) -> bool:\n        def dfs(i: int) -> bool:\n            if i == destination:\n                return True\n            if i in vis:\n                return False\n            return any(dfs(j) for j in g[i])\n\n        g = [[] for _ in range(n)]\n        for u, v in edges:\n            g[u].append(v)\n            g[v].append(u)\n        vis = set()\n        return dfs(source)\n", "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def validPath(\n      self,\n      n: int,\n      edges: list[list[int]],\n      source: int,\n      destination: int,\n  ) -> bool:\n    uf = UnionFind(n)\n\n    for u, v in edges:\n      uf.unionByRank(u, v)\n\n    return uf.find(source) == uf.find(destination)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1994, "slug": "the-number-of-good-subsets", "solutions": ["class Solution:\n    def numberOfGoodSubsets(self, nums: List[int]) -> int:\n        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n        cnt = Counter(nums)\n        mod = 10**9 + 7\n        n = len(primes)\n        f = [0] * (1 << n)\n        f[0] = pow(2, cnt[1])\n        for x in range(2, 31):\n            if cnt[x] == 0 or x % 4 == 0 or x % 9 == 0 or x % 25 == 0:\n                continue\n            mask = 0\n            for i, p in enumerate(primes):\n                if x % p == 0:\n                    mask |= 1 << i\n            for state in range((1 << n) - 1, 0, -1):\n                if state & mask == mask:\n                    f[state] = (f[state] + cnt[x] * f[state ^ mask]) % mod\n        return sum(f[i] for i in range(1, 1 << n)) % mod\n", "class Solution:\n  def numberOfGoodSubsets(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n    n = 1 << len(primes)\n    # dp[i] := the number of good subsets with set of primes = i bit mask\n    dp = [1] + [0] * (n - 1)\n    count = collections.Counter(nums)\n\n    for num, freq in count.items():\n      if num == 1:\n        continue\n      if any(num % squared == 0 for squared in [4, 9, 25]):\n        continue\n      numPrimesMask = sum(1 << i\n                          for i, prime in enumerate(primes)\n                          if num % prime == 0)\n      for primesMask in range(n):\n        # Skip since there're commen set of primes (becomes invalid subset)\n        if primesMask & numPrimesMask > 0:\n          continue\n        nextPrimesMask = numPrimesMask | primesMask\n        dp[nextPrimesMask] += dp[primesMask] * freq\n        dp[nextPrimesMask] %= MOD\n\n    return (1 << count[1]) * sum(dp[1:]) % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1902, "slug": "depth-of-bst-given-insertion-order", "solutions": ["class Solution:\n    def maxDepthBST(self, order: List[int]) -> int:\n        sd = SortedDict({0: 0, inf: 0, order[0]: 1})\n        ans = 1\n        for v in order[1:]:\n            lower = sd.bisect_left(v) - 1\n            higher = lower + 1\n            depth = 1 + max(sd.values()[lower], sd.values()[higher])\n            ans = max(ans, depth)\n            sd[v] = depth\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1978, "slug": "employees-whose-manager-left-the-company", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1947, "slug": "maximum-compatibility-score-sum", "solutions": ["class Solution:\n    def maxCompatibilitySum(\n        self, students: List[List[int]], mentors: List[List[int]]\n    ) -> int:\n        def dfs(i: int, s: int):\n            if i >= m:\n                nonlocal ans\n                ans = max(ans, s)\n                return\n            for j in range(m):\n                if not vis[j]:\n                    vis[j] = True\n                    dfs(i + 1, s + g[i][j])\n                    vis[j] = False\n\n        ans = 0\n        m = len(students)\n        vis = [False] * m\n        g = [[0] * m for _ in range(m)]\n        for i, x in enumerate(students):\n            for j, y in enumerate(mentors):\n                g[i][j] = sum(a == b for a, b in zip(x, y))\n        dfs(0, 0)\n        return ans\n", "class Solution:\n  def maxCompatibilitySum(\n      self,\n      students: list[list[int]],\n      mentors: list[list[int]],\n  ) -> int:\n    ans = 0\n\n    def dfs(i: int, scoreSum: int, used: list[bool]) -> None:\n      nonlocal ans\n      if i == len(students):\n        ans = max(ans, scoreSum)\n        return\n\n      for j, mentor in enumerate(mentors):\n        if used[j]:\n          continue\n        used[j] = True  # The `mentors[j]` is used.\n        dfs(i + 1, scoreSum + sum(s == m\n                                  for s, m in zip(students[i], mentor)), used)\n        used[j] = False\n\n    dfs(0, 0, [False] * len(students))\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1912, "slug": "design-movie-rental-system", "solutions": ["class MovieRentingSystem:\n    def __init__(self, n: int, entries: List[List[int]]):\n        self.unrented = collections.defaultdict(SortedList)  # {movie: (price, shop)}\n        self.shopAndMovieToPrice = {}  # {(shop, movie): price}\n        self.rented = SortedList()  # (price, shop, movie)\n        for shop, movie, price in entries:\n            self.unrented[movie].add((price, shop))\n            self.shopAndMovieToPrice[(shop, movie)] = price\n\n    def search(self, movie: int) -> List[int]:\n        return [shop for _, shop in self.unrented[movie][:5]]\n\n    def rent(self, shop: int, movie: int) -> None:\n        price = self.shopAndMovieToPrice[(shop, movie)]\n        self.unrented[movie].remove((price, shop))\n        self.rented.add((price, shop, movie))\n\n    def drop(self, shop: int, movie: int) -> None:\n        price = self.shopAndMovieToPrice[(shop, movie)]\n        self.unrented[movie].add((price, shop))\n        self.rented.remove((price, shop, movie))\n\n    def report(self) -> List[List[int]]:\n        return [[shop, movie] for _, shop, movie in self.rented[:5]]\n\n\n# Your MovieRentingSystem object will be instantiated and called as such:\n# obj = MovieRentingSystem(n, entries)\n# param_1 = obj.search(movie)\n# obj.rent(shop,movie)\n# obj.drop(shop,movie)\n# param_4 = obj.report()\n", "from sortedcontainers import SortedList\n\n\nclass MovieRentingSystem:\n  def __init__(self, n: int, entries: list[list[int]]):\n    self.unrented = collections.defaultdict(\n        SortedList)  # {movie: (price, shop)}\n    self.shopAndMovieToPrice = {}  # {(shop, movie): price}\n    self.rented = SortedList()  # (price, shop, movie)\n    for shop, movie, price in entries:\n      self.unrented[movie].add((price, shop))\n      self.shopAndMovieToPrice[(shop, movie)] = price\n\n  def search(self, movie: int) -> list[int]:\n    return [shop for _, shop in self.unrented[movie][:5]]\n\n  def rent(self, shop: int, movie: int) -> None:\n    price = self.shopAndMovieToPrice[(shop, movie)]\n    self.unrented[movie].remove((price, shop))\n    self.rented.add((price, shop, movie))\n\n  def drop(self, shop: int, movie: int) -> None:\n    price = self.shopAndMovieToPrice[(shop, movie)]\n    self.unrented[movie].add((price, shop))\n    self.rented.remove((price, shop, movie))\n\n  def report(self) -> list[list[int]]:\n    return [[shop, movie] for _, shop, movie in self.rented[:5]]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1941, "slug": "check-if-all-characters-have-equal-number-of-occurrences", "solutions": ["class Solution:\n    def areOccurrencesEqual(self, s: str) -> bool:\n        return len(set(Counter(s).values())) == 1\n", "class Solution:\n  def areOccurrencesEqual(self, s: str) -> bool:\n    return len(set(collections.Counter(s).values())) == 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1916, "slug": "count-ways-to-build-rooms-in-an-ant-colony", "solutions": ["class Solution:\n    def waysToBuildRooms(self, prevRoom: List[int]) -> int:\n        modulo = 10**9 + 7\n        ingoing = defaultdict(set)\n        outgoing = defaultdict(set)\n\n        for i in range(1, len(prevRoom)):\n            ingoing[i].add(prevRoom[i])\n            outgoing[prevRoom[i]].add(i)\n        ans = [1]\n\n        def recurse(i):\n            if len(outgoing[i]) == 0:\n                return 1\n\n            nodes_in_tree = 0\n            for v in outgoing[i]:\n                cn = recurse(v)\n                if nodes_in_tree != 0:\n                    ans[0] *= comb(nodes_in_tree + cn, cn)\n                    ans[0] %= modulo\n                nodes_in_tree += cn\n            return nodes_in_tree + 1\n\n        recurse(0)\n        return ans[0] % modulo\n", "class Solution:\n  def waysToBuildRooms(self, prevRoom: list[int]) -> int:\n    MOD = 1_000_000_007\n    graph = collections.defaultdict(list)\n\n    for i, prev in enumerate(prevRoom):\n      graph[prev].append(i)\n\n    def dfs(node: int) -> tuple[int, int]:\n      if not graph[node]:\n        return 1, 1\n\n      ans = 1\n      l = 0\n\n      for child in graph[node]:\n        temp, r = dfs(child)\n        ans = (ans * temp * math.comb(l + r, r)) % MOD\n        l += r\n\n      return ans, l + 1\n\n    return dfs(0)[0]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1958, "slug": "check-if-move-is-legal", "solutions": ["class Solution:\n    def checkMove(\n        self, board: List[List[str]], rMove: int, cMove: int, color: str\n    ) -> bool:\n        for a in range(-1, 2):\n            for b in range(-1, 2):\n                if a == 0 and b == 0:\n                    continue\n                i, j = rMove, cMove\n                cnt = 0\n                while 0 <= i + a < 8 and 0 <= j + b < 8:\n                    cnt += 1\n                    i, j = i + a, j + b\n                    if cnt > 1 and board[i][j] == color:\n                        return True\n                    if board[i][j] in (color, \".\"):\n                        break\n        return False\n", "class Solution:\n  def checkMove(\n      self,\n      board: list[list[str]],\n      rMove: int,\n      cMove: int,\n      color: str,\n  ) -> bool:\n    DIRS = ((-1, -1), (-1, 0), (-1, 1), (0, -1),\n            (0, 1), (1, -1), (1, 0), (1, 1))\n\n    for dx, dy in DIRS:\n      cellsCount = 2\n      i = rMove + dx\n      j = cMove + dy\n      while 0 <= i < 8 and 0 <= j < 8:\n        # There are no free cells in between.\n        if board[i][j] == '.':\n          break\n        # Need >= 3 cells.\n        if cellsCount == 2 and board[i][j] == color:\n          break\n        # >= 3 cells.\n        if board[i][j] == color:\n          return True\n        i += dx\n        j += dy\n        cellsCount += 1\n\n    return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1938, "slug": "maximum-genetic-difference-query", "solutions": ["class TrieNode:\n  def __init__(self):\n    self.children: list[TrieNode] = [None] * 2\n    self.count = 0\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n    self.HEIGHT = 17\n\n  def update(self, num: int, val: int) -> None:\n    node = self.root\n    for i in range(self.HEIGHT, -1, -1):\n      bit = (num >> i) & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n      node.count += val\n\n  def query(self, num: int) -> int:\n    ans = 0\n    node = self.root\n    for i in range(self.HEIGHT, -1, -1):\n      bit = (num >> i) & 1\n      targetBit = bit ^ 1\n      if node.children[targetBit] and node.children[targetBit].count > 0:\n        ans += 1 << i\n        node = node.children[targetBit]\n      else:\n        node = node.children[targetBit ^ 1]\n    return ans\n\n\nclass Solution:\n  def maxGeneticDifference(\n      self,\n      parents: list[int],\n      queries: list[list[int]],\n  ) -> list[int]:\n    n = len(parents)\n    ans = [0] * len(queries)\n    rootVal = -1\n    tree = [[] for _ in range(n)]\n    nodeToQueries = collections.defaultdict(list)  # {node: (index, val)}\n    trie = Trie()\n\n    for i, parent in enumerate(parents):\n      if parent == -1:\n        rootVal = i\n      else:\n        tree[parent].append(i)\n\n    for i, (node, val) in enumerate(queries):\n      nodeToQueries[node].append((i, val))\n\n    def dfs(node: int) -> None:\n      trie.update(node, 1)\n\n      # Answer queries for node\n      for i, val in nodeToQueries[node]:\n        ans[i] = trie.query(val)\n\n      for child in tree[node]:\n        dfs(child)\n\n      trie.update(node, -1)\n\n    dfs(rootVal)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1946, "slug": "largest-number-after-mutating-substring", "solutions": ["class Solution:\n    def maximumNumber(self, num: str, change: List[int]) -> str:\n        s = list(num)\n        changed = False\n        for i, c in enumerate(s):\n            d = str(change[int(c)])\n            if changed and d < c:\n                break\n            if d > c:\n                changed = True\n                s[i] = d\n        return \"\".join(s)\n", "class Solution:\n  def maximumNumber(self, num: str, change: list[int]) -> str:\n    numList = list(num)\n    mutated = False\n\n    for i, c in enumerate(numList):\n      d = int(c)\n      numlist[i] = chr(ord('0') + max(d, change[d]))\n      if mutated and d > change[d]:\n        return ''.join(numList)\n      if d < change[d]:\n        mutated = True\n\n    return ''.join(numList)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1998, "slug": "gcd-sort-of-an-array", "solutions": ["class Solution:\n    def gcdSort(self, nums: List[int]) -> bool:\n        n = 10**5 + 10\n        p = list(range(n))\n        f = defaultdict(list)\n        mx = max(nums)\n        for i in range(2, mx + 1):\n            if f[i]:\n                continue\n            for j in range(i, mx + 1, i):\n                f[j].append(i)\n\n        def find(x):\n            if p[x] != x:\n                p[x] = find(p[x])\n            return p[x]\n\n        for i in nums:\n            for j in f[i]:\n                p[find(i)] = find(j)\n\n        s = sorted(nums)\n        for i, num in enumerate(nums):\n            if s[i] != num and find(num) != find(s[i]):\n                return False\n        return True\n", "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def gcdSort(self, nums: list[int]) -> bool:\n    mx = max(nums)\n    minPrimeFactors = self._sieveEratosthenes(mx + 1)\n    uf = UnionFind(mx + 1)\n\n    for num in nums:\n      for primeFactor in self._getPrimeFactors(num, minPrimeFactors):\n        uf.unionByRank(num, primeFactor)\n\n    for a, b in zip(nums, sorted(nums)):\n      # Can't swap nums[i] with sortedNums[i].\n      if uf.find(a) != uf.find(b):\n        return False\n\n    return True\n\n  def _sieveEratosthenes(self, n: int) -> list[int]:\n    \"\"\"Gets the minimum prime factor of i, where 1 < i <= n.\"\"\"\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:  # `i` is prime.\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactors(self, num: int, minPrimeFactors: list[int]) -> list[int]:\n    primeFactors = []\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.append(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return primeFactors\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1933, "slug": "check-if-string-is-decomposable-into-value-equal-substrings", "solutions": ["class Solution:\n    def isDecomposable(self, s: str) -> bool:\n        i, n = 0, len(s)\n        cnt2 = 0\n        while i < n:\n            j = i\n            while j < n and s[j] == s[i]:\n                j += 1\n            if (j - i) % 3 == 1:\n                return False\n            cnt2 += (j - i) % 3 == 2\n            if cnt2 > 1:\n                return False\n            i = j\n        return cnt2 == 1\n", "class Solution:\n  def isDecomposable(self, s: str) -> bool:\n    twos = 0\n\n    for _, group in itertools.groupby(s):\n      groupLength = len(list(group))\n      if groupLength % 3 == 1:\n        return False\n      if groupLength % 3 == 2:\n        twos += 1\n        if twos > 1:\n          return False\n\n    return twos == 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1986, "slug": "minimum-number-of-work-sessions-to-finish-the-tasks", "solutions": ["class Solution:\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\n        n = len(tasks)\n        ok = [False] * (1 << n)\n        for i in range(1, 1 << n):\n            t = sum(tasks[j] for j in range(n) if i >> j & 1)\n            ok[i] = t <= sessionTime\n        f = [inf] * (1 << n)\n        f[0] = 0\n        for i in range(1, 1 << n):\n            j = i\n            while j:\n                if ok[j]:\n                    f[i] = min(f[i], f[i ^ j] + 1)\n                j = (j - 1) & i\n        return f[-1]\n", "class Solution:\n  def minSessions(self, tasks: list[int], sessionTime: int) -> int:\n    # Returns True if we can assign tasks[s..n) to `sessions`. Note that `sessions`\n    # may be occupied by some tasks.\n    def dfs(s: int, sessions: list[int]) -> bool:\n      if s == len(tasks):\n        return True\n\n      for i, session in enumerate(sessions):\n        # Can't assign the tasks[s] to this session.\n        if session + tasks[s] > sessionTime:\n          continue\n        # Assign the tasks[s] to this session.\n        sessions[i] += tasks[s]\n        if dfs(s + 1, sessions):\n          return True\n        # Backtracking.\n        sessions[i] -= tasks[s]\n        # If it's the first time we assign the tasks[s] to this session, then future\n        # `session`s can't satisfy either.\n        if sessions[i] == 0:\n          return False\n\n      return False\n\n    for numSessions in range(1, len(tasks) + 1):\n      if dfs(0, [0] * numSessions):\n        return numSessions\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1969, "slug": "minimum-non-zero-product-of-the-array-elements", "solutions": ["class Solution:\n    def minNonZeroProduct(self, p: int) -> int:\n        mod = 10**9 + 7\n        return (2**p - 1) * pow(2**p - 2, 2 ** (p - 1) - 1, mod) % mod\n", "class Solution:\n  def minNonZeroProduct(self, p: int) -> int:\n    MOD = 1_000_000_007\n    # Can always turn [1..2^p - 1] to [1, 1, ..., 2^p - 2, 2^p - 2, 2^p - 1].\n    n = 1 << p\n    halfCount = n // 2 - 1\n    return pow(n - 2, halfCount, MOD) * ((n - 1) % MOD) % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1940, "slug": "longest-common-subsequence-between-sorted-arrays", "solutions": ["class Solution:\n    def longestCommonSubsequence(self, arrays: List[List[int]]) -> List[int]:\n        cnt = [0] * 101\n        for row in arrays:\n            for x in row:\n                cnt[x] += 1\n        return [x for x, v in enumerate(cnt) if v == len(arrays)]\n", "class Solution:\n  def longestCommonSubsequence(self, arrays: list[list[int]]) -> list[int]:\n    MAX = 100\n    ans = []\n    count = [0] * (MAX + 1)\n\n    for array in arrays:\n      for a in array:\n        count[a] += 1\n        if count[a] == len(arrays):\n          ans.append(a)\n\n    return ans\n", "class Solution:\n  def longestCommonSubsequence(self, arrays: list[list[int]]) -> list[int]:\n    return sorted(functools.reduce(lambda a, b: set(a) & set(b), arrays))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1975, "slug": "maximum-matrix-sum", "solutions": ["class Solution:\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\n        mi = inf\n        s = cnt = 0\n        for row in matrix:\n            for x in row:\n                cnt += x < 0\n                y = abs(x)\n                mi = min(mi, y)\n                s += y\n        return s if cnt % 2 == 0 else s - mi * 2\n", "class Solution:\n  def maxMatrixSum(self, matrix: list[list[int]]) -> int:\n    absSum = 0\n    minAbs = math.inf\n    # 0 := even number of negatives\n    # 1 := odd number of negatives\n    oddNeg = 0\n\n    for row in matrix:\n      for num in row:\n        absSum += abs(num)\n        minAbs = min(minAbs, abs(num))\n        if num < 0:\n          oddNeg ^= 1\n\n    return absSum - oddNeg * minAbs * 2\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1930, "slug": "unique-length-3-palindromic-subsequences", "solutions": ["class Solution:\n    def countPalindromicSubsequence(self, s: str) -> int:\n        ans = 0\n        for c in ascii_lowercase:\n            l, r = s.find(c), s.rfind(c)\n            if r - l > 1:\n                ans += len(set(s[l + 1 : r]))\n        return ans\n", "class Solution:\n  def countPalindromicSubsequence(self, s: str) -> int:\n    ans = 0\n    first = [len(s)] * 26\n    last = [-1] * 26\n\n    for i, c in enumerate(s):\n      index = ord(c) - ord('a')\n      first[index] = min(first[index], i)\n      last[index] = i\n\n    for f, l in zip(first, last):\n      if f < l:\n        ans += len(set(s[f + 1:l]))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1980, "slug": "find-unique-binary-string", "solutions": ["class Solution:\n    def findDifferentBinaryString(self, nums: List[str]) -> str:\n        mask = 0\n        for x in nums:\n            mask |= 1 << x.count(\"1\")\n        n = len(nums)\n        for i in range(n + 1):\n            if mask >> i & 1 ^ 1:\n                return \"1\" * i + \"0\" * (n - i)\n", "class Solution:\n  def findDifferentBinaryString(self, nums: list[str]) -> str:\n    return ''.join('1' if num[i] == '0' else '0' for i, num in enumerate(nums))\n", "class Solution:\n  def findDifferentBinaryString(self, nums: list[str]) -> str:\n    bitSize = len(nums[0])\n    maxNum = 1 << bitSize\n    numsSet = {int(num, 2) for num in nums}\n\n    for num in range(maxNum):\n      if num not in numsSet:\n        return f'{num:0>{bitSize}b}'\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1997, "slug": "first-day-where-you-have-been-in-all-the-rooms", "solutions": ["class Solution:\n    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\n        n = len(nextVisit)\n        f = [0] * n\n        mod = 10**9 + 7\n        for i in range(1, n):\n            f[i] = (f[i - 1] + 1 + f[i - 1] - f[nextVisit[i - 1]] + 1) % mod\n        return f[-1]\n", "class Solution:\n  def firstDayBeenInAllRooms(self, nextVisit: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(nextVisit)\n    # dp[i] := the number of days to visit room i for the first time\n    dp = [0] * n\n\n    # Whenever we visit i, visit times of room[0..i - 1] are all even.\n    # Therefore, the rooms before i can be seen as reset and we can safely\n    # reuse dp[0..i - 1] as first-time visit to get second-time visit.\n    for i in range(1, n):\n      # The total days to visit room[i] is the sum of\n      #   * dp[i - 1]: 1st-time visit room[i - 1]\n      #   * 1: visit room[nextVisit[i - 1]]\n      #   * dp[i - 1] - dp[nextVisit[i - 1]]: 2-time visit room[i - 1]\n      #   * 1: visit room[i]\n      dp[i] = (2 * dp[i - 1] - dp[nextVisit[i - 1]] + 2) % MOD\n\n    return dp[-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1985, "slug": "find-the-kth-largest-integer-in-the-array", "solutions": ["class Solution:\n    def kthLargestNumber(self, nums: List[str], k: int) -> str:\n        return nlargest(k, nums, key=lambda x: int(x))[k - 1]\n", "class Solution:\n  # Similar to 215. Kth Largest Element in an Array\n  def kthLargestNumber(self, nums: list[str], k: int) -> str:\n    minHeap = []\n\n    for num in nums:\n      heapq.heappush(minHeap, int(num))\n      if len(minHeap) > k:\n        heapq.heappop(minHeap)\n\n    return str(minHeap[0])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1991, "slug": "find-the-middle-index-in-array", "solutions": ["class Solution:\n    def findMiddleIndex(self, nums: List[int]) -> int:\n        l, r = 0, sum(nums)\n        for i, x in enumerate(nums):\n            r -= x\n            if l == r:\n                return i\n            l += x\n        return -1\n", "class Solution:\n  def findMiddleIndex(self, nums: list[int]) -> int:\n    prefix = 0\n    suffix = sum(nums)\n\n    for i, num in enumerate(nums):\n      suffix -= num\n      if prefix == suffix:\n        return i\n      prefix += num\n\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1976, "slug": "number-of-ways-to-arrive-at-destination", "solutions": ["class Solution:\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\n        g = [[inf] * n for _ in range(n)]\n        for u, v, t in roads:\n            g[u][v] = g[v][u] = t\n        g[0][0] = 0\n        dist = [inf] * n\n        dist[0] = 0\n        f = [0] * n\n        f[0] = 1\n        vis = [False] * n\n        for _ in range(n):\n            t = -1\n            for j in range(n):\n                if not vis[j] and (t == -1 or dist[j] < dist[t]):\n                    t = j\n            vis[t] = True\n            for j in range(n):\n                if j == t:\n                    continue\n                ne = dist[t] + g[t][j]\n                if dist[j] > ne:\n                    dist[j] = ne\n                    f[j] = f[t]\n                elif dist[j] == ne:\n                    f[j] += f[t]\n        mod = 10**9 + 7\n        return f[-1] % mod\n", "class Solution:\n  def countPaths(self, n: int, roads: list[list[int]]) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in roads:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, n - 1)\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n      dst: int,\n  ) -> int:\n    MOD = 10**9 + 7\n    ways = [0] * len(graph)\n    dist = [math.inf] * len(graph)\n\n    ways[src] = 1\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          ways[v] = ways[u]\n          heapq.heappush(minHeap, (dist[v], v))\n        elif d + w == dist[v]:\n          ways[v] += ways[u]\n          ways[v] %= MOD\n\n    return ways[dst]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1972, "slug": "first-and-last-call-on-the-same-day", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1951, "slug": "all-the-pairs-with-the-maximum-number-of-common-followers", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1961, "slug": "check-if-string-is-a-prefix-of-array", "solutions": ["class Solution:\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\n        n, m = len(s), 0\n        for i, w in enumerate(words):\n            m += len(w)\n            if m == n:\n                return \"\".join(words[: i + 1]) == s\n        return False\n", "class Solution:\n  def isPrefixString(self, s: str, words: list[str]) -> bool:\n    prefix = []\n    for word in words:\n      prefix.append(word)\n      if ''.join(prefix) == s:\n        return True\n    return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1953, "slug": "maximum-number-of-weeks-for-which-you-can-work", "solutions": ["class Solution:\n    def numberOfWeeks(self, milestones: List[int]) -> int:\n        mx, s = max(milestones), sum(milestones)\n        rest = s - mx\n        return rest * 2 + 1 if mx > rest + 1 else s\n", "class Solution:\n  def numberOfWeeks(self, milestones: list[int]) -> int:\n    # The best strategy is to pick 'max, nonMax, max, nonMax, ...'.\n    summ = sum(milestones)\n    nonMax = summ - max(milestones)\n    return min(summ, 2 * nonMax + 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1955, "slug": "count-number-of-special-subsequences", "solutions": ["class Solution:\n    def countSpecialSubsequences(self, nums: List[int]) -> int:\n        mod = 10**9 + 7\n        n = len(nums)\n        f = [[0] * 3 for _ in range(n)]\n        f[0][0] = nums[0] == 0\n        for i in range(1, n):\n            if nums[i] == 0:\n                f[i][0] = (2 * f[i - 1][0] + 1) % mod\n                f[i][1] = f[i - 1][1]\n                f[i][2] = f[i - 1][2]\n            elif nums[i] == 1:\n                f[i][0] = f[i - 1][0]\n                f[i][1] = (f[i - 1][0] + 2 * f[i - 1][1]) % mod\n                f[i][2] = f[i - 1][2]\n            else:\n                f[i][0] = f[i - 1][0]\n                f[i][1] = f[i - 1][1]\n                f[i][2] = (f[i - 1][1] + 2 * f[i - 1][2]) % mod\n        return f[n - 1][2]\n", "class Solution:\n  def countSpecialSubsequences(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def dp(i: int, prev: int) -> int:\n      \"\"\"\n      Returns the number of increasing subsequences of the first i numbers,\n      where the the previous number is j - 1.\n      \"\"\"\n      if i == len(nums):\n        return prev == 2\n\n      res = 0\n\n      # Don't include `nums[i]`.\n      res += dp(i + 1, prev)\n\n      # Include `nums[i]`.\n      if nums[i] == prev:\n        res += dp(i + 1, prev)\n      if prev == -1 and nums[i] == 0:\n        res += dp(i + 1, 0)\n      if prev == 0 and nums[i] == 1:\n        res += dp(i + 1, 1)\n      if prev == 1 and nums[i] == 2:\n        res += dp(i + 1, 2)\n\n      res %= MOD\n      return res\n\n    return dp(0, -1)\n", "class Solution:\n  def countSpecialSubsequences(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(nums)\n    # dp[j] := the number of increasing subsequences of the numbers so far that\n    # end in j\n    dp = [0] * 3\n\n    if nums[0] == 0:\n      dp[0] = 1\n\n    for i in range(1, n):\n      if nums[i] == 0:\n        dp[0] = dp[0] * 2 + 1\n      elif nums[i] == 1:\n        dp[1] = dp[1] * 2 + dp[0]\n      else:  # nums[i] == 2\n        dp[2] = dp[2] * 2 + dp[1]\n\n      for ending in range(3):\n        dp[ending] %= MOD\n\n    return dp[2]\n", "class Solution:\n  def countSpecialSubsequences(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(nums)\n    # dp[i][j] := the number of increasing subsequences of the first i numbers\n    # that end in j\n    dp = [[0] * 3 for _ in range(n)]\n\n    if nums[0] == 0:\n      dp[0][0] = 1\n\n    for i in range(1, n):\n      for ending in range(3):\n        dp[i][ending] = dp[i - 1][ending]\n\n      if nums[i] == 0:\n        # 1. The number of the previous subsequences that end in 0.\n        # 2. Append a 0 to the previous subsequences that end in 0.\n        # 3. Start a new subsequence from this 0.\n        dp[i][0] = dp[i - 1][0] * 2 + 1\n      elif nums[i] == 1:\n        # 1. The number of the previous subsequences that end in 1.\n        # 2. Append a 1 to the previous subsequences that end in 1.\n        # 3. Append a 1 to the previous subsequences that end in 0.\n        dp[i][1] = dp[i - 1][1] * 2 + dp[i - 1][0]\n      else:  # nums[i] == 2\n        # 1. The number of the previous subsequences that end in 2.\n        # 2. Append a 2 to the previous subsequences that end in 2.\n        # 3. Append a 2 to the previous subsequences that end in 1.\n        dp[i][2] = dp[i - 1][2] * 2 + dp[i - 1][1]\n\n      for ending in range(3):\n        dp[i][ending] %= MOD\n\n    return dp[-1][2]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1956, "slug": "minimum-time-for-k-virus-variants-to-spread", "solutions": ["class Solution:\n  def minDayskVariants(self, points: list[list[int]], k: int) -> int:\n    MAX = 100\n    ans = math.inf\n\n    for a in range(1, MAX + 1):\n      for b in range(1, MAX + 1):\n        # Stores the k minimum distances of points that can reach (a, b).\n        maxHeap = []\n        for x, y in points:\n          heapq.heappush(maxHeap, -abs(x - a) + -abs(y - b))\n          if len(maxHeap) > k:\n            heapq.heappop(maxHeap)\n        ans = min(ans, -maxHeap[0])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1965, "slug": "employees-with-missing-information", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1984, "slug": "minimum-difference-between-highest-and-lowest-of-k-scores", "solutions": ["class Solution:\n    def minimumDifference(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        return min(nums[i + k - 1] - nums[i] for i in range(len(nums) - k + 1))\n", "class Solution:\n  def minimumDifference(self, nums: list[int], k: int) -> int:\n    nums.sort()\n    ans = nums[k - 1] - nums[0]\n\n    for i in range(k, len(nums)):\n      ans = min(ans, nums[i] - nums[i - k + 1])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1944, "slug": "number-of-visible-people-in-a-queue", "solutions": ["class Solution:\n    def canSeePersonsCount(self, heights: List[int]) -> List[int]:\n        n = len(heights)\n        ans = [0] * n\n        stk = []\n        for i in range(n - 1, -1, -1):\n            while stk and stk[-1] < heights[i]:\n                ans[i] += 1\n                stk.pop()\n            if stk:\n                ans[i] += 1\n            stk.append(heights[i])\n        return ans\n", "class Solution:\n  def canSeePersonsCount(self, heights: list[int]) -> list[int]:\n    ans = [0] * len(heights)\n    stack = []\n\n    for i, height in enumerate(heights):\n      while stack and heights[stack[-1]] <= height:\n        ans[stack.pop()] += 1\n      if stack:\n        ans[stack[-1]] += 1\n      stack.append(i)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1942, "slug": "the-number-of-the-smallest-unoccupied-chair", "solutions": ["class Solution:\n    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\n        n = len(times)\n        for i in range(n):\n            times[i].append(i)\n        times.sort()\n        idle = list(range(n))\n        heapify(idle)\n        busy = []\n        for arrival, leaving, i in times:\n            while busy and busy[0][0] <= arrival:\n                heappush(idle, heappop(busy)[1])\n            j = heappop(idle)\n            if i == targetFriend:\n                return j\n            heappush(busy, (leaving, j))\n", "class Solution:\n  def smallestChair(self, times: list[list[int]], targetFriend: int) -> int:\n    nextUnsatChair = 0\n    emptyChairs = []\n    occupied = []  # (leaving, chair)\n\n    for i in range(len(times)):\n      times[i].append(i)\n\n    times.sort(key=lambda x: x[0])\n\n    for arrival, leaving, i in times:\n      while len(occupied) > 0 and occupied[0][0] <= arrival:\n        unsatChair = heapq.heappop(occupied)[1]\n        heapq.heappush(emptyChairs, unsatChair)\n      if i == targetFriend:\n        return emptyChairs[0] if len(emptyChairs) > 0 else nextUnsatChair\n      if len(emptyChairs) == 0:\n        heapq.heappush(occupied, (leaving, nextUnsatChair))\n        nextUnsatChair += 1\n      else:\n        emptyChair = heapq.heappop(emptyChairs)\n        heapq.heappush(occupied, (leaving, emptyChair))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1959, "slug": "minimum-total-space-wasted-with-k-resizing-operations", "solutions": ["class Solution:\n    def minSpaceWastedKResizing(self, nums: List[int], k: int) -> int:\n        k += 1\n        n = len(nums)\n        g = [[0] * n for _ in range(n)]\n        for i in range(n):\n            s = mx = 0\n            for j in range(i, n):\n                s += nums[j]\n                mx = max(mx, nums[j])\n                g[i][j] = mx * (j - i + 1) - s\n        f = [[inf] * (k + 1) for _ in range(n + 1)]\n        f[0][0] = 0\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                for h in range(i):\n                    f[i][j] = min(f[i][j], f[h][j - 1] + g[h][i - 1])\n        return f[-1][-1]\n", "class Solution:\n  def minSpaceWastedKResizing(self, nums: list[int], k: int) -> int:\n    MAX = 200_000_000\n\n    @functools.lru_cache(None)\n    def dp(i: int, k: int) -> int:\n      \"\"\"\n      Returns the minimum space wasted for nums[i..n) if you can resize k times.\n      \"\"\"\n      if i == len(nums):\n        return 0\n      if k == -1:\n        return MAX\n\n      res = MAX\n      summ = 0\n      maxNum = nums[i]\n\n      for j in range(i, len(nums)):\n        summ += nums[j]\n        maxNum = max(maxNum, nums[j])\n        wasted = maxNum * (j - i + 1) - summ\n        res = min(res, dp(j + 1, k - 1) + wasted)\n\n      return res\n\n    return dp(0, k)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1921, "slug": "eliminate-maximum-number-of-monsters", "solutions": ["class Solution:\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\n        times = sorted((d - 1) // s for d, s in zip(dist, speed))\n        for i, t in enumerate(times):\n            if t < i:\n                return i\n        return len(times)\n", "class Solution:\n  def eliminateMaximum(self, dist: list[int], speed: list[int]) -> int:\n    for i, arrivalTime in enumerate(\n            sorted([(d - 1) // s for d, s in zip(dist, speed)])):\n      if i > arrivalTime:\n        return i\n    return len(dist)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1923, "slug": "longest-common-subpath", "solutions": ["class Solution:\n    def longestCommonSubpath(self, n: int, paths: List[List[int]]) -> int:\n        def check(k: int) -> bool:\n            cnt = Counter()\n            for h in hh:\n                vis = set()\n                for i in range(1, len(h) - k + 1):\n                    j = i + k - 1\n                    x = (h[j] - h[i - 1] * p[j - i + 1]) % mod\n                    if x not in vis:\n                        vis.add(x)\n                        cnt[x] += 1\n            return max(cnt.values()) == m\n\n        m = len(paths)\n        mx = max(len(path) for path in paths)\n        base = 133331\n        mod = 2**64 + 1\n        p = [0] * (mx + 1)\n        p[0] = 1\n        for i in range(1, len(p)):\n            p[i] = p[i - 1] * base % mod\n        hh = []\n        for path in paths:\n            k = len(path)\n            h = [0] * (k + 1)\n            for i, x in enumerate(path, 1):\n                h[i] = h[i - 1] * base % mod + x\n            hh.append(h)\n        l, r = 0, min(len(path) for path in paths)\n        while l < r:\n            mid = (l + r + 1) >> 1\n            if check(mid):\n                l = mid\n            else:\n                r = mid - 1\n        return l\n", "class Solution:\n  def __init__(self):\n    self.BASE = 165_131\n    self.HASH = 8_417_508_174_513\n\n  def longestCommonSubpath(self, n: int, paths: list[list[int]]) -> int:\n    l = 0\n    r = len(paths[0])\n\n    while l < r:\n      m = l + (r - l + 1) // 2\n      if self._checkCommonSubpath(paths, m):\n        l = m\n      else:\n        r = m - 1\n\n    return l\n\n  def _checkCommonSubpath(self, paths: list[list[int]], m: int) -> bool:\n    \"\"\"\n    Returns True if there's a common subpath of length m for all the paths.\n    \"\"\"\n    # Calculate the hash values for subpaths of length m for every path.\n    hashSets = [self._rabinKarp(path, m) for path in paths]\n\n    # Check if there is a common subpath of length m.\n    for subpathHash in hashSets[0]:\n      if all(subpathHash in hashSet for hashSet in hashSets):\n        return True\n\n    return False\n\n  def _rabinKarp(self, path: list[int], m: int) -> set[int]:\n    \"\"\"Returns the hash values for subpaths of length m in the path.\"\"\"\n    hashes = set()\n    maxPower = 1\n    hash = 0\n\n    for i, num in enumerate(path):\n      hash = (hash * self.BASE + num) % self.HASH\n      if i >= m:\n        hash = (hash - path[i - m] * maxPower %\n                self.HASH + self.HASH) % self.HASH\n      else:\n        maxPower = maxPower * self.BASE % self.HASH\n      if i >= m - 1:\n        hashes.add(hash)\n\n    return hashes\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1937, "slug": "maximum-number-of-points-with-cost", "solutions": ["class Solution:\n    def maxPoints(self, points: List[List[int]]) -> int:\n        n = len(points[0])\n        f = points[0][:]\n        for p in points[1:]:\n            g = [0] * n\n            lmx = -inf\n            for j in range(n):\n                lmx = max(lmx, f[j] + j)\n                g[j] = max(g[j], p[j] + lmx - j)\n            rmx = -inf\n            for j in range(n - 1, -1, -1):\n                rmx = max(rmx, f[j] - j)\n                g[j] = max(g[j], p[j] + rmx + j)\n            f = g\n        return max(f)\n", "class Solution:\n  def maxPoints(self, points: list[list[int]]) -> int:\n    n = len(points[0])\n    # dp[j] := the maximum number of points you can have if points[i][j] is the\n    # most recent cell you picked\n    dp = [0] * n\n\n    for row in points:\n      leftToRight = [0] * n\n      runningMax = 0\n      for j in range(n):\n        runningMax = max(runningMax - 1, dp[j])\n        leftToRight[j] = runningMax\n\n      rightToLeft = [0] * n\n      runningMax = 0\n      for j in range(n - 1, - 1, -1):\n        runningMax = max(runningMax - 1, dp[j])\n        rightToLeft[j] = runningMax\n\n      for j in range(n):\n        dp[j] = max(leftToRight[j], rightToLeft[j]) + row[j]\n\n    return max(dp)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1960, "slug": "maximum-product-of-the-length-of-two-palindromic-substrings", "solutions": ["class Solution:\n  def maxProduct(self, s: str) -> int:\n    n = len(s)\n\n    def manacher(s: str) -> list[int]:\n      maxExtends = [0] * n\n      leftToRight = [1] * n\n      center = 0\n\n      for i in range(n):\n        r = center + maxExtends[center] - 1\n        mirrorIndex = center - (i - center)\n        extend = 1 if i > r else min(maxExtends[mirrorIndex], r - i + 1)\n        while i - extend >= 0 and i + extend < n and s[i - extend] == s[i + extend]:\n          leftToRight[i + extend] = 2 * extend + 1\n          extend += 1\n        maxExtends[i] = extend\n        if i + maxExtends[i] >= r:\n          center = i\n\n      for i in range(1, n):\n        leftToRight[i] = max(leftToRight[i], leftToRight[i - 1])\n\n      return leftToRight\n\n    # maxLeft[i] := the maximum odd length of palindromes in s[0..i]\n    maxLeft = manacher(s)\n    # maxRight[i] := the maximum odd length of palindromes in s[i..n - 1]\n    maxRight = manacher(s[::-1])[::-1]\n    return max(maxLeft[i - 1] * maxRight[i] for i in range(1, n))\n", "class Solution:\n  def maxProduct(self, s: str) -> int:\n    BASE = 26\n    HASH = 1_000_000_007\n    n = len(s)\n    pows = [1]  # pows[i] := BASE^i % HASH\n    # hashL[i] = the hash of the first i letters of s, where hashL[i] =\n    # (26^(i - 1) * s[0] + 26^(i - 2) * s[1] + ... + s[i - 1]) % HASH\n    hashL = [0]\n    # hashR[i] = the hash of the last i letters of s, where hashR[i] =\n    # (26^(i - 1) * s[-1] + 26^(i - 2) * s[-2] + ... + s[-i]) % HASH\n    hashR = [0]\n    # maxLeft[i] := the maximum odd length of palindromes in s[0..i]\n    maxLeft = [0] * n\n    # maxRight[i] := the maximum odd length of palindromes in s[i..n - 1]\n    maxRight = [0] * n\n\n    def val(c: str) -> int:\n      return ord(c) - ord('a')\n\n    for _ in range(n):\n      pows.append(pows[-1] * BASE % HASH)\n\n    for c in s:\n      hashL.append((hashL[-1] * BASE + val(c)) % HASH)\n\n    for c in reversed(s):\n      hashR.append((hashR[-1] * BASE + val(c)) % HASH)\n\n    hashR.reverse()\n\n    def getLeftRollingHash(l: int, r: int) -> int:\n      \"\"\"Returns the left rolling hash of s[l..r).\"\"\"\n      h = (hashL[r] - hashL[l] * pows[r - l]) % HASH\n      return h + HASH if h < 0 else h\n\n    def getRightRollingHash(l: int, r: int) -> int:\n      \"\"\"Returns the right rolling hash of s[l..r).\"\"\"\n      h = (hashR[l] - hashR[r] * pows[r - l]) % HASH\n      return h + HASH if h < 0 else h\n\n    def isPalindrome(l: int, r: int) -> bool:\n      \"\"\"Returns True if s[l..r) is a palindrome.\"\"\"\n      return getLeftRollingHash(l, r) == getRightRollingHash(l, r)\n\n    maxLength = 1\n    for r in range(n):\n      l = (r - maxLength - 2) + 1\n      if l >= 0 and isPalindrome(l, r + 1):\n        maxLength += 2\n      maxLeft[r] = maxLength\n\n    maxLength = 1\n    for l in reversed(range(n)):\n      r = (l + maxLength + 2) - 1\n      if r < n and isPalindrome(l, r + 1):\n        maxLength += 2\n      maxRight[l] = maxLength\n\n    return max(maxLeft[i - 1] * maxRight[i] for i in range(1, n))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1907, "slug": "count-salary-categories", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1983, "slug": "widest-pair-of-indices-with-equal-range-sum", "solutions": ["class Solution:\n    def widestPairOfIndices(self, nums1: List[int], nums2: List[int]) -> int:\n        d = {0: -1}\n        ans = s = 0\n        for i, (a, b) in enumerate(zip(nums1, nums2)):\n            s += a - b\n            if s in d:\n                ans = max(ans, i - d[s])\n            else:\n                d[s] = i\n        return ans\n", "class Solution:\n  def widestPairOfIndices(self, nums1: list[int], nums2: list[int]) -> int:\n    ans = 0\n    prefix = 0\n    prefixToIndex = {0: -1}\n\n    for i, (num1, num2) in enumerate(zip(nums1, nums2)):\n      prefix += num1 - num2\n      ans = max(ans, i - prefixToIndex.setdefault(prefix, i))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1911, "slug": "maximum-alternating-subsequence-sum", "solutions": ["class Solution:\n    def maxAlternatingSum(self, nums: List[int]) -> int:\n        n = len(nums)\n        f = [0] * (n + 1)\n        g = [0] * (n + 1)\n        for i, x in enumerate(nums, 1):\n            f[i] = max(g[i - 1] - x, f[i - 1])\n            g[i] = max(f[i - 1] + x, g[i - 1])\n        return max(f[n], g[n])\n", "class Solution:\n  def maxAlternatingSum(self, nums: list[int]) -> int:\n    even = 0  # the maximum alternating sum ending in an even index\n    odd = 0  # the maximum alternating sum ending in an odd index\n\n    for num in nums:\n      even = max(even, odd + num)\n      odd = even - num\n\n    return even\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1963, "slug": "minimum-number-of-swaps-to-make-the-string-balanced", "solutions": ["class Solution:\n    def minSwaps(self, s: str) -> int:\n        x = 0\n        for c in s:\n            if c == \"[\":\n                x += 1\n            elif x:\n                x -= 1\n        return (x + 1) >> 1\n", "class Solution:\n  def minSwaps(self, s: str) -> int:\n    # Cancel out all the matched pairs, then we'll be left with ']]]..[[['.\n    # The answer is ceil(# of unmatched pairs // 2).\n    unmatched = 0\n\n    for c in s:\n      if c == '[':\n        unmatched += 1\n      elif unmatched > 0:  # c == ']' and there's a match.\n        unmatched -= 1\n\n    return (unmatched + 1) // 2\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1914, "slug": "cyclically-rotating-a-grid", "solutions": ["class Solution:\n    def rotateGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\n        def rotate(p: int, k: int):\n            nums = []\n            for j in range(p, n - p - 1):\n                nums.append(grid[p][j])\n            for i in range(p, m - p - 1):\n                nums.append(grid[i][n - p - 1])\n            for j in range(n - p - 1, p, -1):\n                nums.append(grid[m - p - 1][j])\n            for i in range(m - p - 1, p, -1):\n                nums.append(grid[i][p])\n            k %= len(nums)\n            if k == 0:\n                return\n            nums = nums[k:] + nums[:k]\n            k = 0\n            for j in range(p, n - p - 1):\n                grid[p][j] = nums[k]\n                k += 1\n            for i in range(p, m - p - 1):\n                grid[i][n - p - 1] = nums[k]\n                k += 1\n            for j in range(n - p - 1, p, -1):\n                grid[m - p - 1][j] = nums[k]\n                k += 1\n            for i in range(m - p - 1, p, -1):\n                grid[i][p] = nums[k]\n                k += 1\n\n        m, n = len(grid), len(grid[0])\n        for p in range(min(m, n) >> 1):\n            rotate(p, k)\n        return grid\n", "class Solution:\n  def rotateGrid(self, grid: list[list[int]], k: int) -> list[list[int]]:\n    m = len(grid)\n    n = len(grid[0])\n    t = 0  # the top\n    l = 0  # the left\n    b = m - 1  # the bottom\n    r = n - 1  # the right\n\n    while t < b and l < r:\n      elementInThisLayer = 2 * (b - t + 1) + 2 * (r - l + 1) - 4\n      netRotations = k % elementInThisLayer\n      for _ in range(netRotations):\n        topLeft = grid[t][l]\n        for j in range(l, r):\n          grid[t][j] = grid[t][j + 1]\n        for i in range(t, b):\n          grid[i][r] = grid[i + 1][r]\n        for j in range(r, l, - 1):\n          grid[b][j] = grid[b][j - 1]\n        for i in range(b, t, -1):\n          grid[i][l] = grid[i - 1][l]\n        grid[t + 1][l] = topLeft\n      t += 1\n      l += 1\n      b -= 1\n      r -= 1\n\n    return grid\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1936, "slug": "add-minimum-number-of-rungs", "solutions": ["class Solution:\n    def addRungs(self, rungs: List[int], dist: int) -> int:\n        rungs = [0] + rungs\n        return sum((b - a - 1) // dist for a, b in pairwise(rungs))\n", "class Solution:\n  def addRungs(self, rungs: list[int], dist: int) -> int:\n    ans = 0\n    prev = 0\n\n    for rung in rungs:\n      ans += (rung - prev - 1) // dist\n      prev = rung\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1934, "slug": "confirmation-rate", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2045, "slug": "second-minimum-time-to-reach-destination", "solutions": ["class Solution:\n    def secondMinimum(\n        self, n: int, edges: List[List[int]], time: int, change: int\n    ) -> int:\n        g = defaultdict(set)\n        for u, v in edges:\n            g[u].add(v)\n            g[v].add(u)\n        q = deque([(1, 0)])\n        dist = [[inf] * 2 for _ in range(n + 1)]\n        dist[1][1] = 0\n        while q:\n            u, d = q.popleft()\n            for v in g[u]:\n                if d + 1 < dist[v][0]:\n                    dist[v][0] = d + 1\n                    q.append((v, d + 1))\n                elif dist[v][0] < d + 1 < dist[v][1]:\n                    dist[v][1] = d + 1\n                    if v == n:\n                        break\n                    q.append((v, d + 1))\n        ans = 0\n        for i in range(dist[n][1]):\n            ans += time\n            if i < dist[n][1] - 1 and (ans // change) % 2 == 1:\n                ans = (ans + change) // change * change\n        return ans\n", "class Solution:\n  def secondMinimum(\n      self,\n      n: int,\n      edges: list[list[int]],\n      time: int,\n      change: int,\n  ) -> int:\n    graph = [[] for _ in range(n + 1)]\n    q = collections.deque([(1, 0)])\n    # minTime[u][0] := the first minimum time to reach the node u\n    # minTime[u][1] := the second minimum time to reach the node u\n    minTime = [[math.inf] * 2 for _ in range(n + 1)]\n    minTime[1][0] = 0\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    while q:\n      u, prevTime = q.popleft()\n      # Start from green.\n      # If `numChangeSignal` is odd, now red.\n      # If numChangeSignal is even -> now gree\n      numChangeSignal = prevTime // change\n      waitTime = (0 if numChangeSignal % 2 == 0\n                  else change - (prevTime % change))\n      newTime = prevTime + waitTime + time\n      for v in graph[u]:\n        if newTime < minTime[v][0]:\n          minTime[v][0] = newTime\n          q.append((v, newTime))\n        elif minTime[v][0] < newTime < minTime[v][1]:\n          if v == n:\n            return newTime\n          minTime[v][1] = newTime\n          q.append((v, newTime))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2010, "slug": "the-number-of-seniors-and-juniors-to-join-the-company-ii", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2021, "slug": "brightest-position-on-street", "solutions": ["class Solution:\n    def brightestPosition(self, lights: List[List[int]]) -> int:\n        d = defaultdict(int)\n        for i, j in lights:\n            l, r = i - j, i + j\n            d[l] += 1\n            d[r + 1] -= 1\n        ans = s = mx = 0\n        for k in sorted(d):\n            s += d[k]\n            if mx < s:\n                mx = s\n                ans = k\n        return ans\n", "from sortedcontainers import SortedDict\n\n\nclass Solution:\n  def brightestPosition(self, lights: list[list[int]]) -> int:\n    ans = math.inf\n    maxBrightness = -1\n    currBrightness = 0\n    line = SortedDict()\n\n    for position, rg in lights:\n      start = position - rg\n      end = position + rg + 1\n      line[start] = line.get(start, 0) + 1\n      line[end] = line.get(end, 0) - 1\n\n    for pos, brightness in line.items():\n      currBrightness += brightness\n      if currBrightness > maxBrightness:\n        maxBrightness = currBrightness\n        ans = pos\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2023, "slug": "number-of-pairs-of-strings-with-concatenation-equal-to-target", "solutions": ["class Solution:\n    def numOfPairs(self, nums: List[str], target: str) -> int:\n        n = len(nums)\n        return sum(\n            i != j and nums[i] + nums[j] == target for i in range(n) for j in range(n)\n        )\n", "class Solution:\n  def numOfPairs(self, nums: list[str], target: str) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    for num in nums:\n      k = len(num)\n      if target[:k] == num:\n        ans += count[target[k:]]\n      if target[-k:] == num:\n        ans += count[target[:-k]]\n      count[num] += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2012, "slug": "sum-of-beauty-in-the-array", "solutions": ["class Solution:\n    def sumOfBeauties(self, nums: List[int]) -> int:\n        n = len(nums)\n        right = [nums[-1]] * n\n        for i in range(n - 2, -1, -1):\n            right[i] = min(right[i + 1], nums[i])\n        ans = 0\n        l = nums[0]\n        for i in range(1, n - 1):\n            r = right[i + 1]\n            if l < nums[i] < r:\n                ans += 2\n            elif nums[i - 1] < nums[i] < nums[i + 1]:\n                ans += 1\n            l = max(l, nums[i])\n        return ans\n", "class Solution:\n  def sumOfBeauties(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = 0\n    minOfRight = [0] * (n - 1) + [nums[-1]]\n\n    for i in range(n - 2, 1, -1):\n      minOfRight[i] = min(nums[i], minOfRight[i + 1])\n\n    maxOfLeft = nums[0]\n\n    for i in range(1, n - 1):\n      if maxOfLeft < nums[i] < minOfRight[i + 1]:\n        ans += 2\n      elif nums[i - 1] < nums[i] < nums[i + 1]:\n        ans += 1\n      maxOfLeft = max(maxOfLeft, nums[i])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2041, "slug": "accepted-candidates-from-the-interviews", "solutions": ["import pandas as pd\n\n\ndef accepted_candidates(candidates: pd.DataFrame, rounds: pd.DataFrame) -> pd.DataFrame:\n    merged_df = pd.merge(candidates, rounds, on=\"interview_id\")\n    filtered_df = merged_df[merged_df[\"years_of_exp\"] >= 2]\n    grouped_df = filtered_df.groupby(\"candidate_id\").agg({\"score\": \"sum\"})\n    return grouped_df[grouped_df[\"score\"] > 15].reset_index()[[\"candidate_id\"]]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2062, "slug": "count-vowel-substrings-of-a-string", "solutions": ["class Solution:\n    def countVowelSubstrings(self, word: str) -> int:\n        s = set(\"aeiou\")\n        ans, n = 0, len(word)\n        for i in range(n):\n            t = set()\n            for c in word[i:]:\n                if c not in s:\n                    break\n                t.add(c)\n                ans += len(t) == 5\n        return ans\n", "class Solution:\n  def countVowelSubstrings(self, word: str) -> int:\n    VOWELS = 'aeiou'\n\n    def countVowelSubstringsAtMost(goal: int) -> int:\n      ans = 0\n      k = goal\n      count = collections.Counter()\n\n      l = 0\n      for r, c in enumerate(word):\n        if c not in VOWELS:  # Fresh start.\n          l = r + 1\n          k = goal\n          count = collections.Counter()\n          continue\n        count[c] += 1\n        if count[c] == 1:\n          k -= 1\n        while k == -1:\n          count[word[l]] -= 1\n          if count[word[l]] == 0:\n            k += 1\n          l += 1\n        ans += r - l + 1  # s[l..r], s[l + 1..r], ..., s[r]\n\n      return ans\n\n    return countVowelSubstringsAtMost(5) - countVowelSubstringsAtMost(4)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2020, "slug": "number-of-accounts-that-did-not-stream", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2044, "slug": "count-number-of-maximum-bitwise-or-subsets", "solutions": ["class Solution:\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\n        mx = ans = 0\n        for x in nums:\n            mx |= x\n\n        def dfs(i, t):\n            nonlocal mx, ans\n            if i == len(nums):\n                if t == mx:\n                    ans += 1\n                return\n            dfs(i + 1, t)\n            dfs(i + 1, t | nums[i])\n\n        dfs(0, 0)\n        return ans\n", "class Solution:\n  def countMaxOrSubsets(self, nums: list[int]) -> int:\n    ors = functools.reduce(operator.or_, nums)\n    ans = 0\n\n    def dfs(i: int, path: int) -> None:\n      nonlocal ans\n      if i == len(nums):\n        if path == ors:\n          ans += 1\n        return\n\n      dfs(i + 1, path)\n      dfs(i + 1, path | nums[i])\n\n    dfs(0, 0)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2000, "slug": "reverse-prefix-of-word", "solutions": ["class Solution:\n    def reversePrefix(self, word: str, ch: str) -> str:\n        i = word.find(ch)\n        return word if i == -1 else word[i::-1] + word[i + 1 :]\n", "class Solution:\n  def reversePrefix(self, word: str, ch: str) -> str:\n    i = word.find(ch) + 1\n    return word[:i][::-1] + word[i:]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2011, "slug": "final-value-of-variable-after-performing-operations", "solutions": ["class Solution:\n    def finalValueAfterOperations(self, operations: List[str]) -> int:\n        return sum(1 if s[1] == '+' else -1 for s in operations)\n", "class Solution:\n  def finalValueAfterOperations(self, operations: list[str]) -> int:\n    return sum(op[1] == '+' or -1 for op in operations)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2095, "slug": "delete-the-middle-node-of-a-linked-list", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode(next=head)\n        slow, fast = dummy, head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        slow.next = slow.next.next\n        return dummy.next\n", "class Solution:\n  def deleteMiddle(self, head: ListNode | None) -> ListNode | None:\n    dummy = ListNode(0, head)\n    slow = dummy\n    fast = dummy\n\n    while fast.next and fast.next.next:\n      slow = slow.next\n      fast = fast.next.next\n\n    # Delete the middle node.\n    slow.next = slow.next.next\n    return dummy.next\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2040, "slug": "kth-smallest-product-of-two-sorted-arrays", "solutions": ["class Solution:\n    def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:\n        def count(p: int) -> int:\n            cnt = 0\n            n = len(nums2)\n            for x in nums1:\n                if x > 0:\n                    cnt += bisect_right(nums2, p / x)\n                elif x < 0:\n                    cnt += n - bisect_left(nums2, p / x)\n                else:\n                    cnt += n * int(p >= 0)\n            return cnt\n\n        mx = max(abs(nums1[0]), abs(nums1[-1])) * max(abs(nums2[0]), abs(nums2[-1]))\n        return bisect_left(range(-mx, mx + 1), k, key=count) - mx\n", "class Solution:\n  def kthSmallestProduct(\n      self,\n      nums1: list[int],\n      nums2: list[int],\n      k: int,\n  ) -> int:\n    A1 = [-num for num in nums1 if num < 0][::-1]\n    A2 = [num for num in nums1 if num >= 0]\n    B1 = [-num for num in nums2 if num < 0][::-1]\n    B2 = [num for num in nums2 if num >= 0]\n\n    negCount = len(A1) * len(B2) + len(A2) * len(B1)\n\n    if k > negCount:  # Find the (k - negCount)-th positive.\n      k -= negCount\n      sign = 1\n    else:\n      k = negCount - k + 1  # Find the (negCount - k + 1)-th abs(negative).\n      sign = -1\n      B1, B2 = B2, B1\n\n    def numProductNoGreaterThan(A: list[int], B: list[int], m: int) -> int:\n      ans = 0\n      j = len(B) - 1\n      for i in range(len(A)):\n        # For each A[i], find the first index j s.t. A[i] * B[j] <= m\n        # So numProductNoGreaterThan m for this row will be j + 1\n        while j >= 0 and A[i] * B[j] > m:\n          j -= 1\n        ans += j + 1\n      return ans\n\n    l = 0\n    r = 10**10\n\n    while l < r:\n      m = (l + r) // 2\n      if (numProductNoGreaterThan(A1, B1, m) +\n              numProductNoGreaterThan(A2, B2, m) >= k):\n        r = m\n      else:\n        l = m + 1\n\n    return sign * l\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2032, "slug": "two-out-of-three", "solutions": ["class Solution:\n    def twoOutOfThree(\n        self, nums1: List[int], nums2: List[int], nums3: List[int]\n    ) -> List[int]:\n        s1, s2, s3 = set(nums1), set(nums2), set(nums3)\n        return [i for i in range(1, 101) if (i in s1) + (i in s2) + (i in s3) > 1]\n", "class Solution:\n  def twoOutOfThree(\n      self,\n      nums1: list[int],\n      nums2: list[int],\n      nums3: list[int],\n  ) -> list[int]:\n    count = collections.Counter()\n    for nums in nums1, nums2, nums3:\n      count.update(set(nums))\n    return [i for i, c in count.items() if c >= 2]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2058, "slug": "find-the-minimum-and-maximum-number-of-nodes-between-critical-points", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\n        ans = [inf, -inf]\n        first = last = -1\n        i = 0\n        while head.next.next:\n            a, b, c = head.val, head.next.val, head.next.next.val\n            if a > b < c or a < b > c:\n                if last == -1:\n                    first = last = i\n                else:\n                    ans[0] = min(ans[0], i - last)\n                    last = i\n                    ans[1] = max(ans[1], last - first)\n            i += 1\n            head = head.next\n        return [-1, -1] if first == last else ans\n", "class Solution:\n  def nodesBetweenCriticalPoints(self, head: ListNode | None) -> list[int]:\n    minDistance = math.inf\n    firstMaIndex = -1\n    prevMaIndex = -1\n    index = 1\n    prev = head  # Point to the index 0.\n    curr = head.next  # Point to the index 1.\n\n    while curr.next:\n      if (curr.val > prev.val and curr.val > curr.next.val or\n              curr.val < prev.val and curr.val < curr.next.val):\n        if firstMaIndex == -1:  # Only assign once.\n          firstMaIndex = index\n        if prevMaIndex != -1:\n          minDistance = min(minDistance, index - prevMaIndex)\n        prevMaIndex = index\n      prev = curr\n      curr = curr.next\n      index += 1\n\n    if minDistance == math.inf:\n      return [-1, -1]\n    return [minDistance, prevMaIndex - firstMaIndex]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2043, "slug": "simple-bank-system", "solutions": ["class Bank:\n    def __init__(self, balance: List[int]):\n        self.balance = balance\n        self.n = len(balance)\n\n    def transfer(self, account1: int, account2: int, money: int) -> bool:\n        if account1 > self.n or account2 > self.n or self.balance[account1 - 1] < money:\n            return False\n        self.balance[account1 - 1] -= money\n        self.balance[account2 - 1] += money\n        return True\n\n    def deposit(self, account: int, money: int) -> bool:\n        if account > self.n:\n            return False\n        self.balance[account - 1] += money\n        return True\n\n    def withdraw(self, account: int, money: int) -> bool:\n        if account > self.n or self.balance[account - 1] < money:\n            return False\n        self.balance[account - 1] -= money\n        return True\n\n\n# Your Bank object will be instantiated and called as such:\n# obj = Bank(balance)\n# param_1 = obj.transfer(account1,account2,money)\n# param_2 = obj.deposit(account,money)\n# param_3 = obj.withdraw(account,money)\n", "class Bank:\n  def __init__(self, balance: list[int]):\n    self.balance = balance\n\n  def transfer(self, account1: int, account2: int, money: int) -> bool:\n    if not self._isValid(account2):\n      return False\n    return self.withdraw(account1, money) and self.deposit(account2, money)\n\n  def deposit(self, account: int, money: int) -> bool:\n    if not self._isValid(account):\n      return False\n    self.balance[account - 1] += money\n    return True\n\n  def withdraw(self, account: int, money: int) -> bool:\n    if not self._isValid(account):\n      return False\n    if self.balance[account - 1] < money:\n      return False\n    self.balance[account - 1] -= money\n    return True\n\n  def _isValid(self, account: int) -> bool:\n    return 1 <= account <= len(self.balance)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2053, "slug": "kth-distinct-string-in-an-array", "solutions": ["class Solution:\n    def kthDistinct(self, arr: List[str], k: int) -> str:\n        cnt = Counter(arr)\n        for s in arr:\n            if cnt[s] == 1:\n                k -= 1\n                if k == 0:\n                    return s\n        return \"\"\n", "class Solution:\n  def kthDistinct(self, arr: list[str], k: int) -> str:\n    count = collections.Counter(arr)\n\n    for a in arr:\n      if count[a] == 1:\n        k -= 1\n        if k == 0:\n          return a\n\n    return ''\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2059, "slug": "minimum-operations-to-convert-number", "solutions": ["class Solution:\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\n        op1 = lambda x, y: x + y\n        op2 = lambda x, y: x - y\n        op3 = lambda x, y: x ^ y\n        ops = [op1, op2, op3]\n        vis = [False] * 1001\n        q = deque([(start, 0)])\n        while q:\n            x, step = q.popleft()\n            for num in nums:\n                for op in ops:\n                    nx = op(x, num)\n                    if nx == goal:\n                        return step + 1\n                    if 0 <= nx <= 1000 and not vis[nx]:\n                        q.append((nx, step + 1))\n                        vis[nx] = True\n        return -1\n", "class Solution:\n  def minimumOperations(self, nums: list[int], start: int, goal: int) -> int:\n    q = collections.deque([start])\n    seen = {start}\n\n    step = 1\n    while q:\n      for _ in range(len(q)):\n        x = q.popleft()\n        for num in nums:\n          for res in (x + num, x - num, x ^ num):\n            if res == goal:\n              return step\n            if res < 0 or res > 1000 or res in seen:\n              continue\n            seen.add(res)\n            q.append(res)\n      step += 1\n\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2097, "slug": "valid-arrangement-of-pairs", "solutions": ["class Solution:\n  def validArrangement(self, pairs: list[list[int]]) -> list[list[int]]:\n    ans = []\n    graph = collections.defaultdict(list)\n    outDegree = collections.Counter()\n    inDegrees = collections.Counter()\n\n    for start, end in pairs:\n      graph[start].append(end)\n      outDegree[start] += 1\n      inDegrees[end] += 1\n\n    def getStartNode() -> int:\n      for u in graph.keys():\n        if outDegree[u] - inDegrees[u] == 1:\n          return u\n      return pairs[0][0]  # Arbitrarily choose a node.\n\n    def euler(u: int) -> None:\n      stack = graph[u]\n      while stack:\n        v = stack.pop()\n        euler(v)\n        ans.append([u, v])\n\n    euler(getStartNode())\n    return ans[::-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2096, "slug": "step-by-step-directions-from-a-binary-tree-node-to-another", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\n\nclass Solution:\n    def getDirections(\n        self, root: Optional[TreeNode], startValue: int, destValue: int\n    ) -> str:\n        def lca(node: Optional[TreeNode], p: int, q: int):\n            if node is None or node.val in (p, q):\n                return node\n            left = lca(node.left, p, q)\n            right = lca(node.right, p, q)\n            if left and right:\n                return node\n            return left or right\n\n        def dfs(node: Optional[TreeNode], x: int, path: List[str]):\n            if node is None:\n                return False\n            if node.val == x:\n                return True\n            path.append(\"L\")\n            if dfs(node.left, x, path):\n                return True\n            path[-1] = \"R\"\n            if dfs(node.right, x, path):\n                return True\n            path.pop()\n            return False\n\n        node = lca(root, startValue, destValue)\n\n        path_to_start = []\n        path_to_dest = []\n\n        dfs(node, startValue, path_to_start)\n        dfs(node, destValue, path_to_dest)\n\n        return \"U\" * len(path_to_start) + \"\".join(path_to_dest)\n", "class Solution:\n  def getDirections(\n      self,\n      root: TreeNode | None,\n      startValue: int,\n      destValue: int,\n  ) -> str:\n    def dfs(root: TreeNode | None, val: int, path: list[str]) -> bool:\n      \"\"\"Builds the string in reverse order to avoid creating a new copy.\"\"\"\n      if root.val == val:\n        return True\n      if root.left and dfs(root.left, val, path):\n        path.append('L')\n      elif root.right and dfs(root.right, val, path):\n        path.append('R')\n      return len(path) > 0\n\n    pathToStart = []\n    pathToDest = []\n\n    dfs(root, startValue, pathToStart)\n    dfs(root, destValue, pathToDest)\n\n    while pathToStart and pathToDest and pathToStart[-1] == pathToDest[-1]:\n      pathToStart.pop()\n      pathToDest.pop()\n\n    return 'U' * len(pathToStart) + ''.join(reversed(pathToDest))\n", "class Solution:\n  def getDirections(\n      self,\n      root: TreeNode | None,\n      startValue: int,\n      destValue: int,\n  ) -> str:\n    def lca(root: TreeNode | None) -> TreeNode | None:\n      if not root or root.val in (startValue, destValue):\n        return root\n      left = lca(root.left)\n      right = lca(root.right)\n      if left and right:\n        return root\n      return left or right\n\n    def dfs(root: TreeNode | None, path: list[str]) -> None:\n      if not root:\n        return\n      if root.val == startValue:\n        self.pathToStart = ''.join(path)\n      if root.val == destValue:\n        self.pathToDest = ''.join(path)\n      path.append('L')\n      dfs(root.left, path)\n      path.pop()\n      path.append('R')\n      dfs(root.right, path)\n      path.pop()\n\n    dfs(lca(root), [])  # Only this subtree matters.\n    return 'U' * len(self.pathToStart) + ''.join(self.pathToDest)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2031, "slug": "count-subarrays-with-more-ones-than-zeros", "solutions": ["class BinaryIndexedTree:\n    __slots__ = [\"n\", \"c\"]\n\n    def __init__(self, n: int):\n        self.n = n\n        self.c = [0] * (n + 1)\n\n    def update(self, x: int, v: int):\n        while x <= self.n:\n            self.c[x] += v\n            x += x & -x\n\n    def query(self, x: int) -> int:\n        s = 0\n        while x:\n            s += self.c[x]\n            x -= x & -x\n        return s\n\n\nclass Solution:\n    def subarraysWithMoreZerosThanOnes(self, nums: List[int]) -> int:\n        n = len(nums)\n        base = n + 1\n        tree = BinaryIndexedTree(n + base)\n        tree.update(base, 1)\n        mod = 10**9 + 7\n        ans = s = 0\n        for x in nums:\n            s += x or -1\n            ans += tree.query(s - 1 + base)\n            ans %= mod\n            tree.update(s + base, 1)\n        return ans\n", "class FenwichTree:\n  def __init__(self, n: int):\n    self.n = n\n    self.sums = [0] * (2 * n + 1)\n\n  def add(self, i: int, delta: int) -> None:\n    i += self.n + 1  # re-mapping\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += i & -i\n\n  def get(self, i: int) -> int:\n    i += self.n + 1  # re-mapping\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= i & -i\n    return summ\n\n\nclass Solution:\n  def subarraysWithMoreZerosThanOnes(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    prefix = 0\n    tree = FenwichTree(len(nums))\n    tree.add(0, 1)\n\n    for num in nums:\n      prefix += -1 if num == 0 else 1\n      ans += tree.get(prefix - 1)\n      ans %= MOD\n      tree.add(prefix, 1)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2008, "slug": "maximum-earnings-from-taxi", "solutions": ["class Solution:\n    def maxTaxiEarnings(self, n: int, rides: List[List[int]]) -> int:\n        @cache\n        def dfs(i: int) -> int:\n            if i >= len(rides):\n                return 0\n            st, ed, tip = rides[i]\n            j = bisect_left(rides, ed, lo=i + 1, key=lambda x: x[0])\n            return max(dfs(i + 1), dfs(j) + ed - st + tip)\n\n        rides.sort()\n        return dfs(0)\n", "class Solution:\n  def maxTaxiEarnings(self, n: int, rides: list[list[int]]) -> int:\n    startToEndAndEarns = [[] for _ in range(n)]\n    # dp[i] := the maximum dollars you can earn starting at i\n    dp = [0] * (n + 1)\n\n    for start, end, tip in rides:\n      earn = end - start + tip\n      startToEndAndEarns[start].append((end, earn))\n\n    for i in range(n - 1, 0, -1):\n      dp[i] = dp[i + 1]\n      for end, earn in startToEndAndEarns[i]:\n        dp[i] = max(dp[i], dp[end] + earn)\n\n    return dp[1]\n", "class Solution:\n  def maxTaxiEarnings(self, n: int, rides: list[list[int]]) -> int:\n    endToStartAndEarns = [[] for _ in range(n + 1)]\n    # dp[i] := the maximum dollars you can earn starting at i\n    dp = [0] * (n + 1)\n\n    for start, end, tip in rides:\n      earn = end - start + tip\n      endToStartAndEarns[end].append((start, earn))\n\n    for i in range(1, n + 1):\n      dp[i] = dp[i - 1]\n      for start, earn in endToStartAndEarns[i]:\n        dp[i] = max(dp[i], dp[start] + earn)\n\n    return dp[n]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2026, "slug": "low-quality-problems", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2006, "slug": "count-number-of-pairs-with-absolute-difference-k", "solutions": ["class Solution:\n    def countKDifference(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        return sum(\n            abs(nums[i] - nums[j]) == k for i in range(n) for j in range(i + 1, n)\n        )\n", "class Solution:\n  def countKDifference(self, nums: list[int], k: int) -> int:\n    count = collections.Counter(nums)\n    return sum(count[i] * count[i - k] for i in range(k + 1, 101))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2088, "slug": "count-fertile-pyramids-in-a-land", "solutions": ["class Solution:\n    def countPyramids(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        f = [[0] * n for _ in range(m)]\n        ans = 0\n        for i in range(m - 1, -1, -1):\n            for j in range(n):\n                if grid[i][j] == 0:\n                    f[i][j] = -1\n                elif not (i == m - 1 or j == 0 or j == n - 1):\n                    f[i][j] = min(f[i + 1][j - 1], f[i + 1][j], f[i + 1][j + 1]) + 1\n                    ans += f[i][j]\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 0:\n                    f[i][j] = -1\n                elif i == 0 or j == 0 or j == n - 1:\n                    f[i][j] = 0\n                else:\n                    f[i][j] = min(f[i - 1][j - 1], f[i - 1][j], f[i - 1][j + 1]) + 1\n                    ans += f[i][j]\n        return ans\n", "class Solution:\n  def countPyramids(self, grid: list[list[int]]) -> int:\n    # dp[i][j] := the maximum height of the pyramid for which it is the apex\n    def count(dp: list[list[int]]) -> int:\n      ans = 0\n      for i in range(len(dp) - 2, -1, -1):\n        for j in range(1, len(dp[0]) - 1):\n          if dp[i][j] == 1:\n            dp[i][j] = min(dp[i + 1][j - 1],\n                           dp[i + 1][j],\n                           dp[i + 1][j + 1]) + 1\n            ans += dp[i][j] - 1\n      return ans\n\n    return count(deepcopy(grid)[::-1]) + count(grid)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2015, "slug": "average-height-of-buildings-in-each-segment", "solutions": ["class Solution:\n    def averageHeightOfBuildings(self, buildings: List[List[int]]) -> List[List[int]]:\n        cnt = defaultdict(int)\n        d = defaultdict(int)\n        for start, end, height in buildings:\n            cnt[start] += 1\n            cnt[end] -= 1\n            d[start] += height\n            d[end] -= height\n        s = m = 0\n        last = -1\n        ans = []\n        for k, v in sorted(d.items()):\n            if m:\n                avg = s // m\n                if ans and ans[-1][2] == avg and ans[-1][1] == last:\n                    ans[-1][1] = k\n                else:\n                    ans.append([last, k, avg])\n            s += v\n            m += cnt[k]\n            last = k\n        return ans\n", "class Solution:\n  def averageHeightOfBuildings(self, buildings: list[list[int]]) -> list[list[int]]:\n    ans = []\n    events = []\n\n    for start, end, height in buildings:\n      events.append((start, height))\n      events.append((end, -height))\n\n    prev = 0\n    count = 0\n    sumHeight = 0\n\n    for curr, height in sorted(events):\n      if sumHeight > 0 and curr > prev:\n        avgHeight = sumHeight // count\n        if ans and ans[-1][1] == prev and avgHeight == ans[-1][2]:\n          ans[-1][1] = curr\n        else:\n          ans.append([prev, curr, avgHeight])\n      sumHeight += height\n      count += 1 if height > 0 else -1\n      prev = curr\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2019, "slug": "the-score-of-students-solving-math-expression", "solutions": ["class Solution:\n    def scoreOfStudents(self, s: str, answers: List[int]) -> int:\n        def cal(s: str) -> int:\n            res, pre = 0, int(s[0])\n            for i in range(1, n, 2):\n                if s[i] == \"*\":\n                    pre *= int(s[i + 1])\n                else:\n                    res += pre\n                    pre = int(s[i + 1])\n            res += pre\n            return res\n\n        n = len(s)\n        x = cal(s)\n        m = (n + 1) >> 1\n        f = [[set() for _ in range(m)] for _ in range(m)]\n        for i in range(m):\n            f[i][i] = {int(s[i << 1])}\n        for i in range(m - 1, -1, -1):\n            for j in range(i, m):\n                for k in range(i, j):\n                    for l in f[i][k]:\n                        for r in f[k + 1][j]:\n                            if s[k << 1 | 1] == \"+\" and l + r <= 1000:\n                                f[i][j].add(l + r)\n                            elif s[k << 1 | 1] == \"*\" and l * r <= 1000:\n                                f[i][j].add(l * r)\n        cnt = Counter(answers)\n        ans = cnt[x] * 5\n        for k, v in cnt.items():\n            if k != x and k in f[0][m - 1]:\n                ans += v << 1\n        return ans\n", "class Solution:\n  def scoreOfStudents(self, s: str, answers: list[int]) -> int:\n    n = len(s) // 2 + 1\n    ans = 0\n    func = {'+': operator.add, '*': operator.mul}\n    dp = [[set() for j in range(n)] for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i].add(int(s[i * 2]))\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        for k in range(i, j):\n          op = s[k * 2 + 1]\n          for a in dp[i][k]:\n            for b in dp[k + 1][j]:\n              res = func[op](a, b)\n              if res <= 1000:\n                dp[i][j].add(res)\n\n    correctAnswer = eval(s)\n\n    for answer, freq in collections.Counter(answers).items():\n      if answer == correctAnswer:\n        ans += 5 * freq\n      elif answer in dp[0][n - 1]:\n        ans += 2 * freq\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2075, "slug": "decode-the-slanted-ciphertext", "solutions": ["class Solution:\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\n        ans = []\n        cols = len(encodedText) // rows\n        for j in range(cols):\n            x, y = 0, j\n            while x < rows and y < cols:\n                ans.append(encodedText[x * cols + y])\n                x, y = x + 1, y + 1\n        return ''.join(ans).rstrip()\n", "class Solution:\n  def decodeCiphertext(self, encodedText: str, rows: int) -> str:\n    n = len(encodedText)\n    cols = n // rows\n\n    ans = []\n    matrix = [[' '] * cols for _ in range(rows)]\n\n    for i in range(rows):\n      for j in range(cols):\n        matrix[i][j] = encodedText[i * cols + j]\n\n    for col in range(cols):\n      i = 0\n      j = col\n      while i < rows and j < cols:\n        ans.append(matrix[i][j])\n        i += 1\n        j += 1\n\n    return ''.join(ans).rstrip()\n", "class Solution:\n  def decodeCiphertext(self, encodedText: str, rows: int) -> str:\n    n = len(encodedText)\n    cols = n // rows\n\n    ans = []\n\n    for j in range(cols):\n      for i in range(j, n, cols + 1):\n        ans.append(encodedText[i])\n\n    return ''.join(ans).rstrip()\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2085, "slug": "count-common-words-with-one-occurrence", "solutions": ["class Solution:\n    def countWords(self, words1: List[str], words2: List[str]) -> int:\n        cnt1 = Counter(words1)\n        cnt2 = Counter(words2)\n        return sum(v == 1 and cnt2[w] == 1 for w, v in cnt1.items())\n", "class Solution:\n  def countWords(self, words1: list[str], words2: list[str]) -> int:\n    count = collections.Counter(words1)\n\n    for word in words2:\n      if word in count and count[word] < 2:\n        count[word] -= 1\n\n    return sum(value == 0 for value in count.values())\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2067, "slug": "number-of-equal-count-substrings", "solutions": ["class Solution:\n    def equalCountSubstrings(self, s: str, count: int) -> int:\n        ans = 0\n        for i in range(1, 27):\n            k = i * count\n            if k > len(s):\n                break\n            cnt = Counter()\n            t = 0\n            for j, c in enumerate(s):\n                cnt[c] += 1\n                t += cnt[c] == count\n                t -= cnt[c] == count + 1\n                if j >= k:\n                    cnt[s[j - k]] -= 1\n                    t += cnt[s[j - k]] == count\n                    t -= cnt[s[j - k]] == count - 1\n                ans += i == t\n        return ans\n", "class Solution:\n  def equalCountSubstrings(self, s: str, count: int) -> int:\n    maxUnique = len(set(s))\n    ans = 0\n\n    for unique in range(1, maxUnique + 1):\n      windowSize = unique * count\n      lettersCount = collections.Counter()\n      uniqueCount = 0\n      for i, c in enumerate(s):\n        lettersCount[c] += 1\n        if lettersCount[c] == count:\n          uniqueCount += 1\n        if i >= windowSize:\n          lettersCount[s[i - windowSize]] -= 1\n          if lettersCount[s[i - windowSize]] == count - 1:\n            uniqueCount -= 1\n        ans += uniqueCount == unique\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2089, "slug": "find-target-indices-after-sorting-array", "solutions": ["class Solution:\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\n        nums.sort()\n        return [i for i, v in enumerate(nums) if v == target]\n", "class Solution:\n  def targetIndices(self, nums: list[int], target: int) -> list[int]:\n    count = nums.count(target)\n    lessThan = sum(num < target for num in nums)\n    return [i for i in range(lessThan, lessThan + count)]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2007, "slug": "find-original-array-from-doubled-array", "solutions": ["class Solution:\n    def findOriginalArray(self, changed: List[int]) -> List[int]:\n        changed.sort()\n        cnt = Counter(changed)\n        ans = []\n        for x in changed:\n            if cnt[x] == 0:\n                continue\n            cnt[x] -= 1\n            if cnt[x << 1] <= 0:\n                return []\n            cnt[x << 1] -= 1\n            ans.append(x)\n        return ans\n", "class Solution:\n  def findOriginalArray(self, changed: list[int]) -> list[int]:\n    ans = []\n    q = collections.deque()\n\n    for num in sorted(changed):\n      if q and num == q[0]:\n        q.popleft()\n      else:\n        q.append(num * 2)\n        ans.append(num)\n\n    return [] if q else ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2084, "slug": "drop-type-1-orders-for-customers-with-type-0-orders", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2051, "slug": "the-category-of-each-member-in-the-store", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2030, "slug": "smallest-k-length-subsequence-with-occurrences-of-a-letter", "solutions": ["class Solution:\n  def smallestSubsequence(\n      self,\n      s: str,\n      k: int,\n      letter: str,\n      repetition: int,\n  ) -> str:\n    stack = []  # running string\n    required = repetition\n    nLetters = s.count(letter)\n\n    for i, c in enumerate(s):\n      # Make sure the length is sufficient:\n      # Len(stack) := the length of running string\n      # Len(s) - i := the length of remain chars\n      # -1 := we're going to pop a char\n      while (stack and stack[-1] > c\n              and len(stack) + len(s) - i - 1 >= k\n              and (stack[-1] != letter or nLetters > required)):\n        if stack.pop() == letter:\n          required += 1\n      if len(stack) < k:\n        if c == letter:\n          stack.append(c)\n          required -= 1\n        elif k - len(stack) > required:\n          stack.append(c)\n      if c == letter:\n        nLetters -= 1\n\n    return ''.join(stack)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2003, "slug": "smallest-missing-genetic-value-in-each-subtree", "solutions": ["class Solution:\n    def smallestMissingValueSubtree(\n        self, parents: List[int], nums: List[int]\n    ) -> List[int]:\n        def dfs(i: int):\n            if vis[i]:\n                return\n            vis[i] = True\n            if nums[i] < len(has):\n                has[nums[i]] = True\n            for j in g[i]:\n                dfs(j)\n\n        n = len(nums)\n        ans = [1] * n\n        g = [[] for _ in range(n)]\n        idx = -1\n        for i, p in enumerate(parents):\n            if i:\n                g[p].append(i)\n            if nums[i] == 1:\n                idx = i\n        if idx == -1:\n            return ans\n        vis = [False] * n\n        has = [False] * (n + 2)\n        i = 2\n        while idx != -1:\n            dfs(idx)\n            while has[i]:\n                i += 1\n            ans[idx] = i\n            idx = parents[idx]\n        return ans\n", "class Solution:\n  def smallestMissingValueSubtree(\n      self,\n      parents: list[int],\n      nums: list[int],\n  ) -> list[int]:\n    n = len(parents)\n    ans = [1] * n\n    tree = [[] for _ in range(n)]\n    seen = set()\n    minMiss = 1\n\n    for i in range(1, n):\n      tree[parents[i]].append(i)\n\n    def getNode(nums: list[int]) -> int:\n      for i, num in enumerate(nums):\n        if num == 1:\n          return i\n      return -1\n\n    nodeThatsOne = getNode(nums)\n    if nodeThatsOne == -1:\n      return ans\n\n    u = nodeThatsOne\n    prev = -1  # the u that just handled\n\n    def dfs(u: int) -> None:\n      seen.add(nums[u])\n      for v in tree[u]:\n        dfs(v)\n\n    # Upward from `nodeThatsOne` to the root `u`.\n    while u != -1:\n      for v in tree[u]:\n        if v != prev:\n          dfs(v)\n      seen.add(nums[u])\n      while minMiss in seen:\n        minMiss += 1\n      ans[u] = minMiss\n      prev = u\n      u = parents[u]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2081, "slug": "sum-of-k-mirror-numbers", "solutions": ["class Solution:\n  def kMirror(self, k: int, n: int) -> int:\n    ans = 0\n    A = ['0']\n\n    def nextKMirror(A: list[str]) -> list[str]:\n      for i in range(len(A) // 2, len(A)):\n        nextNum = int(A[i]) + 1\n        if nextNum < k:\n          A[i] = str(nextNum)\n          A[~i] = str(nextNum)\n          for j in range(len(A) // 2, i):\n            A[j] = '0'\n            A[~j] = '0'\n          return A\n      return ['1'] + ['0'] * (len(A) - 1) + ['1']\n\n    for _ in range(n):\n      while True:\n        A = nextKMirror(A)\n        num = int(''.join(A), k)\n        if str(num)[::-1] == str(num):\n          break\n      ans += num\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2079, "slug": "watering-plants", "solutions": ["class Solution:\n    def wateringPlants(self, plants: List[int], capacity: int) -> int:\n        ans, water = 0, capacity\n        for i, p in enumerate(plants):\n            if water >= p:\n                water -= p\n                ans += 1\n            else:\n                water = capacity - p\n                ans += i * 2 + 1\n        return ans\n", "class Solution:\n  def wateringPlants(self, plants: list[int], capacity: int) -> int:\n    ans = 0\n    currCapacity = 0\n\n    for i, plant in enumerate(plants):\n      if currCapacity + plant <= capacity:\n        currCapacity += plant\n      else:\n        currCapacity = plant  # Reset\n        ans += i * 2\n\n    return ans + len(plants)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2052, "slug": "minimum-cost-to-separate-sentence-into-rows", "solutions": ["class Solution:\n    def minimumCost(self, sentence: str, k: int) -> int:\n        @cache\n        def dfs(i: int) -> int:\n            if s[n] - s[i] + n - i - 1 <= k:\n                return 0\n            ans = inf\n            j = i + 1\n            while j < n and (m := s[j] - s[i] + j - i - 1) <= k:\n                ans = min(ans, dfs(j) + (k - m) ** 2)\n                j += 1\n            return ans\n\n        nums = [len(s) for s in sentence.split()]\n        n = len(nums)\n        s = list(accumulate(nums, initial=0))\n        return dfs(0)\n", "class Solution:\n  def minimumCost(self, sentence: str, k: int) -> int:\n    if len(sentence) <= k:\n      return 0\n\n    words = sentence.split()\n\n    # dp[i] := the minimum cost of the first i words\n    dp = [0] * (len(words) + 1)\n\n    for i in range(1, len(words) + 1):\n      n = len(words[i - 1])  # the length of the current row\n      dp[i] = dp[i - 1] + (k - n)**2\n      # Gradually add words[j - 1], words[j - 2], ....\n      for j in range(i - 1, 0, -1):\n        n += len(words[j - 1]) + 1\n        if n > k:\n          break\n        dp[i] = min(dp[i], dp[j - 1] + (k - n)**2)\n\n    lastRowLen = len(words[-1])\n    i = len(words) - 2  # Greedily put words into last row\n\n    while i > 0 and lastRowLen + len(words[i]) + 1 <= k:\n      lastRowLen += len(words[i]) + 1\n      i -= 1\n\n    return min(dp[i + 1:len(words)])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2065, "slug": "maximum-path-quality-of-a-graph", "solutions": ["class Solution:\n    def maximalPathQuality(\n        self, values: List[int], edges: List[List[int]], maxTime: int\n    ) -> int:\n        def dfs(u: int, cost: int, value: int):\n            if u == 0:\n                nonlocal ans\n                ans = max(ans, value)\n            for v, t in g[u]:\n                if cost + t <= maxTime:\n                    if vis[v]:\n                        dfs(v, cost + t, value)\n                    else:\n                        vis[v] = True\n                        dfs(v, cost + t, value + values[v])\n                        vis[v] = False\n\n        n = len(values)\n        g = [[] for _ in range(n)]\n        for u, v, t in edges:\n            g[u].append((v, t))\n            g[v].append((u, t))\n        vis = [False] * n\n        vis[0] = True\n        ans = 0\n        dfs(0, 0, values[0])\n        return ans\n", "class Solution:\n  def maximalPathQuality(\n      self,\n      values: list[int],\n      edges: list[list[int]],\n      maxTime: int,\n  ) -> int:\n    ans = 0\n    graph = [[] for _ in range(len(values))]\n    # (node, quality, remainingTime, seen)\n    q = collections.deque([(0, values[0], maxTime, {0})])\n\n    for u, v, time in edges:\n      graph[u].append((v, time))\n      graph[v].append((u, time))\n\n    while q:\n      u, quality, remainingTime, seen = q.popleft()\n      if u == 0:\n        ans = max(ans, quality)\n      for v, time in graph[u]:\n        if time <= remainingTime:\n          q.append(\n              (v, quality + values[v] * (v not in seen),\n               remainingTime - time, seen | set([v])))\n\n    return ans\n", "class Solution:\n  def maximalPathQuality(\n      self,\n      values: list[int],\n      edges: list[list[int]],\n      maxTime: int,\n  ) -> int:\n    n = len(values)\n    ans = 0\n    graph = [[] for _ in range(n)]\n    seen = [0] * n\n    seen[0] = 1\n\n    for u, v, time in edges:\n      graph[u].append((v, time))\n      graph[v].append((u, time))\n\n    def dfs(u: int, quality: int, remainingTime: int):\n      nonlocal ans\n      if u == 0:\n        ans = max(ans, quality)\n      for v, time in graph[u]:\n        if time > remainingTime:\n          continue\n        newQuality = quality + values[v] * (seen[v] == 0)\n        seen[v] += 1\n        dfs(v, newQuality, remainingTime - time)\n        seen[v] -= 1\n\n    dfs(0, values[0], maxTime)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2036, "slug": "maximum-alternating-subarray-sum", "solutions": ["class Solution:\n    def maximumAlternatingSubarraySum(self, nums: List[int]) -> int:\n        ans = f = g = -inf\n        for x in nums:\n            f, g = max(g, 0) + x, f - x\n            ans = max(ans, f, g)\n        return ans\n", "class Solution:\n  def maximumAlternatingSubarraySum(self, nums: list[int]) -> int:\n    ans = -math.inf\n    even = 0  # the subarray sum starting from an even index\n    odd = 0  # the subarray sum starting from an odd index\n\n    for i in range(len(nums)):\n      if i % 2 == 0:  # Must pick.\n        even += nums[i]\n      else:  # Start a fresh subarray or subtract `nums[i]`.\n        even = max(0, even - nums[i])\n      ans = max(ans, even)\n\n    for i in range(1, len(nums)):\n      if i % 2 == 1:  # Must pick.\n        odd += nums[i]\n      else:  # Start a fresh subarray or subtract `nums[i]`.\n        odd = max(0, odd - nums[i])\n      ans = max(ans, odd)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2033, "slug": "minimum-operations-to-make-a-uni-value-grid", "solutions": ["class Solution:\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\n        nums = []\n        mod = grid[0][0] % x\n        for row in grid:\n            for v in row:\n                if v % x != mod:\n                    return -1\n                nums.append(v)\n        nums.sort()\n        mid = nums[len(nums) >> 1]\n        return sum(abs(v - mid) // x for v in nums)\n", "class Solution:\n  def minOperations(self, grid: list[list[int]], x: int) -> int:\n    arr = sorted([a for row in grid for a in row])\n    if any((a - arr[0]) % x for a in arr):\n      return -1\n\n    ans = 0\n\n    for a in arr:\n      ans += abs(a - arr[len(arr) // 2]) // x\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2039, "slug": "the-time-when-the-network-becomes-idle", "solutions": ["class Solution:\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\n        g = defaultdict(list)\n        for u, v in edges:\n            g[u].append(v)\n            g[v].append(u)\n        q = deque([0])\n        vis = {0}\n        ans = d = 0\n        while q:\n            d += 1\n            t = d * 2\n            for _ in range(len(q)):\n                u = q.popleft()\n                for v in g[u]:\n                    if v not in vis:\n                        vis.add(v)\n                        q.append(v)\n                        ans = max(ans, (t - 1) // patience[v] * patience[v] + t + 1)\n        return ans\n", "class Solution:\n  def networkBecomesIdle(\n      self,\n      edges: list[list[int]],\n      patience: list[int],\n  ) -> int:\n    n = len(patience)\n    ans = 0\n    graph = [[] for _ in range(n)]\n    q = collections.deque([0])\n    dist = [math.inf] * n  # dist[i] := the distance between i and 0\n    dist[0] = 0\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    while q:\n      for _ in range(len(q)):\n        u = q.popleft()\n        for v in graph[u]:\n          if dist[v] == math.inf:\n            dist[v] = dist[u] + 1\n            q.append(v)\n\n    for i in range(1, n):\n      numResending = (dist[i] * 2 - 1) // patience[i]\n      lastResendingTime = patience[i] * numResending\n      lastArrivingTime = lastResendingTime + dist[i] * 2\n      ans = max(ans, lastArrivingTime)\n\n    return ans + 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2028, "slug": "find-missing-observations", "solutions": ["class Solution:\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\n        m = len(rolls)\n        s = (n + m) * mean - sum(rolls)\n        if s > n * 6 or s < n:\n            return []\n        ans = [s // n] * n\n        for i in range(s % n):\n            ans[i] += 1\n        return ans\n", "class Solution:\n  def missingRolls(self, rolls: list[int], mean: int, n: int) -> list[int]:\n    targetSum = (len(rolls) + n) * mean\n    missingSum = targetSum - sum(rolls)\n    if missingSum > n * 6 or missingSum < n:\n      return []\n\n    ans = [missingSum // n] * n\n    for i in range(missingSum % n):\n      ans[i] += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2077, "slug": "paths-in-maze-that-lead-to-same-room", "solutions": ["class Solution:\n    def numberOfPaths(self, n: int, corridors: List[List[int]]) -> int:\n        g = defaultdict(set)\n        for a, b in corridors:\n            g[a].add(b)\n            g[b].add(a)\n        ans = 0\n        for i in range(1, n + 1):\n            for j, k in combinations(g[i], 2):\n                if j in g[k]:\n                    ans += 1\n        return ans // 3\n", "class Solution:\n  def numberOfPaths(self, n: int, corridors: list[list[int]]) -> int:\n    ans = 0\n    graph = [[False] * 1001 for _ in range(n + 1)]\n\n    for u, v in corridors:\n      graph[u][v] = True\n      graph[v][u] = True\n\n    for u, v in corridors:\n      for i in range(1, n + 1):\n        if graph[u][i] and graph[i][v]:\n          ans += 1\n\n    return ans // 3\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2069, "slug": "walking-robot-simulation-ii", "solutions": ["class Robot:\n  def __init__(self, width: int, height: int):\n    self.isOrigin = True\n    self.i = 0\n    self.pos = ([((0, 0), 'South')] +\n                [((i, 0), 'East') for i in range(1, width)] +\n                [((width - 1, j), 'North') for j in range(1, height)] +\n                [((i, height - 1), 'West') for i in range(width - 2, -1, -1)] +\n                [((0, j), 'South') for j in range(height - 2, 0, -1)])\n\n  def step(self, num: int) -> None:\n    self.isOrigin = False\n    self.i = (self.i + num) % len(self.pos)\n\n  def getPos(self) -> list[int]:\n    return self.pos[self.i][0]\n\n  def getDir(self) -> str:\n    return 'East' if self.isOrigin else self.pos[self.i][1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2091, "slug": "removing-minimum-and-maximum-from-array", "solutions": ["class Solution:\n    def minimumDeletions(self, nums: List[int]) -> int:\n        mi = mx = 0\n        for i, num in enumerate(nums):\n            if num < nums[mi]:\n                mi = i\n            if num > nums[mx]:\n                mx = i\n        if mi > mx:\n            mi, mx = mx, mi\n        return min(mx + 1, len(nums) - mi, mi + 1 + len(nums) - mx)\n", "class Solution:\n  def minimumDeletions(self, nums: list[int]) -> int:\n    n = len(nums)\n    a = nums.index(min(nums))\n    b = nums.index(max(nums))\n    if a > b:\n      a, b = b, a\n    return min(a + 1 + n - b, b + 1, n - a)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2076, "slug": "process-restricted-friend-requests", "solutions": ["class Solution:\n    def friendRequests(\n        self, n: int, restrictions: List[List[int]], requests: List[List[int]]\n    ) -> List[bool]:\n        def find(x: int) -> int:\n            if p[x] != x:\n                p[x] = find(p[x])\n            return p[x]\n\n        p = list(range(n))\n        ans = []\n        for u, v in requests:\n            pu, pv = find(u), find(v)\n            if pu == pv:\n                ans.append(True)\n            else:\n                ok = True\n                for x, y in restrictions:\n                    px, py = find(x), find(y)\n                    if (pu == px and pv == py) or (pu == py and pv == px):\n                        ok = False\n                        break\n                ans.append(ok)\n                if ok:\n                    p[pu] = pv\n        return ans\n", "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def friendRequests(\n      self,\n      n: int,\n      restrictions: list[list[int]],\n      requests: list[list[int]],\n  ) -> list[bool]:\n    ans = []\n    uf = UnionFind(n)\n\n    for u, v in requests:\n      pu = uf.find(u)\n      pv = uf.find(v)\n      isValid = True\n      if pu != pv:\n        for x, y in restrictions:\n          px = uf.find(x)\n          py = uf.find(y)\n          if (pu, pv) in [(px, py), (py, px)]:\n            isValid = False\n            break\n      ans.append(isValid)\n      if isValid:\n        uf.unionByRank(pu, pv)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2061, "slug": "number-of-spaces-cleaning-robot-cleaned", "solutions": ["class Solution:\n    def numberOfCleanRooms(self, room: List[List[int]]) -> int:\n        def dfs(i, j, k):\n            if (i, j, k) in vis:\n                return\n            nonlocal ans\n            ans += room[i][j] == 0\n            room[i][j] = -1\n            vis.add((i, j, k))\n            x, y = i + dirs[k], j + dirs[k + 1]\n            if 0 <= x < len(room) and 0 <= y < len(room[0]) and room[x][y] != 1:\n                dfs(x, y, k)\n            else:\n                dfs(i, j, (k + 1) % 4)\n\n        vis = set()\n        dirs = (0, 1, 0, -1, 0)\n        ans = 0\n        dfs(0, 0, 0)\n        return ans\n", "class Solution:\n  def numberOfCleanRooms(self, room: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(room)\n    n = len(room[0])\n    ans = 1\n    i = 0\n    j = 0\n    state = 0  # 0 := right, 1 := down, 2 := left, 3 := up\n    seen = {(i, j, state)}\n    room[i][j] = 2  # 2 := cleaned\n\n    while True:\n      x = i + DIRS[state][0]\n      y = j + DIRS[state][1]\n      if x < 0 or x == m or y < 0 or y == n or room[x][y] == 1:\n        # Turn 90 degrees clockwise.\n        state = (state + 1) % 4\n      else:\n        # Walk to (x, y).\n        if room[x][y] == 0:\n          ans += 1\n          room[x][y] = 2\n        i = x\n        j = y\n      if (x, y, state) in seen:\n        return ans\n      seen.add((x, y, state))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2034, "slug": "stock-price-fluctuation", "solutions": ["class StockPrice:\n    def __init__(self):\n        self.d = {}\n        self.ls = SortedList()\n        self.last = 0\n\n    def update(self, timestamp: int, price: int) -> None:\n        if timestamp in self.d:\n            self.ls.remove(self.d[timestamp])\n        self.d[timestamp] = price\n        self.ls.add(price)\n        self.last = max(self.last, timestamp)\n\n    def current(self) -> int:\n        return self.d[self.last]\n\n    def maximum(self) -> int:\n        return self.ls[-1]\n\n    def minimum(self) -> int:\n        return self.ls[0]\n\n\n# Your StockPrice object will be instantiated and called as such:\n# obj = StockPrice()\n# obj.update(timestamp,price)\n# param_2 = obj.current()\n# param_3 = obj.maximum()\n# param_4 = obj.minimum()\n", "from sortedcontainers import SortedDict\n\n\nclass StockPrice:\n  def __init__(self):\n    self.timestampToPrice = SortedDict()\n    self.pricesCount = SortedDict()\n\n  def update(self, timestamp: int, price: int) -> None:\n    if timestamp in self.timestampToPrice:\n      prevPrice = self.timestampToPrice[timestamp]\n      self.pricesCount[prevPrice] -= 1\n      if self.pricesCount[prevPrice] == 0:\n        del self.pricesCount[prevPrice]\n    self.timestampToPrice[timestamp] = price\n    self.pricesCount[price] = self.pricesCount.get(price, 0) + 1\n\n  def current(self) -> int:\n    return self.timestampToPrice.peekitem(-1)[1]\n\n  def maximum(self) -> int:\n    return self.pricesCount.peekitem(-1)[0]\n\n  def minimum(self) -> int:\n    return self.pricesCount.peekitem(0)[0]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2038, "slug": "remove-colored-pieces-if-both-neighbors-are-the-same-color", "solutions": ["class Solution:\n    def winnerOfGame(self, colors: str) -> bool:\n        a = b = 0\n        for c, v in groupby(colors):\n            m = len(list(v)) - 2\n            if m > 0 and c == 'A':\n                a += m\n            elif m > 0 and c == 'B':\n                b += m\n        return a > b\n", "class Solution:\n  def winnerOfGame(self, colors: str) -> bool:\n    countAAA = 0\n    countBBB = 0\n\n    for a, b, c in zip(colors, colors[1:], colors[2:]):\n      if 'A' == a == b == c:\n        countAAA += 1\n      elif 'B' == a == b == c:\n        countBBB += 1\n\n    return countAAA > countBBB\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2056, "slug": "number-of-valid-move-combinations-on-chessboard", "solutions": ["rook_dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\nbishop_dirs = [(1, 1), (1, -1), (-1, 1), (-1, -1)]\nqueue_dirs = rook_dirs + bishop_dirs\n\n\ndef get_dirs(piece: str) -> List[Tuple[int, int]]:\n    match piece[0]:\n        case \"r\":\n            return rook_dirs\n        case \"b\":\n            return bishop_dirs\n        case _:\n            return queue_dirs\n\n\nclass Solution:\n    def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:\n        def check_stop(i: int, x: int, y: int, t: int) -> bool:\n            return all(dist[j][x][y] < t for j in range(i))\n\n        def check_pass(i: int, x: int, y: int, t: int) -> bool:\n            for j in range(i):\n                if dist[j][x][y] == t:\n                    return False\n                if end[j][0] == x and end[j][1] == y and end[j][2] <= t:\n                    return False\n            return True\n\n        def dfs(i: int) -> None:\n            if i >= n:\n                nonlocal ans\n                ans += 1\n                return\n            x, y = positions[i]\n            dist[i][:] = [[-1] * m for _ in range(m)]\n            dist[i][x][y] = 0\n            end[i] = (x, y, 0)\n            if check_stop(i, x, y, 0):\n                dfs(i + 1)\n            dirs = get_dirs(pieces[i])\n            for dx, dy in dirs:\n                dist[i][:] = [[-1] * m for _ in range(m)]\n                dist[i][x][y] = 0\n                nx, ny, nt = x + dx, y + dy, 1\n                while 1 <= nx < m and 1 <= ny < m and check_pass(i, nx, ny, nt):\n                    dist[i][nx][ny] = nt\n                    end[i] = (nx, ny, nt)\n                    if check_stop(i, nx, ny, nt):\n                        dfs(i + 1)\n                    nx += dx\n                    ny += dy\n                    nt += 1\n\n        n = len(pieces)\n        m = 9\n        dist = [[[-1] * m for _ in range(m)] for _ in range(n)]\n        end = [(0, 0, 0) for _ in range(n)]\n        ans = 0\n        dfs(0)\n        return ans\n", "class Solution:\n  def countCombinations(\n      self,\n      pieces: list[str],\n      positions: list[list[int]],\n  ) -> int:\n    n = len(pieces)\n    moves = {\"rook\": [(1, 0), (-1, 0), (0, 1), (0, -1)],\n             \"bishop\": [(1, 1), (1, -1), (-1, 1), (-1, -1)],\n             \"queen\": [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1)]}\n    hashedBoards = set()\n\n    def getHash(board: list[list[int]]) -> Tuple:\n      return tuple([tuple(pos) for pos in board])\n\n    def dfs(\n        board: list[list[int]],\n        pieceMoves: list[tuple[int, int]],\n        activeMask: int,\n    ) -> None:\n      \"\"\"Performs a depth-first search to explore all possible board states.\"\"\"\n      if activeMask == 0:\n        return\n      hashedBoards.add(getHash(board))\n\n      for nextActiveMask in range(1, 1 << n):\n        if activeMask & nextActiveMask != nextActiveMask:\n          continue\n\n        # Copy the board.\n        nextBoard = [pos.copy() for pos in board]\n\n        # Move the pieces that are active in this turn.\n        for i in range(n):\n          if nextActiveMask >> i & 1:\n            nextBoard[i][0] += pieceMoves[i][0]\n            nextBoard[i][1] += pieceMoves[i][1]\n\n        # No two or more pieces occupy the same square.\n        if len(set(getHash(nextBoard))) < n:\n          continue\n\n        # Every piece needs to be in the boundary.\n        if all(1 <= x <= 8 and 1 <= y <= 8 for x, y in nextBoard):\n          dfs(nextBoard, pieceMoves, nextActiveMask)\n\n    for pieceMoves in itertools.product(*(moves[piece] for piece in pieces)):\n      dfs(positions, pieceMoves, (1 << n) - 1)\n\n    return len(hashedBoards)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2002, "slug": "maximum-product-of-the-length-of-two-palindromic-subsequences", "solutions": ["class Solution:\n    def maxProduct(self, s: str) -> int:\n        n = len(s)\n        p = [True] * (1 << n)\n        for k in range(1, 1 << n):\n            i, j = 0, n - 1\n            while i < j:\n                while i < j and (k >> i & 1) == 0:\n                    i += 1\n                while i < j and (k >> j & 1) == 0:\n                    j -= 1\n                if i < j and s[i] != s[j]:\n                    p[k] = False\n                    break\n                i, j = i + 1, j - 1\n        ans = 0\n        for i in range(1, 1 << n):\n            if p[i]:\n                mx = ((1 << n) - 1) ^ i\n                j = mx\n                a = i.bit_count()\n                while j:\n                    if p[j]:\n                        b = j.bit_count()\n                        ans = max(ans, a * b)\n                    j = (j - 1) & mx\n        return ans\n", "class Solution:\n  def maxProduct(self, s: str) -> int:\n    ans = 0\n\n    def isPalindrome(s: str) -> bool:\n      i = 0\n      j = len(s) - 1\n      while i < j:\n        if s[i] != s[j]:\n          return False\n        i += 1\n        j -= 1\n      return True\n\n    @functools.lru_cache(None)\n    def dfs(i: int, s1: str, s2: str) -> None:\n      nonlocal ans\n      if i == len(s):\n        if isPalindrome(s1) and isPalindrome(s2):\n          ans = max(ans, len(s1) * len(s2))\n        return\n\n      dfs(i + 1, s1 + s[i], s2)\n      dfs(i + 1, s1, s2 + s[i])\n      dfs(i + 1, s1, s2)\n\n    dfs(0, '', '')\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2055, "slug": "plates-between-candles", "solutions": ["class Solution:\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        presum = [0] * (n + 1)\n        for i, c in enumerate(s):\n            presum[i + 1] = presum[i] + (c == '*')\n\n        left, right = [0] * n, [0] * n\n        l = r = -1\n        for i, c in enumerate(s):\n            if c == '|':\n                l = i\n            left[i] = l\n        for i in range(n - 1, -1, -1):\n            if s[i] == '|':\n                r = i\n            right[i] = r\n\n        ans = [0] * len(queries)\n        for k, (l, r) in enumerate(queries):\n            i, j = right[l], left[r]\n            if i >= 0 and j >= 0 and i < j:\n                ans[k] = presum[j] - presum[i + 1]\n        return ans\n", "class Solution:\n  def platesBetweenCandles(self, s: str, queries: list[list[int]]) -> list[int]:\n    n = len(s)\n    ans = []\n    closestLeftCandle = [0] * n\n    closestRightCandle = [0] * n\n    candleCount = [0] * n  # candleCount[i] := the number of candles in s[0..i]\n    candle = -1\n    count = 0\n\n    for i, c in enumerate(s):\n      if c == '|':\n        candle = i\n        count += 1\n      closestLeftCandle[i] = candle\n      candleCount[i] = count\n\n    candle = -1\n    for i, c in reversed(list(enumerate(s))):\n      if c == '|':\n        candle = i\n      closestRightCandle[i] = candle\n\n    for left, right in queries:\n      l = closestRightCandle[left]\n      r = closestLeftCandle[right]\n      if l == -1 or r == -1 or l > r:\n        ans.append(0)\n      else:\n        lengthBetweenCandles = r - l + 1\n        numCandles = candleCount[r] - candleCount[l] + 1\n        ans.append(lengthBetweenCandles - numCandles)\n\n    return ans\n", "class Solution:\n  def platesBetweenCandles(self, s: str, queries: list[list[int]]) -> list[int]:\n    ans = []\n    indices = [i for i, c in enumerate(s) if c == '|']  # indices of '|'\n\n    for left, right in queries:\n      l = bisect.bisect_left(indices, left)\n      r = bisect.bisect_right(indices, right) - 1\n      if l < r:\n        lengthBetweenCandles = indices[r] - indices[l] + 1\n        numCandles = r - l + 1\n        ans.append(lengthBetweenCandles - numCandles)\n      else:\n        ans.append(0)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2018, "slug": "check-if-word-can-be-placed-in-crossword", "solutions": ["class Solution:\n    def placeWordInCrossword(self, board: List[List[str]], word: str) -> bool:\n        def check(i, j, a, b):\n            x, y = i + a * k, j + b * k\n            if 0 <= x < m and 0 <= y < n and board[x][y] != '#':\n                return False\n            for c in word:\n                if (\n                    i < 0\n                    or i >= m\n                    or j < 0\n                    or j >= n\n                    or (board[i][j] != ' ' and board[i][j] != c)\n                ):\n                    return False\n                i, j = i + a, j + b\n            return True\n\n        m, n = len(board), len(board[0])\n        k = len(word)\n        for i in range(m):\n            for j in range(n):\n                left_to_right = (j == 0 or board[i][j - 1] == '#') and check(i, j, 0, 1)\n                right_to_left = (j == n - 1 or board[i][j + 1] == '#') and check(\n                    i, j, 0, -1\n                )\n                up_to_down = (i == 0 or board[i - 1][j] == '#') and check(i, j, 1, 0)\n                down_to_up = (i == m - 1 or board[i + 1][j] == '#') and check(\n                    i, j, -1, 0\n                )\n                if left_to_right or right_to_left or up_to_down or down_to_up:\n                    return True\n        return False\n", "class Solution:\n  def placeWordInCrossword(self, board: list[list[str]], word: str) -> bool:\n    for x in board, zip(*board):\n      for row in x:\n        for token in ''.join(row).split('#'):\n          for letters in word, word[::-1]:\n            if len(token) == len(letters):\n              if all(c in (' ', letter) for c, letter in zip(token, letters)):\n                return True\n    return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2005, "slug": "subtree-removal-game-with-fibonacci-tree", "solutions": ["class Solution:\n  def findGameWinner(self, n: int) -> bool:\n    return n % 6 != 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2093, "slug": "minimum-cost-to-reach-city-with-discounts", "solutions": ["class Solution:\n    def minimumCost(self, n: int, highways: List[List[int]], discounts: int) -> int:\n        g = defaultdict(list)\n        for a, b, c in highways:\n            g[a].append((b, c))\n            g[b].append((a, c))\n        q = [(0, 0, 0)]\n        dist = [[inf] * (discounts + 1) for _ in range(n)]\n        while q:\n            cost, i, k = heappop(q)\n            if k > discounts:\n                continue\n            if i == n - 1:\n                return cost\n            if dist[i][k] > cost:\n                dist[i][k] = cost\n                for j, v in g[i]:\n                    heappush(q, (cost + v, j, k))\n                    heappush(q, (cost + v // 2, j, k + 1))\n        return -1\n", "class Solution:\n  def minimumCost(\n      self,\n      n: int,\n      highways: list[list[int]],\n      discounts: int,\n  ) -> int:\n    graph = [[] for _ in range(n)]\n    minHeap = [(0, 0, discounts)]  # (d, u, leftDiscounts)\n    minDiscounts = {}\n\n    for city1, city2, toll in highways:\n      graph[city1].append((city2, toll))\n      graph[city2].append((city1, toll))\n\n    while minHeap:\n      d, u, leftDiscounts = heapq.heappop(minHeap)\n      if u == n - 1:\n        return d\n      if u in minDiscounts and minDiscounts[u] >= leftDiscounts:\n        continue\n      minDiscounts[u] = leftDiscounts\n      for v, w in graph[u]:\n        heapq.heappush(minHeap, (d + w, v, leftDiscounts))\n        if leftDiscounts > 0:\n          heapq.heappush(minHeap, (d + w // 2, v, leftDiscounts - 1))\n\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2068, "slug": "check-whether-two-strings-are-almost-equivalent", "solutions": ["class Solution:\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\n        cnt = Counter(word1)\n        for c in word2:\n            cnt[c] -= 1\n        return all(abs(x) <= 3 for x in cnt.values())\n", "class Solution:\n  def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\n    count = collections.Counter(word1)\n    count.subtract(collections.Counter(word2))\n    return all(abs(freq) <= 3 for freq in count.values())\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2098, "slug": "subsequence-of-size-k-with-the-largest-even-sum", "solutions": ["class Solution:\n    def largestEvenSum(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        ans = sum(nums[-k:])\n        if ans % 2 == 0:\n            return ans\n        n = len(nums)\n        mx1 = mx2 = -inf\n        for x in nums[: n - k]:\n            if x & 1:\n                mx1 = x\n            else:\n                mx2 = x\n        mi1 = mi2 = inf\n        for x in nums[-k:][::-1]:\n            if x & 1:\n                mi2 = x\n            else:\n                mi1 = x\n        ans = max(ans - mi1 + mx1, ans - mi2 + mx2, -1)\n        return -1 if ans < 0 else ans\n", "class Solution:\n  def largestEvenSum(self, nums: list[int], k: int) -> int:\n    nums.sort()\n    summ = sum(nums[-k:])\n    if summ % 2 == 0:\n      return summ\n\n    minOdd = -1\n    minEven = -1\n    maxOdd = -1\n    maxEven = -1\n\n    for i in range(len(nums) - 1, len(nums) - k - 1, -1):\n      if nums[i] & 1:\n        minOdd = nums[i]\n      else:\n        minEven = nums[i]\n\n    for i in range(len(nums) - k):\n      if nums[i] & 1:\n        maxOdd = nums[i]\n      else:\n        maxEven = nums[i]\n\n    ans = -1\n\n    if maxEven >= 0 and minOdd >= 0:\n      ans = max(ans, summ + maxEven - minOdd)\n    if maxOdd >= 0 and minEven >= 0:\n      ans = max(ans, summ + maxOdd - minEven)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2014, "slug": "longest-subsequence-repeated-k-times", "solutions": ["class Solution:\n  def longestSubsequenceRepeatedK(self, s: str, k: int) -> str:\n    ans = ''\n    count = [0] * 26\n    possibleChars = []\n    # Stores subsequences, where the length grows by 1 each time.\n    q = collections.deque([''])\n\n    for c in s:\n      count[ord(c) - ord('a')] += 1\n\n    for c in string.ascii_lowercase:\n      if count[ord(c) - ord('a')] >= k:\n        possibleChars.append(c)\n\n    def isSubsequence(subseq: str, s: str, k: int) -> bool:\n      i = 0  # subseq's index\n      for c in s:\n        if c == subseq[i]:\n          i += 1\n          if i == len(subseq):\n            k -= 1\n            if k == 0:\n              return True\n            i = 0\n      return False\n\n    while q:\n      currSubseq = q.popleft()\n      if len(currSubseq) * k > len(s):\n        return ans\n      for c in possibleChars:\n        newSubseq = currSubseq + c\n        if isSubsequence(newSubseq, s, k):\n          q.append(newSubseq)\n          ans = newSubseq\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2070, "slug": "most-beautiful-item-for-each-query", "solutions": ["class Solution:\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\n        items.sort()\n        n, m = len(items), len(queries)\n        ans = [0] * len(queries)\n        i = mx = 0\n        for q, j in sorted(zip(queries, range(m))):\n            while i < n and items[i][0] <= q:\n                mx = max(mx, items[i][1])\n                i += 1\n            ans[j] = mx\n        return ans\n", "class Solution:\n  def maximumBeauty(\n      self,\n      items: list[list[int]],\n      queries: list[int],\n  ) -> list[int]:\n    prices, beauties = zip(*sorted(items))\n    maxBeautySoFar = [0] * (len(beauties) + 1)\n\n    for i, beauty in enumerate(beauties):\n      maxBeautySoFar[i + 1] = max(maxBeautySoFar[i], beauty)\n\n    return [maxBeautySoFar[bisect_right(prices, query)] for query in queries]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2087, "slug": "minimum-cost-homecoming-of-a-robot-in-a-grid", "solutions": ["class Solution:\n    def minCost(\n        self,\n        startPos: List[int],\n        homePos: List[int],\n        rowCosts: List[int],\n        colCosts: List[int],\n    ) -> int:\n        i, j = startPos\n        x, y = homePos\n        ans = 0\n        if i < x:\n            ans += sum(rowCosts[i + 1 : x + 1])\n        else:\n            ans += sum(rowCosts[x:i])\n        if j < y:\n            ans += sum(colCosts[j + 1 : y + 1])\n        else:\n            ans += sum(colCosts[y:j])\n        return ans\n", "class Solution:\n  def minCost(\n      self,\n      startPos: list[int],\n      homePos: list[int],\n      rowCosts: list[int],\n      colCosts: list[int],\n  ) -> int:\n    ans = 0\n    i, j = startPos\n    x, y = homePos\n\n    while i != x:\n      i += 1 if i < x else -1\n      ans += rowCosts[i]\n\n    while j != y:\n      j += 1 if j < y else -1\n      ans += colCosts[j]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2072, "slug": "the-winner-university", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2080, "slug": "range-frequency-queries", "solutions": ["class RangeFreqQuery:\n\n    def __init__(self, arr: List[int]):\n        self.g = defaultdict(list)\n        for i, x in enumerate(arr):\n            self.g[x].append(i)\n\n    def query(self, left: int, right: int, value: int) -> int:\n        idx = self.g[value]\n        l = bisect_left(idx, left)\n        r = bisect_left(idx, right + 1)\n        return r - l\n\n\n# Your RangeFreqQuery object will be instantiated and called as such:\n# obj = RangeFreqQuery(arr)\n# param_1 = obj.query(left,right,value)\n", "class RangeFreqQuery:\n  def __init__(self, arr: list[int]):\n    self.valueToIndices = collections.defaultdict(list)\n    for i, a in enumerate(arr):\n      self.valueToIndices[a].append(i)\n\n  def query(self, left: int, right: int, value: int) -> int:\n    indices = self.valueToIndices[value]\n    i = bisect_left(indices, left)\n    j = bisect_right(indices, right)\n    return j - i\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2024, "slug": "maximize-the-confusion-of-an-exam", "solutions": ["class Solution:\n    def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\n        def f(c: str) -> int:\n            cnt = l = 0\n            for ch in answerKey:\n                cnt += ch == c\n                if cnt > k:\n                    cnt -= answerKey[l] == c\n                    l += 1\n            return len(answerKey) - l\n\n        return max(f(\"T\"), f(\"F\"))\n", "class Solution:\n  def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\n    ans = 0\n    maxCount = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, c in enumerate(answerKey):\n      count[c == 'T'] += 1\n      maxCount = max(maxCount, count[c == 'T'])\n      while maxCount + k < r - l + 1:\n        count[answerKey[l] == 'T'] -= 1\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2016, "slug": "maximum-difference-between-increasing-elements", "solutions": ["class Solution:\n    def maximumDifference(self, nums: List[int]) -> int:\n        mi = inf\n        ans = -1\n        for x in nums:\n            if x > mi:\n                ans = max(ans, x - mi)\n            else:\n                mi = x\n        return ans\n", "class Solution:\n  def maximumDifference(self, nums: list[int]) -> int:\n    ans = -1\n    mn = nums[0]\n\n    for i in range(len(nums)):\n      if nums[i] > mn:\n        ans = max(ans, nums[i] - mn)\n      mn = min(mn, nums[i])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2049, "slug": "count-nodes-with-the-highest-score", "solutions": ["class Solution:\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\n        def dfs(i: int, fa: int):\n            cnt = score = 1\n            for j in g[i]:\n                if j != fa:\n                    t = dfs(j, i)\n                    score *= t\n                    cnt += t\n            if n - cnt:\n                score *= n - cnt\n            nonlocal ans, mx\n            if mx < score:\n                mx = score\n                ans = 1\n            elif mx == score:\n                ans += 1\n            return cnt\n\n        n = len(parents)\n        g = [[] for _ in range(n)]\n        for i in range(1, n):\n            g[parents[i]].append(i)\n        ans = mx = 0\n        dfs(0, -1)\n        return ans\n", "class Solution:\n  def countHighestScoreNodes(self, parents: list[int]) -> int:\n    tree = [[] for _ in range(len(parents))]\n\n    for i, parent in enumerate(parents):\n      if parent == -1:\n        continue\n      tree[parent].append(i)\n\n    ans = 0\n    maxScore = 0\n\n    def dfs(u: int) -> int:  # Returns node count\n      nonlocal ans\n      nonlocal maxScore\n      count = 1\n      score = 1\n      for v in tree[u]:\n        childCount = dfs(v)\n        count += childCount\n        score *= childCount\n      score *= len(parents) - count or 1\n      if score > maxScore:\n        maxScore = score\n        ans = 1\n      elif score == maxScore:\n        ans += 1\n      return count\n\n    dfs(0)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2082, "slug": "the-number-of-rich-customers", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2083, "slug": "substrings-that-begin-and-end-with-the-same-letter", "solutions": ["class Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        cnt = Counter()\n        ans = 0\n        for c in s:\n            cnt[c] += 1\n            ans += cnt[c]\n        return ans\n", "class Solution:\n  def numberOfSubstrings(self, s: str) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    for c in s:\n      ans += count[c] + 1\n      count[c] += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2047, "slug": "number-of-valid-words-in-a-sentence", "solutions": ["class Solution:\n    def countValidWords(self, sentence: str) -> int:\n        def check(s: str) -> bool:\n            st = False\n            for i, c in enumerate(s):\n                if c.isdigit() or (c in \"!.,\" and i < len(s) - 1):\n                    return False\n                if c == \"-\":\n                    if (\n                        st\n                        or i in (0, len(s) - 1)\n                        or not s[i - 1].isalpha()\n                        or not s[i + 1].isalpha()\n                    ):\n                        return False\n                    st = True\n            return True\n\n        return sum(check(s) for s in sentence.split())\n", "class Solution:\n  def countValidWords(self, sentence: str) -> int:\n    def isValid(token: str) -> bool:\n      countHyphen = 0\n      for i, c in enumerate(token):\n        if c.isdigit():\n          return False\n        if c == '-':\n          if i == 0 or not token[i - 1].isalpha():\n            return False\n          if i == len(token) - 1 or not token[i + 1].isalpha():\n            return False\n          if countHyphen == 1:\n            return False\n          countHyphen += 1\n        if c in ['!', '.', ',']:\n          if i != len(token) - 1:\n            return False\n      return True\n\n    return sum(isValid(token) for token in sentence.split())\n", "class Solution:\n  def countValidWords(self, sentence: str) -> int:\n    pattern = re.compile(r'^[a-z]*([a-z]-[a-z])?[a-z]*[!,.]?$')\n    return sum(pattern.search(token) != None for token in\n               sentence.strip().split())\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2078, "slug": "two-furthest-houses-with-different-colors", "solutions": ["class Solution:\n    def maxDistance(self, colors: List[int]) -> int:\n        ans, n = 0, len(colors)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if colors[i] != colors[j]:\n                    ans = max(ans, abs(i - j))\n        return ans\n", "class Solution:\n  def maxDistance(self, colors: list[int]) -> int:\n    # The maximum distance always includes either the first or the last house.\n    n = len(colors)\n    i = 0  # the leftmost index, where colors[i] != colors[-1]\n    j = n - 1  # the rightmost index, where colors[j] != colors[0]\n    while colors[i] == colors[-1]:\n      i += 1\n    while colors[j] == colors[0]:\n      j -= 1\n    return max(n - 1 - i, j)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2001, "slug": "number-of-pairs-of-interchangeable-rectangles", "solutions": ["class Solution:\n    def interchangeableRectangles(self, rectangles: List[List[int]]) -> int:\n        ans = 0\n        cnt = Counter()\n        for w, h in rectangles:\n            g = gcd(w, h)\n            w, h = w // g, h // g\n            ans += cnt[(w, h)]\n            cnt[(w, h)] += 1\n        return ans\n", "class Solution:\n  def interchangeableRectangles(self, rectangles: list[list[int]]) -> int:\n    ratioCount = collections.Counter()\n\n    def gcd(a: int, b: int) -> int:\n      return a if b == 0 else gcd(b, a % b)\n\n    for width, height in rectangles:\n      d = gcd(width, height)\n      ratioCount[(width // d, height // d)] += 1\n\n    return sum(c * (c - 1) // 2 for c in ratioCount.values())\n", "class Solution:\n  def interchangeableRectangles(self, rectangles: list[list[int]]) -> int:\n    ratioCount = collections.Counter()\n\n    for width, height in rectangles:\n      ratioCount[width / height] += 1\n\n    return sum(count * (count - 1) // 2\n               for count in ratioCount.values())\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2029, "slug": "stone-game-ix", "solutions": ["class Solution:\n    def stoneGameIX(self, stones: List[int]) -> bool:\n        def check(cnt: List[int]) -> bool:\n            if cnt[1] == 0:\n                return False\n            cnt[1] -= 1\n            r = 1 + min(cnt[1], cnt[2]) * 2 + cnt[0]\n            if cnt[1] > cnt[2]:\n                cnt[1] -= 1\n                r += 1\n            return r % 2 == 1 and cnt[1] != cnt[2]\n\n        c1 = [0] * 3\n        for x in stones:\n            c1[x % 3] += 1\n        c2 = [c1[0], c1[2], c1[1]]\n        return check(c1) or check(c2)\n", "class Solution:\n  def stoneGameIX(self, stones: list[int]) -> bool:\n    count = collections.Counter(stone % 3 for stone in stones)\n    if count[0] % 2 == 0:\n      return min(count[1], count[2]) > 0\n    return abs(count[1] - count[2]) > 2\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2066, "slug": "account-balance", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2099, "slug": "find-subsequence-of-length-k-with-the-largest-sum", "solutions": ["class Solution:\n    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\n        idx = sorted(range(len(nums)), key=lambda i: nums[i])[-k:]\n        return [nums[i] for i in sorted(idx)]\n", "class Solution:\n  def maxSubsequence(self, nums: list[int], k: int) -> list[int]:\n    ans = []\n    threshold = sorted(nums)[-k]\n    larger = sum(num > threshold for num in nums)\n    equal = k - larger\n\n    for num in nums:\n      if num > threshold:\n        ans.append(num)\n      elif num == threshold and equal:\n        ans.append(num)\n        equal -= 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2027, "slug": "minimum-moves-to-convert-string", "solutions": ["class Solution:\n    def minimumMoves(self, s: str) -> int:\n        ans = i = 0\n        while i < len(s):\n            if s[i] == \"X\":\n                ans += 1\n                i += 3\n            else:\n                i += 1\n        return ans\n", "class Solution:\n  def minimumMoves(self, s: str) -> int:\n    ans = 0\n\n    i = 0\n    while i < len(s):\n      if s[i] == 'O':\n        i += 1\n      else:\n        ans += 1\n        i += 3\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2063, "slug": "vowels-of-all-substrings", "solutions": ["class Solution:\n    def countVowels(self, word: str) -> int:\n        n = len(word)\n        return sum((i + 1) * (n - i) for i, c in enumerate(word) if c in 'aeiou')\n", "class Solution:\n  def countVowels(self, word: str) -> int:\n    # dp[i] := the sum of the number of vowels of word[0..i), ...,\n    # word[i - 1..i)\n    dp = [0] * (len(word) + 1)\n\n    for i, c in enumerate(word):\n      dp[i + 1] = dp[i]\n      if c in 'aeiou':\n        dp[i + 1] += i + 1\n\n    return sum(dp)\n", "class Solution:\n  def countVowels(self, word: str) -> int:\n    return sum((i + 1) * (len(word) - i)\n               for i, c in enumerate(word)\n               if c in 'aeiou')\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2071, "slug": "maximum-number-of-tasks-you-can-assign", "solutions": ["class Solution:\n    def maxTaskAssign(\n        self, tasks: List[int], workers: List[int], pills: int, strength: int\n    ) -> int:\n        def check(x):\n            i = 0\n            q = deque()\n            p = pills\n            for j in range(m - x, m):\n                while i < x and tasks[i] <= workers[j] + strength:\n                    q.append(tasks[i])\n                    i += 1\n                if not q:\n                    return False\n                if q[0] <= workers[j]:\n                    q.popleft()\n                elif p == 0:\n                    return False\n                else:\n                    p -= 1\n                    q.pop()\n            return True\n\n        n, m = len(tasks), len(workers)\n        tasks.sort()\n        workers.sort()\n        left, right = 0, min(n, m)\n        while left < right:\n            mid = (left + right + 1) >> 1\n            if check(mid):\n                left = mid\n            else:\n                right = mid - 1\n        return left\n", "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def maxTaskAssign(\n      self,\n      tasks: list[int],\n      workers: list[int],\n      pills: int,\n      strength: int,\n  ) -> int:\n    tasks.sort()\n    workers.sort()\n\n    def canComplete(k: int, pillsLeft: int) -> bool:\n      \"\"\"Returns True if we can finish k tasks.\"\"\"\n      # k strongest workers\n      sortedWorkers = SortedList(workers[-k:])\n\n      # Out of the k smallest tasks, start from the biggest one.\n      for i in reversed(range(k)):\n        # Find the first worker that has strength >= tasks[i].\n        index = sortedWorkers.bisect_left(tasks[i])\n        if index < len(sortedWorkers):\n          sortedWorkers.pop(index)\n        elif pillsLeft > 0:\n          # Find the first worker that has strength >= tasks[i] - strength.\n          index = sortedWorkers.bisect_left(tasks[i] - strength)\n          if index < len(sortedWorkers):\n            sortedWorkers.pop(index)\n            pillsLeft -= 1\n          else:\n            return False\n        else:\n          return False\n\n      return True\n\n    ans = 0\n    l = 0\n    r = min(len(tasks), len(workers))\n\n    while l <= r:\n      m = (l + r) // 2\n      if canComplete(m, pills):\n        ans = m\n        l = m + 1\n      else:\n        r = m - 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2086, "slug": "minimum-number-of-food-buckets-to-feed-the-hamsters", "solutions": ["class Solution:\n    def minimumBuckets(self, street: str) -> int:\n        ans = 0\n        i, n = 0, len(street)\n        while i < n:\n            if street[i] == 'H':\n                if i + 1 < n and street[i + 1] == '.':\n                    i += 2\n                    ans += 1\n                elif i and street[i - 1] == '.':\n                    ans += 1\n                else:\n                    return -1\n            i += 1\n        return ans\n", "class Solution:\n  def minimumBuckets(self, street: str) -> int:\n    A = list(street)\n\n    for i, c in enumerate(A):\n      if c == 'H':\n        if i > 0 and A[i - 1] == 'B':\n          continue\n        if i + 1 < len(A) and A[i + 1] == '.':\n          # Always prefer place a bucket in (i + 1) because it enhances the\n          # possibility to collect the upcoming houses.\n          A[i + 1] = 'B'\n        elif i > 0 and A[i - 1] == '.':\n          A[i - 1] = 'B'\n        else:\n          return -1\n\n    return A.count('B')\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2004, "slug": "the-number-of-seniors-and-juniors-to-join-the-company", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2009, "slug": "minimum-number-of-operations-to-make-array-continuous", "solutions": ["class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = n = len(nums)\n        nums = sorted(set(nums))\n        for i, v in enumerate(nums):\n            j = bisect_right(nums, v + n - 1)\n            ans = min(ans, n - (j - i))\n        return ans\n", "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = n\n    nums = sorted(set(nums))\n\n    for i, start in enumerate(nums):\n      end = start + n - 1\n      index = bisect_right(nums, end)\n      uniqueLength = index - i\n      ans = min(ans, n - uniqueLength)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2073, "slug": "time-needed-to-buy-tickets", "solutions": ["class Solution:\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\n        ans = 0\n        for i, x in enumerate(tickets):\n            ans += min(x, tickets[k] if i <= k else tickets[k] - 1)\n        return ans\n", "class Solution:\n  def timeRequiredToBuy(self, tickets: list[int], k: int) -> int:\n    ans = 0\n\n    for i, ticket in enumerate(tickets):\n      if i <= k:\n        ans += min(ticket, tickets[k])\n      else:\n        ans += min(ticket, tickets[k] - 1)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2064, "slug": "minimized-maximum-of-products-distributed-to-any-store", "solutions": ["class Solution:\n    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\n        def check(x):\n            return sum((v + x - 1) // x for v in quantities) <= n\n\n        return 1 + bisect_left(range(1, 10**6), True, key=check)\n", "class Solution:\n  def minimizedMaximum(self, n: int, quantities: list[int]) -> int:\n    l = 1\n    r = max(quantities)\n\n    def numStores(m: int) -> int:\n      return sum((q - 1) // m + 1 for q in quantities)\n\n    while l < r:\n      m = (l + r) // 2\n      if numStores(m) <= n:\n        r = m\n      else:\n        l = m + 1\n\n    return l\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2035, "slug": "partition-array-into-two-arrays-to-minimize-sum-difference", "solutions": ["class Solution:\n    def minimumDifference(self, nums: List[int]) -> int:\n        n = len(nums) >> 1\n        f = defaultdict(set)\n        g = defaultdict(set)\n        for i in range(1 << n):\n            s = cnt = 0\n            s1 = cnt1 = 0\n            for j in range(n):\n                if (i & (1 << j)) != 0:\n                    s += nums[j]\n                    cnt += 1\n                    s1 += nums[n + j]\n                    cnt1 += 1\n                else:\n                    s -= nums[j]\n                    s1 -= nums[n + j]\n            f[cnt].add(s)\n            g[cnt1].add(s1)\n\n        ans = inf\n        for i in range(n + 1):\n            fi, gi = sorted(list(f[i])), sorted(list(g[n - i]))\n            # min(abs(f[i] + g[n - i]))\n            for a in fi:\n                left, right = 0, len(gi) - 1\n                b = -a\n                while left < right:\n                    mid = (left + right) >> 1\n                    if gi[mid] >= b:\n                        right = mid\n                    else:\n                        left = mid + 1\n                ans = min(ans, abs(a + gi[left]))\n                if left > 0:\n                    ans = min(ans, abs(a + gi[left - 1]))\n        return ans\n", "class Solution:\n  def minimumDifference(self, nums: list[int]) -> int:\n    n = len(nums) // 2\n    summ = sum(nums)\n    goal = summ // 2\n    lNums = nums[:n]\n    rNums = nums[n:]\n    ans = abs(sum(lNums) - sum(rNums))\n    lSums = [[] for _ in range(n + 1)]\n    rSums = [[] for _ in range(n + 1)]\n\n    def dfs(\n        arr: list[int],\n        i: int,\n        count: int,\n        path: int,\n        sums: list[list[int]]\n    ):\n      if i == len(arr):\n        sums[count].append(path)\n        return\n      dfs(arr, i + 1, count + 1, path + arr[i], sums)\n      dfs(arr, i + 1, count, path, sums)\n\n    dfs(lNums, 0, 0, 0, lSums)\n    dfs(rNums, 0, 0, 0, rSums)\n\n    for lCount in range(n):\n      l = lSums[lCount]\n      r = rSums[n - lCount]\n      r.sort()\n      for lSum in l:\n        i = bisect_left(r, goal - lSum)\n        if i < len(r):\n          sumPartOne = summ - lSum - r[i]\n          sumPartTwo = summ - sumPartOne\n          ans = min(ans, abs(sumPartOne - sumPartTwo))\n        if i > 0:\n          sumPartOne = summ - lSum - r[i - 1]\n          sumPartTwo = summ - sumPartOne\n          ans = min(ans, abs(sumPartOne - sumPartTwo))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2050, "slug": "parallel-courses-iii", "solutions": ["class Solution:\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\n        g = defaultdict(list)\n        indeg = [0] * n\n        for a, b in relations:\n            g[a - 1].append(b - 1)\n            indeg[b - 1] += 1\n        q = deque()\n        f = [0] * n\n        ans = 0\n        for i, (v, t) in enumerate(zip(indeg, time)):\n            if v == 0:\n                q.append(i)\n                f[i] = t\n                ans = max(ans, t)\n        while q:\n            i = q.popleft()\n            for j in g[i]:\n                f[j] = max(f[j], f[i] + time[j])\n                ans = max(ans, f[j])\n                indeg[j] -= 1\n                if indeg[j] == 0:\n                    q.append(j)\n        return ans\n", "class Solution:\n  def minimumTime(\n      self,\n      n: int,\n      relations: list[list[int]],\n      time: list[int],\n  ) -> int:\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n    dist = time.copy()\n\n    # Build the graph.\n    for a, b in relations:\n      u = a - 1\n      v = b - 1\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    # Perform topological sorting.\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    while q:\n      u = q.popleft()\n      for v in graph[u]:\n        dist[v] = max(dist[v], dist[u] + time[v])\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    return max(dist)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2090, "slug": "k-radius-subarray-averages", "solutions": ["class Solution:\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        ans = [-1] * n\n        s = 0\n        for i, x in enumerate(nums):\n            s += x\n            if i >= k * 2:\n                ans[i - k] = s // (k * 2 + 1)\n                s -= nums[i - k * 2]\n        return ans\n", "class Solution:\n  def getAverages(self, nums: list[int], k: int) -> list[int]:\n    n = len(nums)\n    size = 2 * k + 1\n    ans = [-1] * n\n    if size > n:\n      return ans\n\n    summ = sum(nums[:size])\n\n    for i in range(k, n - k):\n      ans[i] = summ // size\n      if i + k + 1 < n:\n        summ += nums[i + k + 1] - nums[i - k]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2054, "slug": "two-best-non-overlapping-events", "solutions": ["class Solution:\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\n        events.sort()\n        n = len(events)\n        f = [events[-1][2]] * n\n        for i in range(n - 2, -1, -1):\n            f[i] = max(f[i + 1], events[i][2])\n        ans = 0\n        for _, e, v in events:\n            idx = bisect_right(events, e, key=lambda x: x[0])\n            if idx < n:\n                v += f[idx]\n            ans = max(ans, v)\n        return ans\n", "class Solution:\n  def maxTwoEvents(self, events: list[list[int]]) -> int:\n    ans = 0\n    maxValue = 0\n    evts = []  # (time, isStart, value)\n\n    for s, e, v in events:\n      evts.append((s, 1, v))\n      evts.append((e + 1, 0, v))\n\n    # When two events have the same time, the one is not start will be in the front\n    evts.sort()\n\n    for _, isStart, value in evts:\n      if isStart:\n        ans = max(ans, value + maxValue)\n      else:\n        maxValue = max(maxValue, value)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2025, "slug": "maximum-number-of-ways-to-partition-an-array", "solutions": ["class Solution:\n    def waysToPartition(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        s = [nums[0]] * n\n        right = defaultdict(int)\n        for i in range(1, n):\n            s[i] = s[i - 1] + nums[i]\n            right[s[i - 1]] += 1\n\n        ans = 0\n        if s[-1] % 2 == 0:\n            ans = right[s[-1] // 2]\n\n        left = defaultdict(int)\n        for v, x in zip(s, nums):\n            d = k - x\n            if (s[-1] + d) % 2 == 0:\n                t = left[(s[-1] + d) // 2] + right[(s[-1] - d) // 2]\n                if ans < t:\n                    ans = t\n            left[v] += 1\n            right[v] -= 1\n        return ans\n", "class Solution:\n  def waysToPartition(self, nums: list[int], k: int) -> int:\n    n = len(nums)\n    summ = sum(nums)\n    prefix = 0\n    # Count of sum(A[0..k)) - sum(A[k..n)) for k in [0..i)\n    l = collections.Counter()\n    # Count of sum(A[0..k)) - sum(A[k..n)) for k in [i..n)\n    r = collections.Counter()\n\n    for pivot in range(1, n):\n      prefix += nums[pivot - 1]\n      suffix = summ - prefix\n      r[prefix - suffix] += 1\n\n    ans = r[0]\n    prefix = 0\n\n    for num in nums:\n      ans = max(ans, l[k - num] + r[num - k])\n      prefix += num\n      suffix = summ - prefix\n      diff = prefix - suffix\n      r[diff] -= 1\n      l[diff] += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2046, "slug": "sort-linked-list-already-sorted-using-absolute-values", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def sortLinkedList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev, curr = head, head.next\n        while curr:\n            if curr.val < 0:\n                t = curr.next\n                prev.next = t\n                curr.next = head\n                head = curr\n                curr = t\n            else:\n                prev, curr = curr, curr.next\n        return head\n", "class Solution:\n  def sortLinkedList(self, head: ListNode | None) -> ListNode | None:\n    prev = head\n    curr = head.next\n\n    while curr:\n      if curr.val < 0:\n        prev.next = curr.next\n        curr.next = head\n        head = curr\n        curr = prev.next\n      else:\n        prev = curr\n        curr = curr.next\n\n    return head\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2022, "slug": "convert-1d-array-into-2d-array", "solutions": ["class Solution:\n    def construct2DArray(self, original: List[int], m: int, n: int) -> List[List[int]]:\n        if m * n != len(original):\n            return []\n        return [original[i : i + n] for i in range(0, m * n, n)]\n", "class Solution:\n  def construct2DArray(self, original: list[int],\n                       m: int, n: int) -> list[list[int]]:\n    if len(original) != m * n:\n      return []\n\n    ans = [[0] * n for _ in range(m)]\n\n    for i, num in enumerate(original):\n      ans[i // n][i % n] = num\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2074, "slug": "reverse-nodes-in-even-length-groups", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        def reverse(head, l):\n            prev, cur, tail = None, head, head\n            i = 0\n            while cur and i < l:\n                t = cur.next\n                cur.next = prev\n                prev = cur\n                cur = t\n                i += 1\n            tail.next = cur\n            return prev\n\n        n = 0\n        t = head\n        while t:\n            t = t.next\n            n += 1\n        dummy = ListNode(0, head)\n        prev = dummy\n        l = 1\n        while (1 + l) * l // 2 <= n and prev:\n            if l % 2 == 0:\n                prev.next = reverse(prev.next, l)\n            i = 0\n            while i < l and prev:\n                prev = prev.next\n                i += 1\n            l += 1\n        left = n - l * (l - 1) // 2\n        if left > 0 and left % 2 == 0:\n            prev.next = reverse(prev.next, left)\n        return dummy.next\n", "class Solution:\n  def reverseEvenLengthGroups(self, head: ListNode | None) -> ListNode | None:\n    # prev -> (head -> ... -> tail) -> next -> ...\n    dummy = ListNode(0, head)\n    prev = dummy\n    tail = head\n    next = head.next\n    groupLength = 1\n\n    def getTailAndLength(head: ListNode | None, groupLength: int) -> tuple[ListNode | None, int]:\n      length = 1\n      tail = head\n      while length < groupLength and tail.next:\n        tail = tail.next\n        length += 1\n      return tail, length\n\n    def reverse(head: ListNode | None) -> ListNode | None:\n      prev = None\n      while head:\n        next = head.next\n        head.next = prev\n        prev = head\n        head = next\n      return prev\n\n    while True:\n      if groupLength % 2 == 1:\n        prev.next = head\n        prev = tail\n      else:\n        tail.next = None\n        prev.next = reverse(head)\n        # Prev -> (tail -> ... -> head) -> next -> ...\n        head.next = next\n        prev = head\n      if not next:\n        break\n      head = next\n      tail, length = getTailAndLength(head, groupLength + 1)\n      next = tail.next\n      groupLength = length\n\n    return dummy.next\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2013, "slug": "detect-squares", "solutions": ["class DetectSquares:\n    def __init__(self):\n        self.cnt = defaultdict(Counter)\n\n    def add(self, point: List[int]) -> None:\n        x, y = point\n        self.cnt[x][y] += 1\n\n    def count(self, point: List[int]) -> int:\n        x1, y1 = point\n        if x1 not in self.cnt:\n            return 0\n        ans = 0\n        for x2 in self.cnt.keys():\n            if x2 != x1:\n                d = x2 - x1\n                ans += self.cnt[x2][y1] * self.cnt[x1][y1 + d] * self.cnt[x2][y1 + d]\n                ans += self.cnt[x2][y1] * self.cnt[x1][y1 - d] * self.cnt[x2][y1 - d]\n        return ans\n\n\n# Your DetectSquares object will be instantiated and called as such:\n# obj = DetectSquares()\n# obj.add(point)\n# param_2 = obj.count(point)\n", "class DetectSquares:\n  def __init__(self):\n    self.pointCount = collections.Counter()\n\n  def add(self, point: list[int]) -> None:\n    self.pointCount[tuple(point)] += 1\n\n  def count(self, point: list[int]) -> int:\n    x1, y1 = point\n    ans = 0\n    for (x3, y3), c in self.pointCount.items():\n      if x1 != x3 and abs(x1 - x3) == abs(y1 - y3):\n        ans += c * self.pointCount[(x1, y3)] * self.pointCount[(x3, y1)]\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2057, "slug": "smallest-index-with-equal-value", "solutions": ["class Solution:\n    def smallestEqual(self, nums: List[int]) -> int:\n        for i, x in enumerate(nums):\n            if i % 10 == x:\n                return i\n        return -1\n", "class Solution:\n  def smallestEqual(self, nums: list[int]) -> int:\n    return next((i for i, num in enumerate(nums) if i % 10 == num), -1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2042, "slug": "check-if-numbers-are-ascending-in-a-sentence", "solutions": ["class Solution:\n    def areNumbersAscending(self, s: str) -> bool:\n        pre = 0\n        for t in s.split():\n            if t[0].isdigit():\n                if (cur := int(t)) <= pre:\n                    return False\n                pre = cur\n        return True\n", "class Solution:\n  def areNumbersAscending(self, s: str) -> bool:\n    prev = 0\n\n    for token in s.split():\n      if token.isdigit():\n        num = int(token)\n        if num <= prev:\n          return False\n        prev = num\n\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2092, "slug": "find-all-people-with-secret", "solutions": ["class Solution:\n    def findAllPeople(\n        self, n: int, meetings: List[List[int]], firstPerson: int\n    ) -> List[int]:\n        vis = [False] * n\n        vis[0] = vis[firstPerson] = True\n        meetings.sort(key=lambda x: x[2])\n        i, m = 0, len(meetings)\n        while i < m:\n            j = i\n            while j + 1 < m and meetings[j + 1][2] == meetings[i][2]:\n                j += 1\n            s = set()\n            g = defaultdict(list)\n            for x, y, _ in meetings[i : j + 1]:\n                g[x].append(y)\n                g[y].append(x)\n                s.update([x, y])\n            q = deque([u for u in s if vis[u]])\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if not vis[v]:\n                        vis[v] = True\n                        q.append(v)\n            i = j + 1\n        return [i for i, v in enumerate(vis) if v]\n", "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def connected(self, u: int, v: int) -> bool:\n    return self._find(self.id[u]) == self._find(self.id[v])\n\n  def reset(self, u: int) -> None:\n    self.id[u] = u\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findAllPeople(\n      self,\n      n: int,\n      meetings: list[list[int]],\n      firstPerson: int,\n  ) -> list[int]:\n    uf = UnionFind(n)\n    timeToPairs = collections.defaultdict(list)\n\n    uf.unionByRank(0, firstPerson)\n\n    for x, y, time in meetings:\n      timeToPairs[time].append((x, y))\n\n    for _, pairs in sorted(timeToPairs.items(), key=lambda x: x[0]):\n      peopleUnioned = set()\n      for x, y in pairs:\n        uf.unionByRank(x, y)\n        peopleUnioned.add(x)\n        peopleUnioned.add(y)\n      for person in peopleUnioned:\n        if not uf.connected(person, 0):\n          uf.reset(person)\n\n    return [i for i in range(n) if uf.connected(i, 0)]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2060, "slug": "check-if-an-original-string-exists-given-two-encoded-strings", "solutions": ["class Solution:\n  def possiblyEquals(self, s1: str, s2: str) -> bool:\n    def getNums(s: str) -> set[int]:\n      nums = {int(s)}\n      for i in range(1, len(s)):\n        nums |= {x + y for x in getNums(s[:i]) for y in getNums(s[i:])}\n      return nums\n\n    def getNextLetterIndex(s: str, i: int) -> int:\n      j = i\n      while j < len(s) and s[j].isdigit():\n        j += 1\n      return j\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, paddingDiff: int) -> bool:\n      \"\"\"\n      Returns True if s1[i..n) matches s2[j..n), accounting for the padding\n      difference. Here, `paddingDiff` represents the signed padding. A positive\n      `paddingDiff` indicates that s1 has an additional number of offset bytes\n      compared to s2.\n      \"\"\"\n      if i == len(s1) and j == len(s2):\n        return paddingDiff == 0\n      # Add padding on s1.\n      if i < len(s1) and s1[i].isdigit():\n        nextLetterIndex = getNextLetterIndex(s1, i)\n        for num in getNums(s1[i:nextLetterIndex]):\n          if dp(nextLetterIndex, j, paddingDiff + num):\n            return True\n      # Add padding on s2.\n      elif j < len(s2) and s2[j].isdigit():\n        nextLetterIndex = getNextLetterIndex(s2, j)\n        for num in getNums(s2[j:nextLetterIndex]):\n          if dp(i, nextLetterIndex, paddingDiff - num):\n            return True\n      # `s1` has more padding, so j needs to catch up.\n      elif paddingDiff > 0:\n        if j < len(s2):\n          return dp(i, j + 1, paddingDiff - 1)\n      # `s2` has more padding, so i needs to catch up.\n      elif paddingDiff < 0:\n        if i < len(s1):\n          return dp(i + 1, j, paddingDiff + 1)\n      # There's no padding difference, so consume the next letter.\n      else:  # paddingDiff == 0\n        if i < len(s1) and j < len(s2) and s1[i] == s2[j]:\n          return dp(i + 1, j + 1, 0)\n      return False\n\n    return dp(0, 0, 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2037, "slug": "minimum-number-of-moves-to-seat-everyone", "solutions": ["class Solution:\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\n        seats.sort()\n        students.sort()\n        return sum(abs(a - b) for a, b in zip(seats, students))\n", "class Solution:\n  def minMovesToSeat(self, seats: list[int], students: list[int]) -> int:\n    return sum(\n        abs(seat - student) for seat,\n        student in zip(sorted(seats),\n                       sorted(students)))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2017, "slug": "grid-game", "solutions": ["class Solution:\n    def gridGame(self, grid: List[List[int]]) -> int:\n        ans = inf\n        s1, s2 = sum(grid[0]), 0\n        for j, v in enumerate(grid[0]):\n            s1 -= v\n            ans = min(ans, max(s1, s2))\n            s2 += grid[1][j]\n        return ans\n", "class Solution:\n  def gridGame(self, grid: list[list[int]]) -> int:\n    n = len(grid[0])\n    ans = math.inf\n    sumRow0 = sum(grid[0])\n    sumRow1 = 0\n\n    for i in range(n):\n      sumRow0 -= grid[0][i]\n      ans = min(ans, max(sumRow0, sumRow1))\n      sumRow1 += grid[1][i]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2048, "slug": "next-greater-numerically-balanced-number", "solutions": ["class Solution:\n    def nextBeautifulNumber(self, n: int) -> int:\n        for x in count(n + 1):\n            y = x\n            cnt = [0] * 10\n            while y:\n                y, v = divmod(y, 10)\n                cnt[v] += 1\n            if all(v == 0 or i == v for i, v in enumerate(cnt)):\n                return x\n", "class Solution:\n  def nextBeautifulNumber(self, n: int) -> int:\n    def isBalance(num: int) -> bool:\n      count = [0] * 10\n      while num > 0:\n        if num % 10 == 0:\n          return False\n        count[num % 10] += 1\n        num //= 10\n      return all(c == i for i, c in enumerate(count) if c)\n\n    n += 1\n    while not isBalance(n):\n      n += 1\n    return n\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2094, "slug": "finding-3-digit-even-numbers", "solutions": ["class Solution:\n    def findEvenNumbers(self, digits: List[int]) -> List[int]:\n        cnt = Counter(digits)\n        ans = []\n        for x in range(100, 1000, 2):\n            cnt1 = Counter()\n            y = x\n            while y:\n                y, v = divmod(y, 10)\n                cnt1[v] += 1\n            if all(cnt[i] >= cnt1[i] for i in range(10)):\n                ans.append(x)\n        return ans\n", "class Solution:\n  def findEvenNumbers(self, digits: list[int]) -> list[int]:\n    ans = []\n    count = collections.Counter(digits)\n\n    # Try to construct `abc`.\n    for a in range(1, 10):\n      for b in range(0, 10):\n        for c in range(0, 9, 2):\n          if count[a] > 0 and count[b] > (\n                  b == a) and count[c] > (\n                  c == a) + (\n                  c == b):\n            ans.append(a * 100 + b * 10 + c)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3021, "slug": "alice-and-bob-playing-flower-game", "solutions": ["class Solution:\n    def flowerGame(self, n: int, m: int) -> int:\n        a1 = (n + 1) // 2\n        b1 = (m + 1) // 2\n        a2 = n // 2\n        b2 = m // 2\n        return a1 * b2 + a2 * b1\n", "class Solution:\n  def flowerGame(self, n: int, m: int) -> int:\n    # Alice wins if x + y is odd, occurring when:\n    #   1. x is even and y is odd, or\n    #   2. y is even and x is odd.\n    xEven = n // 2\n    yEven = m // 2\n    xOdd = (n + 1) // 2\n    yOdd = (m + 1) // 2\n    return xEven * yOdd + yEven * xOdd\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3016, "slug": "minimum-number-of-pushes-to-type-word-ii", "solutions": ["class Solution:\n    def minimumPushes(self, word: str) -> int:\n        cnt = Counter(word)\n        ans = 0\n        for i, x in enumerate(sorted(cnt.values(), reverse=True)):\n            ans += (i // 8 + 1) * x\n        return ans\n", "class Solution:\n  # Same as 3014. Minimum Number of Pushes to Type Word I\n  def minimumPushes(self, word: str) -> int:\n    freqs = sorted(collections.Counter(word).values(), reverse=True)\n    return sum(freq * (i // 8 + 1) for i, freq in enumerate(freqs))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3023, "slug": "find-pattern-in-infinite-stream-i", "solutions": ["# Definition for an infinite stream.\n# class InfiniteStream:\n#     def next(self) -> int:\n#         pass\nclass Solution:\n    def findPattern(\n        self, stream: Optional[\"InfiniteStream\"], pattern: List[int]\n    ) -> int:\n        a = b = 0\n        m = len(pattern)\n        half = m >> 1\n        mask1 = (1 << half) - 1\n        mask2 = (1 << (m - half)) - 1\n        for i in range(half):\n            a |= pattern[i] << (half - 1 - i)\n        for i in range(half, m):\n            b |= pattern[i] << (m - 1 - i)\n        x = y = 0\n        for i in count(1):\n            v = stream.next()\n            y = y << 1 | v\n            v = y >> (m - half) & 1\n            y &= mask2\n            x = x << 1 | v\n            x &= mask1\n            if i >= m and a == x and b == y:\n                return i - m\n", "# Definition for an infinite stream.\n# class InfiniteStream:\n#   def next(self) -> int:\n#     pass\n\nclass Solution:\n  def findPattern(\n      self,\n      stream: Optional['InfiniteStream'],\n      pattern: list[int],\n  ) -> int:\n    lps = self._getLPS(pattern)\n    i = 0  # stream's index\n    j = 0  # pattern's index\n    bit = 0  # the bit in the stream\n    readNext = False\n    while True:\n      if not readNext:\n        bit = stream.next()\n        readNext = True\n      if bit == pattern[j]:\n        i += 1\n        readNext = False\n        j += 1\n        if j == len(pattern):\n          return i - j\n      # Mismatch after j matches.\n      elif j > 0:\n        # Don't match lps[0..lps[j - 1]] since they will match anyway.\n        j = lps[j - 1]\n      else:\n        i += 1\n        readNext = False\n\n  def _getLPS(self, pattern: list[int]) -> list[int]:\n    \"\"\"\n    Returns the lps array, where lps[i] is the length of the longest prefix of\n    pattern[0..i] which is also a suffix of this substring.\n    \"\"\"\n    lps = [0] * len(pattern)\n    j = 0\n    for i in range(1, len(pattern)):\n      while j > 0 and pattern[j] != pattern[i]:\n        j = lps[j - 1]\n      if pattern[i] == pattern[j]:\n        j += 1\n        lps[i] = j\n    return lps\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3002, "slug": "maximum-size-of-a-set-after-removals", "solutions": ["class Solution:\n    def maximumSetSize(self, nums1: List[int], nums2: List[int]) -> int:\n        s1 = set(nums1)\n        s2 = set(nums2)\n        n = len(nums1)\n        a = min(len(s1 - s2), n // 2)\n        b = min(len(s2 - s1), n // 2)\n        return min(a + b + len(s1 & s2), n)\n", "class Solution:\n  def maximumSetSize(self, nums1: list[int], nums2: list[int]) -> int:\n    set1 = set(nums1)\n    set2 = set(nums2)\n    common = set1.intersection(set2)\n\n    n = len(nums1)\n    n1 = len(set1)\n    n2 = len(set2)\n    nc = len(common)\n    maxUniqueNums1 = min(n1 - nc, n // 2)\n    maxUniqueNums2 = min(n2 - nc, n // 2)\n    return min(n, maxUniqueNums1 + maxUniqueNums2 + nc)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3007, "slug": "maximum-number-that-sum-of-the-prices-is-less-than-or-equal-to-k", "solutions": ["class Solution:\n    def findMaximumNumber(self, k: int, x: int) -> int:\n        @cache\n        def dfs(pos, limit, cnt):\n            if pos == 0:\n                return cnt\n            ans = 0\n            up = (self.num >> (pos - 1) & 1) if limit else 1\n            for i in range(up + 1):\n                ans += dfs(pos - 1, limit and i == up, cnt + (i == 1 and pos % x == 0))\n            return ans\n\n        l, r = 1, 10**18\n        while l < r:\n            mid = (l + r + 1) >> 1\n            self.num = mid\n            v = dfs(mid.bit_length(), True, 0)\n            dfs.cache_clear()\n            if v <= k:\n                l = mid\n            else:\n                r = mid - 1\n        return l\n", "class Solution:\n  def findMaximumNumber(self, k: int, x: int) -> int:\n    def getSumPrices(num: int) -> int:\n      \"\"\"Returns the sum of prices of all numbers from 1 to `num`.\"\"\"\n      sumPrices = 0\n      # Increment `num` to account the 0-th row in the count of groups.\n      num += 1\n      for i in range(num.bit_length(), 0, -1):\n        if i % x == 0:\n          groupSize = 1 << i\n          halfGroupSize = 1 << i - 1\n          sumPrices += num // groupSize * halfGroupSize\n          sumPrices += max(0, (num % groupSize) - halfGroupSize)\n      return sumPrices\n\n    l = 1\n    r = 10**15\n    return bisect.bisect_right(range(l, r + 1), k, key=getSumPrices) - 1 + l\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3061, "slug": "calculate-trapping-rain-water", "solutions": ["import pandas as pd\n\n\ndef calculate_trapped_rain_water(heights: pd.DataFrame) -> pd.DataFrame:\n    heights[\"l\"] = heights[\"height\"].cummax()\n    heights[\"r\"] = heights[\"height\"][::-1].cummax()[::-1]\n    heights[\"trapped_water\"] = heights[[\"l\", \"r\"]].min(axis=1) - heights[\"height\"]\n    return pd.DataFrame({\"total_trapped_water\": [heights[\"trapped_water\"].sum()]})\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3097, "slug": "shortest-subarray-with-or-at-least-k-ii", "solutions": ["class Solution:\n    def minimumSubarrayLength(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        cnt = [0] * 32\n        ans = n + 1\n        s = i = 0\n        for j, x in enumerate(nums):\n            s |= x\n            for h in range(32):\n                if x >> h & 1:\n                    cnt[h] += 1\n            while s >= k and i <= j:\n                ans = min(ans, j - i + 1)\n                y = nums[i]\n                for h in range(32):\n                    if y >> h & 1:\n                        cnt[h] -= 1\n                        if cnt[h] == 0:\n                            s ^= 1 << h\n                i += 1\n        return -1 if ans > n else ans\n", "class Solution:\n  # Same as 3095. Shortest Subarray With OR at Least K I\n  def minimumSubarrayLength(self, nums: list[int], k: int) -> int:\n    ans = len(nums) + 1\n    ors = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, num in enumerate(nums):\n      ors = self._orNum(ors, num, count)\n      while ors >= k and l <= r:\n        ans = min(ans, r - l + 1)\n        ors = self._undoOrNum(ors, nums[l], count)\n        l += 1\n\n    return -1 if ans == len(nums) + 1 else ans\n\n  def _orNum(self, ors: int, num: int, count: dict[int, int]) -> int:\n    for i in range(30):\n      if num >> i & 1:\n        count[i] += 1\n        if count[i] == 1:\n          ors += 1 << i\n    return ors\n\n  def _undoOrNum(self, ors: int, num: int, count: dict[int, int]) -> int:\n    for i in range(30):\n      if num >> i & 1:\n        count[i] -= 1\n        if count[i] == 0:\n          ors -= 1 << i\n    return ors\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3012, "slug": "minimize-length-of-array-using-operations", "solutions": ["class Solution:\n    def minimumArrayLength(self, nums: List[int]) -> int:\n        mi = min(nums)\n        if any(x % mi for x in nums):\n            return 1\n        return (nums.count(mi) + 1) // 2\n", "class Solution:\n  def minimumArrayLength(self, nums: list[int]) -> int:\n    # Let the minimum number in the array `nums` be x.\n    # * If there exists any element nums[i] where nums[i] % x > 0, a new\n    #   minimum can be generated and all other numbers can be removed.\n    # * If not, count the frequency of x in `nums`. For each pair of x, a 0 is\n    #   generated which cannot be removed. Therefore, the result will be\n    #   (frequency of x + 1) / 2.\n    minNum = min(nums)\n    if any(num % minNum > 0 for num in nums):\n      return 1\n    return (nums.count(minNum) + 1) // 2\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3039, "slug": "apply-operations-to-make-string-empty", "solutions": ["class Solution:\n    def lastNonEmptyString(self, s: str) -> str:\n        cnt = Counter(s)\n        mx = cnt.most_common(1)[0][1]\n        last = {c: i for i, c in enumerate(s)}\n        return \"\".join(c for i, c in enumerate(s) if cnt[c] == mx and last[c] == i)\n", "class Solution:\n  def lastNonEmptyString(self, s: str) -> str:\n    ans = []\n    count = collections.Counter(s)\n    maxFreq = max(count.values())\n\n    for c in reversed(s):\n      if count[c] == maxFreq:\n        ans.append(c)\n        count[c] -= 1\n\n    return ''.join(reversed(ans))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3076, "slug": "shortest-uncommon-substring-in-an-array", "solutions": ["class Solution:\n    def shortestSubstrings(self, arr: List[str]) -> List[str]:\n        ans = [\"\"] * len(arr)\n        for i, s in enumerate(arr):\n            m = len(s)\n            for j in range(1, m + 1):\n                for l in range(m - j + 1):\n                    sub = s[l : l + j]\n                    if not ans[i] or ans[i] > sub:\n                        if all(k == i or sub not in t for k, t in enumerate(arr)):\n                            ans[i] = sub\n                if ans[i]:\n                    break\n        return ans\n", "class Solution:\n  def shortestSubstrings(self, arr: list[str]) -> list[str]:\n    ans = []\n    count = collections.Counter()\n\n    def getSubstrings(s: str) -> Iterator[str]:\n      for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n          yield s[i:j]\n\n    def add(s: str) -> None:\n      \"\"\"Adds all substrings of s to `count`.\"\"\"\n      for sub in getSubstrings(s):\n        count[sub] += 1\n\n    def remove(s: str) -> None:\n      \"\"\"Removes all substrings of s from `count`.\"\"\"\n      for sub in getSubstrings(s):\n        count[sub] -= 1\n\n    def getMinSub(s: str) -> str:\n      minSub = ''\n      for sub in getSubstrings(s):\n        if count[sub] > 0:\n          continue\n        if minSub == ('' or\n                      len(sub) < len(minSub) or\n                      len(sub) == len(minSub) and sub < minSub):\n          minSub = sub\n      return minSub\n\n    for s in arr:\n      add(s)\n\n    for s in arr:\n      remove(s)\n      ans.append(getMinSub(s))\n      add(s)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3027, "slug": "find-the-number-of-ways-to-place-people-ii", "solutions": ["class Solution:\n    def numberOfPairs(self, points: List[List[int]]) -> int:\n        points.sort(key=lambda x: (x[0], -x[1]))\n        ans = 0\n        for i, (_, y1) in enumerate(points):\n            max_y = -inf\n            for _, y2 in points[i + 1 :]:\n                if max_y < y2 <= y1:\n                    max_y = y2\n                    ans += 1\n        return ans\n", "class Solution:\n  # Same as 3025. Find the Number of Ways to Place People I\n  def numberOfPairs(self, points: list[list[int]]) -> int:\n    ans = 0\n\n    points.sort(key=lambda x: (x[0], -x[1]))\n\n    for i, (_, yi) in enumerate(points):\n      maxY = -math.inf\n      for j in range(i + 1, len(points)):\n        _, yj = points[j]\n        # Chisato is in the upper-left corner at (xi, yi), and Takina is in the\n        # lower-right corner at (xj, yj). Also, if yj > maxY, it means that\n        # nobody other than Chisato and Takina is inside or on the fence.\n        if yi >= yj > maxY:\n          ans += 1\n          maxY = yj\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3086, "slug": "minimum-moves-to-pick-k-ones", "solutions": ["class Solution:\n    def minimumMoves(self, nums: List[int], k: int, maxChanges: int) -> int:\n        n = len(nums)\n        cnt = [0] * (n + 1)\n        s = [0] * (n + 1)\n        for i, x in enumerate(nums, 1):\n            cnt[i] = cnt[i - 1] + x\n            s[i] = s[i - 1] + i * x\n        ans = inf\n        max = lambda x, y: x if x > y else y\n        min = lambda x, y: x if x < y else y\n        for i, x in enumerate(nums, 1):\n            t = 0\n            need = k - x\n            for j in (i - 1, i + 1):\n                if need > 0 and 1 <= j <= n and nums[j - 1] == 1:\n                    need -= 1\n                    t += 1\n            c = min(need, maxChanges)\n            need -= c\n            t += c * 2\n            if need <= 0:\n                ans = min(ans, t)\n                continue\n            l, r = 2, max(i - 1, n - i)\n            while l <= r:\n                mid = (l + r) >> 1\n                l1, r1 = max(1, i - mid), max(0, i - 2)\n                l2, r2 = min(n + 1, i + 2), min(n, i + mid)\n                c1 = cnt[r1] - cnt[l1 - 1]\n                c2 = cnt[r2] - cnt[l2 - 1]\n                if c1 + c2 >= need:\n                    t1 = c1 * i - (s[r1] - s[l1 - 1])\n                    t2 = s[r2] - s[l2 - 1] - c2 * i\n                    ans = min(ans, t + t1 + t2)\n                    r = mid - 1\n                else:\n                    l = mid + 1\n        return ans\n", "class Solution:\n  def minimumMoves(self, nums: list[int], k: int, maxChanges: int) -> int:\n    # Dylan has two actions for collecting '1's in a sequence:\n    # Action 1: Put a '1' next to him and pick it up.\n    #           The cost is 2.\n    # Action 2: Swap a '1' towards him and collect it.\n    #           The cost equals the distance to the '1'.\n    #\n    # To minimize the swapping cost, Dylan can use a sliding window strategy,\n    # selecting the optimal position (middle '1' in the window) for efficient\n    # collection. The window's size is crucial:\n\n    # The minimum window size: min(0, k - maxChanges), ensuring the window\n    # isn't too small.\n    # The maximum window size: min(k, minOnesByTwo + 3, the number of ones),\n    # preventing overly ambitious swaps.\n    #\n    # Note that if needing to move a '1' beyond `minOnesByTwo + 3`, it's\n    # cheaper to use Action 1.\n\n    # At most three indices, (dylanIndex - 1, dylanIndex, dylanIndex + 1), have\n    # a distance <= 1 from dylanIndex, implying that we'll be taking at most\n    # `maxOnesByTwo + 3` using Action 2. Any more Action 2 is not optimal and\n    # should be replaced with Action 1.\n    NUM_OF_INDICES_WITHIN_ONE_DISTANCE = 3\n    ans = math.inf\n    oneIndices = [i for i, num in enumerate(nums) if num == 1]\n    prefix = list(itertools.accumulate(oneIndices, initial=0))\n\n    minOnesByTwo = max(0, k - maxChanges)\n    maxOnesByTwo = min(\n        k, minOnesByTwo + NUM_OF_INDICES_WITHIN_ONE_DISTANCE, len(oneIndices))\n\n    for onesByTwo in range(minOnesByTwo, maxOnesByTwo + 1):\n      for l in range(len(prefix) - onesByTwo):\n        r = l + onesByTwo  # Collect 1s in oneIndices[l - 1..r - 1].\n        cost1 = (k - onesByTwo) * 2\n        cost2 = ((prefix[r] - prefix[(l + r) // 2]) -\n                 (prefix[(l + r + 1) // 2] - prefix[l]))\n        ans = min(ans, cost1 + cost2)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3079, "slug": "find-the-sum-of-encrypted-integers", "solutions": ["class Solution:\n    def sumOfEncryptedInt(self, nums: List[int]) -> int:\n        def encrypt(x: int) -> int:\n            mx = p = 0\n            while x:\n                x, v = divmod(x, 10)\n                mx = max(mx, v)\n                p = p * 10 + 1\n            return mx * p\n\n        return sum(encrypt(x) for x in nums)\n", "class Solution:\n  def sumOfEncryptedInt(self, nums: list[int]) -> int:\n    def getEncrypted(num: int) -> int:\n      maxDigit = 0\n      base = 0\n      while num > 0:\n        maxDigit = max(maxDigit, num % 10)\n        base = base * 10 + 1\n        num //= 10\n      return base * maxDigit\n\n    return sum(getEncrypted(num) for num in nums)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3045, "slug": "count-prefix-and-suffix-pairs-ii", "solutions": ["class Node:\n    __slots__ = [\"children\", \"cnt\"]\n\n    def __init__(self):\n        self.children = {}\n        self.cnt = 0\n\n\nclass Solution:\n    def countPrefixSuffixPairs(self, words: List[str]) -> int:\n        ans = 0\n        trie = Node()\n        for s in words:\n            node = trie\n            for p in zip(s, reversed(s)):\n                if p not in node.children:\n                    node.children[p] = Node()\n                node = node.children[p]\n                ans += node.cnt\n            node.cnt += 1\n        return ans\n", "class TrieNode:\n  def __init__(self):\n    self.children: dict[tuple[str, str], TrieNode] = {}\n    self.count = 0\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, word: str) -> int:\n    node = self.root\n    count = 0\n    for i, prefix in enumerate(word):\n      suffix = word[-1 - i]\n      node = node.children.setdefault((prefix, suffix), TrieNode())\n      count += node.count\n    node.count += 1\n    return count\n\n\nclass Solution:\n  # Same as 3045. Count Prefix and Suffix Pairs II\n  def countPrefixSuffixPairs(self, words: list[str]) -> int:\n    trie = Trie()\n    return sum(trie.insert(word) for word in words)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3062, "slug": "winner-of-the-linked-list-game", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def gameResult(self, head: Optional[ListNode]) -> str:\n        odd = even = 0\n        while head:\n            a = head.val\n            b = head.next.val\n            odd += a < b\n            even += a > b\n            head = head.next.next\n        if odd > even:\n            return \"Odd\"\n        if odd < even:\n            return \"Even\"\n        return \"Tie\"\n", "class Solution:\n  def gameResult(self, head: ListNode | None) -> str:\n    even = 0\n    odd = 0\n\n    while head:\n      if head.val > head.next.val:\n        even += 1\n      elif head.val < head.next.val:\n        odd += 1\n      head = head.next.next\n\n    if even > odd:\n      return 'Even'\n    if even < odd:\n      return 'Odd'\n    return 'Tie'\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3043, "slug": "find-the-length-of-the-longest-common-prefix", "solutions": ["class Solution:\n    def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:\n        s = set()\n        for x in arr1:\n            while x:\n                s.add(x)\n                x //= 10\n        ans = 0\n        for x in arr2:\n            while x:\n                if x in s:\n                    ans = max(ans, len(str(x)))\n                    break\n                x //= 10\n        return ans\n", "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, word: str) -> None:\n    node: TrieNode = self.root\n    for c in word:\n      node = node.children.setdefault(c, TrieNode())\n    node.isWord = True\n\n  def search(self, word: str) -> int:\n    prefixLength = 0\n    node = self.root\n    for c in word:\n      if c not in node.children:\n        break\n      node = node.children[c]\n      prefixLength += 1\n    return prefixLength\n\n\nclass Solution:\n  def longestCommonPrefix(self, arr1: list[int], arr2: list[int]) -> int:\n    trie = Trie()\n\n    for num in arr1:\n      trie.insert(str(num))\n\n    return max(trie.search(str(num)) for num in arr2)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3048, "slug": "earliest-second-to-mark-indices-i", "solutions": ["class Solution:\n    def earliestSecondToMarkIndices(\n        self, nums: List[int], changeIndices: List[int]\n    ) -> int:\n        def check(t: int) -> bool:\n            decrement = 0\n            marked = 0\n            last = {i: s for s, i in enumerate(changeIndices[:t])}\n            for s, i in enumerate(changeIndices[:t]):\n                if last[i] == s:\n                    if decrement < nums[i - 1]:\n                        return False\n                    decrement -= nums[i - 1]\n                    marked += 1\n                else:\n                    decrement += 1\n            return marked == len(nums)\n\n        m = len(changeIndices)\n        l = bisect_left(range(1, m + 2), True, key=check) + 1\n        return -1 if l > m else l\n", "class Solution:\n  def earliestSecondToMarkIndices(\n      self,\n      nums: list[int],\n      changeIndices: list[int],\n  ) -> int:\n    def canMark(second: int) -> bool:\n      \"\"\"\n      Returns True if all indices of `nums` can be marked within `second`.\n      \"\"\"\n      numMarked = 0\n      decrement = 0\n      indexToLastSecond = {}\n\n      for i in range(second):\n        indexToLastSecond[changeIndices[i] - 1] = i\n\n      for i in range(second):\n        index = changeIndices[i] - 1  # Convert to 0-indexed\n        if i == indexToLastSecond[index]:\n          # Reach the last occurrence of the number.\n          # So, the current second will be used to mark the index.\n          if nums[index] > decrement:\n            # The decrement is less than the number to be marked.\n            return False\n          decrement -= nums[index]\n          numMarked += 1\n        else:\n          decrement += 1\n\n      return numMarked == len(nums)\n\n    l = 1\n    r = len(changeIndices) + 1\n    ans = bisect.bisect_left(range(l, r), True, key=canMark) + l\n    return ans if ans <= len(changeIndices) else -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3033, "slug": "modify-the-matrix", "solutions": ["class Solution:\n    def modifiedMatrix(self, matrix: List[List[int]]) -> List[List[int]]:\n        m, n = len(matrix), len(matrix[0])\n        for j in range(n):\n            mx = max(matrix[i][j] for i in range(m))\n            for i in range(m):\n                if matrix[i][j] == -1:\n                    matrix[i][j] = mx\n        return matrix\n", "class Solution:\n  def modifiedMatrix(self, matrix: list[list[int]]) -> list[list[int]]:\n    m = len(matrix)\n    n = len(matrix[0])\n    ans = matrix.copy()\n\n    for j in range(n):\n      mx = max(matrix[i][j] for i in range(m))\n      for i in range(m):\n        if matrix[i][j] == -1:\n          ans[i][j] = mx\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3054, "slug": "binary-tree-nodes", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3022, "slug": "minimize-or-of-remaining-elements-using-operations", "solutions": ["class Solution:\n    def minOrAfterOperations(self, nums: List[int], k: int) -> int:\n        ans = 0\n        rans = 0\n        for i in range(29, -1, -1):\n            test = ans + (1 << i)\n            cnt = 0\n            val = 0\n            for num in nums:\n                if val == 0:\n                    val = test & num\n                else:\n                    val &= test & num\n                if val:\n                    cnt += 1\n            if cnt > k:\n                rans += 1 << i\n            else:\n                ans += 1 << i\n        return rans\n", "class Solution:\n  def minOrAfterOperations(self, nums: list[int], k: int) -> int:\n    MAX_BIT = 30\n    ans = 0\n    prefixMask = 0  # Grows like: 10000 -> 11000 -> ... -> 11111\n\n    for i in range(MAX_BIT, -1, -1):\n      # Add the i-th bit to `prefixMask` and attempt to \"turn off\" the\n      # currently added bit within k operations. If it's impossible, then we\n      # add the i-th bit to the answer.\n      prefixMask |= 1 << i\n      if self._getMergeOps(nums, prefixMask, ans) > k:\n        ans |= 1 << i\n\n    return ans\n\n  def _getMergeOps(self, nums: list[int], prefixMask: int, target: int) -> int:\n    \"\"\"\n    Returns the number of merge operations to turn `prefixMask` to the target\n    by ANDing `nums`.\n    \"\"\"\n    mergeOps = 0\n    ands = prefixMask\n    for num in nums:\n      ands &= num\n      if (ands | target) == target:\n        ands = prefixMask\n      else:\n        mergeOps += 1  # Keep merging the next num\n    return mergeOps\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3078, "slug": "match-alphanumerical-pattern-in-matrix-i", "solutions": ["class Solution:\n    def findPattern(self, board: List[List[int]], pattern: List[str]) -> List[int]:\n        def check(i: int, j: int) -> bool:\n            d1 = {}\n            d2 = {}\n            for a in range(r):\n                for b in range(c):\n                    x, y = i + a, j + b\n                    if pattern[a][b].isdigit():\n                        if int(pattern[a][b]) != board[x][y]:\n                            return False\n                    else:\n                        if pattern[a][b] in d1 and d1[pattern[a][b]] != board[x][y]:\n                            return False\n                        if board[x][y] in d2 and d2[board[x][y]] != pattern[a][b]:\n                            return False\n                        d1[pattern[a][b]] = board[x][y]\n                        d2[board[x][y]] = pattern[a][b]\n            return True\n\n        m, n = len(board), len(board[0])\n        r, c = len(pattern), len(pattern[0])\n        for i in range(m - r + 1):\n            for j in range(n - c + 1):\n                if check(i, j):\n                    return [i, j]\n        return [-1, -1]\n", "class Solution:\n  def findPattern(\n      self,\n      board: list[list[int]],\n      pattern: list[str],\n  ) -> list[int]:\n    def isMatch(x: int, y: int) -> bool:\n      digitToLetter = {}\n      letterToDigit = {}\n      for i, row in enumerate(pattern):\n        for j, c in enumerate(row):\n          digit = board[i + x][j + y]\n          if c.isdigit():\n            if int(c) != digit:\n              return False\n          else:\n            if digitToLetter.get(digit, c) != c:\n              return False\n            if letterToDigit.get(c, digit) != digit:\n              return False\n            digitToLetter[digit] = c\n            letterToDigit[c] = digit\n      return True\n\n    for x in range(len(board) - len(pattern) + 1):\n      for y in range(len(board[0]) - len(pattern[0]) + 1):\n        if isMatch(x, y):\n          return [x, y]\n\n    return [-1, -1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3026, "slug": "maximum-good-subarray-sum", "solutions": ["class Solution:\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\n        ans = -inf\n        p = {nums[0]: 0}\n        s, n = 0, len(nums)\n        for i, x in enumerate(nums):\n            s += x\n            if x - k in p:\n                ans = max(ans, s - p[x - k])\n            if x + k in p:\n                ans = max(ans, s - p[x + k])\n            if i + 1 < n and (nums[i + 1] not in p or p[nums[i + 1]] > s):\n                p[nums[i + 1]] = s\n        return 0 if ans == -inf else ans\n", "class Solution:\n  def maximumSubarraySum(self, nums: list[int], k: int) -> int:\n    ans = -math.inf\n    prefix = 0\n    numToMinPrefix = {}\n\n    for num in nums:\n      if num not in numToMinPrefix or numToMinPrefix[num] > prefix:\n        numToMinPrefix[num] = prefix\n      prefix += num\n      if num + k in numToMinPrefix:\n        ans = max(ans, prefix - numToMinPrefix[num + k])\n      if num - k in numToMinPrefix:\n        ans = max(ans, prefix - numToMinPrefix[num - k])\n\n    return 0 if ans == -math.inf else ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3035, "slug": "maximum-palindromes-after-operations", "solutions": ["class Solution:\n    def maxPalindromesAfterOperations(self, words: List[str]) -> int:\n        s = mask = 0\n        for w in words:\n            s += len(w)\n            for c in w:\n                mask ^= 1 << (ord(c) - ord(\"a\"))\n        s -= mask.bit_count()\n        words.sort(key=len)\n        ans = 0\n        for w in words:\n            s -= len(w) // 2 * 2\n            if s < 0:\n                break\n            ans += 1\n        return ans\n", "class Solution:\n  def maxPalindromesAfterOperations(self, words: list[str]) -> int:\n    ans = 0\n    count = collections.Counter(''.join(words))\n    pairs = sum(value // 2 for value in count.values())\n\n    for length in sorted(len(word) for word in words):\n      needPairs = length // 2\n      if pairs < needPairs:\n        return ans\n      ans += 1\n      pairs -= needPairs\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3004, "slug": "maximum-subtree-of-the-same-color", "solutions": ["class Solution:\n    def maximumSubtreeSize(self, edges: List[List[int]], colors: List[int]) -> int:\n        def dfs(a: int, fa: int) -> bool:\n            ok = True\n            for b in g[a]:\n                if b != fa:\n                    t = dfs(b, a)\n                    ok = ok and colors[a] == colors[b] and t\n                    size[a] += size[b]\n            if ok:\n                nonlocal ans\n                ans = max(ans, size[a])\n            return ok\n\n        n = len(edges) + 1\n        g = [[] for _ in range(n)]\n        size = [1] * n\n        for a, b in edges:\n            g[a].append(b)\n            g[b].append(a)\n        ans = 0\n        dfs(0, -1)\n        return ans\n", "class Solution:\n  def maximumSubtreeSize(\n      self,\n      edges: list[list[int]],\n      colors: list[int],\n  ) -> int:\n    ans = 1\n    tree = [[] for _ in range(len(colors))]\n\n    for u, v in edges:\n      tree[u].append(v)\n\n    def dfs(u: int) -> int:\n      \"\"\"\n      Returns the size of subtree of u if every node in the subtree has the same\n      color. Otherwise, returns -1.\n      \"\"\"\n      nonlocal ans\n      res = 1\n      for v in tree[u]:\n        if colors[v] != colors[u]:\n          res = -1\n        # If any node in the subtree of v has a different color, the result of\n        # the subtree of u will be -1 as well.\n        subtreeSize = dfs(v)\n        if subtreeSize == -1:\n          res = -1\n        elif res != -1:\n          res += subtreeSize\n      ans = max(ans, res)\n      return res\n\n    dfs(0)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3050, "slug": "pizza-toppings-cost-analysis", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3059, "slug": "find-all-unique-email-domains", "solutions": ["import pandas as pd\n\n\ndef find_unique_email_domains(emails: pd.DataFrame) -> pd.DataFrame:\n    emails[\"email_domain\"] = emails[\"email\"].str.split(\"@\").str[-1]\n    emails = emails[emails[\"email\"].str.contains(\".com\")]\n    return (\n        emails.groupby(\"email_domain\")\n        .size()\n        .reset_index(name=\"count\")\n        .sort_values(by=\"email_domain\")\n    )\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3042, "slug": "count-prefix-and-suffix-pairs-i", "solutions": ["class Solution:\n    def countPrefixSuffixPairs(self, words: List[str]) -> int:\n        ans = 0\n        for i, s in enumerate(words):\n            for t in words[i + 1 :]:\n                ans += t.endswith(s) and t.startswith(s)\n        return ans\n", "class TrieNode:\n  def __init__(self):\n    self.children: dict[tuple[str, str], TrieNode] = {}\n    self.count = 0\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, word: str) -> int:\n    node = self.root\n    count = 0\n    for i, prefix in enumerate(word):\n      suffix = word[-1 - i]\n      node = node.children.setdefault((prefix, suffix), TrieNode())\n      count += node.count\n    node.count += 1\n    return count\n\n\nclass Solution:\n  def countPrefixSuffixPairs(self, words: list[str]) -> int:\n    trie = Trie()\n    return sum(trie.insert(word) for word in words)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3015, "slug": "count-the-number-of-houses-at-a-certain-distance-i", "solutions": ["class Solution:\n    def countOfPairs(self, n: int, x: int, y: int) -> List[int]:\n        x, y = x - 1, y - 1\n        ans = [0] * n\n        for i in range(n):\n            for j in range(i + 1, n):\n                a = j - i\n                b = abs(i - x) + 1 + abs(j - y)\n                c = abs(i - y) + 1 + abs(j - x)\n                ans[min(a, b, c) - 1] += 2\n        return ans\n", "class Solution:\n  def countOfPairs(self, n: int, x: int, y: int) -> list[int]:\n    if x > y:\n      x, y = y, x\n\n    def bothInRing(ringLen: int) -> list[int]:\n      \"\"\"\n      Returns the contribution from the scenario where two houses are located\n      in the ring.\n      \"\"\"\n      res = [0] * n\n      for k in range(1, (ringLen - 1) // 2 + 1):\n        res[k - 1] += ringLen\n      if ringLen % 2 == 0:\n        res[ringLen // 2 - 1] += ringLen // 2\n      return res\n\n    def bothInTheSameLine(lineLen: int) -> list[int]:\n      \"\"\"\n      Returns the contribution from the scenario where two houses are either\n      located in the left line [1, x) or the right line (y, n].\n      \"\"\"\n      res = [0] * n\n      for k in range(1, lineLen + 1):\n        res[k - 1] += lineLen - k\n      return res\n\n    def lineToRing(lineLen: int, ringLen: int) -> list[int]:\n      \"\"\"\n      Returns the contribution from the scenario where one house is either\n      located in the left line [1, x) or the right line (y, n] and the\n      other house is located in the cycle.\n      \"\"\"\n      res = [0] * n\n      for k in range(1, lineLen + ringLen):\n        # min(\n        #   at most k - 1 since we need to give 1 to the line,\n        #   at most ringLen / 2 since for length > ringLen / 2, it can always be\n        #     calculated as ringLen - ringLen / 2\n        # )\n        maxInRingLen = min(k - 1, ringLen // 2)\n        # max(at least 0, at lest k - lineLen)\n        minInRingLen = max(0, k - lineLen)\n        if minInRingLen <= maxInRingLen:\n          # Each ring length contributes 2 to the count due to the split of\n          # paths when entering the ring: One path traverses the upper half of\n          # the ring, and the other traverses the lower half.\n          # This is illustrated as follows:\n          #   Path 1: ... -- x -- (upper half of the ring)\n          #   Path 2: ... -- x -- (lower half of the ring)\n          res[k - 1] += (maxInRingLen - minInRingLen + 1) * 2\n          if minInRingLen == 0:\n            # Subtract 1 since there's no split.\n            res[k - 1] -= 1\n          if maxInRingLen * 2 == ringLen:\n            # Subtract 1 since the following case only contribute one:\n            #   ... -- x -- (upper half of the ring) -- middle point\n            #   ... -- x -- (upper half of the ring) -- middle point\n            res[k - 1] -= 1\n      return res\n\n    def lineToLine(leftLineLen: int, rightLineLen: int) -> list[int]:\n      \"\"\"\n      Returns the contribution from the scenario where one house is in the left\n      line [1, x) and the other house is in the right line (y, n].\n      \"\"\"\n      res = [0] * n\n      for k in range(leftLineLen + rightLineLen + 2):\n        # min(\n        #   at most leftLineLen,\n        #   at most k - 1 - (x < y) since we need to give 1 to the right line\n        #     and if x < y we need to give another 1 to \"x - y\".\n        # )\n        maxInLeft = min(leftLineLen, k - 1 - (x < y))\n        # max(at least 1, at least k - rightLineLen - (x < y))\n        minInLeft = max(1, k - rightLineLen - (x < y))\n        if minInLeft <= maxInLeft:\n          res[k - 1] += maxInLeft - minInLeft + 1\n      return res\n\n    ringLen = y - x + 1\n    leftLineLen = x - 1\n    rightLineLen = (n - y)\n\n    ans = [0] * n\n    ans = list(map(operator.add, ans, bothInRing(ringLen)))\n    ans = list(map(operator.add, ans, bothInTheSameLine(leftLineLen)))\n    ans = list(map(operator.add, ans, bothInTheSameLine(rightLineLen)))\n    ans = list(map(operator.add, ans, lineToRing(leftLineLen, ringLen)))\n    ans = list(map(operator.add, ans, lineToRing(rightLineLen, ringLen)))\n    ans = list(map(operator.add, ans, lineToLine(leftLineLen, rightLineLen)))\n    return [freq * 2 for freq in ans]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3090, "slug": "maximum-length-substring-with-two-occurrences", "solutions": ["class Solution:\n    def maximumLengthSubstring(self, s: str) -> int:\n        cnt = Counter()\n        ans = i = 0\n        for j, c in enumerate(s):\n            cnt[c] += 1\n            while cnt[c] > 2:\n                cnt[s[i]] -= 1\n                i += 1\n            ans = max(ans, j - i + 1)\n        return ans\n", "class Solution:\n  def maximumLengthSubstring(self, s: str) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] += 1\n      while count[c] > 2:\n        count[s[l]] -= 1\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3096, "slug": "minimum-levels-to-gain-more-points", "solutions": ["class Solution:\n    def minimumLevels(self, possible: List[int]) -> int:\n        s = sum(-1 if x == 0 else 1 for x in possible)\n        t = 0\n        for i, x in enumerate(possible[:-1], 1):\n            t += -1 if x == 0 else 1\n            if t > s - t:\n                return i\n        return -1\n", "class Solution:\n  def minimumLevels(self, possible: list[int]) -> int:\n    n = len(possible)\n    nums = [num if num == 1 else -1 for num in possible]\n    prefix = list(itertools.accumulate(nums, initial=0))\n\n    for i in range(1, n):\n      if prefix[i] > prefix[n] - prefix[i]:\n        return i\n\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3044, "slug": "most-frequent-prime", "solutions": ["class Solution:\n    def mostFrequentPrime(self, mat: List[List[int]]) -> int:\n        def is_prime(x: int) -> int:\n            return all(x % i != 0 for i in range(2, isqrt(x) + 1))\n\n        m, n = len(mat), len(mat[0])\n        cnt = Counter()\n        for i in range(m):\n            for j in range(n):\n                for a in range(-1, 2):\n                    for b in range(-1, 2):\n                        if a == 0 and b == 0:\n                            continue\n                        x, y, v = i + a, j + b, mat[i][j]\n                        while 0 <= x < m and 0 <= y < n:\n                            v = v * 10 + mat[x][y]\n                            if is_prime(v):\n                                cnt[v] += 1\n                            x, y = x + a, y + b\n        ans, mx = -1, 0\n        for v, x in cnt.items():\n            if mx < x:\n                mx = x\n                ans = v\n            elif mx == x:\n                ans = max(ans, v)\n        return ans\n", "class Solution:\n  def mostFrequentPrime(self, mat: list[list[int]]) -> int:\n    DIRS = ((1, 0), (1, -1), (0, -1), (-1, -1),\n            (-1, 0), (-1, 1), (0, 1), (1, 1))\n    m = len(mat)\n    n = len(mat[0])\n    count = collections.Counter()\n\n    def isPrime(num: int) -> bool:\n      return not any(num % i == 0 for i in range(2, int(num**0.5 + 1)))\n\n    for i in range(m):\n      for j in range(n):\n        for dx, dy in DIRS:\n          num = 0\n          x = i\n          y = j\n          while 0 <= x < m and 0 <= y < n:\n            num = num * 10 + mat[x][y]\n            if num > 10 and isPrime(num):\n              count[num] += 1\n            x += dx\n            y += dy\n\n    if not count.items():\n      return -1\n    return max(count.items(), key=lambda x: (x[1], x[0]))[0]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3046, "slug": "split-the-array", "solutions": ["class Solution:\n    def isPossibleToSplit(self, nums: List[int]) -> bool:\n        return max(Counter(nums).values()) < 3\n", "class Solution:\n  def isPossibleToSplit(self, nums: list[int]) -> bool:\n    return all(freq <= 2 for freq in collections.Counter(nums).values())\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3082, "slug": "find-the-sum-of-the-power-of-all-subsequences", "solutions": ["class Solution:\n    def sumOfPower(self, nums: List[int], k: int) -> int:\n        mod = 10**9 + 7\n        n = len(nums)\n        f = [[0] * (k + 1) for _ in range(n + 1)]\n        f[0][0] = 1\n        for i, x in enumerate(nums, 1):\n            for j in range(k + 1):\n                f[i][j] = f[i - 1][j] * 2 % mod\n                if j >= x:\n                    f[i][j] = (f[i][j] + f[i - 1][j - x]) % mod\n        return f[n][k]\n", "class Solution:\n  def sumOfPower(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i] := the number of subsequences in nums so far that sums to k\n    dp = [1] + [0] * k\n\n    for num in nums:\n      for i in range(k, -1, -1):\n        if i < num:\n          dp[i] = (dp[i] * 2) % MOD\n        else:\n          dp[i] = (dp[i] * 2 + dp[i - num]) % MOD\n\n    return dp[k]\n", "class Solution:\n  def sumOfPower(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    n = len(nums)\n    # dp[i][j] := the number of subsequences in nums[0..i) that sums to k\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n      num = nums[i - 1]\n      for j in range(k + 1):\n        if j < num:\n          # 1. Exclude nums[i] in the subsequence.\n          # 2. Include nums[i] in the subsequence and skip it.\n          dp[i][j] = (dp[i - 1][j] * 2) % MOD\n        else:\n          # 1. Exclude nums[i] in the subsequence.\n          # 2. Include nums[i] in the subsequence and skip it.\n          # 3. Include nums[i] in the subsequence and pick it.\n          dp[i][j] = (dp[i - 1][j] * 2 + dp[i - 1][j - num]) % MOD\n\n    return dp[n][k]\n", "class Solution:\n  def sumOfPower(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int) -> int:\n      \"\"\"Returns the number of subsequences in nums[i..n) that sums to j.\"\"\"\n      if j == 0:\n        # For each of the remaining number, we can either pick it or skip it.\n        return pow(2, len(nums) - i, MOD)\n      if i == len(nums) or j < 0:\n        return 0\n        # 1. Include nums[i] in the subsequence and pick it.\n        # 2. Include nums[i] in the subsequence and skip it.\n        # 3. Exclude nums[i] in the subsequence.\n      return (dp(i + 1, j - nums[i]) + 2 * dp(i + 1, j)) % MOD\n\n    return dp(0, k)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3036, "slug": "number-of-subarrays-that-match-a-pattern-ii", "solutions": ["def partial(s):\n    g, pi = 0, [0] * len(s)\n    for i in range(1, len(s)):\n        while g and (s[g] != s[i]):\n            g = pi[g - 1]\n        pi[i] = g = g + (s[g] == s[i])\n    return pi\n\n\ndef match(s, pat):\n    pi = partial(pat)\n    g, idx = 0, []\n    for i in range(len(s)):\n        while g and pat[g] != s[i]:\n            g = pi[g - 1]\n        g += pat[g] == s[i]\n        if g == len(pi):\n            idx.append(i + 1 - g)\n            g = pi[g - 1]\n    return idx\n\n\ndef string_find(s, pat):\n    pi = partial(pat)\n    g = 0\n    for i in range(len(s)):\n        while g and pat[g] != s[i]:\n            g = pi[g - 1]\n        g += pat[g] == s[i]\n        if g == len(pi):\n            return True\n    return False\n\n\nclass Solution:\n    def countMatchingSubarrays(self, nums: List[int], pattern: List[int]) -> int:\n        s = []\n        for i in range(1, len(nums)):\n            if nums[i] > nums[i - 1]:\n                s.append(1)\n            elif nums[i] == nums[i - 1]:\n                s.append(0)\n            else:\n                s.append(-1)\n        return len(match(s, pattern))\n", "class Solution:\n  # Same as 3034. Number of Subarrays That Match a Pattern I\n  def countMatchingSubarrays(self, nums: list[int], pattern: list[int]) -> int:\n    def getNum(a: int, b: int) -> int:\n      if a < b:\n        return 1\n      if a > b:\n        return -1\n      return 0\n\n    numsPattern = [getNum(a, b) for a, b in itertools.pairwise(nums)]\n    return self._kmp(numsPattern, pattern)\n\n  def _kmp(self, nums: list[int], pattern: list[int]) -> int:\n    \"\"\"Returns the number of occurrences of the pattern in `nums`.\"\"\"\n\n    def getLPS(nums: list[int]) -> list[int]:\n      \"\"\"\n      Returns the lps array, where lps[i] is the length of the longest prefix of\n      nums[0..i] which is also a suffix of this substring.\n      \"\"\"\n      lps = [0] * len(nums)\n      j = 0\n      for i in range(1, len(nums)):\n        while j > 0 and nums[j] != nums[i]:\n          j = lps[j - 1]\n        if nums[i] == nums[j]:\n          lps[i] = j + 1\n          j += 1\n      return lps\n\n    lps = getLPS(pattern)\n    res = 0\n    i = 0  # s' index\n    j = 0  # pattern's index\n    while i < len(nums):\n      if nums[i] == pattern[j]:\n        i += 1\n        j += 1\n        if j == len(pattern):\n          res += 1\n          j = lps[j - 1]\n      elif j != 0:  # Mismatch after j matches.\n        # Don't match lps[0..lps[j - 1]] since they will match anyway.\n        j = lps[j - 1]\n      else:\n        i += 1\n    return res\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3070, "slug": "count-submatrices-with-top-left-element-and-sum-less-than-k", "solutions": ["class Solution:\n    def countSubmatrices(self, grid: List[List[int]], k: int) -> int:\n        s = [[0] * (len(grid[0]) + 1) for _ in range(len(grid) + 1)]\n        ans = 0\n        for i, row in enumerate(grid, 1):\n            for j, x in enumerate(row, 1):\n                s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + x\n                ans += s[i][j] <= k\n        return ans\n", "class Solution:\n  def countSubmatrices(self, grid: list[list[int]], k: int) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    # prefix[i][j] := the sum of matrix[0..i)[0..j)\n    prefix = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m):\n      for j in range(n):\n        prefix[i + 1][j + 1] = (grid[i][j] + prefix[i][j + 1] +\n                                prefix[i + 1][j] - prefix[i][j])\n        if prefix[i + 1][j + 1] <= k:\n          ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3083, "slug": "existence-of-a-substring-in-a-string-and-its-reverse", "solutions": ["class Solution:\n    def isSubstringPresent(self, s: str) -> bool:\n        st = {(a, b) for a, b in pairwise(s[::-1])}\n        return any((a, b) in st for a, b in pairwise(s))\n", "class Solution:\n  def isSubstringPresent(self, s: str) -> bool:\n    return any(s[i:i + 2] in s[::-1] for i in range(len(s) - 1))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3057, "slug": "employees-project-allocation", "solutions": ["import pandas as pd\n\n\ndef employees_with_above_avg_workload(\n    project: pd.DataFrame, employees: pd.DataFrame\n) -> pd.DataFrame:\n    merged_df = pd.merge(project, employees, on=\"employee_id\")\n    avg_workload_per_team = merged_df.groupby(\"team\")[\"workload\"].mean().reset_index()\n    merged_df = pd.merge(\n        merged_df, avg_workload_per_team, on=\"team\", suffixes=(\"\", \"_avg\")\n    )\n    ans = merged_df[merged_df[\"workload\"] > merged_df[\"workload_avg\"]]\n    ans = ans[[\"employee_id\", \"project_id\", \"name\", \"workload\"]]\n    ans = ans.rename(columns={\"name\": \"employee_name\", \"workload\": \"project_workload\"})\n    return ans.sort_values(by=[\"employee_id\", \"project_id\"])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3011, "slug": "find-if-array-can-be-sorted", "solutions": ["class Solution:\n    def canSortArray(self, nums: List[int]) -> bool:\n        pre_mx = 0\n        i, n = 0, len(nums)\n        while i < n:\n            cnt = nums[i].bit_count()\n            j = i + 1\n            mi = mx = nums[i]\n            while j < n and nums[j].bit_count() == cnt:\n                mi = min(mi, nums[j])\n                mx = max(mx, nums[j])\n                j += 1\n            if pre_mx > mi:\n                return False\n            pre_mx = mx\n            i = j\n        return True\n", "class Solution:\n  def canSortArray(self, nums: list[int]) -> int:\n    # Divide the array into distinct segments where each segment is comprised\n    # of consecutive elements sharing an equal number of set bits. Ensure that\n    # for each segment, when moving from left to right, the maximum of a\n    # preceding segment is less than the minimum of the following segment.\n    prevSetBits = 0\n    prevMax = -math.inf  # the maximum of the previous segment\n    currMax = -math.inf  # the maximum of the current segment\n    currMin = math.inf   # the minimum of the current segment\n\n    for num in nums:\n      setBits = num.bit_count()\n      if setBits != prevSetBits:  # Start a new segment.\n        if prevMax > currMin:\n          return False\n        prevSetBits = setBits\n        prevMax = currMax\n        currMax = num\n        currMin = num\n      else:  # Continue with the current segment.\n        currMax = max(currMax, num)\n        currMin = min(currMin, num)\n\n    return prevMax <= currMin\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3081, "slug": "replace-question-marks-in-string-to-minimize-its-value", "solutions": ["class Solution:\n    def minimizeStringValue(self, s: str) -> str:\n        cnt = Counter(s)\n        pq = [(cnt[c], c) for c in ascii_lowercase]\n        heapify(pq)\n        t = []\n        for _ in range(s.count(\"?\")):\n            v, c = pq[0]\n            t.append(c)\n            heapreplace(pq, (v + 1, c))\n        t.sort()\n        cs = list(s)\n        j = 0\n        for i, c in enumerate(s):\n            if c == \"?\":\n                cs[i] = t[j]\n                j += 1\n        return \"\".join(cs)\n", "class Solution:\n  def minimizeStringValue(self, s: str) -> str:\n    ans = []\n    count = collections.Counter(s)\n    letters = []\n\n    del count['?']\n\n    def getMinFreqLetter(count: dict[str, int]) -> str:\n      minFreqLetter = 'a'\n      for c in string.ascii_lowercase:\n        if count[c] < count[minFreqLetter]:\n          minFreqLetter = c\n      return minFreqLetter\n\n    for c in s:\n      if c == '?':\n        minFreqLetter = getMinFreqLetter(count)\n        letters.append(minFreqLetter)\n        count[minFreqLetter] += 1\n\n    letters.sort()\n    i = 0  # letters' index\n\n    for c in s:\n      if c == '?':\n        ans.append(letters[i])\n        i += 1\n      else:\n        ans.append(c)\n\n    return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3049, "slug": "earliest-second-to-mark-indices-ii", "solutions": ["class Solution:\n  def earliestSecondToMarkIndices(\n      self,\n      nums: list[int],\n      changeIndices: list[int],\n  ) -> int:\n    # {the second: the index of nums can be zeroed at the current second}\n    secondToIndex = self._getSecondToIndex(nums, changeIndices)\n    numsSum = sum(nums)\n\n    def canMark(maxSecond: int) -> bool:\n      \"\"\"\n      Returns True if all indices of `nums` can be marked within `maxSecond`.\n      \"\"\"\n      # Use a min-heap to greedily pop out the minimum number, which yields the\n      # least saving.\n      minHeap = []\n      marks = 0\n\n      for second in range(maxSecond - 1, -1, -1):\n        if second in secondToIndex:\n          # The number mapped by the index is a candidate to be zeroed out.\n          index = secondToIndex[second]\n          heapq.heappush(minHeap, nums[index])\n          if marks == 0:\n            # Running out of marks, so need to pop out the minimum number.\n            # So, the current second will be used to mark an index.\n            heapq.heappop(minHeap)\n            marks += 1\n          else:\n            # There're enough marks.\n            # So, the current second will be used to zero out a number.\n            marks -= 1\n        else:\n          # There's no candidate to be zeroed out.\n          # So, the current second will be used to mark an index.\n          marks += 1\n\n      decrementAndMarkCost = ((numsSum - sum(minHeap)) +\n                              (len(nums) - len(minHeap)))\n      zeroAndMarkCost = len(minHeap) + len(minHeap)\n      return decrementAndMarkCost + zeroAndMarkCost <= maxSecond\n\n    l = 0\n    r = len(changeIndices) + 1\n    ans = bisect.bisect_left(range(l, r), True, key=canMark) + l\n    return ans if ans <= len(changeIndices) else -1\n\n  def _getSecondToIndex(\n      self,\n      nums: list[int],\n      changeIndices: list[int],\n  ) -> dict[int, int]:\n    # {the `index` of nums: the earliest second to zero out nums[index]}\n    indexToFirstSecond = {}\n    for zeroIndexedSecond, oneIndexedIndex in enumerate(changeIndices):\n      index = oneIndexedIndex - 1  # Convert to 0-indexed.\n      if nums[index] > 0 and index not in indexToFirstSecond:\n        indexToFirstSecond[index] = zeroIndexedSecond\n    return {second: index for index, second in indexToFirstSecond.items()}\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3067, "slug": "count-pairs-of-connectable-servers-in-a-weighted-tree-network", "solutions": ["class Solution:\n    def countPairsOfConnectableServers(\n        self, edges: List[List[int]], signalSpeed: int\n    ) -> List[int]:\n        def dfs(a: int, fa: int, ws: int) -> int:\n            cnt = 0 if ws % signalSpeed else 1\n            for b, w in g[a]:\n                if b != fa:\n                    cnt += dfs(b, a, ws + w)\n            return cnt\n\n        n = len(edges) + 1\n        g = [[] for _ in range(n)]\n        for a, b, w in edges:\n            g[a].append((b, w))\n            g[b].append((a, w))\n        ans = [0] * n\n        for a in range(n):\n            s = 0\n            for b, w in g[a]:\n                t = dfs(b, a, w)\n                ans[a] += s * t\n                s += t\n        return ans\n", "class Solution:\n  def countPairsOfConnectableServers(\n      self,\n      edges: list[list[int]],\n      signalSpeed: int,\n  ) -> list[int]:\n    n = len(edges) + 1\n    tree = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      tree[u].append((v, w))\n      tree[v].append((u, w))\n\n    def connectablePairsRootedAt(u: int) -> int:\n      pairs = 0\n      count = 0\n      for v, w in tree[u]:\n        childCount = dfs(v, u, w)\n        pairs += count * childCount\n        count += childCount\n      return pairs\n\n    def dfs(u: int, prev: int, dist: int) -> int:\n      return (int(dist % signalSpeed == 0) +\n              sum(dfs(v, u, dist + w)\n              for v, w in tree[u]\n              if v != prev))\n\n    return [connectablePairsRootedAt(i) for i in range(n)]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3034, "slug": "number-of-subarrays-that-match-a-pattern-i", "solutions": ["class Solution:\n    def countMatchingSubarrays(self, nums: List[int], pattern: List[int]) -> int:\n        def f(a: int, b: int) -> int:\n            return 0 if a == b else (1 if a < b else -1)\n\n        ans = 0\n        for i in range(len(nums) - len(pattern)):\n            ans += all(\n                f(nums[i + k], nums[i + k + 1]) == p for k, p in enumerate(pattern)\n            )\n        return ans\n", "class Solution:\n  def countMatchingSubarrays(self, nums: list[int], pattern: list[int]) -> int:\n    def getNum(a: int, b: int) -> int:\n      if a < b:\n        return 1\n      if a > b:\n        return -1\n      return 0\n\n    numsPattern = [getNum(a, b) for a, b in itertools.pairwise(nums)]\n    return self._kmp(numsPattern, pattern)\n\n  def _kmp(self, nums: list[int], pattern: list[int]) -> int:\n    \"\"\"Returns the number of occurrences of the pattern in `nums`.\"\"\"\n\n    def getLPS(nums: list[int]) -> list[int]:\n      \"\"\"\n      Returns the lps array, where lps[i] is the length of the longest prefix of\n      nums[0..i] which is also a suffix of this substring.\n      \"\"\"\n      lps = [0] * len(nums)\n      j = 0\n      for i in range(1, len(nums)):\n        while j > 0 and nums[j] != nums[i]:\n          j = lps[j - 1]\n        if nums[i] == nums[j]:\n          lps[i] = j + 1\n          j += 1\n      return lps\n\n    lps = getLPS(pattern)\n    res = 0\n    i = 0  # s' index\n    j = 0  # pattern's index\n    while i < len(nums):\n      if nums[i] == pattern[j]:\n        i += 1\n        j += 1\n        if j == len(pattern):\n          res += 1\n          j = lps[j - 1]\n      elif j != 0:  # Mismatch after j matches.\n        # Don't match lps[0..lps[j - 1]] since they will match anyway.\n        j = lps[j - 1]\n      else:\n        i += 1\n    return res\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3009, "slug": "maximum-number-of-intersections-on-the-chart", "solutions": ["class Solution:\n  def maxIntersectionCount(self, y: list[int]) -> int:\n    ans = 0\n    intersectionCount = 0\n    line = collections.Counter()\n\n    for i, (a, b) in enumerate(itertools.pairwise(y)):\n      start = 2 * a\n      end = 2 * b + (0 if i == len(y) - 2 else -1 if b > a else 1)\n      line[min(start, end)] += 1\n      line[max(start, end) + 1] -= 1\n\n    for count in sorted(line):\n      intersectionCount += line[count]\n      ans = max(ans, intersectionCount)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3024, "slug": "type-of-triangle", "solutions": ["class Solution:\n    def triangleType(self, nums: List[int]) -> str:\n        nums.sort()\n        if nums[0] + nums[1] <= nums[2]:\n            return \"none\"\n        if nums[0] == nums[2]:\n            return \"equilateral\"\n        if nums[0] == nums[1] or nums[1] == nums[2]:\n            return \"isosceles\"\n        return \"scalene\"\n", "class Solution:\n  def triangleType(self, nums: list[int]) -> str:\n    nums.sort()\n    if nums[0] + nums[1] <= nums[2]:\n      return 'none'\n    if nums[0] == nums[1] and nums[1] == nums[2]:\n      return 'equilateral'\n    if nums[0] == nums[1] or nums[1] == nums[2]:\n      return 'isosceles'\n    return 'scalene'\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3085, "slug": "minimum-deletions-to-make-string-k-special", "solutions": ["class Solution:\n    def minimumDeletions(self, word: str, k: int) -> int:\n        def f(v: int) -> int:\n            ans = 0\n            for x in nums:\n                if x < v:\n                    ans += x\n                elif x > v + k:\n                    ans += x - v - k\n            return ans\n\n        nums = Counter(word).values()\n        return min(f(v) for v in range(len(word) + 1))\n", "class Solution:\n  def minimumDeletions(self, word: str, k: int) -> int:\n    ans = math.inf\n    count = collections.Counter(word)\n\n    for minFreq in count.values():\n      deletions = 0\n      for freq in count.values():\n        if freq < minFreq:\n          deletions += freq\n        else:\n          deletions += max(0, freq - (minFreq + k))\n      ans = min(ans, deletions)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3056, "slug": "snaps-analysis", "solutions": ["import pandas as pd\n\n\ndef snap_analysis(activities: pd.DataFrame, age: pd.DataFrame) -> pd.DataFrame:\n    merged_df = pd.merge(activities, age, on=\"user_id\")\n    total_time_per_age_activity = (\n        merged_df.groupby([\"age_bucket\", \"activity_type\"])[\"time_spent\"]\n        .sum()\n        .reset_index()\n    )\n    pivot_df = total_time_per_age_activity.pivot(\n        index=\"age_bucket\", columns=\"activity_type\", values=\"time_spent\"\n    ).reset_index()\n    pivot_df = pivot_df.fillna(0)\n    pivot_df[\"send_perc\"] = round(\n        100 * pivot_df[\"send\"] / (pivot_df[\"send\"] + pivot_df[\"open\"]), 2\n    )\n    pivot_df[\"open_perc\"] = round(\n        100 * pivot_df[\"open\"] / (pivot_df[\"send\"] + pivot_df[\"open\"]), 2\n    )\n    return pivot_df[[\"age_bucket\", \"send_perc\", \"open_perc\"]]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3018, "slug": "maximum-number-of-removal-queries-that-can-be-processed-i", "solutions": ["class Solution:\n    def maximumProcessableQueries(self, nums: List[int], queries: List[int]) -> int:\n        n = len(nums)\n        f = [[0] * n for _ in range(n)]\n        m = len(queries)\n        for i in range(n):\n            for j in range(n - 1, i - 1, -1):\n                if i:\n                    f[i][j] = max(\n                        f[i][j], f[i - 1][j] + (nums[i - 1] >= queries[f[i - 1][j]])\n                    )\n                if j + 1 < n:\n                    f[i][j] = max(\n                        f[i][j], f[i][j + 1] + (nums[j + 1] >= queries[f[i][j + 1]])\n                    )\n                if f[i][j] == m:\n                    return m\n        return max(f[i][i] + (nums[i] >= queries[f[i][i]]) for i in range(n))\n", "class Solution:\n  def maximumProcessableQueries(\n      self,\n      nums: list[int],\n      queries: list[int],\n  ) -> int:\n    n = len(nums)\n    # dp[i][j] := the maximum number of queries processed if nums[i..j] are not\n    # removed after processing dp[i][j] queries\n    dp = [[0] * n for _ in range(n)]\n\n    for d in range(n - 1, -1, -1):\n      for i in range(n):\n        j = i + d\n        if j >= n:\n          continue\n        if i > 0:\n          # Remove nums[i - 1] from nums[i - 1..j] if possible.\n          dp[i][j] = max(dp[i][j], dp[i - 1][j] +\n                         (nums[i - 1] >= queries[dp[i - 1][j]]))\n        if j + 1 < n:\n          # Remove nums[j + 1] from nums[i..j + 1] if possible.\n          dp[i][j] = max(dp[i][j], dp[i][j + 1] +\n                         (nums[j + 1] >= queries[dp[i][j + 1]]))\n        if dp[i][j] == len(queries):\n          return len(queries)\n\n    return max(dp[i][i] + (nums[i] >= queries[dp[i][i]])\n               for i in range(n))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3000, "slug": "maximum-area-of-longest-diagonal-rectangle", "solutions": ["class Solution:\n    def areaOfMaxDiagonal(self, dimensions: List[List[int]]) -> int:\n        ans = mx = 0\n        for l, w in dimensions:\n            t = l**2 + w**2\n            if mx < t:\n                mx = t\n                ans = l * w\n            elif mx == t:\n                ans = max(ans, l * w)\n        return ans\n", "class Solution:\n  def areaOfMaxDiagonal(self, dimensions: list[list[int]]) -> int:\n    a, b = max(dimensions, key=lambda x: (x[0]**2 + x[1]**2, x[0] * x[1]))\n    return a * b\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3071, "slug": "minimum-operations-to-write-the-letter-y-on-a-grid", "solutions": ["class Solution:\n    def minimumOperationsToWriteY(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        cnt1 = Counter()\n        cnt2 = Counter()\n        for i, row in enumerate(grid):\n            for j, x in enumerate(row):\n                a = i == j and i <= n // 2\n                b = i + j == n - 1 and i <= n // 2\n                c = j == n // 2 and i >= n // 2\n                if a or b or c:\n                    cnt1[x] += 1\n                else:\n                    cnt2[x] += 1\n        return min(\n            n * n - cnt1[i] - cnt2[j] for i in range(3) for j in range(3) if i != j\n        )\n", "class Solution:\n  def minimumOperationsToWriteY(self, grid: list[list[int]]) -> int:\n    n = len(grid)\n    mid = n // 2\n\n    def getOperations(a: int, b: int) -> int:\n      \"\"\"Returns the number of operations to turn Y into a and non-Y into b.\"\"\"\n      operations = 0\n      for i, row in enumerate(grid):\n        for j, num in enumerate(row):\n          # For the 'Y' pattern, before the midpoint, check the diagonal and\n          # anti-diagonal. After the midpoint, check the middle column.\n          if (i < mid and (i == j or i + j == n - 1)) or i >= mid and j == mid:\n            if num != a:\n              operations += 1\n          elif num != b:\n            operations += 1\n      return operations\n\n    return min(getOperations(0, 1), getOperations(0, 2),\n               getOperations(1, 0), getOperations(1, 2),\n               getOperations(2, 0), getOperations(2, 1))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3073, "slug": "maximum-increasing-triplet-value", "solutions": ["class Solution:\n    def maximumTripletValue(self, nums: List[int]) -> int:\n        n = len(nums)\n        right = [nums[-1]] * n\n        for i in range(n - 2, -1, -1):\n            right[i] = max(nums[i], right[i + 1])\n        sl = SortedList([nums[0]])\n        ans = 0\n        for j in range(1, n - 1):\n            if right[j + 1] > nums[j]:\n                i = sl.bisect_left(nums[j]) - 1\n                if i >= 0:\n                    ans = max(ans, sl[i] - nums[j] + right[j + 1])\n            sl.add(nums[j])\n        return ans\n", "from sortedcontainers import SortedSet\n\n\nclass Solution:\n  def maximumTripletValue(self, nums: list[int]) -> int:\n    ans = 0\n    rightMax = [0] * len(nums)  # rightMax[i] := max(nums[i + 1..n))\n    leftSortedSet = SortedSet([nums[0]])\n\n    for i in range(len(nums) - 2, -1, -1):\n      rightMax[i] = max(nums[i + 1], rightMax[i + 1])\n\n    for j in range(1, len(nums) - 1):\n      i = bisect.bisect_left(leftSortedSet, nums[j])\n      if i > 0 and rightMax[j] > nums[j]:\n        ans = max(ans, leftSortedSet[i - 1] - nums[j] + rightMax[j])\n      leftSortedSet.add(nums[j])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3030, "slug": "find-the-grid-of-region-average", "solutions": ["class Solution:\n    def resultGrid(self, image: List[List[int]], threshold: int) -> List[List[int]]:\n        n, m = len(image), len(image[0])\n        ans = [[0] * m for _ in range(n)]\n        ct = [[0] * m for _ in range(n)]\n        for i in range(n - 2):\n            for j in range(m - 2):\n                region = True\n                for k in range(3):\n                    for l in range(2):\n                        region &= (\n                            abs(image[i + k][j + l] - image[i + k][j + l + 1])\n                            <= threshold\n                        )\n                for k in range(2):\n                    for l in range(3):\n                        region &= (\n                            abs(image[i + k][j + l] - image[i + k + 1][j + l])\n                            <= threshold\n                        )\n\n                if region:\n                    tot = 0\n                    for k in range(3):\n                        for l in range(3):\n                            tot += image[i + k][j + l]\n                    for k in range(3):\n                        for l in range(3):\n                            ct[i + k][j + l] += 1\n                            ans[i + k][j + l] += tot // 9\n\n        for i in range(n):\n            for j in range(m):\n                if ct[i][j] == 0:\n                    ans[i][j] = image[i][j]\n                else:\n                    ans[i][j] //= ct[i][j]\n\n        return ans\n", "class Solution:\n  def resultGrid(\n      self,\n      image: list[list[int]],\n      threshold: int,\n  ) -> list[list[int]]:\n    m = len(image)\n    n = len(image[0])\n    sums = [[0] * n for _ in range(m)]\n    counts = [[0] * n for _ in range(m)]\n\n    for i in range(m - 2):\n      for j in range(n - 2):\n        if self._isRegion(image, i, j, threshold):\n          subgridSum = sum(image[x][y]\n                           for x in range(i, i + 3)\n                           for y in range(j, j + 3))\n          for x in range(i, i + 3):\n            for y in range(j, j + 3):\n              sums[x][y] += subgridSum // 9\n              counts[x][y] += 1\n\n    for i in range(m):\n      for j in range(n):\n        if counts[i][j] > 0:\n          image[i][j] = sums[i][j] // counts[i][j]\n\n    return image\n\n  def _isRegion(\n      self,\n      image: list[list[int]],\n      i: int,\n      j: int,\n      threshold: int,\n  ) -> bool:\n    \"\"\"Returns True if image[i..i + 2][j..j + 2] is a region.\"\"\"\n    for x in range(i, i + 3):\n      for y in range(j, j + 3):\n        if x > i and abs(image[x][y] - image[x - 1][y]) > threshold:\n          return False\n        if y > j and abs(image[x][y] - image[x][y - 1]) > threshold:\n          return False\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3031, "slug": "minimum-time-to-revert-word-to-initial-state-ii", "solutions": ["class Hashing:\n    __slots__ = [\"mod\", \"h\", \"p\"]\n\n    def __init__(self, s: str, base: int, mod: int):\n        self.mod = mod\n        self.h = [0] * (len(s) + 1)\n        self.p = [1] * (len(s) + 1)\n        for i in range(1, len(s) + 1):\n            self.h[i] = (self.h[i - 1] * base + ord(s[i - 1])) % mod\n            self.p[i] = (self.p[i - 1] * base) % mod\n\n    def query(self, l: int, r: int) -> int:\n        return (self.h[r] - self.h[l - 1] * self.p[r - l + 1]) % self.mod\n\n\nclass Solution:\n    def minimumTimeToInitialState(self, word: str, k: int) -> int:\n        hashing = Hashing(word, 13331, 998244353)\n        n = len(word)\n        for i in range(k, n, k):\n            if hashing.query(1, n - i) == hashing.query(i + 1, n):\n                return i // k\n        return (n + k - 1) // k\n", "class Solution:\n  # Same as 3029. Minimum Time to Revert Word to Initial State I\n  def minimumTimeToInitialState(self, word: str, k: int) -> int:\n    n = len(word)\n    maxOps = (n - 1) // k + 1\n    z = self._zFunction(word)\n\n    for ans in range(1, maxOps):\n      if z[ans * k] >= n - ans * k:\n        return ans\n\n    return maxOps\n\n  def _zFunction(self, s: str) -> list[int]:\n    \"\"\"\n    Returns the z array, where z[i] is the length of the longest prefix of\n    s[i..n) which is also a prefix of s.\n\n    https://cp-algorithms.com/string/z-function.html#implementation\n    \"\"\"\n    n = len(s)\n    z = [0] * n\n    l = 0\n    r = 0\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n    return z\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3058, "slug": "friends-with-no-mutual-friends", "solutions": ["import pandas as pd\n\n\ndef friends_with_no_mutual_friends(friends: pd.DataFrame) -> pd.DataFrame:\n    cp = friends.copy()\n    t = cp[[\"user_id1\", \"user_id2\"]].copy()\n    t = pd.concat(\n        [\n            t,\n            cp[[\"user_id2\", \"user_id1\"]].rename(\n                columns={\"user_id2\": \"user_id1\", \"user_id1\": \"user_id2\"}\n            ),\n        ]\n    )\n    merged = t.merge(t, left_on=\"user_id2\", right_on=\"user_id2\")\n    ans = cp[\n        ~cp.apply(\n            lambda x: (x[\"user_id1\"], x[\"user_id2\"])\n            in zip(merged[\"user_id1_x\"], merged[\"user_id1_y\"]),\n            axis=1,\n        )\n    ]\n    return ans.sort_values(by=[\"user_id1\", \"user_id2\"])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3088, "slug": "make-string-anti-palindrome", "solutions": ["class Solution:\n    def makeAntiPalindrome(self, s: str) -> str:\n        cs = sorted(s)\n        n = len(cs)\n        m = n // 2\n        if cs[m] == cs[m - 1]:\n            i = m\n            while i < n and cs[i] == cs[i - 1]:\n                i += 1\n            j = m\n            while j < n and cs[j] == cs[n - j - 1]:\n                if i >= n:\n                    return \"-1\"\n                cs[i], cs[j] = cs[j], cs[i]\n                i, j = i + 1, j + 1\n        return \"\".join(cs)\n", "class Solution:\n  def makeAntiPalindrome(self, s: str) -> str:\n    n = len(s)\n    i = n // 2\n    chars = sorted(list(s))\n    if chars[i] != chars[n - 1 - i]:\n      return ''.join(chars)\n\n    j = self._getFirstDiffIndexInSecondHalf(chars)\n    while chars[i] == chars[n - 1 - i]:\n      if j == n:\n        return '-1'\n      chars[i], chars[j] = chars[j], chars[i]\n      i += 1\n      j += 1\n\n    return ''.join(chars)\n\n  def _getFirstDiffIndexInSecondHalf(self, chars: list[str]) -> int:\n    \"\"\"\n    Returns the first index in chars[n / 2..n) that is different from the first\n    letter of the second half, chars[n / 2].\n    \"\"\"\n    n = len(chars)\n    firstLetter = chars[n // 2]\n    firstDiffIndex = n // 2\n    while firstDiffIndex < n and chars[firstDiffIndex] == firstLetter:\n      firstDiffIndex += 1\n    return firstDiffIndex\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3010, "slug": "divide-an-array-into-subarrays-with-minimum-cost-i", "solutions": ["class Solution:\n    def minimumCost(self, nums: List[int]) -> int:\n        a, b, c = nums[0], inf, inf\n        for x in nums[1:]:\n            if x < b:\n                c, b = b, x\n            elif x < c:\n                c = x\n        return a + b + c\n", "class Solution:\n  def minimumCost(self, nums: list[int]) -> int:\n    MAX = 50\n    min1 = MAX\n    min2 = MAX\n\n    for i in range(1, len(nums)):\n      if nums[i] < min1:\n        min2 = min1\n        min1 = nums[i]\n      elif nums[i] < min2:\n        min2 = nums[i]\n\n    return nums[0] + min1 + min2\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3019, "slug": "number-of-changing-keys", "solutions": ["class Solution:\n    def countKeyChanges(self, s: str) -> int:\n        return sum(a != b for a, b in pairwise(s.lower()))\n", "class Solution:\n  def countKeyChanges(self, s: str) -> int:\n    return sum(a.lower() != b.lower()\n               for a, b in itertools.pairwise(s))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3091, "slug": "apply-operations-to-make-sum-of-array-greater-than-or-equal-to-k", "solutions": ["class Solution:\n    def minOperations(self, k: int) -> int:\n        ans = k\n        for a in range(k):\n            x = a + 1\n            b = (k + x - 1) // x - 1\n            ans = min(ans, a + b)\n        return ans\n", "class Solution:\n  def minOperations(self, k: int) -> int:\n    # The required operations are\n    #   1. Increase `1` to `x`\n    #   2. Duplicate `x`, `y` times, to `sum` s.t. x * (1 + y) >= k.\n    # The number of operations used would be (x - 1) + y. Equivalently, the\n    # problem can be rephrased as finding min(x - 1 + y) s.t. x * (1 + y) >= k.\n    # Optimally, `x` should equal to `1 + y`, implying that x^2 >= k, and\n    # hence, x >= sqrt(k) and y = ceil(k / x) - 1.\n    x = math.ceil(math.sqrt(k))\n    y = (k - 1) // x + 1 - 1  # ceil(k / x) - 1\n    return x - 1 + y\n", "class Solution:\n  def minOperations(self, k: int) -> int:\n    # The required operations are\n    #   1. Increase `1` to `x`\n    #   2. Duplicate `x`, `y` times, to `sum` s.t. x * (1 + y) >= k.\n    # The number of operations used would be (x - 1) + y. Equivalently, the\n    # problem can be rephrased as finding min(x - 1 + y) s.t. x * (1 + y) >= k.\n    # Optimally, `x` should equal to `1 + y`, implying that x^2 >= k, and\n    # hence, x >= sqrt(k) and y = ceil(k / x) - 1.\n    x = math.isqrt(k)\n    y = (k - 1) // x + 1 - 1  # ceil(k / x) - 1\n    return x - 1 + y\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3080, "slug": "mark-elements-on-array-by-performing-queries", "solutions": ["class Solution:\n    def unmarkedSumArray(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(nums)\n        s = sum(nums)\n        mark = [False] * n\n        arr = sorted((x, i) for i, x in enumerate(nums))\n        j = 0\n        ans = []\n        for index, k in queries:\n            if not mark[index]:\n                mark[index] = True\n                s -= nums[index]\n            while k and j < n:\n                if not mark[arr[j][1]]:\n                    mark[arr[j][1]] = True\n                    s -= arr[j][0]\n                    k -= 1\n                j += 1\n            ans.append(s)\n        return ans\n", "class Solution:\n  def unmarkedSumArray(\n      self,\n      nums: list[int],\n      queries: list[list[int]],\n  ) -> list[int]:\n    ans = []\n    marked = set()\n    summ = sum(nums)\n    minHeap = [(num, i) for i, num in enumerate(nums)]\n    heapq.heapify(minHeap)\n\n    for index, k in queries:\n      if index not in marked:\n        marked.add(index)\n        summ -= nums[index]\n      popped = 0\n      while popped < k and minHeap:\n        num, i = heapq.heappop(minHeap)\n        if i not in marked:\n          marked.add(i)\n          summ -= num\n          popped += 1\n      ans.append(summ)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3003, "slug": "maximize-the-number-of-partitions-after-operations", "solutions": ["class Solution:\n    def maxPartitionsAfterOperations(self, s: str, k: int) -> int:\n        @cache\n        def dfs(i: int, cur: int, t: int) -> int:\n            if i >= n:\n                return 1\n            v = 1 << (ord(s[i]) - ord(\"a\"))\n            nxt = cur | v\n            if nxt.bit_count() > k:\n                ans = dfs(i + 1, v, t) + 1\n            else:\n                ans = dfs(i + 1, nxt, t)\n            if t:\n                for j in range(26):\n                    nxt = cur | (1 << j)\n                    if nxt.bit_count() > k:\n                        ans = max(ans, dfs(i + 1, 1 << j, 0) + 1)\n                    else:\n                        ans = max(ans, dfs(i + 1, nxt, 0))\n            return ans\n\n        n = len(s)\n        return dfs(0, 0, 1)\n", "class Solution:\n  def maxPartitionsAfterOperations(self, s: str, k: int) -> int:\n    @functools.lru_cache(None)\n    def dp(i: int, canChange: bool, mask: int) -> int:\n      \"\"\"\n      Returns the maximum number of partitions of s[i..n), where `canChange` is\n      True if we can still change a letter, and `mask` is the bitmask of the\n      letters we've seen.\n      \"\"\"\n      if i == len(s):\n        return 0\n\n      def getRes(newBit: int, nextCanChange: bool) -> int:\n        nextMask = mask | newBit\n        if nextMask.bit_count() > k:\n          return 1 + dp(i + 1, nextCanChange, newBit)\n        return dp(i + 1, nextCanChange, nextMask)\n\n      # Initialize the result based on the current letter.\n      res = getRes(1 << (ord(s[i]) - ord('a')), canChange)\n\n      # If allowed, explore the option to change the current letter.\n      if canChange:\n        for j in range(26):\n          res = max(res, getRes(1 << j, False))\n      return res\n\n    return dp(0, True, 0) + 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3075, "slug": "maximize-happiness-of-selected-children", "solutions": ["class Solution:\n    def maximumHappinessSum(self, happiness: List[int], k: int) -> int:\n        happiness.sort(reverse=True)\n        ans = 0\n        for i, x in enumerate(happiness[:k]):\n            x -= i\n            ans += max(x, 0)\n        return ans\n", "class Solution:\n  def maximumHappinessSum(self, happiness: list[int], k: int) -> int:\n    ans = 0\n    decremented = 0\n\n    happiness.sort(reverse=True)\n\n    for i in range(k):\n      ans += max(0, happiness[i] - decremented)\n      decremented += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3005, "slug": "count-elements-with-maximum-frequency", "solutions": ["class Solution:\n    def maxFrequencyElements(self, nums: List[int]) -> int:\n        cnt = Counter(nums)\n        mx = max(cnt.values())\n        return sum(x for x in cnt.values() if x == mx)\n", "class Solution:\n  def maxFrequencyElements(self, nums: list[int]) -> int:\n    count = collections.Counter(nums)\n    maxFreq = max(count.values())\n    return sum(freq == maxFreq for freq in count.values()) * maxFreq\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3014, "slug": "minimum-number-of-pushes-to-type-word-i", "solutions": ["class Solution:\n    def minimumPushes(self, word: str) -> int:\n        n = len(word)\n        ans, k = 0, 1\n        for _ in range(n // 8):\n            ans += k * 8\n            k += 1\n        ans += k * (n % 8)\n        return ans\n", "class Solution:\n  def minimumPushes(self, word: str) -> int:\n    freqs = sorted(collections.Counter(word).values(), reverse=True)\n    return sum(freq * (i // 8 + 1) for i, freq in enumerate(freqs))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3052, "slug": "maximize-items", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3040, "slug": "maximum-number-of-operations-with-the-same-score-ii", "solutions": ["class Solution:\n    def maxOperations(self, nums: List[int]) -> int:\n        @cache\n        def dfs(i: int, j: int, s: int) -> int:\n            if j - i < 1:\n                return 0\n            ans = 0\n            if nums[i] + nums[i + 1] == s:\n                ans = max(ans, 1 + dfs(i + 2, j, s))\n            if nums[i] + nums[j] == s:\n                ans = max(ans, 1 + dfs(i + 1, j - 1, s))\n            if nums[j - 1] + nums[j] == s:\n                ans = max(ans, 1 + dfs(i, j - 2, s))\n            return ans\n\n        n = len(nums)\n        a = dfs(2, n - 1, nums[0] + nums[1])\n        b = dfs(0, n - 3, nums[-1] + nums[-2])\n        c = dfs(1, n - 2, nums[0] + nums[-1])\n        return 1 + max(a, b, c)\n", "class Solution:\n  def maxOperations(self, nums: list[int]) -> int:\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, score: int) -> int:\n      \"\"\"\n      Returns the maximum number of operations that can be performed for\n      nums[i..j], s.t. all operations have the same `score`.\n      \"\"\"\n      if i >= j:\n        return 0\n      deleteFirstTwo = (1 + dp(i + 2, j, score)\n                        if nums[i] + nums[i + 1] == score else 0)\n      deleteLastTwo = (1 + dp(i, j - 2, score)\n                       if nums[j] + nums[j - 1] == score else 0)\n      deleteFirstAndLast = (1 + dp(i + 1, j - 1, score)\n                            if nums[i] + nums[j] == score else 0)\n      return max(deleteFirstTwo, deleteLastTwo, deleteFirstAndLast)\n\n    n = len(nums)\n    return max(dp(0, n - 1, nums[0] + nums[1]),\n               dp(0, n - 1, nums[-1] + nums[-2]),\n               dp(0, n - 1, nums[0] + nums[-1]))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3087, "slug": "find-trending-hashtags", "solutions": ["import pandas as pd\n\n\ndef find_trending_hashtags(tweets: pd.DataFrame) -> pd.DataFrame:\n    tweets = tweets[tweets[\"tweet_date\"].dt.strftime(\"%Y%m\") == \"202402\"]\n    tweets[\"hashtag\"] = \"#\" + tweets[\"tweet\"].str.extract(r\"#(\\w+)\")\n    hashtag_counts = tweets[\"hashtag\"].value_counts().reset_index()\n    hashtag_counts.columns = [\"hashtag\", \"hashtag_count\"]\n    hashtag_counts = hashtag_counts.sort_values(\n        by=[\"hashtag_count\", \"hashtag\"], ascending=[False, False]\n    )\n    top_3_hashtags = hashtag_counts.head(3)\n    return top_3_hashtags\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3063, "slug": "linked-list-frequency", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def frequenciesOfElements(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        cnt = Counter()\n        while head:\n            cnt[head.val] += 1\n            head = head.next\n        dummy = ListNode()\n        for val in cnt.values():\n            dummy.next = ListNode(val, dummy.next)\n        return dummy.next\n", "class Solution:\n  def frequenciesOfElements(self, head: ListNode | None) -> ListNode | None:\n    count = collections.Counter()\n    curr = head\n\n    while curr:\n      count[curr.val] += 1\n      curr = curr.next\n\n    dummy = ListNode(0)\n    tail = dummy\n\n    for freq in count.values():\n      tail.next = ListNode(freq)\n      tail = tail.next\n\n    return dummy.next\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3047, "slug": "find-the-largest-area-of-square-inside-two-rectangles", "solutions": ["class Solution:\n    def largestSquareArea(\n        self, bottomLeft: List[List[int]], topRight: List[List[int]]\n    ) -> int:\n        ans = 0\n        for ((x1, y1), (x2, y2)), ((x3, y3), (x4, y4)) in combinations(\n            zip(bottomLeft, topRight), 2\n        ):\n            w = min(x2, x4) - max(x1, x3)\n            h = min(y2, y4) - max(y1, y3)\n            e = min(w, h)\n            if e > 0:\n                ans = max(ans, e * e)\n        return ans\n", "class Solution:\n  def largestSquareArea(\n      self,\n      bottomLeft: list[list[int]],\n      topRight: list[list[int]],\n  ) -> int:\n    minSide = 0\n\n    for ((ax1, ay1), (ax2, ay2)), ((bx1, by1), (bx2, by2)) in (\n            itertools.combinations(zip(bottomLeft, topRight), 2)):\n      overlapX = min(ax2, bx2) - max(ax1, bx1)\n      overlapY = min(ay2, by2) - max(ay1, by1)\n      minSide = max(minSide, min(overlapX, overlapY))\n\n    return minSide**2\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3095, "slug": "shortest-subarray-with-or-at-least-k-i", "solutions": ["class Solution:\n    def minimumSubarrayLength(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        cnt = [0] * 32\n        ans = n + 1\n        s = i = 0\n        for j, x in enumerate(nums):\n            s |= x\n            for h in range(32):\n                if x >> h & 1:\n                    cnt[h] += 1\n            while s >= k and i <= j:\n                ans = min(ans, j - i + 1)\n                y = nums[i]\n                for h in range(32):\n                    if y >> h & 1:\n                        cnt[h] -= 1\n                        if cnt[h] == 0:\n                            s ^= 1 << h\n                i += 1\n        return -1 if ans > n else ans\n", "class Solution:\n  def minimumSubarrayLength(self, nums: list[int], k: int) -> int:\n    ans = len(nums) + 1\n    ors = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, num in enumerate(nums):\n      ors = self._orNum(ors, num, count)\n      while ors >= k and l <= r:\n        ans = min(ans, r - l + 1)\n        ors = self._undoOrNum(ors, nums[l], count)\n        l += 1\n\n    return -1 if ans == len(nums) + 1 else ans\n\n  def _orNum(self, ors: int, num: int, count: dict[int, int]) -> int:\n    for i in range(30):\n      if num >> i & 1:\n        count[i] += 1\n        if count[i] == 1:\n          ors += 1 << i\n    return ors\n\n  def _undoOrNum(self, ors: int, num: int, count: dict[int, int]) -> int:\n    for i in range(30):\n      if num >> i & 1:\n        count[i] -= 1\n        if count[i] == 0:\n          ors -= 1 << i\n    return ors\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3098, "slug": "find-the-sum-of-subsequence-powers", "solutions": ["class Solution:\n    def sumOfPowers(self, nums: List[int], k: int) -> int:\n        @cache\n        def dfs(i: int, j: int, k: int, mi: int) -> int:\n            if i >= n:\n                return mi if k == 0 else 0\n            if n - i < k:\n                return 0\n            ans = dfs(i + 1, j, k, mi)\n            if j == n:\n                ans += dfs(i + 1, i, k - 1, mi)\n            else:\n                ans += dfs(i + 1, i, k - 1, min(mi, nums[i] - nums[j]))\n            ans %= mod\n            return ans\n\n        mod = 10**9 + 7\n        n = len(nums)\n        nums.sort()\n        return dfs(0, n, k, inf)\n", "class Solution:\n  def sumOfPowers(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    n = len(nums)\n\n    nums.sort()\n\n    @functools.lru_cache(None)\n    def dp(i: int, k: int, lastPickIndex: int, minDiff: int) -> int:\n      if k == 0:\n        return minDiff\n      if i == n:\n        return 0\n      newMinDiff = (minDiff if lastPickIndex == - 1\n                    else min(minDiff, nums[i] - nums[lastPickIndex]))\n      pick = dp(i + 1, k - 1, i, newMinDiff)\n      skip = dp(i + 1, k, lastPickIndex, minDiff)\n      return (pick + skip) % MOD\n\n    return dp(0, k, -1, math.inf)\n", "class Solution:\n  def sumOfPowers(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    nums.sort()\n\n    @functools.lru_cache(None)\n    def dp(\n        i: int,\n        k: int,\n        lastPickedIndex: int,\n        firstIndex: int,\n        secondIndex: int\n    ) -> int:\n      if k == 0:\n        return nums[secondIndex] - nums[firstIndex]\n      if i == len(nums):\n        return 0\n      newFirstIndex = firstIndex\n      newSecondIndex = secondIndex\n      if firstIndex == -1:\n        newFirstIndex = i\n      elif secondIndex == -1:\n        newSecondIndex = i\n      elif nums[i] - nums[lastPickedIndex] < nums[secondIndex] - nums[firstIndex]:\n        newFirstIndex = lastPickedIndex\n        newSecondIndex = i\n      pick = dp(i + 1, k - 1, i, newFirstIndex, newSecondIndex)\n      skip = dp(i + 1, k, lastPickedIndex, firstIndex, secondIndex)\n      return (pick + skip) % MOD\n\n    return dp(0, k, -1, -1, -1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3068, "slug": "find-the-maximum-sum-of-node-values", "solutions": ["class Solution:\n    def maximumValueSum(self, nums: List[int], k: int, edges: List[List[int]]) -> int:\n        f0, f1 = 0, -inf\n        for x in nums:\n            f0, f1 = max(f0 + x, f1 + (x ^ k)), max(f1 + x, f0 + (x ^ k))\n        return f0\n", "class Solution:\n  def maximumValueSum(\n      self,\n      nums: list[int],\n      k: int,\n      edges: list[list[int]],\n  ) -> int:\n    maxSum = sum(max(num, num ^ k) for num in nums)\n    changedCount = sum((num ^ k) > num for num in nums)\n    if changedCount % 2 == 0:\n      return maxSum\n    minChangeDiff = min(abs(num - (num ^ k)) for num in nums)\n    return maxSum - minChangeDiff\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3089, "slug": "find-bursty-behavior", "solutions": ["import pandas as pd\n\n\ndef find_bursty_behavior(posts: pd.DataFrame) -> pd.DataFrame:\n    # Subquery P\n    p1 = pd.merge(posts, posts, on=\"user_id\", suffixes=(\"_1\", \"_2\"))\n    p1 = p1[\n        p1[\"post_date_2\"].between(\n            p1[\"post_date_1\"], p1[\"post_date_1\"] + pd.Timedelta(days=6)\n        )\n    ]\n    p1 = p1.groupby([\"user_id\", \"post_id_1\"]).size().reset_index(name=\"cnt\")\n\n    # Subquery T\n    t = posts[\n        (posts[\"post_date\"] >= \"2024-02-01\") & (posts[\"post_date\"] <= \"2024-02-28\")\n    ]\n    t = t.groupby(\"user_id\").size().div(4).reset_index(name=\"avg_weekly_posts\")\n\n    # Joining P and T\n    merged_df = pd.merge(p1, t, on=\"user_id\", how=\"inner\")\n\n    # Filtering\n    filtered_df = merged_df[merged_df[\"cnt\"] >= merged_df[\"avg_weekly_posts\"] * 2]\n\n    # Aggregating\n    result_df = (\n        filtered_df.groupby(\"user_id\")\n        .agg({\"cnt\": \"max\", \"avg_weekly_posts\": \"first\"})\n        .reset_index()\n    )\n    result_df.columns = [\"user_id\", \"max_7day_posts\", \"avg_weekly_posts\"]\n\n    # Sorting\n    result_df.sort_values(by=\"user_id\", inplace=True)\n\n    return result_df\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3092, "slug": "most-frequent-ids", "solutions": ["class Solution:\n    def mostFrequentIDs(self, nums: List[int], freq: List[int]) -> List[int]:\n        cnt = Counter()\n        lazy = Counter()\n        ans = []\n        pq = []\n        for x, f in zip(nums, freq):\n            lazy[cnt[x]] += 1\n            cnt[x] += f\n            heappush(pq, -cnt[x])\n            while pq and lazy[-pq[0]] > 0:\n                lazy[-pq[0]] -= 1\n                heappop(pq)\n            ans.append(0 if not pq else -pq[0])\n        return ans\n", "from sortedcontainers import SortedDict\n\n\nclass Solution:\n  def mostFrequentIDs(self, nums: list[int], freq: list[int]) -> list[int]:\n    ans = []\n    numCount = collections.Counter()  # {num: freq}\n    freqCount = SortedDict()  # {num's freq: freq}\n\n    for num, f in zip(nums, freq):\n      if numCount[num] > 0:\n        numFreq = numCount[num]\n        freqCount[numFreq] -= 1\n        if freqCount[numFreq] == 0:\n          del freqCount[numFreq]\n      newFreq = numCount[num] + f\n      if newFreq == 0:\n        del numCount[num]\n      else:\n        numCount[num] = newFreq\n        freqCount[newFreq] = freqCount.get(newFreq, 0) + 1\n      ans.append(freqCount.peekitem(-1)[0] if freqCount else 0)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3028, "slug": "ant-on-the-boundary", "solutions": ["class Solution:\n    def returnToBoundaryCount(self, nums: List[int]) -> int:\n        return sum(s == 0 for s in accumulate(nums))\n", "class Solution:\n  def returnToBoundaryCount(self, nums: list[int]) -> int:\n    return sum(prefix == 0 for prefix in itertools.accumulate(nums))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3025, "slug": "find-the-number-of-ways-to-place-people-i", "solutions": ["class Solution:\n    def numberOfPairs(self, points: List[List[int]]) -> int:\n        points.sort(key=lambda x: (x[0], -x[1]))\n        ans = 0\n        for i, (_, y1) in enumerate(points):\n            max_y = -inf\n            for _, y2 in points[i + 1 :]:\n                if max_y < y2 <= y1:\n                    max_y = y2\n                    ans += 1\n        return ans\n", "class Solution:\n  def numberOfPairs(self, points: list[list[int]]) -> int:\n    ans = 0\n\n    points.sort(key=lambda x: (x[0], -x[1]))\n\n    for i, (_, yi) in enumerate(points):\n      maxY = -math.inf\n      for j in range(i + 1, len(points)):\n        _, yj = points[j]\n        # Chisato is in the upper-left corner at (xi, yi), and Takina is in the\n        # lower-right corner at (xj, yj). Also, if yj > maxY, it means that\n        # nobody other than Chisato and Takina is inside or on the fence.\n        if yi >= yj > maxY:\n          ans += 1\n          maxY = yj\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3041, "slug": "maximize-consecutive-elements-in-an-array-after-modification", "solutions": ["class Solution:\n  def maxSelectedElements(self, nums: list[int]) -> int:\n    ans = 1\n    prev = -math.inf\n    # the length of the longest consecutive elements (seq0) ending in the\n    # previous number\n    dp0 = 1\n    # the length of the longest consecutive elements (seq1) ending in the\n    # previous number + 1\n    dp1 = 1\n\n    for num in sorted(nums):\n      if num == prev:\n        dp1 = dp0 + 1  # Append `num + 1` to seq0.\n      elif num == prev + 1:\n        dp0 += 1  # Append `num` to seq0.\n        dp1 += 1  # Add 1 to every number in seq0 and append `num + 1` to seq0.\n      elif num == prev + 2:\n        dp0 = dp1 + 1  # Append `num` to seq1.\n        dp1 = 1        # Start a new sequence [`num + 1`].\n      else:\n        dp0 = 1  # Start a new sequence [`num`].\n        dp1 = 1  # Start a new sequence [`num + 1`].\n      ans = max(ans, dp0, dp1)\n      prev = num\n\n    return ans\n", "class Solution:\n  def maxSelectedElements(self, nums: list[int]) -> int:\n    ans = 0\n    # {num: the length of the longest consecutive elements ending in num}\n    dp = {}\n\n    for num in sorted(nums):\n      dp[num + 1] = dp.get(num, 0) + 1\n      dp[num] = dp.get(num - 1, 0) + 1\n      ans = max(ans, dp[num], dp[num + 1])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3037, "slug": "find-pattern-in-infinite-stream-ii", "solutions": ["# Definition for an infinite stream.\n# class InfiniteStream:\n#   def next(self) -> int:\n#     pass\n\nclass Solution:\n  # Same as 3023. Find Pattern in Infinite Stream I\n  def findPattern(\n      self,\n      stream: Optional['InfiniteStream'],\n      pattern: list[int]\n  ) -> int:\n    lps = self._getLPS(pattern)\n    i = 0  # stream's index\n    j = 0  # pattern's index\n    bit = 0  # the bit in the stream\n    readNext = False\n    while True:\n      if not readNext:\n        bit = stream.next()\n        readNext = True\n      if bit == pattern[j]:\n        i += 1\n        readNext = False\n        j += 1\n        if j == len(pattern):\n          return i - j\n      # Mismatch after j matches.\n      elif j > 0:\n        # Don't match lps[0..lps[j - 1]] since they will match anyway.\n        j = lps[j - 1]\n      else:\n        i += 1\n        readNext = False\n\n  def _getLPS(self, pattern: list[int]) -> list[int]:\n    \"\"\"\n    Returns the lps array, where lps[i] is the length of the longest prefix of\n    pattern[0..i] which is also a suffix of this substring.\n    \"\"\"\n    lps = [0] * len(pattern)\n    j = 0\n    for i in range(1, len(pattern)):\n      while j > 0 and pattern[j] != pattern[i]:\n        j = lps[j - 1]\n      if pattern[i] == pattern[j]:\n        j += 1\n        lps[i] = j\n    return lps\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3001, "slug": "minimum-moves-to-capture-the-queen", "solutions": ["class Solution:\n    def minMovesToCaptureTheQueen(\n        self, a: int, b: int, c: int, d: int, e: int, f: int\n    ) -> int:\n        if a == e and (c != a or (d - b) * (d - f) > 0):\n            return 1\n        if b == f and (d != b or (c - a) * (c - e) > 0):\n            return 1\n        if c - e == d - f and (a - e != b - f or (a - c) * (a - e) > 0):\n            return 1\n        if c - e == f - d and (a - e != f - b or (a - c) * (a - e) > 0):\n            return 1\n        return 2\n", "class Solution:\n  def minMovesToCaptureTheQueen(\n      self, a: int, b: int, c: int, d: int, e: int, f: int,\n  ) -> int:\n    # The rook is in the same row as the queen.\n    if a == e:\n      # The bishop blocks the rook or not.\n      return 2 if c == a and (b < d < f or b > d > f) else 1\n    # The rook is in the same column as the queen.\n    if b == f:\n      # The bishop blocks the rook or not.\n      return 2 if d == f and (a < c < e or a > c > e) else 1\n    # The bishop is in the same up-diagonal as the queen.\n    if c + d == e + f:\n      # The rook blocks the bishop or not.\n      return 2 if a + b == c + d and (c < a < e or c > a > e) else 1\n    # The bishop is in the same down-diagonal as the queen.\n    if c - d == e - f:\n      # The rook blocks the bishop or not.\n      return 2 if a - b == c - d and (c < a < e or c > a > e) else 1\n    # The rook can always get the green in two steps.\n    return 2\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3038, "slug": "maximum-number-of-operations-with-the-same-score-i", "solutions": ["class Solution:\n    def maxOperations(self, nums: List[int]) -> int:\n        s = nums[0] + nums[1]\n        ans, n = 0, len(nums)\n        for i in range(0, n, 2):\n            if i + 1 == n or nums[i] + nums[i + 1] != s:\n                break\n            ans += 1\n        return ans\n", "class Solution:\n  def maxOperations(self, nums: list[int]) -> int:\n    ans = 1\n    summ = nums[0] + nums[1]\n\n    for i in range(2, len(nums) - 1, 2):\n      if nums[i] + nums[i + 1] == summ:\n        ans += 1\n      else:\n        break\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3065, "slug": "minimum-operations-to-exceed-threshold-value-i", "solutions": ["class Solution:\n    def minOperations(self, nums: List[int], k: int) -> int:\n        return sum(x < k for x in nums)\n", "class Solution:\n  def minOperations(self, nums: list[int], k: int) -> int:\n    return sum(num < k for num in nums)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3084, "slug": "count-substrings-starting-and-ending-with-given-character", "solutions": ["class Solution:\n    def countSubstrings(self, s: str, c: str) -> int:\n        cnt = s.count(c)\n        return cnt + cnt * (cnt - 1) // 2\n", "class Solution:\n  def countSubstrings(self, s: str, c: str) -> int:\n    freq = s.count(c)\n    return freq * (freq + 1) // 2\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3053, "slug": "classifying-triangles-by-lengths", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3060, "slug": "user-activities-within-time-bounds", "solutions": ["import pandas as pd\n\n\ndef user_activities(sessions: pd.DataFrame) -> pd.DataFrame:\n    sessions = sessions.sort_values(by=[\"user_id\", \"session_start\"])\n    sessions[\"prev_session_end\"] = sessions.groupby([\"user_id\", \"session_type\"])[\n        \"session_end\"\n    ].shift(1)\n    sessions_filtered = sessions[\n        sessions[\"session_start\"] - sessions[\"prev_session_end\"]\n        <= pd.Timedelta(hours=12)\n    ]\n    return pd.DataFrame({\"user_id\": sessions_filtered[\"user_id\"].unique()})\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3072, "slug": "distribute-elements-into-two-arrays-ii", "solutions": ["class BinaryIndexedTree:\n    __slots__ = \"n\", \"c\"\n\n    def __init__(self, n: int):\n        self.n = n\n        self.c = [0] * (n + 1)\n\n    def update(self, x: int, delta: int) -> None:\n        while x <= self.n:\n            self.c[x] += delta\n            x += x & -x\n\n    def query(self, x: int) -> int:\n        s = 0\n        while x:\n            s += self.c[x]\n            x -= x & -x\n        return s\n\n\nclass Solution:\n    def resultArray(self, nums: List[int]) -> List[int]:\n        st = sorted(set(nums))\n        m = len(st)\n        tree1 = BinaryIndexedTree(m + 1)\n        tree2 = BinaryIndexedTree(m + 1)\n        tree1.update(bisect_left(st, nums[0]) + 1, 1)\n        tree2.update(bisect_left(st, nums[1]) + 1, 1)\n        arr1 = [nums[0]]\n        arr2 = [nums[1]]\n        for x in nums[2:]:\n            i = bisect_left(st, x) + 1\n            a = len(arr1) - tree1.query(i)\n            b = len(arr2) - tree2.query(i)\n            if a > b:\n                arr1.append(x)\n                tree1.update(i, 1)\n            elif a < b:\n                arr2.append(x)\n                tree2.update(i, 1)\n            elif len(arr1) <= len(arr2):\n                arr1.append(x)\n                tree1.update(i, 1)\n            else:\n                arr2.append(x)\n                tree2.update(i, 1)\n        return arr1 + arr2\n", "class FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def add(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def resultArray(self, nums: list[int]) -> list[int]:\n    arr1 = []\n    arr2 = []\n    ranks = self._getRanks(nums)\n    tree1 = FenwickTree(len(ranks))\n    tree2 = FenwickTree(len(ranks))\n\n    def add(num: int, arr: list[int], tree: FenwickTree) -> None:\n      arr.append(num)\n      tree.add(ranks[num], 1)\n\n    add(nums[0], arr1, tree1)\n    add(nums[1], arr2, tree2)\n\n    for i in range(2, len(nums)):\n      greaterCount1 = len(arr1) - tree1.get(ranks[nums[i]])\n      greaterCount2 = len(arr2) - tree2.get(ranks[nums[i]])\n      if greaterCount1 > greaterCount2:\n        add(nums[i], arr1, tree1)\n      elif greaterCount1 < greaterCount2:\n        add(nums[i], arr2, tree2)\n      elif len(arr1) > len(arr2):\n        add(nums[i], arr2, tree2)\n      else:\n        add(nums[i], arr1, tree1)\n\n    return arr1 + arr2\n\n  def _getRanks(self, nums: list[int]) -> dict[int, int]:\n    ranks = collections.Counter()\n    rank = 0\n    for num in sorted(set(nums)):\n      rank += 1\n      ranks[num] = rank\n    return ranks\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3013, "slug": "divide-an-array-into-subarrays-with-minimum-cost-ii", "solutions": ["class Solution:\n    def minimumCost(self, nums: List[int], k: int, dist: int) -> int:\n        def l2r():\n            nonlocal s\n            x = l.pop()\n            s -= x\n            r.add(x)\n\n        def r2l():\n            nonlocal s\n            x = r.pop(0)\n            l.add(x)\n            s += x\n\n        k -= 1\n        s = sum(nums[: dist + 2])\n        l = SortedList(nums[1 : dist + 2])\n        r = SortedList()\n        while len(l) > k:\n            l2r()\n        ans = s\n        for i in range(dist + 2, len(nums)):\n            x = nums[i - dist - 1]\n            if x in l:\n                l.remove(x)\n                s -= x\n            else:\n                r.remove(x)\n            y = nums[i]\n            if y < l[-1]:\n                l.add(y)\n                s += y\n            else:\n                r.add(y)\n            while len(l) < k:\n                r2l()\n            while len(l) > k:\n                l2r()\n            ans = min(ans, s)\n        return ans\n", "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def minimumCost(self, nums: list[int], k: int, dist: int) -> int:\n    # Equivalently, the problem is to find nums[0] + the minimum sum of the top\n    # k - 1 numbers in nums[i..i + dist], where i > 0 and i + dist < n.\n    windowSum = sum(nums[i] for i in range(1, dist + 2))\n    selected = SortedList(nums[i] for i in range(1, dist + 2))\n    candidates = SortedList()\n\n    def balance() -> int:\n      \"\"\"\n      Returns the updated `windowSum` by balancing the multiset `selected` to\n      keep the top k - 1 numbers.\n      \"\"\"\n      nonlocal windowSum\n      while len(selected) < k - 1:\n        minCandidate = candidates[0]\n        windowSum += minCandidate\n        selected.add(minCandidate)\n        candidates.remove(minCandidate)\n      while len(selected) > k - 1:\n        maxSelected = selected[-1]\n        windowSum -= maxSelected\n        selected.remove(maxSelected)\n        candidates.add(maxSelected)\n      return windowSum\n\n    windowSum = balance()\n    minWindowSum = windowSum\n\n    for i in range(dist + 2, len(nums)):\n      outOfScope = nums[i - dist - 1]\n      if outOfScope in selected:\n        windowSum -= outOfScope\n        selected.remove(outOfScope)\n      else:\n        candidates.remove(outOfScope)\n      if nums[i] < selected[-1]:  # nums[i] is a better number.\n        windowSum += nums[i]\n        selected.add(nums[i])\n      else:\n        candidates.add(nums[i])\n      windowSum = balance()\n      minWindowSum = min(minWindowSum, windowSum)\n\n    return nums[0] + minWindowSum\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3069, "slug": "distribute-elements-into-two-arrays-i", "solutions": ["class Solution:\n    def resultArray(self, nums: List[int]) -> List[int]:\n        arr1 = [nums[0]]\n        arr2 = [nums[1]]\n        for x in nums[2:]:\n            if arr1[-1] > arr2[-1]:\n                arr1.append(x)\n            else:\n                arr2.append(x)\n        return arr1 + arr2\n", "class Solution:\n  def resultArray(self, nums: list[int]) -> list[int]:\n    arr1 = [nums[0]]\n    arr2 = [nums[1]]\n\n    for i in range(2, len(nums)):\n      if arr1[-1] > arr2[-1]:\n        arr1.append(nums[i])\n      else:\n        arr2.append(nums[i])\n\n    return arr1 + arr2\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3055, "slug": "top-percentile-fraud", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3064, "slug": "guess-the-number-using-bitwise-questions-i", "solutions": ["# Definition of commonSetBits API.\n# def commonSetBits(num: int) -> int:\n\n\nclass Solution:\n    def findNumber(self) -> int:\n        return sum(1 << i for i in range(32) if commonSetBits(1 << i))\n", "# Definition of commonSetBits API.\n# def commonSetBits(num: int) -> int:\n\nclass Solution:\n  def findNumber(self) -> int:\n    return sum(1 << i for i in range(31)\n               if commonSetBits(1 << i) == 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3029, "slug": "minimum-time-to-revert-word-to-initial-state-i", "solutions": ["class Solution:\n    def minimumTimeToInitialState(self, word: str, k: int) -> int:\n        n = len(word)\n        for i in range(k, n, k):\n            if word[i:] == word[:-i]:\n                return i // k\n        return (n + k - 1) // k\n", "class Solution:\n  # Same as 3029. Minimum Time to Revert Word to Initial State I\n  def minimumTimeToInitialState(self, word: str, k: int) -> int:\n    n = len(word)\n    maxOps = (n - 1) // k + 1\n    z = self._zFunction(word)\n\n    for ans in range(1, maxOps):\n      if z[ans * k] >= n - ans * k:\n        return ans\n\n    return maxOps\n\n  def _zFunction(self, s: str) -> list[int]:\n    \"\"\"\n    Returns the z array, where z[i] is the length of the longest prefix of\n    s[i..n) which is also a prefix of s.\n\n    https://cp-algorithms.com/string/z-function.html#implementation\n    \"\"\"\n    n = len(s)\n    z = [0] * n\n    l = 0\n    r = 0\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n    return z\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3017, "slug": "count-the-number-of-houses-at-a-certain-distance-ii", "solutions": ["class Solution:\n    def countOfPairs(self, n: int, x: int, y: int) -> List[int]:\n        if abs(x - y) <= 1:\n            return [2 * x for x in reversed(range(n))]\n        cycle_len = abs(x - y) + 1\n        n2 = n - cycle_len + 2\n        res = [2 * x for x in reversed(range(n2))]\n        while len(res) < n:\n            res.append(0)\n        res2 = [cycle_len * 2] * (cycle_len >> 1)\n        if not cycle_len & 1:\n            res2[-1] = cycle_len\n        res2[0] -= 2\n        for i in range(len(res2)):\n            res[i] += res2[i]\n        if x > y:\n            x, y = y, x\n        tail1 = x - 1\n        tail2 = n - y\n        for tail in (tail1, tail2):\n            if not tail:\n                continue\n            i_mx = tail + (cycle_len >> 1)\n            val_mx = 4 * min((cycle_len - 3) >> 1, tail)\n            i_mx2 = i_mx - (1 - (cycle_len & 1))\n            res3 = [val_mx] * i_mx\n            res3[0] = 0\n            res3[1] = 0\n            if not cycle_len & 1:\n                res3[-1] = 0\n            for i, j in enumerate(range(4, val_mx, 4)):\n                res3[i + 2] = j\n                res3[i_mx2 - i - 1] = j\n            for i in range(1, tail + 1):\n                res3[i] += 2\n            if not cycle_len & 1:\n                mn = cycle_len >> 1\n                for i in range(mn, mn + tail):\n                    res3[i] += 2\n            for i in range(len(res3)):\n                res[i] += res3[i]\n        return res\n", "class Solution:\n  # Same as 3015. Count the Number of Houses at a Certain Distance I\n  def countOfPairs(self, n: int, x: int, y: int) -> list[int]:\n    if x > y:\n      x, y = y, x\n\n    def bothInRing(ringLen: int) -> list[int]:\n      \"\"\"\n      Returns the contribution from the scenario where two houses are located\n      in the ring.\n      \"\"\"\n      res = [0] * n\n      for k in range(1, (ringLen - 1) // 2 + 1):\n        res[k - 1] += ringLen\n      if ringLen % 2 == 0:\n        res[ringLen // 2 - 1] += ringLen // 2\n      return res\n\n    def bothInTheSameLine(lineLen: int) -> list[int]:\n      \"\"\"\n      Returns the contribution from the scenario where two houses are either\n      located in the left line [1, x) or the right line (y, n].\n      \"\"\"\n      res = [0] * n\n      for k in range(1, lineLen + 1):\n        res[k - 1] += lineLen - k\n      return res\n\n    def lineToRing(lineLen: int, ringLen: int) -> list[int]:\n      \"\"\"\n      Returns the contribution from the scenario where one house is either\n      located in the left line [1, x) or the right line (y, n] and the\n      other house is located in the cycle.\n      \"\"\"\n      res = [0] * n\n      for k in range(1, lineLen + ringLen):\n        # min(\n        #   at most k - 1 since we need to give 1 to the line,\n        #   at most ringLen / 2 since for length > ringLen / 2, it can always be\n        #     calculated as ringLen - ringLen / 2\n        # )\n        maxInRingLen = min(k - 1, ringLen // 2)\n        # max(at least 0, at lest k - lineLen)\n        minInRingLen = max(0, k - lineLen)\n        if minInRingLen <= maxInRingLen:\n          # Each ring length contributes 2 to the count due to the split of\n          # paths when entering the ring: One path traverses the upper half of\n          # the ring, and the other traverses the lower half.\n          # This is illustrated as follows:\n          #   Path 1: ... -- x -- (upper half of the ring)\n          #   Path 2: ... -- x -- (lower half of the ring)\n          res[k - 1] += (maxInRingLen - minInRingLen + 1) * 2\n          if minInRingLen == 0:\n            # Subtract 1 since there's no split.\n            res[k - 1] -= 1\n          if maxInRingLen * 2 == ringLen:\n            # Subtract 1 since the following case only contribute one:\n            #   ... -- x -- (upper half of the ring) -- middle point\n            #   ... -- x -- (upper half of the ring) -- middle point\n            res[k - 1] -= 1\n      return res\n\n    def lineToLine(leftLineLen: int, rightLineLen: int) -> list[int]:\n      \"\"\"\n      Returns the contribution from the scenario where one house is in the left\n      line [1, x) and the other house is in the right line (y, n].\n      \"\"\"\n      res = [0] * n\n      for k in range(leftLineLen + rightLineLen + 2):\n        # min(\n        #   at most leftLineLen,\n        #   at most k - 1 - (x < y) since we need to give 1 to the right line\n        #     and if x < y we need to give another 1 to \"x - y\".\n        # )\n        maxInLeft = min(leftLineLen, k - 1 - (x < y))\n        # max(at least 1, at least k - rightLineLen - (x < y))\n        minInLeft = max(1, k - rightLineLen - (x < y))\n        if minInLeft <= maxInLeft:\n          res[k - 1] += maxInLeft - minInLeft + 1\n      return res\n\n    ringLen = y - x + 1\n    leftLineLen = x - 1\n    rightLineLen = (n - y)\n\n    ans = [0] * n\n    ans = list(map(operator.add, ans, bothInRing(ringLen)))\n    ans = list(map(operator.add, ans, bothInTheSameLine(leftLineLen)))\n    ans = list(map(operator.add, ans, bothInTheSameLine(rightLineLen)))\n    ans = list(map(operator.add, ans, lineToRing(leftLineLen, ringLen)))\n    ans = list(map(operator.add, ans, lineToRing(rightLineLen, ringLen)))\n    ans = list(map(operator.add, ans, lineToLine(leftLineLen, rightLineLen)))\n    return [freq * 2 for freq in ans]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3099, "slug": "harshad-number", "solutions": ["class Solution:\n    def sumOfTheDigitsOfHarshadNumber(self, x: int) -> int:\n        s, y = 0, x\n        while y:\n            s += y % 10\n            y //= 10\n        return s if x % s == 0 else -1\n", "class Solution:\n  def sumOfTheDigitsOfHarshadNumber(self, x: int) -> int:\n    digitSum = self._getDigitSum(x)\n    return digitSum if x % digitSum == 0 else -1\n\n  def _getDigitSum(self, num: int) -> int:\n    return sum(int(digit) for digit in str(num))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3077, "slug": "maximum-strength-of-k-disjoint-subarrays", "solutions": ["class Solution:\n    def maximumStrength(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        f = [[[-inf, -inf] for _ in range(k + 1)] for _ in range(n + 1)]\n        f[0][0][0] = 0\n        for i, x in enumerate(nums, 1):\n            for j in range(k + 1):\n                sign = 1 if j & 1 else -1\n                f[i][j][0] = max(f[i - 1][j][0], f[i - 1][j][1])\n                f[i][j][1] = max(f[i][j][1], f[i - 1][j][1] + sign * x * (k - j + 1))\n                if j:\n                    f[i][j][1] = max(\n                        f[i][j][1], max(f[i - 1][j - 1]) + sign * x * (k - j + 1)\n                    )\n        return max(f[n][k])\n", "class Solution:\n  def maximumStrength(self, nums: list[int], k: int) -> int:\n\n    @functools.lru_cache(None)\n    def dp(i: int, k: int, fresh: bool) -> int:\n      \"\"\"\n      Returns the maximum strength of nums[i..n) with k operations left, where\n      `fresh` means we're starting a new subarray.\n      \"\"\"\n      if len(nums) - i < k:\n        return -math.inf\n      if k == 0:\n        return 0\n      if i == len(nums):\n        return 0 if k == 0 else -math.inf\n      # If it's not fresh, we can't skip the current number and consider it as a\n      # fresh start, since the case where it's fresh is already covered by\n      # `includeAndFreshStart`.\n      skip = dp(i + 1, k, True) if fresh else -math.inf\n      gain = (-1 if k % 2 == 0 else 1) * nums[i] * k\n      includeAndContinue = dp(i + 1, k, False) + gain\n      includeAndFreshStart = dp(i + 1, k - 1, True) + gain\n      return max(skip, includeAndContinue, includeAndFreshStart)\n\n    return dp(0, k, True)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3020, "slug": "find-the-maximum-number-of-elements-in-subset", "solutions": ["class Solution:\n    def maximumLength(self, nums: List[int]) -> int:\n        cnt = Counter(nums)\n        ans = cnt[1] - (cnt[1] % 2 ^ 1)\n        del cnt[1]\n        for x in cnt:\n            t = 0\n            while cnt[x] > 1:\n                x = x * x\n                t += 2\n            t += 1 if cnt[x] else -1\n            ans = max(ans, t)\n        return ans\n", "class Solution:\n  def maximumLength(self, nums: list[int]) -> int:\n    maxNum = max(nums)\n    count = collections.Counter(nums)\n    ans = count[1] - (count[1] % 2 == 0) if 1 in count else 1\n\n    for num in nums:\n      if num == 1:\n        continue\n      length = 0\n      x = num\n      while x <= maxNum and x in count and count[x] >= 2:\n        length += 2\n        x *= x\n      # x is now x^k, and the pattern is [x, ..., x^(k/2), x^(k/2), ..., x].\n      # The goal is to determine if we can insert x^k in the middle of the\n      # pattern to increase the length by 1. If not, we make x^(k/2) the middle\n      # and decrease the length by 1.\n      ans = max(ans, length + (1 if x in count else -1))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3074, "slug": "apple-redistribution-into-boxes", "solutions": ["class Solution:\n    def minimumBoxes(self, apple: List[int], capacity: List[int]) -> int:\n        capacity.sort(reverse=True)\n        s = sum(apple)\n        for i, c in enumerate(capacity, 1):\n            s -= c\n            if s <= 0:\n                return i\n", "class Solution:\n  def minimumBoxes(self, apple: list[int], capacity: list[int]) -> int:\n    appleSum = sum(apple)\n    capacitySum = 0\n\n    for i, c in enumerate(sorted(capacity, reverse=True)):\n      capacitySum += c\n      if capacitySum >= appleSum:\n        return i + 1\n\n    return len(capacity)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3008, "slug": "find-beautiful-indices-in-the-given-array-ii", "solutions": ["class Solution:\n    def beautifulIndices(self, s: str, a: str, b: str, k: int) -> List[int]:\n        def build_prefix_function(pattern):\n            prefix_function = [0] * len(pattern)\n            j = 0\n            for i in range(1, len(pattern)):\n                while j > 0 and pattern[i] != pattern[j]:\n                    j = prefix_function[j - 1]\n                if pattern[i] == pattern[j]:\n                    j += 1\n                prefix_function[i] = j\n            return prefix_function\n\n        def kmp_search(pattern, text, prefix_function):\n            occurrences = []\n            j = 0\n            for i in range(len(text)):\n                while j > 0 and text[i] != pattern[j]:\n                    j = prefix_function[j - 1]\n                if text[i] == pattern[j]:\n                    j += 1\n                if j == len(pattern):\n                    occurrences.append(i - j + 1)\n                    j = prefix_function[j - 1]\n            return occurrences\n\n        prefix_a = build_prefix_function(a)\n        prefix_b = build_prefix_function(b)\n\n        resa = kmp_search(a, s, prefix_a)\n        resb = kmp_search(b, s, prefix_b)\n\n        res = []\n        print(resa, resb)\n        i = 0\n        j = 0\n        while i < len(resa):\n            while j < len(resb):\n                if abs(resb[j] - resa[i]) <= k:\n                    res.append(resa[i])\n                    break\n                elif j + 1 < len(resb) and abs(resb[j + 1] - resa[i]) < abs(\n                    resb[j] - resa[i]\n                ):\n                    j += 1\n                else:\n                    break\n            i += 1\n        return res\n", "class Solution:\n  # Same as 3006. Find Beautiful Indices in the Given Array I\n  def beautifulIndices(self, s: str, a: str, b: str, k: int) -> list[int]:\n    ans = []\n    indicesA = self._kmp(s, a)\n    indicesB = self._kmp(s, b)\n    indicesBIndex = 0  # indicesB' index\n\n    for i in indicesA:\n      # The constraint is: |j - i| <= k. So, -k <= j - i <= k. So, move\n      # `indicesBIndex` s.t. j - i >= -k, where j := indicesB[indicesBIndex].\n      while indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i < -k:\n        indicesBIndex += 1\n      if indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i <= k:\n        ans.append(i)\n\n    return ans\n\n  def _kmp(self, s: str, pattern: str) -> list[int]:\n    \"\"\"Returns the starting indices of all occurrences of the pattern in `s`.\"\"\"\n\n    def getLPS(pattern: str) -> list[int]:\n      \"\"\"\n      Returns the lps array, where lps[i] is the length of the longest prefix of\n      pattern[0..i] which is also a suffix of this substring.\n      \"\"\"\n      lps = [0] * len(pattern)\n      j = 0\n      for i in range(1, len(pattern)):\n        while j > 0 and pattern[j] != pattern[i]:\n          j = lps[j - 1]\n        if pattern[i] == pattern[j]:\n          lps[i] = j + 1\n          j += 1\n      return lps\n\n    lps = getLPS(pattern)\n    res = []\n    i = 0  # s' index\n    j = 0  # pattern's index\n    while i < len(s):\n      if s[i] == pattern[j]:\n        i += 1\n        j += 1\n        if j == len(pattern):\n          res.append(i - j)\n          j = lps[j - 1]\n      elif j != 0:  # Mismatch after j matches.\n        # Don't match lps[0..lps[j - 1]] since they will match anyway.\n        j = lps[j - 1]\n      else:\n        i += 1\n    return res\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3032, "slug": "count-numbers-with-unique-digits-ii", "solutions": ["class Solution:\n    def numberCount(self, a: int, b: int) -> int:\n        @cache\n        def dfs(pos: int, mask: int, limit: bool) -> int:\n            if pos >= len(num):\n                return 1 if mask else 0\n            up = int(num[pos]) if limit else 9\n            ans = 0\n            for i in range(up + 1):\n                if mask >> i & 1:\n                    continue\n                nxt = 0 if mask == 0 and i == 0 else mask | 1 << i\n                ans += dfs(pos + 1, nxt, limit and i == up)\n            return ans\n\n        num = str(a - 1)\n        x = dfs(0, 0, True)\n        dfs.cache_clear()\n        num = str(b)\n        y = dfs(0, 0, True)\n        return y - x\n", "class Solution:\n  def numberCount(self, a: int, b: int) -> int:\n    return sum(len(set(str(num))) == len(str(num))\n               for num in range(a, b + 1))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3094, "slug": "guess-the-number-using-bitwise-questions-ii", "solutions": ["# Definition of commonBits API.\n# def commonBits(num: int) -> int:\n\n\nclass Solution:\n    def findNumber(self) -> int:\n        n = 0\n        for i in range(32):\n            count1 = commonBits(1 << i)\n            count2 = commonBits(1 << i)\n            if count1 > count2:\n                n |= 1 << i\n        return n\n", "# Definition of commonBits API.\n# def commonBits(num: int) -> int:\n\nclass Solution:\n  def findNumber(self) -> int:\n    return functools.reduce(lambda x, i: x | (1 << i)\n                            if commonBits(1 << i) > commonBits(1 << i)\n                            else x, range(31), 0)\n", "# Definition of commonBits API.\n# def commonBits(num: int) -> int:\n\nclass Solution:\n  def findNumber(self) -> int:\n    ans = 0\n    sameCount = commonBits(0)\n\n    for i in range(31):\n      if commonBits(1 << i) > sameCount:\n        ans |= 1 << i\n      commonBits(1 << i)  # Revert the XOR.\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3066, "slug": "minimum-operations-to-exceed-threshold-value-ii", "solutions": ["class Solution:\n    def minOperations(self, nums: List[int], k: int) -> int:\n        heapify(nums)\n        ans = 0\n        while len(nums) > 1 and nums[0] < k:\n            x, y = heappop(nums), heappop(nums)\n            heappush(nums, x * 2 + y)\n            ans += 1\n        return ans\n", "class Solution:\n  def minOperations(self, nums: list[int], k: int) -> int:\n    ans = 0\n    minHeap = nums.copy()\n    heapq.heapify(minHeap)\n\n    while len(minHeap) > 1 and minHeap[0] < k:\n      x = heapq.heappop(minHeap)\n      y = heapq.heappop(minHeap)\n      heapq.heappush(minHeap, min(x, y) * 2 + max(x, y))\n      ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3006, "slug": "find-beautiful-indices-in-the-given-array-i", "solutions": ["class Solution:\n    def beautifulIndices(self, s: str, a: str, b: str, k: int) -> List[int]:\n        def build_prefix_function(pattern):\n            prefix_function = [0] * len(pattern)\n            j = 0\n            for i in range(1, len(pattern)):\n                while j > 0 and pattern[i] != pattern[j]:\n                    j = prefix_function[j - 1]\n                if pattern[i] == pattern[j]:\n                    j += 1\n                prefix_function[i] = j\n            return prefix_function\n\n        def kmp_search(pattern, text, prefix_function):\n            occurrences = []\n            j = 0\n            for i in range(len(text)):\n                while j > 0 and text[i] != pattern[j]:\n                    j = prefix_function[j - 1]\n                if text[i] == pattern[j]:\n                    j += 1\n                if j == len(pattern):\n                    occurrences.append(i - j + 1)\n                    j = prefix_function[j - 1]\n            return occurrences\n\n        prefix_a = build_prefix_function(a)\n        prefix_b = build_prefix_function(b)\n\n        resa = kmp_search(a, s, prefix_a)\n        resb = kmp_search(b, s, prefix_b)\n\n        res = []\n        print(resa, resb)\n        i = 0\n        j = 0\n        while i < len(resa):\n            while j < len(resb):\n                if abs(resb[j] - resa[i]) <= k:\n                    res.append(resa[i])\n                    break\n                elif j + 1 < len(resb) and abs(resb[j + 1] - resa[i]) < abs(\n                    resb[j] - resa[i]\n                ):\n                    j += 1\n                else:\n                    break\n            i += 1\n        return res\n", "class Solution:\n  def beautifulIndices(self, s: str, a: str, b: str, k: int) -> list[int]:\n    ans = []\n    indicesA = self._kmp(s, a)\n    indicesB = self._kmp(s, b)\n    indicesBIndex = 0  # indicesB' index\n\n    for i in indicesA:\n      # The constraint is: |j - i| <= k. So, -k <= j - i <= k. So, move\n      # `indicesBIndex` s.t. j - i >= -k, where j := indicesB[indicesBIndex].\n      while indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i < -k:\n        indicesBIndex += 1\n      if indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i <= k:\n        ans.append(i)\n\n    return ans\n\n  def _kmp(self, s: str, pattern: str) -> list[int]:\n    \"\"\"Returns the starting indices of all occurrences of the pattern in `s`.\"\"\"\n\n    def getLPS(pattern: str) -> list[int]:\n      \"\"\"\n      Returns the lps array, where lps[i] is the length of the longest prefix of\n      pattern[0..i] which is also a suffix of this substring.\n      \"\"\"\n      lps = [0] * len(pattern)\n      j = 0\n      for i in range(1, len(pattern)):\n        while j > 0 and pattern[j] != pattern[i]:\n          j = lps[j - 1]\n        if pattern[i] == pattern[j]:\n          lps[i] = j + 1\n          j += 1\n      return lps\n\n    res = []\n    lps = getLPS(pattern)\n    i = 0  # s' index\n    j = 0  # pattern's index\n    while i < len(s):\n      if s[i] == pattern[j]:\n        i += 1\n        j += 1\n        if j == len(pattern):\n          res.append(i - j)\n          j = lps[j - 1]\n      elif j != 0:  # Mismatch after j matches.\n        # Don't match lps[0..lps[j - 1]] since they will match anyway.\n        j = lps[j - 1]\n      else:\n        i += 1\n    return res\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3051, "slug": "find-candidates-for-data-scientist-position", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3093, "slug": "longest-common-suffix-queries", "solutions": ["class Trie:\n    __slots__ = (\"children\", \"length\", \"idx\")\n\n    def __init__(self):\n        self.children = [None] * 26\n        self.length = inf\n        self.idx = inf\n\n    def insert(self, w: str, i: int):\n        node = self\n        if node.length > len(w):\n            node.length = len(w)\n            node.idx = i\n        for c in w[::-1]:\n            idx = ord(c) - ord(\"a\")\n            if node.children[idx] is None:\n                node.children[idx] = Trie()\n            node = node.children[idx]\n            if node.length > len(w):\n                node.length = len(w)\n                node.idx = i\n\n    def query(self, w: str) -> int:\n        node = self\n        for c in w[::-1]:\n            idx = ord(c) - ord(\"a\")\n            if node.children[idx] is None:\n                break\n            node = node.children[idx]\n        return node.idx\n\n\nclass Solution:\n    def stringIndices(\n        self, wordsContainer: List[str], wordsQuery: List[str]\n    ) -> List[int]:\n        trie = Trie()\n        for i, w in enumerate(wordsContainer):\n            trie.insert(w, i)\n        return [trie.query(w) for w in wordsQuery]\n", "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.isWord = False\n    self.length = math.inf\n    self.index = -1\n\n\nclass Solution:\n  def stringIndices(\n      self,\n      wordsContainer: list[str],\n      wordsQuery: list[str],\n  ) -> list[int]:\n    ans = []\n    root = TrieNode()\n    minIndex = min(enumerate(wordsContainer), key=lambda x: len(x[1]))[0]\n\n    def insert(word: str, index: int) -> None:\n      node = root\n      for c in reversed(word):\n        node = node.children.setdefault(c, TrieNode())\n        if node.length > len(word):\n          node.length = len(word)\n          node.index = index\n\n    def search(word: str) -> int:\n      node = root\n      for c in reversed(word):\n        if c not in node.children:\n          return node.index\n        node = node.children[c]\n      return node.index\n\n    for i, word in enumerate(wordsContainer):\n      insert(word, i)\n\n    for query in wordsQuery:\n      index = search(query)\n      ans.append(minIndex if index == -1 else index)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 634, "slug": "find-the-derangement-of-an-array", "solutions": ["class Solution:\n    def findDerangement(self, n: int) -> int:\n        mod = 10**9 + 7\n        f = [1] + [0] * n\n        for i in range(2, n + 1):\n            f[i] = (i - 1) * (f[i - 1] + f[i - 2]) % mod\n        return f[n]\n", "class Solution:\n  def findDerangement(self, n: int) -> int:\n    MOD = 1_000_000_007\n    dp = [1] + [0] * n\n\n    for i in range(2, n + 1):\n      dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2]) % MOD\n\n    return dp[n]\n", "class Solution:\n  def findDerangement(self, n: int) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def dp(i: int) -> int:\n      if i == 0:\n        return 1\n      if i == 1:\n        return 0\n      return (i - 1) * (dp(i - 1) + dp(i - 2)) % MOD\n\n    return dp(n)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 657, "slug": "robot-return-to-origin", "solutions": ["class Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        x = y = 0\n        for c in moves:\n            match c:\n                case \"U\":\n                    y += 1\n                case \"D\":\n                    y -= 1\n                case \"L\":\n                    x -= 1\n                case \"R\":\n                    x += 1\n        return x == 0 and y == 0\n", "class Solution:\n  def judgeCircle(self, moves: str) -> bool:\n    return moves.count('R') == moves.count('L') and moves.count('U') == moves.count('D')\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 627, "slug": "swap-salary", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 678, "slug": "valid-parenthesis-string", "solutions": ["class Solution:\n    def checkValidString(self, s: str) -> bool:\n        n = len(s)\n        dp = [[False] * n for _ in range(n)]\n        for i, c in enumerate(s):\n            dp[i][i] = c == '*'\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 1, n):\n                dp[i][j] = (\n                    s[i] in '(*' and s[j] in '*)' and (i + 1 == j or dp[i + 1][j - 1])\n                )\n                dp[i][j] = dp[i][j] or any(\n                    dp[i][k] and dp[k + 1][j] for k in range(i, j)\n                )\n        return dp[0][-1]\n", "class Solution:\n  def checkValidString(self, s: str) -> bool:\n    low = 0\n    high = 0\n\n    for c in s:\n      if c == '(':\n        low += 1\n        high += 1\n      elif c == ')':\n        if low > 0:\n          low -= 1\n        high -= 1\n      else:\n        if low > 0:\n          low -= 1\n        high += 1\n      if high < 0:\n        return False\n\n    return low == 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 622, "slug": "design-circular-queue", "solutions": ["class MyCircularQueue:\n    def __init__(self, k: int):\n        self.q = [0] * k\n        self.size = 0\n        self.capacity = k\n        self.front = 0\n\n    def enQueue(self, value: int) -> bool:\n        if self.isFull():\n            return False\n        self.q[(self.front + self.size) % self.capacity] = value\n        self.size += 1\n        return True\n\n    def deQueue(self) -> bool:\n        if self.isEmpty():\n            return False\n        self.front = (self.front + 1) % self.capacity\n        self.size -= 1\n        return True\n\n    def Front(self) -> int:\n        return -1 if self.isEmpty() else self.q[self.front]\n\n    def Rear(self) -> int:\n        if self.isEmpty():\n            return -1\n        return self.q[(self.front + self.size - 1) % self.capacity]\n\n    def isEmpty(self) -> bool:\n        return self.size == 0\n\n    def isFull(self) -> bool:\n        return self.size == self.capacity\n\n\n# Your MyCircularQueue object will be instantiated and called as such:\n# obj = MyCircularQueue(k)\n# param_1 = obj.enQueue(value)\n# param_2 = obj.deQueue()\n# param_3 = obj.Front()\n# param_4 = obj.Rear()\n# param_5 = obj.isEmpty()\n# param_6 = obj.isFull()\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 624, "slug": "maximum-distance-in-arrays", "solutions": ["class Solution:\n    def maxDistance(self, arrays: List[List[int]]) -> int:\n        ans = 0\n        mi, mx = arrays[0][0], arrays[0][-1]\n        for arr in arrays[1:]:\n            a, b = abs(arr[0] - mx), abs(arr[-1] - mi)\n            ans = max(ans, a, b)\n            mi = min(mi, arr[0])\n            mx = max(mx, arr[-1])\n        return ans\n", "class Solution:\n  def maxDistance(self, arrays: list[list[int]]) -> int:\n    min1, index_min1 = min((A[0], i) for i, A in enumerate(arrays))\n    max1, index_max1 = max((A[-1], i) for i, A in enumerate(arrays))\n    if index_min1 != index_max1:\n      return max1 - min1\n\n    min2, index_min2 = min((A[0], i)\n                           for i, A in enumerate(arrays) if i != index_min1)\n    max2, index_min2 = max((A[-1], i)\n                           for i, A in enumerate(arrays) if i != index_max1)\n    return max(max1 - min2, max2 - min1)\n", "class Solution:\n  def maxDistance(self, arrays: list[list[int]]) -> int:\n    ans = 0\n    mn = 10000\n    mx = -10000\n\n    for A in arrays:\n      ans = max(ans, A[-1] - mn, mx - A[0])\n      mn = min(mn, A[0])\n      mx = max(mx, A[-1])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 672, "slug": "bulb-switcher-ii", "solutions": ["class Solution:\n    def flipLights(self, n: int, presses: int) -> int:\n        ops = (0b111111, 0b010101, 0b101010, 0b100100)\n        n = min(n, 6)\n        vis = set()\n        for mask in range(1 << 4):\n            cnt = mask.bit_count()\n            if cnt <= presses and cnt % 2 == presses % 2:\n                t = 0\n                for i, op in enumerate(ops):\n                    if (mask >> i) & 1:\n                        t ^= op\n                t &= (1 << 6) - 1\n                t >>= 6 - n\n                vis.add(t)\n        return len(vis)\n", "class Solution:\n  def flipLights(self, n: int, m: int) -> int:\n    n = min(n, 3)\n\n    if m == 0:\n      return 1\n    if m == 1:\n      return [2, 3, 4][n - 1]\n    if m == 2:\n      return [2, 4, 7][n - 1]\n\n    return [2, 4, 8][n - 1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 629, "slug": "k-inverse-pairs-array", "solutions": ["class Solution:\n    def kInversePairs(self, n: int, k: int) -> int:\n        mod = 10**9 + 7\n        f = [1] + [0] * k\n        s = [0] * (k + 2)\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                f[j] = (s[j + 1] - s[max(0, j - (i - 1))]) % mod\n            for j in range(1, k + 2):\n                s[j] = (s[j - 1] + f[j - 1]) % mod\n        return f[k]\n", "class Solution:\n  def kInversePairs(self, n: int, k: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i][j] := the number of permutations of numbers 1..i with j inverse pairs\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n\n    # If there's no inverse pair, the permutation is unique '123..i'\n    for i in range(n + 1):\n      dp[i][0] = 1\n\n    for i in range(1, n + 1):\n      for j in range(1, k + 1):\n        dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % MOD\n        if j - i >= 0:\n          dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + MOD) % MOD\n\n    return dp[n][k]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 601, "slug": "human-traffic-of-stadium", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 661, "slug": "image-smoother", "solutions": ["class Solution:\n    def imageSmoother(self, img: List[List[int]]) -> List[List[int]]:\n        m, n = len(img), len(img[0])\n        ans = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                s = cnt = 0\n                for x in range(i - 1, i + 2):\n                    for y in range(j - 1, j + 2):\n                        if 0 <= x < m and 0 <= y < n:\n                            cnt += 1\n                            s += img[x][y]\n                ans[i][j] = s // cnt\n        return ans\n", "class Solution:\n  def imageSmoother(self, M: list[list[int]]) -> list[list[int]]:\n    m = len(M)\n    n = len(M[0])\n    ans = [[0 for j in range(n)] for i in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        ones = 0\n        count = 0\n        for y in range(max(0, i - 1), min(m, i + 2)):\n          for x in range(max(0, j - 1), min(n, j + 2)):\n            ones += M[y][x]\n            count += 1\n        ans[i][j] = ones // count\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 613, "slug": "shortest-distance-in-a-line", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 695, "slug": "max-area-of-island", "solutions": ["class Solution:\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n        def dfs(i: int, j: int) -> int:\n            if grid[i][j] == 0:\n                return 0\n            ans = 1\n            grid[i][j] = 0\n            dirs = (-1, 0, 1, 0, -1)\n            for a, b in pairwise(dirs):\n                x, y = i + a, j + b\n                if 0 <= x < m and 0 <= y < n:\n                    ans += dfs(x, y)\n            return ans\n\n        m, n = len(grid), len(grid[0])\n        return max(dfs(i, j) for i in range(m) for j in range(n))\n", "class Solution:\n  def maxAreaOfIsland(self, grid: list[list[int]]) -> int:\n    def dfs(i: int, j: int) -> int:\n      if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]):\n        return 0\n      if grid[i][j] != 1:\n        return 0\n\n      grid[i][j] = 2\n\n      return 1 + dfs(i + 1, j) + dfs(i - 1, j) + dfs(i, j + 1) + dfs(i, j - 1)\n\n    return max(dfs(i, j) for i in range(len(grid)) for j in range(len(grid[0])))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 603, "slug": "consecutive-available-seats", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 617, "slug": "merge-two-binary-trees", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def mergeTrees(\n        self, root1: Optional[TreeNode], root2: Optional[TreeNode]\n    ) -> Optional[TreeNode]:\n        if root1 is None:\n            return root2\n        if root2 is None:\n            return root1\n        node = TreeNode(root1.val + root2.val)\n        node.left = self.mergeTrees(root1.left, root2.left)\n        node.right = self.mergeTrees(root1.right, root2.right)\n        return node\n", "class Solution:\n  def mergeTrees(\n      self,\n      root1: TreeNode | None,\n      root2: TreeNode | None,\n  ) -> TreeNode | None:\n    if not root1 and not root2:\n      return None\n    val = (root1.val if root1 else 0) + (root2.val if root2 else 0)\n    root = TreeNode(val)\n    root.left = self.mergeTrees(root1.left if root1 else None,\n                                root2.left if root2 else None)\n    root.right = self.mergeTrees(root1.right if root1 else None,\n                                 root2.right if root2 else None)\n    return root\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 688, "slug": "knight-probability-in-chessboard", "solutions": ["class Solution:\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\n        f = [[[0] * n for _ in range(n)] for _ in range(k + 1)]\n        for i in range(n):\n            for j in range(n):\n                f[0][i][j] = 1\n        for h in range(1, k + 1):\n            for i in range(n):\n                for j in range(n):\n                    for a, b in pairwise((-2, -1, 2, 1, -2, 1, 2, -1, -2)):\n                        x, y = i + a, j + b\n                        if 0 <= x < n and 0 <= y < n:\n                            f[h][i][j] += f[h - 1][x][y] / 8\n        return f[k][row][column]\n", "class Solution:\n  def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\n    DIRS = ((1, 2), (2, 1), (2, -1), (1, -2),\n            (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n    # dp[i][j] := the probability to stand on (i, j)\n    dp = [[0] * n for _ in range(n)]\n    dp[row][column] = 1.0\n\n    for _ in range(k):\n      newDp = [[0] * n for _ in range(n)]\n      for i in range(n):\n        for j in range(n):\n          for dx, dy in DIRS:\n            x = i + dx\n            y = j + dy\n            if 0 <= x < n and 0 <= y < n:\n              newDp[i][j] += dp[x][y]\n      dp = newDp\n\n    return sum(map(sum, dp)) / 8**k\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 625, "slug": "minimum-factorization", "solutions": ["class Solution:\n    def smallestFactorization(self, num: int) -> int:\n        if num < 2:\n            return num\n        ans, mul = 0, 1\n        for i in range(9, 1, -1):\n            while num % i == 0:\n                num //= i\n                ans = mul * i + ans\n                mul *= 10\n        return ans if num < 2 and ans <= 2**31 - 1 else 0\n", "class Solution:\n  def smallestFactorization(self, num: int) -> int:\n    if num == 1:\n      return 1\n\n    ans = 0\n    base = 1\n\n    for i in range(9, 1, -1):\n      while num % i == 0:\n        num //= i\n        ans = base * i + ans\n        base *= 10\n\n    return ans if num == 1 and ans < 2**31 - 1 else 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 649, "slug": "dota2-senate", "solutions": ["class Solution:\n    def predictPartyVictory(self, senate: str) -> str:\n        qr = deque()\n        qd = deque()\n        for i, c in enumerate(senate):\n            if c == \"R\":\n                qr.append(i)\n            else:\n                qd.append(i)\n        n = len(senate)\n        while qr and qd:\n            if qr[0] < qd[0]:\n                qr.append(qr[0] + n)\n            else:\n                qd.append(qd[0] + n)\n            qr.popleft()\n            qd.popleft()\n        return \"Radiant\" if qr else \"Dire\"\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 611, "slug": "valid-triangle-number", "solutions": ["class Solution:\n    def triangleNumber(self, nums: List[int]) -> int:\n        nums.sort()\n        ans, n = 0, len(nums)\n        for i in range(n - 2):\n            for j in range(i + 1, n - 1):\n                k = bisect_left(nums, nums[i] + nums[j], lo=j + 1) - 1\n                ans += k - j\n        return ans\n", "class Solution:\n  def triangleNumber(self, nums: list[int]) -> int:\n    ans = 0\n\n    nums.sort()\n\n    for k in range(len(nums) - 1, 1, -1):\n      i = 0\n      j = k - 1\n      while i < j:\n        if nums[i] + nums[j] > nums[k]:\n          ans += j - i\n          j -= 1\n        else:\n          i += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 626, "slug": "exchange-seats", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 675, "slug": "cut-off-trees-for-golf-event", "solutions": ["class Solution:\n    def cutOffTree(self, forest: List[List[int]]) -> int:\n        def f(i, j, x, y):\n            return abs(i - x) + abs(j - y)\n\n        def bfs(i, j, x, y):\n            q = [(f(i, j, x, y), i, j)]\n            dist = {i * n + j: 0}\n            while q:\n                _, i, j = heappop(q)\n                step = dist[i * n + j]\n                if (i, j) == (x, y):\n                    return step\n                for a, b in [[0, -1], [0, 1], [-1, 0], [1, 0]]:\n                    c, d = i + a, j + b\n                    if 0 <= c < m and 0 <= d < n and forest[c][d] > 0:\n                        if c * n + d not in dist or dist[c * n + d] > step + 1:\n                            dist[c * n + d] = step + 1\n                            heappush(q, (dist[c * n + d] + f(c, d, x, y), c, d))\n            return -1\n\n        m, n = len(forest), len(forest[0])\n        trees = [\n            (forest[i][j], i, j) for i in range(m) for j in range(n) if forest[i][j] > 1\n        ]\n        trees.sort()\n        i = j = 0\n        ans = 0\n        for _, x, y in trees:\n            t = bfs(i, j, x, y)\n            if t == -1:\n                return -1\n            ans += t\n            i, j = x, y\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 689, "slug": "maximum-sum-of-3-non-overlapping-subarrays", "solutions": ["class Solution:\n    def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:\n        s = s1 = s2 = s3 = 0\n        mx1 = mx12 = 0\n        idx1, idx12 = 0, ()\n        ans = []\n        for i in range(k * 2, len(nums)):\n            s1 += nums[i - k * 2]\n            s2 += nums[i - k]\n            s3 += nums[i]\n            if i >= k * 3 - 1:\n                if s1 > mx1:\n                    mx1 = s1\n                    idx1 = i - k * 3 + 1\n                if mx1 + s2 > mx12:\n                    mx12 = mx1 + s2\n                    idx12 = (idx1, i - k * 2 + 1)\n                if mx12 + s3 > s:\n                    s = mx12 + s3\n                    ans = [*idx12, i - k + 1]\n                s1 -= nums[i - k * 3 + 1]\n                s2 -= nums[i - k * 2 + 1]\n                s3 -= nums[i - k + 1]\n        return ans\n", "class Solution:\n  def maxSumOfThreeSubarrays(self, nums: list[int], k: int) -> list[int]:\n    n = len(nums) - k + 1\n    # sums[i] := sum(nums[i..i + k))\n    sums = [0] * n\n    # l[i] := the index in [0..i] that has the maximum sums[i]\n    l = [0] * n\n    # r[i] := the index in [i..n) that has the maximum sums[i]\n    r = [0] * n\n\n    summ = 0\n    for i, num in enumerate(nums):\n      summ += num\n      if i >= k:\n        summ -= nums[i - k]\n      if i >= k - 1:\n        sums[i - k + 1] = summ\n\n    maxIndex = 0\n    for i in range(n):\n      if sums[i] > sums[maxIndex]:\n        maxIndex = i\n      l[i] = maxIndex\n\n    maxIndex = n - 1\n    for i in range(n - 1, -1, -1):\n      if sums[i] >= sums[maxIndex]:\n        maxIndex = i\n      r[i] = maxIndex\n\n    ans = [-1, -1, -1]\n\n    for i in range(k, n - k):\n      if (ans[0] == -1 or\n          sums[ans[0]] + sums[ans[1]] + sums[ans[2]] <\n              sums[l[i - k]] + sums[i] + sums[r[i + k]]):\n        ans[0] = l[i - k]\n        ans[1] = i\n        ans[2] = r[i + k]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 668, "slug": "kth-smallest-number-in-multiplication-table", "solutions": ["class Solution:\n    def findKthNumber(self, m: int, n: int, k: int) -> int:\n        left, right = 1, m * n\n        while left < right:\n            mid = (left + right) >> 1\n            cnt = 0\n            for i in range(1, m + 1):\n                cnt += min(mid // i, n)\n            if cnt >= k:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 642, "slug": "design-search-autocomplete-system", "solutions": ["class Trie:\n    def __init__(self):\n        self.children = [None] * 27\n        self.v = 0\n        self.w = ''\n\n    def insert(self, w, t):\n        node = self\n        for c in w:\n            idx = 26 if c == ' ' else ord(c) - ord('a')\n            if node.children[idx] is None:\n                node.children[idx] = Trie()\n            node = node.children[idx]\n        node.v += t\n        node.w = w\n\n    def search(self, pref):\n        node = self\n        for c in pref:\n            idx = 26 if c == ' ' else ord(c) - ord('a')\n            if node.children[idx] is None:\n                return None\n            node = node.children[idx]\n        return node\n\n\nclass AutocompleteSystem:\n    def __init__(self, sentences: List[str], times: List[int]):\n        self.trie = Trie()\n        for a, b in zip(sentences, times):\n            self.trie.insert(a, b)\n        self.t = []\n\n    def input(self, c: str) -> List[str]:\n        def dfs(node):\n            if node is None:\n                return\n            if node.v:\n                res.append((node.v, node.w))\n            for nxt in node.children:\n                dfs(nxt)\n\n        if c == '#':\n            s = ''.join(self.t)\n            self.trie.insert(s, 1)\n            self.t = []\n            return []\n\n        res = []\n        self.t.append(c)\n        node = self.trie.search(''.join(self.t))\n        if node is None:\n            return res\n        dfs(node)\n        res.sort(key=lambda x: (-x[0], x[1]))\n        return [v[1] for v in res[:3]]\n\n\n# Your AutocompleteSystem object will be instantiated and called as such:\n# obj = AutocompleteSystem(sentences, times)\n# param_1 = obj.input(c)\n", "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.s: str | None = None\n    self.time = 0\n    self.top3: list[TrieNode] = []\n\n  def __lt__(self, other):\n    if self.time == other.time:\n      return self.s < other.s\n    return self.time > other.time\n\n  def update(self, node) -> None:\n    if node not in self.top3:\n      self.top3.append(node)\n    self.top3.sort()\n    if len(self.top3) > 3:\n      self.top3.pop()\n\n\nclass AutocompleteSystem:\n  def __init__(self, sentences: list[str], times: list[int]):\n    self.root = TrieNode()\n    self.curr = self.root\n    self.s: list[str] = []\n\n    for sentence, time in zip(sentences, times):\n      self._insert(sentence, time)\n\n  def input(self, c: str) -> list[str]:\n    if c == '#':\n      self._insert(''.join(self.s), 1)\n      self.curr = self.root\n      self.s = []\n      return []\n\n    self.s.append(c)\n\n    if self.curr:\n      self.curr = self.curr.children.get(c, None)\n    if not self.curr:\n      return []\n    return [node.s for node in self.curr.top3]\n\n  def _insert(self, sentence: str, time: int) -> None:\n    node = self.root\n    for c in sentence:\n      node = node.children.setdefault(c, TrieNode())\n    node.s = sentence\n    node.time += time\n\n    leaf = node\n    node: TrieNode = self.root\n    for c in sentence:\n      node = node.children[c]\n      node.update(leaf)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 647, "slug": "palindromic-substrings", "solutions": ["class Solution:\n    def countSubstrings(self, s: str) -> int:\n        ans, n = 0, len(s)\n        for k in range(n * 2 - 1):\n            i, j = k // 2, (k + 1) // 2\n            while ~i and j < n and s[i] == s[j]:\n                ans += 1\n                i, j = i - 1, j + 1\n        return ans\n", "class Solution:\n  def countSubstrings(self, s: str) -> int:\n    def extendPalindromes(l: int, r: int) -> int:\n      count = 0\n\n      while l >= 0 and r < len(s) and s[l] == s[r]:\n        count += 1\n        l -= 1\n        r += 1\n\n      return count\n\n    ans = 0\n\n    for i in range(len(s)):\n      ans += extendPalindromes(i, i)\n      ans += extendPalindromes(i, i + 1)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 686, "slug": "repeated-string-match", "solutions": ["class Solution:\n    def repeatedStringMatch(self, a: str, b: str) -> int:\n        m, n = len(a), len(b)\n        ans = ceil(n / m)\n        t = [a] * ans\n        for _ in range(3):\n            if b in ''.join(t):\n                return ans\n            ans += 1\n            t.append(a)\n        return -1\n", "class Solution:\n  def repeatedStringMatch(self, a: str, b: str) -> int:\n    n = math.ceil(len(b) / len(a))\n    s = a * n\n    if b in s:\n      return n\n    if b in s + a:\n      return n + 1\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 637, "slug": "average-of-levels-in-binary-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def averageOfLevels(self, root: Optional[TreeNode]) -> List[float]:\n        q = deque([root])\n        ans = []\n        while q:\n            s, n = 0, len(q)\n            for _ in range(n):\n                root = q.popleft()\n                s += root.val\n                if root.left:\n                    q.append(root.left)\n                if root.right:\n                    q.append(root.right)\n            ans.append(s / n)\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 652, "slug": "find-duplicate-subtrees", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findDuplicateSubtrees(\n        self, root: Optional[TreeNode]\n    ) -> List[Optional[TreeNode]]:\n        def dfs(root):\n            if root is None:\n                return '#'\n            v = f'{root.val},{dfs(root.left)},{dfs(root.right)}'\n            counter[v] += 1\n            if counter[v] == 2:\n                ans.append(root)\n            return v\n\n        ans = []\n        counter = Counter()\n        dfs(root)\n        return ans\n", "class Solution:\n  def findDuplicateSubtrees(self, root: TreeNode | None) -> list[TreeNode | None]:\n    ans = []\n    count = collections.Counter()\n\n    def encode(root: TreeNode | None) -> str:\n      if not root:\n        return ''\n\n      encoded = (str(root.val) + '#' +\n                 encode(root.left) + '#' +\n                 encode(root.right))\n      count[encoded] += 1\n      if count[encoded] == 2:\n        ans.append(root)\n      return encoded\n\n    encode(root)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 697, "slug": "degree-of-an-array", "solutions": ["class Solution:\n    def findShortestSubArray(self, nums: List[int]) -> int:\n        cnt = Counter(nums)\n        degree = cnt.most_common()[0][1]\n        left, right = {}, {}\n        for i, v in enumerate(nums):\n            if v not in left:\n                left[v] = i\n            right[v] = i\n        ans = inf\n        for v in nums:\n            if cnt[v] == degree:\n                t = right[v] - left[v] + 1\n                if ans > t:\n                    ans = t\n        return ans\n", "class Solution:\n  def findShortestSubArray(self, nums: list[int]) -> int:\n    ans = 0\n    degree = 0\n    debut = {}\n    count = collections.Counter()\n\n    for i, num in enumerate(nums):\n      debut.setdefault(num, i)\n      count[num] += 1\n      if count[num] > degree:\n        degree = count[num]\n        ans = i - debut[num] + 1\n      elif count[num] == degree:\n        ans = min(ans, i - debut[num] + 1)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 615, "slug": "average-salary-departments-vs-company", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 685, "slug": "redundant-connection-ii", "solutions": ["class Solution:\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\n        def find(x: int) -> int:\n            if p[x] != x:\n                p[x] = find(p[x])\n            return p[x]\n\n        n = len(edges)\n        ind = [0] * n\n        for _, v in edges:\n            ind[v - 1] += 1\n        dup = [i for i, (_, v) in enumerate(edges) if ind[v - 1] == 2]\n        p = list(range(n))\n        if dup:\n            for i, (u, v) in enumerate(edges):\n                if i == dup[1]:\n                    continue\n                pu, pv = find(u - 1), find(v - 1)\n                if pu == pv:\n                    return edges[dup[0]]\n                p[pu] = pv\n            return edges[dup[1]]\n        for i, (u, v) in enumerate(edges):\n            pu, pv = find(u - 1), find(v - 1)\n            if pu == pv:\n                return edges[i]\n            p[pu] = pv\n", "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findRedundantDirectedConnection(\n      self, edges: list[list[int]],\n  ) -> list[int]:\n    ids = [0] * (len(edges) + 1)\n    nodeWithTwoParents = 0\n\n    for _, v in edges:\n      ids[v] += 1\n      if ids[v] == 2:\n        nodeWithTwoParents = v\n\n    def findRedundantDirectedConnection(skippedEdgeIndex: int) -> list[int]:\n      uf = UnionFind(len(edges) + 1)\n\n      for i, edge in enumerate(edges):\n        if i == skippedEdgeIndex:\n          continue\n        if not uf.unionByRank(edge[0], edge[1]):\n          return edge\n\n      return []\n\n    # If there is no edge with two ids, don't skip any edge.\n    if nodeWithTwoParents == 0:\n      return findRedundantDirectedConnection(-1)\n\n    for i in reversed(range(len(edges))):\n      _, v = edges[i]\n      if v == nodeWithTwoParents:\n        # Try to delete the edges[i].\n        if not findRedundantDirectedConnection(i):\n          return edges[i]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 602, "slug": "friend-requests-ii-who-has-the-most-friends", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 643, "slug": "maximum-average-subarray-i", "solutions": ["class Solution:\n    def findMaxAverage(self, nums: List[int], k: int) -> float:\n        ans = s = sum(nums[:k])\n        for i in range(k, len(nums)):\n            s += nums[i] - nums[i - k]\n            ans = max(ans, s)\n        return ans / k\n", "class Solution:\n  def findMaxAverage(self, nums: list[int], k: int) -> float:\n    summ = sum(nums[:k])\n    ans = summ\n\n    for i in range(k, len(nums)):\n      summ += nums[i] - nums[i - k]\n      ans = max(ans, summ)\n\n    return ans / k\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 674, "slug": "longest-continuous-increasing-subsequence", "solutions": ["class Solution:\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\n        ans = cnt = 1\n        for i, x in enumerate(nums[1:]):\n            if nums[i] < x:\n                cnt += 1\n                ans = max(ans, cnt)\n            else:\n                cnt = 1\n        return ans\n", "class Solution:\n  def findLengthOfLCIS(self, nums: list[int]) -> int:\n    ans = 0\n    j = 0\n\n    for i in range(len(nums)):\n      if i > 0 and nums[i] <= nums[i - 1]:\n        j = i\n      ans = max(ans, i - j + 1)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 687, "slug": "longest-univalue-path", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestUnivaluePath(self, root: Optional[TreeNode]) -> int:\n        def dfs(root: Optional[TreeNode]) -> int:\n            if root is None:\n                return 0\n            l, r = dfs(root.left), dfs(root.right)\n            l = l + 1 if root.left and root.left.val == root.val else 0\n            r = r + 1 if root.right and root.right.val == root.val else 0\n            nonlocal ans\n            ans = max(ans, l + r)\n            return max(l, r)\n\n        ans = 0\n        dfs(root)\n        return ans\n", "class Solution:\n  def longestUnivaluePath(self, root: TreeNode | None) -> int:\n    ans = 0\n\n    def longestUnivaluePathDownFrom(root: TreeNode | None) -> int:\n      nonlocal ans\n      if not root:\n        return 0\n\n      l = longestUnivaluePathDownFrom(root.left)\n      r = longestUnivaluePathDownFrom(root.right)\n      arrowLeft = l + 1 if root.left and root.left.val == root.val else 0\n      arrowRight = r + 1 if root.right and root.right.val == root.val else 0\n      ans = max(ans, arrowLeft + arrowRight)\n      return max(arrowLeft, arrowRight)\n\n    longestUnivaluePathDownFrom(root)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 659, "slug": "split-array-into-consecutive-subsequences", "solutions": ["class Solution:\n    def isPossible(self, nums: List[int]) -> bool:\n        d = defaultdict(list)\n        for v in nums:\n            if h := d[v - 1]:\n                heappush(d[v], heappop(h) + 1)\n            else:\n                heappush(d[v], 1)\n        return all(not v or v and v[0] > 2 for v in d.values())\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 662, "slug": "maximum-width-of-binary-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:\n        ans = 0\n        q = deque([(root, 1)])\n        while q:\n            ans = max(ans, q[-1][1] - q[0][1] + 1)\n            for _ in range(len(q)):\n                root, i = q.popleft()\n                if root.left:\n                    q.append((root.left, i << 1))\n                if root.right:\n                    q.append((root.right, i << 1 | 1))\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 620, "slug": "not-boring-movies", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 623, "slug": "add-one-row-to-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def addOneRow(\n        self, root: Optional[TreeNode], val: int, depth: int\n    ) -> Optional[TreeNode]:\n        def dfs(root, d):\n            if root is None:\n                return\n            if d == depth - 1:\n                root.left = TreeNode(val, root.left, None)\n                root.right = TreeNode(val, None, root.right)\n                return\n            dfs(root.left, d + 1)\n            dfs(root.right, d + 1)\n\n        if depth == 1:\n            return TreeNode(val, root)\n        dfs(root, 1)\n        return root\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 640, "slug": "solve-the-equation", "solutions": ["class Solution:\n    def solveEquation(self, equation: str) -> str:\n        def f(s):\n            x = y = 0\n            if s[0] != '-':\n                s = '+' + s\n            i, n = 0, len(s)\n            while i < n:\n                sign = 1 if s[i] == '+' else -1\n                i += 1\n                j = i\n                while j < n and s[j] not in '+-':\n                    j += 1\n                v = s[i:j]\n                if v[-1] == 'x':\n                    x += sign * (int(v[:-1]) if len(v) > 1 else 1)\n                else:\n                    y += sign * int(v)\n                i = j\n            return x, y\n\n        a, b = equation.split('=')\n        x1, y1 = f(a)\n        x2, y2 = f(b)\n        if x1 == x2:\n            return 'Infinite solutions' if y1 == y2 else 'No solution'\n        return f'x={(y2 - y1) // (x1 - x2)}'\n", "class Solution:\n  def solveEquation(self, equation: str) -> str:\n    def calculate(s: str) -> tuple:\n      coefficient = 0\n      constant = 0\n      num = 0\n      sign = 1\n\n      for i, c in enumerate(s):\n        if c.isdigit():\n          num = num * 10 + int(c)\n        elif c in '+-':\n          constant += sign * num\n          sign = 1 if c == '+' else -1\n          num = 0\n        else:\n          if i > 0 and num == 0 and s[i - 1] == '0':\n            continue\n          coefficient += sign if num == 0 else sign * num\n          num = 0\n\n      return coefficient, constant + sign * num\n\n    lhsEquation, rhsEquation = equation.split('=')\n    lhsCoefficient, lhsConstant = calculate(lhsEquation)\n    rhsCoefficient, rhsConstant = calculate(rhsEquation)\n    coefficient = lhsCoefficient - rhsCoefficient\n    constant = rhsConstant - lhsConstant\n\n    if coefficient == 0 and constant == 0:\n      return \"Infinite solutions\"\n    if coefficient == 0 and constant != 0:\n      return \"No solution\"\n    return \"x=\" + str(constant // coefficient)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 671, "slug": "second-minimum-node-in-a-binary-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\n        def dfs(root):\n            if root:\n                dfs(root.left)\n                dfs(root.right)\n                nonlocal ans, v\n                if root.val > v:\n                    ans = root.val if ans == -1 else min(ans, root.val)\n\n        ans, v = -1, root.val\n        dfs(root)\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 666, "slug": "path-sum-iv", "solutions": ["class Solution:\n    def pathSum(self, nums: List[int]) -> int:\n        def dfs(node, t):\n            if node not in mp:\n                return\n            t += mp[node]\n            d, p = divmod(node, 10)\n            l = (d + 1) * 10 + (p * 2) - 1\n            r = l + 1\n            nonlocal ans\n            if l not in mp and r not in mp:\n                ans += t\n                return\n            dfs(l, t)\n            dfs(r, t)\n\n        ans = 0\n        mp = {num // 10: num % 10 for num in nums}\n        dfs(11, 0)\n        return ans\n", "class Solution:\n  def pathSum(self, nums: list[int]) -> int:\n    ans = 0\n    tree = [[-1] * 8 for _ in range(4)]\n\n    for num in nums:\n      d = num // 100 - 1\n      p = (num % 100) // 10 - 1\n      v = num % 10\n      tree[d][p] = v\n\n    def dfs(i: int, j: int, path: int) -> None:\n      nonlocal ans\n      if tree[i][j] == -1:\n        return\n      if i == 3 or max(tree[i + 1][j * 2], tree[i + 1][j * 2 + 1]) == -1:\n        ans += path + tree[i][j]\n        return\n\n      dfs(i + 1, j * 2, path + tree[i][j])\n      dfs(i + 1, j * 2 + 1, path + tree[i][j])\n\n    dfs(0, 0, 0)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 605, "slug": "can-place-flowers", "solutions": ["class Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed = [0] + flowerbed + [0]\n        for i in range(1, len(flowerbed) - 1):\n            if sum(flowerbed[i - 1 : i + 2]) == 0:\n                flowerbed[i] = 1\n                n -= 1\n        return n <= 0\n", "class Solution:\n  def canPlaceFlowers(self, flowerbed: list[int], n: int) -> bool:\n    for i, flower in enumerate(flowerbed):\n      if flower == 0 and (\n              i == 0 or flowerbed[i - 1] == 0) and (\n              i == len(flowerbed) - 1 or flowerbed[i + 1] == 0):\n        flowerbed[i] = 1\n        n -= 1\n      if n <= 0:\n        return True\n\n    return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 698, "slug": "partition-to-k-equal-sum-subsets", "solutions": ["class Solution:\n    def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:\n        def dfs(i: int) -> bool:\n            if i == len(nums):\n                return True\n            for j in range(k):\n                if j and cur[j] == cur[j - 1]:\n                    continue\n                cur[j] += nums[i]\n                if cur[j] <= s and dfs(i + 1):\n                    return True\n                cur[j] -= nums[i]\n            return False\n\n        s, mod = divmod(sum(nums), k)\n        if mod:\n            return False\n        cur = [0] * k\n        nums.sort(reverse=True)\n        return dfs(0)\n", "class Solution:\n  def canPartitionKSubsets(self, nums: list[int], k: int) -> bool:\n    summ = sum(nums)\n    if summ % k != 0:\n      return False\n\n    target = summ // k  # the target sum of each subset\n    if any(num > target for num in nums):\n      return False\n\n    def dfs(s: int, remainingGroups: int, currSum: int, used: int) -> bool:\n      if remainingGroups == 0:\n        return True\n      if currSum > target:\n        return False\n      if currSum == target:  # Find a valid group, so fresh start.\n        return dfs(0, remainingGroups - 1, 0, used)\n\n      for i in range(s, len(nums)):\n        if used >> i & 1:\n          continue\n        if dfs(i + 1, remainingGroups, currSum + nums[i], used | 1 << i):\n          return True\n\n      return False\n\n    nums.sort(reverse=True)\n    return dfs(0, k, 0, 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 610, "slug": "triangle-judgement", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 650, "slug": "2-keys-keyboard", "solutions": ["class Solution:\n    def minSteps(self, n: int) -> int:\n        @cache\n        def dfs(n):\n            if n == 1:\n                return 0\n            i, ans = 2, n\n            while i * i <= n:\n                if n % i == 0:\n                    ans = min(ans, dfs(n // i) + i)\n                i += 1\n            return ans\n\n        return dfs(n)\n", "class Solution:\n  def minSteps(self, n: int) -> int:\n    if n <= 1:\n      return 0\n\n    # dp[i] := the minimum steps to get i 'A's\n    # Copy 'A', then paste 'A' i - 1 times.\n    dp = [i for i in range(n + 1)]\n\n    for i in range(2, n + 1):\n      for j in range(i // 2, 2, -1):\n        if i % j == 0:\n          dp[i] = dp[j] + i // j  # Paste dp[j] i / j times.\n          break\n\n    return dp[n]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 658, "slug": "find-k-closest-elements", "solutions": ["class Solution:\n    def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:\n        arr.sort(key=lambda v: abs(v - x))\n        return sorted(arr[:k])\n", "class Solution:\n  def findClosestElements(self, arr: list[int], k: int, x: int) -> list[int]:\n    l = 0\n    r = len(arr) - k\n\n    while l < r:\n      m = (l + r) // 2\n      if x - arr[m] <= arr[m + k] - x:\n        r = m\n      else:\n        l = m + 1\n\n    return arr[l:l + k]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 612, "slug": "shortest-distance-in-a-plane", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 646, "slug": "maximum-length-of-pair-chain", "solutions": ["class Solution:\n    def findLongestChain(self, pairs: List[List[int]]) -> int:\n        pairs.sort(key=lambda x: x[1])\n        ans, pre = 0, -inf\n        for a, b in pairs:\n            if pre < a:\n                ans += 1\n                pre = b\n        return ans\n", "class Solution:\n  def findLongestChain(self, pairs: list[list[int]]) -> int:\n    ans = 0\n    prevEnd = -math.inf\n\n    for s, e in sorted(pairs, key=lambda x: x[1]):\n      if s > prevEnd:\n        ans += 1\n        prevEnd = e\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 694, "slug": "number-of-distinct-islands", "solutions": ["class Solution:\n    def numDistinctIslands(self, grid: List[List[int]]) -> int:\n        def dfs(i: int, j: int, k: int):\n            grid[i][j] = 0\n            path.append(str(k))\n            dirs = (-1, 0, 1, 0, -1)\n            for h in range(1, 5):\n                x, y = i + dirs[h - 1], j + dirs[h]\n                if 0 <= x < m and 0 <= y < n and grid[x][y]:\n                    dfs(x, y, h)\n            path.append(str(-k))\n\n        paths = set()\n        path = []\n        m, n = len(grid), len(grid[0])\n        for i, row in enumerate(grid):\n            for j, x in enumerate(row):\n                if x:\n                    dfs(i, j, 0)\n                    paths.add(\"\".join(path))\n                    path.clear()\n        return len(paths)\n", "class Solution:\n  def numDistinctIslands(self, grid: list[list[int]]) -> int:\n    seen = set()\n\n    def dfs(i: int, j: int, i0: int, j0: int):\n      if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]):\n        return\n      if grid[i][j] == 0 or (i, j) in seen:\n        return\n\n      seen.add((i, j))\n      island.append((i - i0, j - j0))\n      dfs(i + 1, j, i0, j0)\n      dfs(i - 1, j, i0, j0)\n      dfs(i, j + 1, i0, j0)\n      dfs(i, j - 1, i0, j0)\n\n    islands = set()  # all the different islands\n\n    for i in range(len(grid)):\n      for j in range(len(grid[0])):\n        island = []\n        dfs(i, j, i, j)\n        if island:\n          islands.add(frozenset(island))\n\n    return len(islands)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 645, "slug": "set-mismatch", "solutions": ["class Solution:\n    def findErrorNums(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        s1 = (1 + n) * n // 2\n        s2 = sum(set(nums))\n        s = sum(nums)\n        return [s - s2, s1 - s2]\n", "class Solution:\n  def findErrorNums(self, nums: list[int]) -> list[int]:\n    for num in nums:\n      if nums[abs(num) - 1] < 0:\n        duplicate = abs(num)\n      else:\n        nums[abs(num) - 1] *= -1\n\n    for i, num in enumerate(nums):\n      if num > 0:\n        return [duplicate, i + 1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 619, "slug": "biggest-single-number", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 604, "slug": "design-compressed-string-iterator", "solutions": ["class StringIterator:\n    def __init__(self, compressedString: str):\n        self.d = []\n        self.p = 0\n        n = len(compressedString)\n        i = 0\n        while i < n:\n            c = compressedString[i]\n            x = 0\n            i += 1\n            while i < n and compressedString[i].isdigit():\n                x = x * 10 + int(compressedString[i])\n                i += 1\n            self.d.append([c, x])\n\n    def next(self) -> str:\n        if not self.hasNext():\n            return ' '\n        ans = self.d[self.p][0]\n        self.d[self.p][1] -= 1\n        if self.d[self.p][1] == 0:\n            self.p += 1\n        return ans\n\n    def hasNext(self) -> bool:\n        return self.p < len(self.d) and self.d[self.p][1] > 0\n\n\n# Your StringIterator object will be instantiated and called as such:\n# obj = StringIterator(compressedString)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()\n", "class StringIterator:\n  def __init__(self, compressedString: str):\n    self.q = collections.deque()  # (currentChar, num)\n\n    i = 0  # compressedString's index\n    while i < len(compressedString):\n      c = compressedString[i]\n      i += 1\n      num = 0\n      while i < len(compressedString) and compressedString[i].isdigit():\n        num = num * 10 + int(compressedString[i])\n        i += 1\n      self.q.append((c, num))\n\n  def next(self) -> str:\n    if not self.hasNext():\n      return ' '\n    c, num = self.q.popleft()\n    if num > 1:\n      self.q.appendleft((c, num - 1))\n    return c\n\n  def hasNext(self) -> bool:\n    return self.q\n", "class StringIterator:\n  def __init__(self, compressedString: str):\n    self.s = compressedString\n    self.i = 0    # s' index\n    self.num = 0  # currentChar's count\n    self.currentChar = ' '\n\n  def next(self) -> str:\n    if not self.hasNext():\n      return ' '\n\n    if self.num == 0:\n      self.currentChar = self.s[self.i]\n      self.i += 1\n      while self.i < len(self.s) and self.s[self.i].isdigit():\n        self.num = self.num * 10 + int(self.s[self.i])\n        self.i += 1\n\n    self.num -= 1\n    return self.currentChar\n\n  def hasNext(self) -> bool:\n    return self.i < len(self.s) or self.num > 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 630, "slug": "course-schedule-iii", "solutions": ["class Solution:\n    def scheduleCourse(self, courses: List[List[int]]) -> int:\n        courses.sort(key=lambda x: x[1])\n        pq = []\n        s = 0\n        for duration, last in courses:\n            heappush(pq, -duration)\n            s += duration\n            while s > last:\n                s += heappop(pq)\n        return len(pq)\n", "class Solution:\n  def scheduleCourse(self, courses: list[list[int]]) -> int:\n    time = 0\n    maxHeap = []\n\n    for duration, lastDay in sorted(courses, key=lambda x: x[1]):\n      heapq.heappush(maxHeap, -duration)\n      time += duration\n      # If the current course cannot be taken, check if it can be swapped with\n      # a previously taken course that has a larger duration to increase the\n      # time available to take upcoming courses.\n      if time > lastDay:\n        time += heapq.heappop(maxHeap)\n\n    return len(maxHeap)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 667, "slug": "beautiful-arrangement-ii", "solutions": ["class Solution:\n    def constructArray(self, n: int, k: int) -> List[int]:\n        l, r = 1, n\n        ans = []\n        for i in range(k):\n            if i % 2 == 0:\n                ans.append(l)\n                l += 1\n            else:\n                ans.append(r)\n                r -= 1\n        for i in range(k, n):\n            if k % 2 == 0:\n                ans.append(r)\n                r -= 1\n            else:\n                ans.append(l)\n                l += 1\n        return ans\n", "class Solution:\n  def constructArray(self, n: int, k: int) -> list[int]:\n    ans = list(range(1, n - k + 1))\n\n    for i in range(k):\n      if i % 2 == 0:\n        ans.append(n - i // 2)\n      else:\n        ans.append(n - k + (i + 1) // 2)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 628, "slug": "maximum-product-of-three-numbers", "solutions": ["class Solution:\n    def maximumProduct(self, nums: List[int]) -> int:\n        nums.sort()\n        a = nums[-1] * nums[-2] * nums[-3]\n        b = nums[-1] * nums[0] * nums[1]\n        return max(a, b)\n", "class Solution:\n  def maximumProduct(self, nums: list[int]) -> int:\n    nums.sort()\n    return max(nums[-1] * nums[0] * nums[1],\n               nums[-1] * nums[-2] * nums[-3])\n", "class Solution:\n  def maximumProduct(self, nums: list[int]) -> int:\n    min1 = inf   # the minimum\n    min2 = inf   # the second minimum\n    max1 = -inf  # the maximum\n    max2 = -inf  # the second maximum\n    max3 = -inf  # the third maximum\n\n    for num in nums:\n      if num <= min1:\n        min2 = min1\n        min1 = num\n      elif num <= min2:\n        min2 = num\n\n      if num >= max1:\n        max3 = max2\n        max2 = max1\n        max1 = num\n      elif num >= max2:\n        max3 = max2\n        max2 = num\n      elif num >= max3:\n        max3 = num\n\n    return max(max1 * min1 * min2, max1 * max2 * max3)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 677, "slug": "map-sum-pairs", "solutions": ["class Trie:\n    def __init__(self):\n        self.children: List[Trie | None] = [None] * 26\n        self.val: int = 0\n\n    def insert(self, w: str, x: int):\n        node = self\n        for c in w:\n            idx = ord(c) - ord('a')\n            if node.children[idx] is None:\n                node.children[idx] = Trie()\n            node = node.children[idx]\n            node.val += x\n\n    def search(self, w: str) -> int:\n        node = self\n        for c in w:\n            idx = ord(c) - ord('a')\n            if node.children[idx] is None:\n                return 0\n            node = node.children[idx]\n        return node.val\n\n\nclass MapSum:\n    def __init__(self):\n        self.d = defaultdict(int)\n        self.tree = Trie()\n\n    def insert(self, key: str, val: int) -> None:\n        x = val - self.d[key]\n        self.d[key] = val\n        self.tree.insert(key, x)\n\n    def sum(self, prefix: str) -> int:\n        return self.tree.search(prefix)\n\n\n# Your MapSum object will be instantiated and called as such:\n# obj = MapSum()\n# obj.insert(key,val)\n# param_2 = obj.sum(prefix)\n", "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.sum = 0\n\n\nclass MapSum:\n  def __init__(self):\n    self.root = TrieNode()\n    self.keyToVal = {}\n\n  def insert(self, key: str, val: int) -> None:\n    diff = val - self.keyToVal.get(key, 0)\n    node: TrieNode = self.root\n    for c in key:\n      node = node.children.setdefault(c, TrieNode())\n      node.sum += diff\n    self.keyToVal[key] = val\n\n  def sum(self, prefix: str) -> int:\n    node: TrieNode = self.root\n    for c in prefix:\n      if c not in node.children:\n        return 0\n      node = node.children[c]\n    return node.sum\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 614, "slug": "second-degree-follower", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 673, "slug": "number-of-longest-increasing-subsequence", "solutions": ["class Solution:\n    def findNumberOfLIS(self, nums: List[int]) -> int:\n        n = len(nums)\n        f = [1] * n\n        cnt = [1] * n\n        mx = 0\n        for i in range(n):\n            for j in range(i):\n                if nums[j] < nums[i]:\n                    if f[i] < f[j] + 1:\n                        f[i] = f[j] + 1\n                        cnt[i] = cnt[j]\n                    elif f[i] == f[j] + 1:\n                        cnt[i] += cnt[j]\n            if mx < f[i]:\n                mx = f[i]\n                ans = cnt[i]\n            elif mx == f[i]:\n                ans += cnt[i]\n        return ans\n", "class Solution:\n  def findNumberOfLIS(self, nums: list[int]) -> int:\n    ans = 0\n    maxLength = 0\n    # length[i] := the length of the LIS ending in nums[i]\n    length = [1] * len(nums)\n    # count[i] := the number of LIS's ending in nums[i]\n    count = [1] * len(nums)\n\n    # Calculate the `length` and `count` arrays.\n    for i, num in enumerate(nums):\n      for j in range(i):\n        if nums[j] < num:\n          if length[i] < length[j] + 1:\n            length[i] = length[j] + 1\n            count[i] = count[j]\n          elif length[i] == length[j] + 1:\n            count[i] += count[j]\n\n    # Get the number of LIS.\n    for i, l in enumerate(length):\n      if l > maxLength:\n        maxLength = l\n        ans = count[i]\n      elif l == maxLength:\n        ans += count[i]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 690, "slug": "employee-importance", "solutions": ["\"\"\"\n# Definition for Employee.\nclass Employee:\n    def __init__(self, id: int, importance: int, subordinates: List[int]):\n        self.id = id\n        self.importance = importance\n        self.subordinates = subordinates\n\"\"\"\n\n\nclass Solution:\n    def getImportance(self, employees: List[\"Employee\"], id: int) -> int:\n        def dfs(i: int) -> int:\n            return d[i].importance + sum(dfs(j) for j in d[i].subordinates)\n\n        d = {e.id: e for e in employees}\n        return dfs(id)\n", "class Solution:\n  def getImportance(self, employees: list['Employee'], id: int) -> int:\n    idToEmployee = {employee.id: employee for employee in employees}\n\n    def dfs(id: int) -> int:\n      values = idToEmployee[id].importance\n      for subId in idToEmployee[id].subordinates:\n        values += dfs(subId)\n      return values\n\n    return dfs(id)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 633, "slug": "sum-of-square-numbers", "solutions": ["class Solution:\n    def judgeSquareSum(self, c: int) -> bool:\n        a, b = 0, int(sqrt(c))\n        while a <= b:\n            s = a**2 + b**2\n            if s == c:\n                return True\n            if s < c:\n                a += 1\n            else:\n                b -= 1\n        return False\n", "class Solution:\n  def judgeSquareSum(self, c: int) -> bool:\n    l = 0\n    r = math.isqrt(c)\n\n    while l <= r:\n      summ = l * l + r * r\n      if summ == c:\n        return True\n      if summ < c:\n        l += 1\n      else:\n        r -= 1\n\n    return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 621, "slug": "task-scheduler", "solutions": ["class Solution:\n    def leastInterval(self, tasks: List[str], n: int) -> int:\n        cnt = Counter(tasks)\n        x = max(cnt.values())\n        s = sum(v == x for v in cnt.values())\n        return max(len(tasks), (x - 1) * (n + 1) + s)\n", "class Solution:\n  def leastInterval(self, tasks: list[str], n: int) -> int:\n    count = collections.Counter(tasks)\n    maxFreq = max(count.values())\n    # Put the most frequent task in the slot first.\n    maxFreqTaskOccupy = (maxFreq - 1) * (n + 1)\n    # Get the number of tasks with same frequency as maxFreq, we'll append them after the\n    # `maxFreqTaskOccupy`.\n    nMaxFreq = sum(value == maxFreq for value in count.values())\n    # max(\n    #   the most frequent task is frequent enough to force some idle slots,\n    #   the most frequent task is not frequent enough to force idle slots\n    # )\n    return max(maxFreqTaskOccupy + nMaxFreq, len(tasks))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 696, "slug": "count-binary-substrings", "solutions": ["class Solution:\n    def countBinarySubstrings(self, s: str) -> int:\n        i, n = 0, len(s)\n        t = []\n        while i < n:\n            cnt = 1\n            while i + 1 < n and s[i + 1] == s[i]:\n                cnt += 1\n                i += 1\n            t.append(cnt)\n            i += 1\n        ans = 0\n        for i in range(1, len(t)):\n            ans += min(t[i - 1], t[i])\n        return ans\n", "class Solution:\n  def countBinarySubstrings(self, s: str) -> int:\n    ans = 0\n    prevCount = 0\n    equals = 1\n\n    for i in range(len(s) - 1):\n      if s[i] == s[i + 1]:\n        equals += 1\n      else:\n        ans += min(prevCount, equals)\n        prevCount = equals\n        equals = 1\n\n    return ans + min(prevCount, equals)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 669, "slug": "trim-a-binary-search-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def trimBST(\n        self, root: Optional[TreeNode], low: int, high: int\n    ) -> Optional[TreeNode]:\n        def dfs(root):\n            if root is None:\n                return root\n            if root.val > high:\n                return dfs(root.left)\n            if root.val < low:\n                return dfs(root.right)\n            root.left = dfs(root.left)\n            root.right = dfs(root.right)\n            return root\n\n        return dfs(root)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 608, "slug": "tree-node", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 632, "slug": "smallest-range-covering-elements-from-k-lists", "solutions": ["class Solution:\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\n        t = [(x, i) for i, v in enumerate(nums) for x in v]\n        t.sort()\n        cnt = Counter()\n        ans = [-inf, inf]\n        j = 0\n        for i, (b, v) in enumerate(t):\n            cnt[v] += 1\n            while len(cnt) == len(nums):\n                a = t[j][0]\n                x = b - a - (ans[1] - ans[0])\n                if x < 0 or (x == 0 and a < ans[0]):\n                    ans = [a, b]\n                w = t[j][1]\n                cnt[w] -= 1\n                if cnt[w] == 0:\n                    cnt.pop(w)\n                j += 1\n        return ans\n", "class Solution:\n  def smallestRange(self, nums: list[list[int]]) -> list[int]:\n    minHeap = [(row[0], i, 0) for i, row in enumerate(nums)]\n    heapq.heapify(minHeap)\n\n    maxRange = max(row[0] for row in nums)\n    minRange = heapq.nsmallest(1, minHeap)[0][0]\n    ans = [minRange, maxRange]\n\n    while len(minHeap) == len(nums):\n      num, r, c = heapq.heappop(minHeap)\n      if c + 1 < len(nums[r]):\n        heapq.heappush(minHeap, (nums[r][c + 1], r, c + 1))\n        maxRange = max(maxRange, nums[r][c + 1])\n        minRange = heapq.nsmallest(1, minHeap)[0][0]\n        if maxRange - minRange < ans[1] - ans[0]:\n          ans[0], ans[1] = minRange, maxRange\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 600, "slug": "non-negative-integers-without-consecutive-ones", "solutions": ["class Solution:\n    def findIntegers(self, n: int) -> int:\n        @cache\n        def dfs(i: int, pre: int, limit: bool) -> int:\n            if i < 0:\n                return 1\n            up = (n >> i & 1) if limit else 1\n            ans = 0\n            for j in range(up + 1):\n                if pre and j:\n                    continue\n                ans += dfs(i - 1, j, limit and j == up)\n            return ans\n\n        return dfs(n.bit_length() - 1, 0, True)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 660, "slug": "remove-9", "solutions": ["class Solution:\n  def newInteger(self, n: int) -> int:\n    ans = []\n    while n:\n      ans.append(str(n % 9))\n      n //= 9\n    return ''.join(reversed(ans))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 680, "slug": "valid-palindrome-ii", "solutions": ["class Solution:\n    def validPalindrome(self, s: str) -> bool:\n        def check(i, j):\n            while i < j:\n                if s[i] != s[j]:\n                    return False\n                i, j = i + 1, j - 1\n            return True\n\n        i, j = 0, len(s) - 1\n        while i < j:\n            if s[i] != s[j]:\n                return check(i, j - 1) or check(i + 1, j)\n            i, j = i + 1, j - 1\n        return True\n", "class Solution:\n  def validPalindrome(self, s: str) -> bool:\n    def validPalindrome(l: int, r: int) -> bool:\n      return all(s[i] == s[r - i + l] for i in range(l, (l + r) // 2 + 1))\n\n    n = len(s)\n\n    for i in range(n // 2):\n      if s[i] != s[~i]:\n        return validPalindrome(i + 1, n - 1 - i) or validPalindrome(i, n - 2 - i)\n\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 679, "slug": "24-game", "solutions": ["class Solution:\n    def judgePoint24(self, cards: List[int]) -> bool:\n        def dfs(nums: List[float]):\n            n = len(nums)\n            if n == 1:\n                if abs(nums[0] - 24) < 1e-6:\n                    return True\n                return False\n            ok = False\n            for i in range(n):\n                for j in range(n):\n                    if i != j:\n                        nxt = [nums[k] for k in range(n) if k != i and k != j]\n                        for op in ops:\n                            match op:\n                                case \"/\":\n                                    if nums[j] == 0:\n                                        continue\n                                    ok |= dfs(nxt + [nums[i] / nums[j]])\n                                case \"*\":\n                                    ok |= dfs(nxt + [nums[i] * nums[j]])\n                                case \"+\":\n                                    ok |= dfs(nxt + [nums[i] + nums[j]])\n                                case \"-\":\n                                    ok |= dfs(nxt + [nums[i] - nums[j]])\n                            if ok:\n                                return True\n            return ok\n\n        ops = (\"+\", \"-\", \"*\", \"/\")\n        nums = [float(x) for x in cards]\n        return dfs(nums)\n", "class Solution:\n  def judgePoint24(self, nums: list[int]) -> bool:\n    def generate(a: float, b: float) -> list[float]:\n      return [a * b,\n              math.inf if b == 0 else a / b,\n              math.inf if a == 0 else b / a,\n              a + b, a - b, b - a]\n\n    def dfs(nums: list[float]) -> bool:\n      if len(nums) == 1:\n        return abs(nums[0] - 24.0) < 0.001\n\n      for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n          for num in generate(nums[i], nums[j]):\n            nextRound = [num]\n            for k in range(len(nums)):\n              if k == i or k == j:\n                continue\n              nextRound.append(nums[k])\n            if dfs(nextRound):\n              return True\n\n      return False\n\n    return dfs(nums)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 631, "slug": "design-excel-sum-formula", "solutions": ["from dataclasses import dataclass\n\n\n@dataclass\nclass Cell:\n  val: int = 0\n  posCount: dict[tuple[int, int], int] | None = None\n\n\nclass Excel:\n  def __init__(self, height: int, width: str):\n    self.width = ord(width) - ord('A') + 1\n    self.sheet = [[Cell() for _ in range(self.width)] for _ in range(height)]\n\n  def set(self, row: int, column: str, val: int) -> None:\n    self._getCell(row, column).val = val\n    self._getCell(row, column).posCount = {}\n\n  def get(self, row: int, column: str) -> int:\n    cell = self._getCell(row, column)\n    if not cell.posCount:\n      return cell.val\n    val = 0\n    for pos, count in cell.posCount.items():\n      val += self.get(pos // self.width + 1, chr(pos %\n                      self.width + ord('A'))) * count\n    return val\n\n  def sum(self, row: int, column: str, numbers: list[str]) -> int:\n    self._getCell(row, column).posCount = self._parse(numbers)\n    return self.get(row, column)\n\n  def _getCell(self, row: int, column: str) -> Cell:\n    return self.sheet[row - 1][ord(column) - ord('A')]\n\n  def _parse(self, numbers: list[str]) -> dict[int, int]:\n    count: dict[int, int] = {}\n    for s in numbers:\n      startRow, startCol, endRow, endCol = self._parseRange(s)\n      for i in range(startRow - 1, endRow):\n        for j in range(ord(startCol) - ord('A'), ord(endCol) - ord('A') + 1):\n          pos = i * self.width + j\n          count[pos] = count.get(pos, 0) + 1\n    return count\n\n  def _parseRange(self, s: str) -> tuple[int, str, int, str]:\n    if ':' not in s:\n      return int(s[1:]), s[0], int(s[1:]), s[0]\n    l, r = s.split(':')\n    return int(l[1:]), l[0], int(r[1:]), r[0]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 648, "slug": "replace-words", "solutions": ["class Trie:\n    def __init__(self):\n        self.children: List[Trie | None] = [None] * 26\n        self.ref: int = -1\n\n    def insert(self, w: str, i: int):\n        node = self\n        for c in w:\n            idx = ord(c) - ord(\"a\")\n            if node.children[idx] is None:\n                node.children[idx] = Trie()\n            node = node.children[idx]\n        node.ref = i\n\n    def search(self, w: str) -> int:\n        node = self\n        for c in w:\n            idx = ord(c) - ord(\"a\")\n            if node.children[idx] is None:\n                return -1\n            node = node.children[idx]\n            if node.ref != -1:\n                return node.ref\n        return -1\n\n\nclass Solution:\n    def replaceWords(self, dictionary: List[str], sentence: str) -> str:\n        trie = Trie()\n        for i, w in enumerate(dictionary):\n            trie.insert(w, i)\n        ans = []\n        for w in sentence.split():\n            idx = trie.search(w)\n            ans.append(dictionary[idx] if idx != -1 else w)\n        return \" \".join(ans)\n", "class Solution:\n  def __init__(self):\n    self.root = {}\n\n  def insert(self, word: str) -> None:\n    node = self.root\n    for c in word:\n      if c not in node:\n        node[c] = {}\n      node = node[c]\n    node['word'] = word\n\n  def search(self, word: str) -> str:\n    node = self.root\n    for c in word:\n      if 'word' in node:\n        return node['word']\n      if c not in node:\n        return word\n      node = node[c]\n    return word\n\n  def replaceWords(self, dictionary: list[str], sentence: str) -> str:\n    for word in dictionary:\n      self.insert(word)\n\n    words = sentence.split(' ')\n    return ' '.join([self.search(word) for word in words])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 635, "slug": "design-log-storage-system", "solutions": ["class LogSystem:\n    def __init__(self):\n        self.logs = []\n        self.d = {\n            \"Year\": 4,\n            \"Month\": 7,\n            \"Day\": 10,\n            \"Hour\": 13,\n            \"Minute\": 16,\n            \"Second\": 19,\n        }\n\n    def put(self, id: int, timestamp: str) -> None:\n        self.logs.append((id, timestamp))\n\n    def retrieve(self, start: str, end: str, granularity: str) -> List[int]:\n        i = self.d[granularity]\n        return [id for id, ts in self.logs if start[:i] <= ts[:i] <= end[:i]]\n\n\n# Your LogSystem object will be instantiated and called as such:\n# obj = LogSystem()\n# obj.put(id,timestamp)\n# param_2 = obj.retrieve(start,end,granularity)\n", "class LogSystem:\n  def __init__(self):\n    self.granularityToIndices = {'Year': 4, 'Month': 7, 'Day': 10,\n                                 'Hour': 13, 'Minute': 16, 'Second': 19}\n    self.idAndTimestamps = []\n\n  def put(self, id: int, timestamp: str) -> None:\n    self.idAndTimestamps.append((id, timestamp))\n\n  def retrieve(self, start: str, end: str, granularity: str) -> list[int]:\n    index = self.granularityToIndices[granularity]\n    s = start[:index]\n    e = end[:index]\n    return [id for id, timestamp in self.idAndTimestamps\n            if s <= timestamp[:index] <= e]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 651, "slug": "4-keys-keyboard", "solutions": ["class Solution:\n    def maxA(self, n: int) -> int:\n        dp = list(range(n + 1))\n        for i in range(3, n + 1):\n            for j in range(2, i - 1):\n                dp[i] = max(dp[i], dp[j - 1] * (i - j))\n        return dp[-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 676, "slug": "implement-magic-dictionary", "solutions": ["class Trie:\n    __slots__ = [\"children\", \"is_end\"]\n\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\n    def insert(self, w: str) -> None:\n        node = self\n        for c in w:\n            if c not in node.children:\n                node.children[c] = Trie()\n            node = node.children[c]\n        node.is_end = True\n\n    def search(self, w: str) -> bool:\n        def dfs(i: int, node: Trie, diff: int) -> bool:\n            if i == len(w):\n                return diff == 1 and node.is_end\n            if w[i] in node.children and dfs(i + 1, node.children[w[i]], diff):\n                return True\n            return diff == 0 and any(\n                dfs(i + 1, node.children[c], 1) for c in node.children if c != w[i]\n            )\n\n        return dfs(0, self, 0)\n\n\nclass MagicDictionary:\n    def __init__(self):\n        self.trie = Trie()\n\n    def buildDict(self, dictionary: List[str]) -> None:\n        for w in dictionary:\n            self.trie.insert(w)\n\n    def search(self, searchWord: str) -> bool:\n        return self.trie.search(searchWord)\n\n\n# Your MagicDictionary object will be instantiated and called as such:\n# obj = MagicDictionary()\n# obj.buildDict(dictionary)\n# param_2 = obj.search(searchWord)\n", "class MagicDictionary:\n  def __init__(self):\n    self.dict = {}\n\n  def buildDict(self, dictionary: list[str]) -> None:\n    for word in dictionary:\n      for i, c in enumerate(word):\n        replaced = self._getReplaced(word, i)\n        self.dict[replaced] = '*' if replaced in self.dict else c\n\n  def search(self, searchWord: str) -> bool:\n    for i, c in enumerate(searchWord):\n      replaced = self._getReplaced(searchWord, i)\n      if self.dict.get(replaced, c) != c:\n        return True\n    return False\n\n  def _getReplaced(self, s: str, i: int) -> str:\n    return s[:i] + '*' + s[i + 1:]\n", "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = collections.defaultdict(TrieNode)\n    self.isWord = False\n\n\nclass MagicDictionary:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def buildDict(self, dictionary: list[str]) -> None:\n    for word in dictionary:\n      self._insert(word)\n\n  def search(self, searchWord: str) -> bool:\n    node: TrieNode = self.root\n    for i, c in enumerate(searchWord):\n      for letter in string.ascii_lowercase:\n        if letter == c:\n          continue\n        child = node.children[letter]\n        if not child:\n          continue\n        # Replace the searchWord[i] with `letter`, then check if\n        # searchWord[i + 1..n) matches `child`.\n        if self._find(child, searchWord, i + 1):\n          return True\n      if not node.children[c]:\n        return False\n      node = node.children[c]\n    return False\n\n  def _insert(self, word: str) -> None:\n    node: TrieNode = self.root\n    for c in word:\n      node = node.children.setdefault(c, TrieNode())\n    node.isWord = True\n\n  def _find(self, node: TrieNode, word: str, i: int) -> bool:\n    for c in word[i:]:\n      if c not in node.children:\n        return False\n      node = node.children[c]\n    return node.isWord\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 653, "slug": "two-sum-iv-input-is-a-bst", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findTarget(self, root: Optional[TreeNode], k: int) -> bool:\n        def dfs(root):\n            if root is None:\n                return False\n            if k - root.val in vis:\n                return True\n            vis.add(root.val)\n            return dfs(root.left) or dfs(root.right)\n\n        vis = set()\n        return dfs(root)\n", "class BSTIterator:\n  def __init__(self, root: TreeNode | None, leftToRight: bool):\n    self.stack = []\n    self.leftToRight = leftToRight\n    self._pushUntilNone(root)\n\n  def next(self) -> int:\n    node = self.stack.pop()\n    if self.leftToRight:\n      self._pushUntilNone(node.right)\n    else:\n      self._pushUntilNone(node.left)\n    return node.val\n\n  def _pushUntilNone(self, root: TreeNode | None):\n    while root:\n      self.stack.append(root)\n      root = root.left if self.leftToRight else root.right\n\n\nclass Solution:\n  def findTarget(self, root: TreeNode | None, k: int) -> bool:\n    if not root:\n      return False\n\n    left = BSTIterator(root, True)\n    right = BSTIterator(root, False)\n\n    l = left.next()\n    r = right.next()\n    while l < r:\n      summ = l + r\n      if summ == k:\n        return True\n      if summ < k:\n        l = left.next()\n      else:\n        r = right.next()\n\n    return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 616, "slug": "add-bold-tag-in-string", "solutions": ["class Trie:\n    def __init__(self):\n        self.children = [None] * 128\n        self.is_end = False\n\n    def insert(self, word):\n        node = self\n        for c in word:\n            idx = ord(c)\n            if node.children[idx] is None:\n                node.children[idx] = Trie()\n            node = node.children[idx]\n        node.is_end = True\n\n\nclass Solution:\n    def addBoldTag(self, s: str, words: List[str]) -> str:\n        trie = Trie()\n        for w in words:\n            trie.insert(w)\n        n = len(s)\n        pairs = []\n        for i in range(n):\n            node = trie\n            for j in range(i, n):\n                idx = ord(s[j])\n                if node.children[idx] is None:\n                    break\n                node = node.children[idx]\n                if node.is_end:\n                    pairs.append([i, j])\n        if not pairs:\n            return s\n        st, ed = pairs[0]\n        t = []\n        for a, b in pairs[1:]:\n            if ed + 1 < a:\n                t.append([st, ed])\n                st, ed = a, b\n            else:\n                ed = max(ed, b)\n        t.append([st, ed])\n\n        ans = []\n        i = j = 0\n        while i < n:\n            if j == len(t):\n                ans.append(s[i:])\n                break\n            st, ed = t[j]\n            if i < st:\n                ans.append(s[i:st])\n            ans.append('<b>')\n            ans.append(s[st : ed + 1])\n            ans.append('</b>')\n            j += 1\n            i = ed + 1\n\n        return ''.join(ans)\n", "class Solution:\n  def addBoldTag(self, s: str, words: list[str]) -> str:\n    n = len(s)\n    ans = []\n    # bold[i] := True if s[i] should be bolded\n    bold = [0] * n\n\n    boldEnd = -1  # s[i:boldEnd] should be bolded\n    for i in range(n):\n      for word in words:\n        if s[i:].startswith(word):\n          boldEnd = max(boldEnd, i + len(word))\n      bold[i] = boldEnd > i\n\n    # Construct the with bold tags\n    i = 0\n    while i < n:\n      if bold[i]:\n        j = i\n        while j < n and bold[j]:\n          j += 1\n        # `s[i..j)` should be bolded.\n        ans.append('<b>' + s[i:j] + '</b>')\n        i = j\n      else:\n        ans.append(s[i])\n        i += 1\n\n    return ''.join(ans)\n", "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.isWord = False\n\n\nclass Solution:\n  def addBoldTag(self, s: str, words: list[str]) -> str:\n    n = len(s)\n    ans = []\n    # bold[i] := True if s[i] should be bolded\n    bold = [0] * n\n    root = TrieNode()\n\n    def insert(word: str) -> None:\n      node = root\n      for c in word:\n        node = node.children.setdefault(c, TrieNode())\n      node.isWord = True\n\n    def find(s: str, i: int) -> int:\n      node = root\n      ans = -1\n      for j in range(i, len(s)):\n        if s[j] not in node.children:\n          node.children[s[j]] = TrieNode()\n        node = node.children[s[j]]\n        if node.isWord:\n          ans = j\n      return ans\n\n    for word in words:\n      insert(word)\n\n    boldEnd = -1  # `s[i..boldEnd]` should be bolded.\n    for i in range(n):\n      boldEnd = max(boldEnd, find(s, i))\n      bold[i] = boldEnd >= i\n\n    # Construct the with bold tags\n    i = 0\n    while i < n:\n      if bold[i]:\n        j = i\n        while j < n and bold[j]:\n          j += 1\n        # `s[i..j)` should be bolded.\n        ans.append('<b>' + s[i:j] + '</b>')\n        i = j\n      else:\n        ans.append(s[i])\n        i += 1\n\n    return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 655, "slug": "print-binary-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def printTree(self, root: Optional[TreeNode]) -> List[List[str]]:\n        def height(root):\n            if root is None:\n                return -1\n            return 1 + max(height(root.left), height(root.right))\n\n        def dfs(root, r, c):\n            if root is None:\n                return\n            ans[r][c] = str(root.val)\n            dfs(root.left, r + 1, c - 2 ** (h - r - 1))\n            dfs(root.right, r + 1, c + 2 ** (h - r - 1))\n\n        h = height(root)\n        m, n = h + 1, 2 ** (h + 1) - 1\n        ans = [[\"\"] * n for _ in range(m)]\n        dfs(root, 0, (n - 1) // 2)\n        return ans\n", "class Solution:\n  def printTree(self, root: TreeNode | None) -> list[list[str]]:\n    def maxHeight(root: TreeNode | None) -> int:\n      if not root:\n        return 0\n      return 1 + max(maxHeight(root.left), maxHeight(root.right))\n\n    def dfs(root: TreeNode | None, row: int, left: int, right: int) -> None:\n      if not root:\n        return\n\n      mid = (left + right) // 2\n      ans[row][mid] = str(root.val)\n      dfs(root.left, row + 1, left, mid - 1)\n      dfs(root.right, row + 1, mid + 1, right)\n\n    m = maxHeight(root)\n    n = pow(2, m) - 1\n    ans = [[''] * n for _ in range(m)]\n    dfs(root, 0, 0, len(ans[0]) - 1)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 665, "slug": "non-decreasing-array", "solutions": ["class Solution:\n    def checkPossibility(self, nums: List[int]) -> bool:\n        def is_sorted(nums: List[int]) -> bool:\n            return all(a <= b for a, b in pairwise(nums))\n\n        n = len(nums)\n        for i in range(n - 1):\n            a, b = nums[i], nums[i + 1]\n            if a > b:\n                nums[i] = b\n                if is_sorted(nums):\n                    return True\n                nums[i] = nums[i + 1] = a\n                return is_sorted(nums)\n        return True\n", "class Solution:\n  def checkPossibility(self, nums: list[int]) -> bool:\n    j = None\n\n    for i in range(len(nums) - 1):\n      if nums[i] > nums[i + 1]:\n        if j is not None:\n          return False\n        j = i\n\n    return (j is None or j == 0 or j == len(nums) - 2 or\n            nums[j - 1] <= nums[j + 1] or nums[j] <= nums[j + 2])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 654, "slug": "maximum-binary-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def constructMaximumBinaryTree(self, nums: List[int]) -> Optional[TreeNode]:\n        def dfs(nums):\n            if not nums:\n                return None\n            val = max(nums)\n            i = nums.index(val)\n            root = TreeNode(val)\n            root.left = dfs(nums[:i])\n            root.right = dfs(nums[i + 1 :])\n            return root\n\n        return dfs(nums)\n", "class Solution:\n  def constructMaximumBinaryTree(self, nums: list[int]) -> TreeNode | None:\n    def build(i: int, j: int) -> TreeNode | None:\n      if i > j:\n        return None\n\n      maxNum = max(nums[i:j + 1])\n      maxIndex = nums.index(maxNum)\n\n      root = TreeNode(maxNum)\n      root.left = build(i, maxIndex - 1)\n      root.right = build(maxIndex + 1, j)\n      return root\n\n    return build(0, len(nums) - 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 692, "slug": "top-k-frequent-words", "solutions": ["class Solution:\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\n        cnt = Counter(words)\n        return sorted(cnt, key=lambda x: (-cnt[x], x))[:k]\n", "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass T:\n  word: str\n  freq: int\n\n  def __lt__(self, other):\n    if self.freq == other.freq:\n      return self.word > other.word\n    return self.freq < other.freq\n\n\nclass Solution:\n  def topKFrequent(self, words: list[str], k: int) -> list[str]:\n    ans = []\n    heap = []\n\n    for word, freq in collections.Counter(words).items():\n      heapq.heappush(heap, T(word, freq))\n      if len(heap) > k:\n        heapq.heappop(heap)\n\n    while heap:\n      ans.append(heapq.heappop(heap).word)\n\n    return ans[::-1]\n", "class Solution:\n  def topKFrequent(self, words: list[str], k: int) -> list[str]:\n    ans = []\n    bucket = [[] for _ in range(len(words) + 1)]\n\n    for word, freq in collections.Counter(words).items():\n      bucket[freq].append(word)\n\n    for b in reversed(bucket):\n      for word in sorted(b):\n        ans.append(word)\n        if len(ans) == k:\n          return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 656, "slug": "coin-path", "solutions": ["class Solution:\n    def cheapestJump(self, coins: List[int], maxJump: int) -> List[int]:\n        if coins[-1] == -1:\n            return []\n        n = len(coins)\n        f = [inf] * n\n        f[-1] = coins[-1]\n        for i in range(n - 2, -1, -1):\n            if coins[i] != -1:\n                for j in range(i + 1, min(n, i + maxJump + 1)):\n                    if f[i] > f[j] + coins[i]:\n                        f[i] = f[j] + coins[i]\n        if f[0] == inf:\n            return []\n        ans = []\n        s = f[0]\n        for i in range(n):\n            if f[i] == s:\n                s -= coins[i]\n                ans.append(i + 1)\n        return ans\n", "class Solution:\n  def cheapestJump(self, coins: list[int], maxJump: int) -> list[int]:\n    if coins[-1] == -1:\n      return []\n\n    n = len(coins)\n    # dp[i] := the minimum cost to jump from i to n - 1\n    dp = [math.inf] * n\n    next = [-1] * n\n\n    def cheapestJump(i: int) -> int:\n      if i == len(coins) - 1:\n        dp[i] = coins[i]\n        return dp[i]\n      if dp[i] < math.inf:\n        return dp[i]\n      if coins[i] == -1:\n        return math.inf\n\n      for j in range(i + 1, min(i + maxJump + 1, n)):\n        res = cheapestJump(j)\n        if res == math.inf:\n          continue\n        cost = coins[i] + res\n        if cost < dp[i]:\n          dp[i] = cost\n          next[i] = j\n\n      return dp[i]\n\n    cheapestJump(0)\n    if dp[0] == math.inf:\n      return []\n    return self._constructPath(next, 0)\n\n  def _constructPath(self, next: list[int], i: int) -> list[int]:\n    ans = []\n    while i != -1:\n      ans.append(i + 1)  # 1-indexed\n      i = next[i]\n    return ans\n", "class Solution:\n  def cheapestJump(self, coins: list[int], maxJump: int) -> list[int]:\n    if coins[-1] == -1:\n      return []\n\n    n = len(coins)\n    # dp[i] := the minimum cost to jump from i to n - 1\n    dp = [math.inf] * n\n    next = [-1] * n\n\n    dp[-1] = coins[-1]\n\n    for i in reversed(range(n - 1)):\n      if coins[i] == -1:\n        continue\n      for j in range(i + 1, min(i + maxJump + 1, n)):\n        if dp[j] == math.inf:\n          continue\n        cost = coins[i] + dp[j]\n        if cost < dp[i]:\n          dp[i] = cost\n          next[i] = j\n\n    if dp[0] == math.inf:\n      return []\n    return self._constructPath(next, 0)\n\n  def _constructPath(self, next: list[int], i: int) -> list[int]:\n    ans = []\n    while i != -1:\n      ans.append(i + 1)  # 1-indexed\n      i = next[i]\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 663, "slug": "equal-tree-partition", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def checkEqualTree(self, root: TreeNode) -> bool:\n        def sum(root):\n            if root is None:\n                return 0\n            l, r = sum(root.left), sum(root.right)\n            seen.append(l + r + root.val)\n            return seen[-1]\n\n        seen = []\n        s = sum(root)\n        if s % 2 == 1:\n            return False\n        seen.pop()\n        return s // 2 in seen\n", "class Solution:\n  def checkEqualTree(self, root: TreeNode | None) -> bool:\n    if not root:\n      return False\n\n    seen = set()\n\n    def dfs(root: TreeNode | None) -> int:\n      if not root:\n        return 0\n\n      summ = root.val + dfs(root.left) + dfs(root.right)\n      seen.add(summ)\n      return summ\n\n    summ = root.val + dfs(root.left) + dfs(root.right)\n    return summ % 2 == 0 and summ // 2 in seen\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 699, "slug": "falling-squares", "solutions": ["class Node:\n    def __init__(self, l, r):\n        self.left = None\n        self.right = None\n        self.l = l\n        self.r = r\n        self.mid = (l + r) >> 1\n        self.v = 0\n        self.add = 0\n\n\nclass SegmentTree:\n    def __init__(self):\n        self.root = Node(1, int(1e9))\n\n    def modify(self, l, r, v, node=None):\n        if l > r:\n            return\n        if node is None:\n            node = self.root\n        if node.l >= l and node.r <= r:\n            node.v = v\n            node.add = v\n            return\n        self.pushdown(node)\n        if l <= node.mid:\n            self.modify(l, r, v, node.left)\n        if r > node.mid:\n            self.modify(l, r, v, node.right)\n        self.pushup(node)\n\n    def query(self, l, r, node=None):\n        if l > r:\n            return 0\n        if node is None:\n            node = self.root\n        if node.l >= l and node.r <= r:\n            return node.v\n        self.pushdown(node)\n        v = 0\n        if l <= node.mid:\n            v = max(v, self.query(l, r, node.left))\n        if r > node.mid:\n            v = max(v, self.query(l, r, node.right))\n        return v\n\n    def pushup(self, node):\n        node.v = max(node.left.v, node.right.v)\n\n    def pushdown(self, node):\n        if node.left is None:\n            node.left = Node(node.l, node.mid)\n        if node.right is None:\n            node.right = Node(node.mid + 1, node.r)\n        if node.add:\n            node.left.v = node.add\n            node.right.v = node.add\n            node.left.add = node.add\n            node.right.add = node.add\n            node.add = 0\n\n\nclass Solution:\n    def fallingSquares(self, positions: List[List[int]]) -> List[int]:\n        ans = []\n        mx = 0\n        tree = SegmentTree()\n        for l, w in positions:\n            r = l + w - 1\n            h = tree.query(l, r) + w\n            mx = max(mx, h)\n            ans.append(mx)\n            tree.modify(l, r, h)\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 638, "slug": "shopping-offers", "solutions": ["class Solution:\n    def shoppingOffers(\n        self, price: List[int], special: List[List[int]], needs: List[int]\n    ) -> int:\n        @cache\n        def dfs(cur: int) -> int:\n            ans = sum(p * (cur >> (i * bits) & 0xF) for i, p in enumerate(price))\n            for offer in special:\n                nxt = cur\n                for j in range(len(needs)):\n                    if (cur >> (j * bits) & 0xF) < offer[j]:\n                        break\n                    nxt -= offer[j] << (j * bits)\n                else:\n                    ans = min(ans, offer[-1] + dfs(nxt))\n            return ans\n\n        bits, mask = 4, 0\n        for i, need in enumerate(needs):\n            mask |= need << i * bits\n        return dfs(mask)\n", "class Solution:\n  def shoppingOffers(\n      self,\n      price: list[int],\n      special: list[list[int]],\n      needs: list[int]\n  ) -> int:\n    def dfs(s: int) -> int:\n      ans = 0\n      for i, need in enumerate(needs):\n        ans += need * price[i]\n\n      for i in range(s, len(special)):\n        offer = special[i]\n        if all(offer[j] <= need for j, need in enumerate(needs)):\n          # Use the special[i].\n          for j in range(len(needs)):\n            needs[j] -= offer[j]\n          ans = min(ans, offer[-1] + dfs(i))\n          # Unuse the special[i] (backtracking).\n          for j in range(len(needs)):\n            needs[j] += offer[j]\n\n      return ans\n\n    return dfs(0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 683, "slug": "k-empty-slots", "solutions": ["class BinaryIndexedTree:\n    def __init__(self, n):\n        self.n = n\n        self.c = [0] * (n + 1)\n\n    def update(self, x, delta):\n        while x <= self.n:\n            self.c[x] += delta\n            x += x & -x\n\n    def query(self, x):\n        s = 0\n        while x:\n            s += self.c[x]\n            x -= x & -x\n        return s\n\n\nclass Solution:\n    def kEmptySlots(self, bulbs: List[int], k: int) -> int:\n        n = len(bulbs)\n        tree = BinaryIndexedTree(n)\n        vis = [False] * (n + 1)\n        for i, x in enumerate(bulbs, 1):\n            tree.update(x, 1)\n            vis[x] = True\n            y = x - k - 1\n            if y > 0 and vis[y] and tree.query(x - 1) - tree.query(y) == 0:\n                return i\n            y = x + k + 1\n            if y <= n and vis[y] and tree.query(y - 1) - tree.query(x) == 0:\n                return i\n        return -1\n", "class Solution:\n  def kEmptySlots(self, bulbs: list[int], k: int) -> int:\n    n = len(bulbs)\n    ans = math.inf\n    # day[i] := the day when bulbs[i] is turned on\n    day = [0] * n\n\n    for i, bulb in enumerate(bulbs):\n      day[bulb - 1] = i + 1\n\n    # Find a subarray of day[l..r], where its length is k + 2.\n    # For each l < i < r, day[i] > max(day[l], day[r]).\n    l = 0\n    r = l + k + 1\n    i = 1\n    while r < n:\n      if i == r:\n        ans = min(ans, max(day[l], day[r]))\n        l = i\n        r = i + k + 1\n      elif day[i] < max(day[l], day[r]):\n        l = i\n        r = i + k + 1\n      i += 1\n\n    return -1 if ans == math.inf else ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 636, "slug": "exclusive-time-of-functions", "solutions": ["class Solution:\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\n        stk = []\n        ans = [0] * n\n        pre = 0\n        for log in logs:\n            i, op, t = log.split(\":\")\n            i, cur = int(i), int(t)\n            if op[0] == \"s\":\n                if stk:\n                    ans[stk[-1]] += cur - pre\n                stk.append(i)\n                pre = cur\n            else:\n                ans[stk.pop()] += cur - pre + 1\n                pre = cur + 1\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 664, "slug": "strange-printer", "solutions": ["class Solution:\n    def strangePrinter(self, s: str) -> int:\n        n = len(s)\n        f = [[inf] * n for _ in range(n)]\n        for i in range(n - 1, -1, -1):\n            f[i][i] = 1\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    f[i][j] = f[i][j - 1]\n                else:\n                    for k in range(i, j):\n                        f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j])\n        return f[0][-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 641, "slug": "design-circular-deque", "solutions": ["class MyCircularDeque:\n    def __init__(self, k: int):\n        \"\"\"\n        Initialize your data structure here. Set the size of the deque to be k.\n        \"\"\"\n        self.q = [0] * k\n        self.front = 0\n        self.size = 0\n        self.capacity = k\n\n    def insertFront(self, value: int) -> bool:\n        \"\"\"\n        Adds an item at the front of Deque. Return true if the operation is successful.\n        \"\"\"\n        if self.isFull():\n            return False\n        if not self.isEmpty():\n            self.front = (self.front - 1 + self.capacity) % self.capacity\n        self.q[self.front] = value\n        self.size += 1\n        return True\n\n    def insertLast(self, value: int) -> bool:\n        \"\"\"\n        Adds an item at the rear of Deque. Return true if the operation is successful.\n        \"\"\"\n        if self.isFull():\n            return False\n        idx = (self.front + self.size) % self.capacity\n        self.q[idx] = value\n        self.size += 1\n        return True\n\n    def deleteFront(self) -> bool:\n        \"\"\"\n        Deletes an item from the front of Deque. Return true if the operation is successful.\n        \"\"\"\n        if self.isEmpty():\n            return False\n        self.front = (self.front + 1) % self.capacity\n        self.size -= 1\n        return True\n\n    def deleteLast(self) -> bool:\n        \"\"\"\n        Deletes an item from the rear of Deque. Return true if the operation is successful.\n        \"\"\"\n        if self.isEmpty():\n            return False\n        self.size -= 1\n        return True\n\n    def getFront(self) -> int:\n        \"\"\"\n        Get the front item from the deque.\n        \"\"\"\n        if self.isEmpty():\n            return -1\n        return self.q[self.front]\n\n    def getRear(self) -> int:\n        \"\"\"\n        Get the last item from the deque.\n        \"\"\"\n        if self.isEmpty():\n            return -1\n        idx = (self.front + self.size - 1) % self.capacity\n        return self.q[idx]\n\n    def isEmpty(self) -> bool:\n        \"\"\"\n        Checks whether the circular deque is empty or not.\n        \"\"\"\n        return self.size == 0\n\n    def isFull(self) -> bool:\n        \"\"\"\n        Checks whether the circular deque is full or not.\n        \"\"\"\n        return self.size == self.capacity\n\n\n# Your MyCircularDeque object will be instantiated and called as such:\n# obj = MyCircularDeque(k)\n# param_1 = obj.insertFront(value)\n# param_2 = obj.insertLast(value)\n# param_3 = obj.deleteFront()\n# param_4 = obj.deleteLast()\n# param_5 = obj.getFront()\n# param_6 = obj.getRear()\n# param_7 = obj.isEmpty()\n# param_8 = obj.isFull()\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 682, "slug": "baseball-game", "solutions": ["class Solution:\n    def calPoints(self, operations: List[str]) -> int:\n        stk = []\n        for op in operations:\n            if op == \"+\":\n                stk.append(stk[-1] + stk[-2])\n            elif op == \"D\":\n                stk.append(stk[-1] << 1)\n            elif op == \"C\":\n                stk.pop()\n            else:\n                stk.append(int(op))\n        return sum(stk)\n", "class Solution:\n  def calPoints(self, operations: list[str]) -> int:\n    scores = []\n\n    for operation in operations:\n      match operation:\n        case '+':\n          scores.append(scores[-1] + scores[-2])\n        case 'D':\n          scores.append(scores[-1] * 2)\n        case 'C':\n          scores.pop()\n        case default:\n          scores.append(int(operation))\n\n    return sum(scores)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 681, "slug": "next-closest-time", "solutions": ["class Solution:\n    def nextClosestTime(self, time: str) -> str:\n        def check(t):\n            h, m = int(t[:2]), int(t[2:])\n            return 0 <= h < 24 and 0 <= m < 60\n\n        def dfs(curr):\n            if len(curr) == 4:\n                if not check(curr):\n                    return\n                nonlocal ans, d\n                p = int(curr[:2]) * 60 + int(curr[2:])\n                if t < p < t + d:\n                    d = p - t\n                    ans = curr[:2] + ':' + curr[2:]\n                return\n            for c in s:\n                dfs(curr + c)\n\n        s = {c for c in time if c != ':'}\n        t = int(time[:2]) * 60 + int(time[3:])\n        d = inf\n        ans = None\n        dfs('')\n        if ans is None:\n            mi = min(int(c) for c in s)\n            ans = f'{mi}{mi}:{mi}{mi}'\n        return ans\n", "class Solution:\n  def nextClosestTime(self, time: str) -> str:\n    ans = list(time)\n    digits = sorted(ans)\n\n    def nextClosest(digit: str, limit: str) -> str:\n      next = bisect_right(digits, digit)\n      return digits[0] if next == 4 or digits[next] > limit else digits[next]\n\n    ans[4] = nextClosest(ans[4], '9')\n    if time[4] < ans[4]:\n      return ''.join(ans)\n\n    ans[3] = nextClosest(ans[3], '5')\n    if time[3] < ans[3]:\n      return ''.join(ans)\n\n    ans[1] = nextClosest(ans[1], '3' if ans[0] == '2' else '9')\n    if time[1] < ans[1]:\n      return ''.join(ans)\n\n    ans[0] = nextClosest(ans[0], '2')\n    return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 639, "slug": "decode-ways-ii", "solutions": ["class Solution:\n    def numDecodings(self, s: str) -> int:\n        mod = int(1e9 + 7)\n        n = len(s)\n\n        # dp[i - 2], dp[i - 1], dp[i]\n        a, b, c = 0, 1, 0\n        for i in range(1, n + 1):\n            # 1 digit\n            if s[i - 1] == \"*\":\n                c = 9 * b % mod\n            elif s[i - 1] != \"0\":\n                c = b\n            else:\n                c = 0\n\n            # 2 digits\n            if i > 1:\n                if s[i - 2] == \"*\" and s[i - 1] == \"*\":\n                    c = (c + 15 * a) % mod\n                elif s[i - 2] == \"*\":\n                    if s[i - 1] > \"6\":\n                        c = (c + a) % mod\n                    else:\n                        c = (c + 2 * a) % mod\n                elif s[i - 1] == \"*\":\n                    if s[i - 2] == \"1\":\n                        c = (c + 9 * a) % mod\n                    elif s[i - 2] == \"2\":\n                        c = (c + 6 * a) % mod\n                elif (\n                    s[i - 2] != \"0\"\n                    and (ord(s[i - 2]) - ord(\"0\")) * 10 + ord(s[i - 1]) - ord(\"0\") <= 26\n                ):\n                    c = (c + a) % mod\n\n            a, b = b, c\n\n        return c\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 691, "slug": "stickers-to-spell-word", "solutions": ["class Solution:\n    def minStickers(self, stickers: List[str], target: str) -> int:\n        n = len(target)\n        q = deque([0])\n        vis = [False] * (1 << n)\n        vis[0] = True\n        ans = 0\n        while q:\n            for _ in range(len(q)):\n                cur = q.popleft()\n                if cur == (1 << n) - 1:\n                    return ans\n                for s in stickers:\n                    cnt = Counter(s)\n                    nxt = cur\n                    for i, c in enumerate(target):\n                        if (cur >> i & 1) == 0 and cnt[c] > 0:\n                            cnt[c] -= 1\n                            nxt |= 1 << i\n                    if not vis[nxt]:\n                        vis[nxt] = True\n                        q.append(nxt)\n            ans += 1\n        return -1\n", "class Solution:\n  def minStickers(self, stickers: list[str], target: str) -> int:\n    maxMask = 1 << len(target)\n    # dp[i] := the minimum number of stickers to spell out i, where i is the\n    # bit mask of target\n    dp = [math.inf] * maxMask\n    dp[0] = 0\n\n    for mask in range(maxMask):\n      if dp[mask] == math.inf:\n        continue\n      # Try to expand from `mask` by using each sticker.\n      for sticker in stickers:\n        superMask = mask\n        for c in sticker:\n          for i, t in enumerate(target):\n            # Try to apply it on a missing letter.\n            if c == t and not (superMask >> i & 1):\n              superMask |= 1 << i\n              break\n        dp[superMask] = min(dp[superMask], dp[mask] + 1)\n\n    return -1 if dp[-1] == math.inf else dp[-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 618, "slug": "students-report-by-geography", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 644, "slug": "maximum-average-subarray-ii", "solutions": ["class Solution:\n    def findMaxAverage(self, nums: List[int], k: int) -> float:\n        def check(v: float) -> bool:\n            s = sum(nums[:k]) - k * v\n            if s >= 0:\n                return True\n            t = mi = 0\n            for i in range(k, len(nums)):\n                s += nums[i] - v\n                t += nums[i - k] - v\n                mi = min(mi, t)\n                if s >= mi:\n                    return True\n            return False\n\n        eps = 1e-5\n        l, r = min(nums), max(nums)\n        while r - l >= eps:\n            mid = (l + r) / 2\n            if check(mid):\n                l = mid\n            else:\n                r = mid\n        return l\n", "class Solution:\n  def findMaxAverage(self, nums: list[int], k: int) -> float:\n    ERR = 1e-5\n    l = min(nums)\n    r = max(nums)\n\n    def check(m: float) -> bool:\n      \"\"\"\n      Returns True if there's a subarray, where its length >= k and its average\n      sum >= m.\n      \"\"\"\n      summ = 0\n      prevSum = 0\n      minPrevSum = 0\n\n      for i, num in enumerate(nums):\n        # Need to substract m for each `num` so that we can check if the sum of\n        # the subarray >= 0.\n        summ += num - m\n        if i >= k:\n          prevSum += nums[i - k] - m\n          minPrevSum = min(minPrevSum, prevSum)\n        if i + 1 >= k and summ >= minPrevSum:\n          return True\n\n      return False\n\n    while r - l > ERR:\n      m = (l + r) / 2\n      if check(m):\n        l = m\n      else:\n        r = m\n\n    return l\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 670, "slug": "maximum-swap", "solutions": ["class Solution:\n    def maximumSwap(self, num: int) -> int:\n        s = list(str(num))\n        n = len(s)\n        d = list(range(n))\n        for i in range(n - 2, -1, -1):\n            if s[i] <= s[d[i + 1]]:\n                d[i] = d[i + 1]\n        for i, j in enumerate(d):\n            if s[i] < s[j]:\n                s[i], s[j] = s[j], s[i]\n                break\n        return int(''.join(s))\n", "class Solution:\n  def maximumSwap(self, num: int) -> int:\n    s = list(str(num))\n    dict = {c: i for i, c in enumerate(s)}\n\n    for i, c in enumerate(s):\n      for digit in reversed(string.digits):\n        if digit <= c:\n          break\n        if digit in dict and dict[digit] > i:\n          s[i], s[dict[digit]] = digit, s[i]\n          return int(''.join(s))\n\n    return num\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 607, "slug": "sales-person", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 606, "slug": "construct-string-from-binary-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def tree2str(self, root: Optional[TreeNode]) -> str:\n        def dfs(root):\n            if root is None:\n                return ''\n            if root.left is None and root.right is None:\n                return str(root.val)\n            if root.right is None:\n                return f'{root.val}({dfs(root.left)})'\n            return f'{root.val}({dfs(root.left)})({dfs(root.right)})'\n\n        return dfs(root)\n", "class Solution:\n  def tree2str(self, t: TreeNode | None) -> str:\n    def dfs(root: TreeNode | None) -> str:\n      if not root:\n        return ''\n      if root.right:\n        return str(root.val) + '(' + dfs(root.left) + ')(' + dfs(root.right) + ')'\n      if root.left:\n        return str(root.val) + '(' + dfs(root.left) + ')'\n      return str(root.val)\n    return dfs(t)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 609, "slug": "find-duplicate-file-in-system", "solutions": ["class Solution:\n    def findDuplicate(self, paths: List[str]) -> List[List[str]]:\n        d = defaultdict(list)\n        for p in paths:\n            ps = p.split()\n            for f in ps[1:]:\n                i = f.find('(')\n                name, content = f[:i], f[i + 1 : -1]\n                d[content].append(ps[0] + '/' + name)\n        return [v for v in d.values() if len(v) > 1]\n", "class Solution:\n  def findDuplicate(self, paths: list[str]) -> list[list[str]]:\n    contentToPathFiles = collections.defaultdict(list)\n\n    for path in paths:\n      words = path.split(' ')\n      rootPath = words[0]  # \"root/d1/d2/.../dm\"\n      for fileAndContent in words[1:]:  # \"fn.txt(fn_content)\"\n        l = fileAndContent.find('(')\n        r = fileAndContent.find(')')\n        # \"fn.txt\"\n        file = fileAndContent[:l]\n        # \"fn_content\"\n        content = fileAndContent[l + 1:r]\n        # \"root/d1/d2/.../dm/fn.txt\"\n        filePath = rootPath + '/' + file\n        contentToPathFiles[content].append(filePath)\n\n    return [filePath for filePath in contentToPathFiles.values() if len(filePath) > 1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 693, "slug": "binary-number-with-alternating-bits", "solutions": ["class Solution:\n    def hasAlternatingBits(self, n: int) -> bool:\n        prev = -1\n        while n:\n            curr = n & 1\n            if prev == curr:\n                return False\n            prev = curr\n            n >>= 1\n        return True\n", "class Solution:\n  def hasAlternatingBits(self, n: int) -> bool:\n    #            n = 0b010101\n    #       n >> 2 = 0b000101\n    # n ^ (n >> 2) = 0b010000 = a\n    #        a - 1 = 0b001111\n    #  a & (a - 1) = 0\n    a = n ^ (n >> 2)\n    return (a & (a - 1)) == 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 684, "slug": "redundant-connection", "solutions": ["class Solution:\n    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n        def find(x: int) -> int:\n            if p[x] != x:\n                p[x] = find(p[x])\n            return p[x]\n\n        p = list(range(len(edges)))\n        for a, b in edges:\n            pa, pb = find(a - 1), find(b - 1)\n            if pa == pb:\n                return [a, b]\n            p[pa] = pb\n", "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findRedundantConnection(self, edges: list[list[int]]) -> list[int]:\n    uf = UnionFind(len(edges) + 1)\n\n    for edge in edges:\n      u, v = edge\n      if not uf.unionByRank(u, v):\n        return edge\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1638, "slug": "count-substrings-that-differ-by-one-character", "solutions": ["class Solution:\n    def countSubstrings(self, s: str, t: str) -> int:\n        ans = 0\n        m, n = len(s), len(t)\n        for i, a in enumerate(s):\n            for j, b in enumerate(t):\n                if a != b:\n                    l = r = 0\n                    while i > l and j > l and s[i - l - 1] == t[j - l - 1]:\n                        l += 1\n                    while (\n                        i + r + 1 < m and j + r + 1 < n and s[i + r + 1] == t[j + r + 1]\n                    ):\n                        r += 1\n                    ans += (l + 1) * (r + 1)\n        return ans\n", "class Solution:\n  def countSubstrings(self, s: str, t: str) -> int:\n    ans = 0\n\n    for i in range(len(s)):\n      ans += self._count(s, t, i, 0)\n\n    for j in range(1, len(t)):\n      ans += self._count(s, t, 0, j)\n\n    return ans\n\n  def _count(self, s: str, t: str, i: int, j: int) -> int:\n    \"\"\"Returns the number of substrings of s[i..n) and t[j:] that differ by one char.\"\"\"\n    res = 0\n    # the number of substrings starting at s[i] and t[j] ending in the current\n    # index with zero different letter\n    dp0 = 0\n    # the number of substrings starting at s[i] and t[j] ending in the current\n    # index with one different letter\n    dp1 = 0\n\n    while i < len(s) and j < len(t):\n      if s[i] == t[j]:\n        dp0 += 1\n      else:\n        dp0, dp1 = 0, dp0 + 1\n      res += dp1\n      i += 1\n      j += 1\n\n    return res\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1672, "slug": "richest-customer-wealth", "solutions": ["class Solution:\n    def maximumWealth(self, accounts: List[List[int]]) -> int:\n        return max(sum(v) for v in accounts)\n", "class Solution:\n  def maximumWealth(self, accounts: list[list[int]]) -> int:\n    return max(map(sum, accounts))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1681, "slug": "minimum-incompatibility", "solutions": ["class Solution:\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        m = n // k\n        g = [-1] * (1 << n)\n        for i in range(1, 1 << n):\n            if i.bit_count() != m:\n                continue\n            s = set()\n            mi, mx = 20, 0\n            for j, x in enumerate(nums):\n                if i >> j & 1:\n                    if x in s:\n                        break\n                    s.add(x)\n                    mi = min(mi, x)\n                    mx = max(mx, x)\n            if len(s) == m:\n                g[i] = mx - mi\n        f = [inf] * (1 << n)\n        f[0] = 0\n        for i in range(1 << n):\n            if f[i] == inf:\n                continue\n            s = set()\n            mask = 0\n            for j, x in enumerate(nums):\n                if (i >> j & 1) == 0 and x not in s:\n                    s.add(x)\n                    mask |= 1 << j\n            if len(s) < m:\n                continue\n            j = mask\n            while j:\n                if g[j] != -1:\n                    f[i | j] = min(f[i | j], f[i] + g[j])\n                j = (j - 1) & mask\n        return f[-1] if f[-1] != inf else -1\n", "class Solution:\n  def __init__(self):\n    self.MAX_NUM = 16\n\n  def minimumIncompatibility(self, nums: list[int], k: int) -> int:\n    MAX_COMPATIBILITY = (16 - 1) * (16 // 2)\n    n = len(nums)\n    subsetSize = n // k\n    maxMask = 1 << n\n    incompatibilities = self._getIncompatibilities(nums, subsetSize)\n\n    # dp[i] := the minimum possible sum of incompatibilities of the subset\n    # of numbers represented by the bitmask i\n    dp = [MAX_COMPATIBILITY] * maxMask\n    dp[0] = 0\n\n    for mask in range(1, maxMask):\n      # The number of 1s in `mask` isn't a multiple of `subsetSize`.\n      if mask.bit_count() % subsetSize != 0:\n        continue\n      # https://cp-algorithms.com/algebra/all-submasks.html\n      submask = mask\n      while submask > 0:\n        if incompatibilities[submask] != -1:  # valid submask\n          dp[mask] = min(dp[mask], dp[mask - submask] +\n                         incompatibilities[submask])\n        submask = (submask - 1) & mask\n\n    return dp[-1] if dp[-1] != MAX_COMPATIBILITY else -1\n\n  def _getIncompatibilities(\n      self,\n      nums: list[int],\n      subsetSize: int,\n  ) -> list[int]:\n    \"\"\"\n    Returns an incompatibilities array where\n    * incompatibilities[i] := the incompatibility of the subset of numbers\n      represented by the bitmask i\n    * incompatibilities[i] := -1 if the number of 1s in the bitmask i is not\n      `subsetSize`\n    \"\"\"\n    maxMask = 1 << len(nums)\n    incompatibilities = [-1] * maxMask\n    for mask in range(maxMask):\n      if mask.bit_count() == subsetSize and self._isUnique(nums, mask, subsetSize):\n        incompatibilities[mask] = self._getIncompatibility(nums, mask)\n    return incompatibilities\n\n  def _isUnique(self, nums: list[int], mask: int, subsetSize: int) -> bool:\n    \"\"\"Returns True if the numbers selected by `mask` are unique.\"\"\"\n    used = 0\n    for i, num in enumerate(nums):\n      if mask >> i & 1:\n        used |= 1 << num\n    return used.bit_count() == subsetSize\n\n  def _getIncompatibility(self, nums: list[int], mask: int) -> int:\n    \"\"\"\n    Returns the incompatibility of the selected numbers represented by the\n    `mask`.\n    \"\"\"\n    mn = self.MAX_NUM\n    mx = 0\n    for i, num in enumerate(nums):\n      if mask >> i & 1:\n        mx = max(mx, num)\n        mn = min(mn, num)\n    return mx - mn\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1654, "slug": "minimum-jumps-to-reach-home", "solutions": ["class Solution:\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\n        s = set(forbidden)\n        q = deque([(0, 1)])\n        vis = {(0, 1)}\n        ans = 0\n        while q:\n            for _ in range(len(q)):\n                i, k = q.popleft()\n                if i == x:\n                    return ans\n                nxt = [(i + a, 1)]\n                if k & 1:\n                    nxt.append((i - b, 0))\n                for j, k in nxt:\n                    if 0 <= j < 6000 and j not in s and (j, k) not in vis:\n                        q.append((j, k))\n                        vis.add((j, k))\n            ans += 1\n        return -1\n", "from enum import Enum\n\n\nclass Direction(Enum):\n  FORWARD = 0\n  BACKWARD = 1\n\n\nclass Solution:\n  def minimumJumps(self, forbidden: list[int], a: int, b: int, x: int) -> int:\n    furthest = max(x + a + b, max(pos + a + b for pos in forbidden))\n    seenForward = {pos for pos in forbidden}\n    seenBackward = {pos for pos in forbidden}\n\n    # (direction, position)\n    q = collections.deque([(Direction.FORWARD, 0)])\n\n    ans = 0\n    while q:\n      for _ in range(len(q)):\n        dir, pos = q.popleft()\n        if pos == x:\n          return ans\n        forward = pos + a\n        backward = pos - b\n        if forward <= furthest and forward not in seenForward:\n          seenForward.add(forward)\n          q.append((Direction.FORWARD, forward))\n        # It cannot jump backward twice in a row.\n        if dir == Direction.FORWARD and backward >= 0 and backward not in seenBackward:\n          seenBackward.add(backward)\n          q.append((Direction.BACKWARD, backward))\n      ans += 1\n\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1609, "slug": "even-odd-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isEvenOddTree(self, root: Optional[TreeNode]) -> bool:\n        even = 1\n        q = deque([root])\n        while q:\n            prev = 0 if even else inf\n            for _ in range(len(q)):\n                root = q.popleft()\n                if even and (root.val % 2 == 0 or prev >= root.val):\n                    return False\n                if not even and (root.val % 2 == 1 or prev <= root.val):\n                    return False\n                prev = root.val\n                if root.left:\n                    q.append(root.left)\n                if root.right:\n                    q.append(root.right)\n            even ^= 1\n        return True\n", "class Solution:\n  def isEvenOddTree(self, root: TreeNode | None) -> bool:\n    q = collections.deque([root])\n    isEven = True\n\n    while q:\n      prevVal = -math.inf if isEven else math.inf\n      for _ in range(sz):\n        node = q.popleft()\n        if isEven and (node.val % 2 == 0 or node.val <= prevVal):\n          return False  # invalid case on even level\n        if not isEven and (node.val % 2 == 1 or node.val >= prevVal):\n          return False  # invalid case on odd level\n        prevVal = node.val\n        if node.left:\n          q.append(node.left)\n        if node.right:\n          q.append(node.right)\n      isEven = not isEven\n\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1686, "slug": "stone-game-vi", "solutions": ["class Solution:\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\n        vals = [(a + b, i) for i, (a, b) in enumerate(zip(aliceValues, bobValues))]\n        vals.sort(reverse=True)\n        a = sum(aliceValues[i] for _, i in vals[::2])\n        b = sum(bobValues[i] for _, i in vals[1::2])\n        if a > b:\n            return 1\n        if a < b:\n            return -1\n        return 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1618, "slug": "maximum-font-to-fit-a-sentence-in-a-screen", "solutions": ["# \"\"\"\n# This is FontInfo's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# class FontInfo(object):\n#    Return the width of char ch when fontSize is used.\n#    def getWidth(self, fontSize, ch):\n#        \"\"\"\n#        :type fontSize: int\n#        :type ch: char\n#        :rtype int\n#        \"\"\"\n#\n#    def getHeight(self, fontSize):\n#        \"\"\"\n#        :type fontSize: int\n#        :rtype int\n#        \"\"\"\nclass Solution:\n    def maxFont(\n        self, text: str, w: int, h: int, fonts: List[int], fontInfo: 'FontInfo'\n    ) -> int:\n        def check(size):\n            if fontInfo.getHeight(size) > h:\n                return False\n            return sum(fontInfo.getWidth(size, c) for c in text) <= w\n\n        left, right = 0, len(fonts) - 1\n        ans = -1\n        while left < right:\n            mid = (left + right + 1) >> 1\n            if check(fonts[mid]):\n                left = mid\n            else:\n                right = mid - 1\n        return fonts[left] if check(fonts[left]) else -1\n", "# \"\"\"\n# This is FontInfo's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# class FontInfo(object):\n#   Return the width of char ch when fontSize is used.\n#   def getWidth(self, fontSize: int, ch: str) -> int:\n#     pass\n#\n#   def getHeight(self, fontSize: int) -> int:\n#     pass\nclass Solution:\n  def maxFont(\n      self,\n      text: str,\n      w: int,\n      h: int,\n      fonts: list[int],\n      fontInfo: 'FontInfo',\n  ) -> int:\n    count = collections.Counter(text)\n    l = 0\n    r = len(fonts) - 1\n\n    while l < r:\n      m = (l + r + 1) // 2\n      if fontInfo.getHeight(\n              fonts[m]) <= h and self._getWidthSum(\n              count, fonts[m],\n              fontInfo) <= w:\n        l = m\n      else:\n        r = m - 1\n\n    return fonts[l] if self._getWidthSum(count, fonts[l], fontInfo) <= w else -1\n\n  def _getWidthSum(\n      self,\n      count: list[int],\n      font: int,\n      fontInfo: 'FontInfo',\n  ) -> int:\n    width = 0\n    for c in string.ascii_lowercase:\n      width += count[c] * fontInfo.getWidth(font, c)\n    return width\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1635, "slug": "hopper-company-queries-i", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1639, "slug": "number-of-ways-to-form-a-target-string-given-a-dictionary", "solutions": ["class Solution:\n    def numWays(self, words: List[str], target: str) -> int:\n        @cache\n        def dfs(i: int, j: int) -> int:\n            if i >= m:\n                return 1\n            if j >= n:\n                return 0\n            ans = dfs(i + 1, j + 1) * cnt[j][ord(target[i]) - ord('a')]\n            ans = (ans + dfs(i, j + 1)) % mod\n            return ans\n\n        m, n = len(target), len(words[0])\n        cnt = [[0] * 26 for _ in range(n)]\n        for w in words:\n            for j, c in enumerate(w):\n                cnt[j][ord(c) - ord('a')] += 1\n        mod = 10**9 + 7\n        return dfs(0, 0)\n", "class Solution:\n  def numWays(self, words: list[str], target: str) -> int:\n    MOD = 1_000_000_007\n    wordLength = len(words[0])\n    # counts[j] := the count map of words[i][j], where 0 <= i < |words|\n    counts = [collections.Counter() for _ in range(wordLength)]\n\n    for i in range(wordLength):\n      for word in words:\n        counts[i][word[i]] += 1\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int):\n      \"\"\"Returns the number of ways to form target[i..n) using word[j..n).\"\"\"\n      if i == len(target):\n        return 1\n      if j == wordLength:\n        return 0\n      return (dp(i + 1, j + 1) * counts[j][target[i]] + dp(i, j + 1)) % MOD\n\n    return dp(0, 0)\n", "class Solution:\n  def numWays(self, words: list[str], target: str) -> int:\n    MOD = 1_000_000_007\n    # dp[i] := the number of ways to form the first i characters of `target`\n    dp = [0] * (len(target) + 1)\n    dp[0] = 1\n\n    for j in range(len(words[0])):\n      count = collections.Counter(word[j] for word in words)\n      for i in range(len(target), 0, -1):\n        dp[i] += dp[i - 1] * count[target[i - 1]]\n        dp[i] %= MOD\n\n    return dp[len(target)]\n", "class Solution:\n  def numWays(self, words: list[str], target: str) -> int:\n    MOD = 1_000_000_007\n    wordLength = len(words[0])\n    # dp[i][j] := the number of ways to form the first i characters of the\n    # `target` using the j first characters in each word\n    dp = [[0] * (wordLength + 1) for _ in range(len(target) + 1)]\n    # counts[j] := the count map of words[i][j], where 0 <= i < |words|\n    counts = [collections.Counter() for _ in range(wordLength)]\n\n    for i in range(wordLength):\n      for word in words:\n        counts[i][word[i]] += 1\n\n    dp[0][0] = 1\n\n    for i in range(len(target) + 1):\n      for j in range(wordLength):\n        if i < len(target):\n          # Pick the character target[i] from word[j].\n          dp[i + 1][j + 1] = dp[i][j] * counts[j][target[i]]\n          dp[i + 1][j + 1] %= MOD\n        # Skip the word[j].\n        dp[i][j + 1] += dp[i][j]\n        dp[i][j + 1] %= MOD\n\n    return dp[len(target)][wordLength]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1698, "slug": "number-of-distinct-substrings-in-a-string", "solutions": ["class Solution:\n    def countDistinct(self, s: str) -> int:\n        n = len(s)\n        return len({s[i:j] for i in range(n) for j in range(i + 1, n + 1)})\n", "class Solution:\n  def countDistinct(self, s: str) -> int:\n    BASE = 26\n    HASH = 1_000_000_007\n\n    n = len(s)\n    ans = 0\n    pow = [1] + [0] * n     # pow[i] := BASE^i\n    hashes = [0] * (n + 1)  # hashes[i] := the hash of s[0..i)\n\n    def val(c: str) -> int:\n      return ord(c) - ord('a')\n\n    for i in range(1, n + 1):\n      pow[i] = pow[i - 1] * BASE % HASH\n      hashes[i] = (hashes[i - 1] * BASE + val(s[i - 1])) % HASH\n\n    def getHash(l: int, r: int) -> int:\n      \"\"\"Returns the hash of s[l..r).\"\"\"\n      hash = (hashes[r] - hashes[l] * pow[r - l]) % HASH\n      return hash + HASH if hash < 0 else hash\n\n    for length in range(1, n + 1):\n      seen = set()\n      for i in range(n - length + 1):\n        seen.add(getHash(i, i + length))\n      ans += len(seen)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1615, "slug": "maximal-network-rank", "solutions": ["class Solution:\n    def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n        g = defaultdict(set)\n        for a, b in roads:\n            g[a].add(b)\n            g[b].add(a)\n        ans = 0\n        for a in range(n):\n            for b in range(a + 1, n):\n                if (t := len(g[a]) + len(g[b]) - (a in g[b])) > ans:\n                    ans = t\n        return ans\n", "class Solution:\n  def maximalNetworkRank(self, n: int, roads: list[list[int]]) -> int:\n    degrees = [0] * n\n\n    for u, v in roads:\n      degrees[u] += 1\n      degrees[v] += 1\n\n    # Find the first maximum and the second maximum degrees.\n    maxDegree1 = 0\n    maxDegree2 = 0\n    for degree in degrees:\n      if degree > maxDegree1:\n        maxDegree2 = maxDegree1\n        maxDegree1 = degree\n      elif degree > maxDegree2:\n        maxDegree2 = degree\n\n    # There can be multiple nodes with `maxDegree1` or `maxDegree2`.\n    # Find the counts of such nodes.\n    countMaxDegree1 = 0\n    countMaxDegree2 = 0\n    for degree in degrees:\n      if degree == maxDegree1:\n        countMaxDegree1 += 1\n      elif degree == maxDegree2:\n        countMaxDegree2 += 1\n\n    if countMaxDegree1 == 1:\n      # 1. If there is only one node with degree = `maxDegree1`, then we'll\n      # need to use the node with degree = `maxDegree2`. The answer in general\n      # will be (maxDegree1 + maxDegree2), but if the two nodes that we're\n      # considering are connected, then we'll have to subtract 1.\n      edgeCount = (self._getEdgeCount(roads, degrees, maxDegree1, maxDegree2) +\n                   self._getEdgeCount(roads, degrees, maxDegree2, maxDegree1))\n      return maxDegree1 + maxDegree2 - (countMaxDegree2 == edgeCount)\n    else:\n      # 2. If there are more than one node with degree = `maxDegree1`, then we\n      # can consider `maxDegree1` twice, and we don't need to use `maxDegree2`.\n      # The answer in general will be 2 * maxDegree1, but if the two nodes that\n      # we're considering are connected, then we'll have to subtract 1.\n      edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree1)\n      maxPossibleEdgeCount = countMaxDegree1 * (countMaxDegree1 - 1) // 2\n      return 2 * maxDegree1 - (maxPossibleEdgeCount == edgeCount)\n\n  def _getEdgeCount(\n      self,\n      roads: list[list[int]],\n      degrees: list[int],\n      degreeU: int, degreeV: int,\n  ) -> int:\n    \"\"\"\n    Returns the number of edges (u, v) where degress[u] == degreeU and\n    degrees[v] == degreeV.\n    \"\"\"\n    edgeCount = 0\n    for u, v in roads:\n      if degrees[u] == degreeU and degrees[v] == degreeV:\n        edgeCount += 1\n    return edgeCount\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1685, "slug": "sum-of-absolute-differences-in-a-sorted-array", "solutions": ["class Solution:\n    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:\n        ans = []\n        s, t = sum(nums), 0\n        for i, x in enumerate(nums):\n            v = x * i - t + s - t - x * (len(nums) - i)\n            ans.append(v)\n            t += x\n        return ans\n", "class Solution:\n  def getSumAbsoluteDifferences(self, nums: list[int]) -> list[int]:\n    prefix = list(itertools.accumulate(nums))\n    suffix = list(itertools.accumulate(nums[::-1]))[::-1]\n    return [num * (i + 1) - prefix[i] + suffix[i] - num * (len(nums) - i)\n            for i, num in enumerate(nums)]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1662, "slug": "check-if-two-string-arrays-are-equivalent", "solutions": ["class Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        return ''.join(word1) == ''.join(word2)\n", "class Solution:\n  def arrayStringsAreEqual(self, word1: list[str], word2: list[str]) -> bool:\n    i = 0  # word1's index\n    j = 0  # word2's index\n    a = 0  # word1[i]'s index\n    b = 0  # word2[j]'s index\n\n    while i < len(word1) and j < len(word2):\n      if word1[i][a] != word2[j][b]:\n        return False\n      a += 1\n      if a == len(word1[i]):\n        i += 1\n        a = 0\n      b += 1\n      if b == len(word2[j]):\n        j += 1\n        b = 0\n\n    return i == len(word1) and j == len(word2)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1616, "slug": "split-two-strings-to-make-palindrome", "solutions": ["class Solution:\n    def checkPalindromeFormation(self, a: str, b: str) -> bool:\n        def check1(a: str, b: str) -> bool:\n            i, j = 0, len(b) - 1\n            while i < j and a[i] == b[j]:\n                i, j = i + 1, j - 1\n            return i >= j or check2(a, i, j) or check2(b, i, j)\n\n        def check2(a: str, i: int, j: int) -> bool:\n            return a[i : j + 1] == a[i : j + 1][::-1]\n\n        return check1(a, b) or check1(b, a)\n", "class Solution:\n  def checkPalindromeFormation(self, a: str, b: str) -> bool:\n    return self._check(a, b) or self._check(b, a)\n\n  def _check(self, a: str, b: str) -> bool:\n    i, j = 0, len(a) - 1\n    while i < j:\n      if a[i] != b[j]:\n        # a[0:i] + a[i..j] + b[j + 1:] or\n        # a[0:i] + b[i..j] + b[j + 1:]\n        return self._isPalindrome(a, i, j) or self._isPalindrome(b, i, j)\n      i += 1\n      j -= 1\n    return True\n\n  def _isPalindrome(self, s: str, i: int, j: int) -> bool:\n    while i < j:\n      if s[i] != s[j]:\n        return False\n      i += 1\n      j -= 1\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1656, "slug": "design-an-ordered-stream", "solutions": ["class OrderedStream:\n    def __init__(self, n: int):\n        self.ptr = 1\n        self.data = [None] * (n + 1)\n\n    def insert(self, idKey: int, value: str) -> List[str]:\n        self.data[idKey] = value\n        ans = []\n        while self.ptr < len(self.data) and self.data[self.ptr]:\n            ans.append(self.data[self.ptr])\n            self.ptr += 1\n        return ans\n\n\n# Your OrderedStream object will be instantiated and called as such:\n# obj = OrderedStream(n)\n# param_1 = obj.insert(idKey,value)\n", "class OrderedStream:\n  def __init__(self, n: int):\n    self.values = [''] * n\n    self.i = 0  # self.values' index (0-indexed)\n\n  def insert(self, idKey: int, value: str) -> list[str]:\n    idKey -= 1  # Converts to 0-indexed.\n    self.values[idKey] = value\n    if idKey > self.i:\n      return []\n    while self.i < len(self.values) and self.values[self.i]:\n      self.i += 1\n    return self.values[idKey:self.i]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1658, "slug": "minimum-operations-to-reduce-x-to-zero", "solutions": ["class Solution:\n    def minOperations(self, nums: List[int], x: int) -> int:\n        s = sum(nums) - x\n        vis = {0: -1}\n        mx, t = -1, 0\n        for i, v in enumerate(nums):\n            t += v\n            if t not in vis:\n                vis[t] = i\n            if t - s in vis:\n                mx = max(mx, i - vis[t - s])\n        return -1 if mx == -1 else len(nums) - mx\n", "class Solution:\n  def minOperations(self, nums: list[int], x: int) -> int:\n    targetSum = sum(nums) - x\n    if targetSum == 0:\n      return len(nums)\n    maxLen = self._maxSubArrayLen(nums, targetSum)\n    return -1 if maxLen == -1 else len(nums) - maxLen\n\n  # Same as 325. Maximum Size Subarray Sum Equals k\n  def _maxSubArrayLen(self, nums: list[int], k: int) -> int:\n    res = -1\n    prefix = 0\n    prefixToIndex = {0: -1}\n\n    for i, num in enumerate(nums):\n      prefix += num\n      target = prefix - k\n      if target in prefixToIndex:\n        res = max(res, i - prefixToIndex[target])\n      # No need to check the existence of the prefix since it's unique.\n      prefixToIndex[prefix] = i\n\n    return res\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1693, "slug": "daily-leads-and-partners", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1649, "slug": "create-sorted-array-through-instructions", "solutions": ["class BinaryIndexedTree:\n    def __init__(self, n):\n        self.n = n\n        self.c = [0] * (n + 1)\n\n    def update(self, x: int, v: int):\n        while x <= self.n:\n            self.c[x] += v\n            x += x & -x\n\n    def query(self, x: int) -> int:\n        s = 0\n        while x:\n            s += self.c[x]\n            x -= x & -x\n        return s\n\n\nclass Solution:\n    def createSortedArray(self, instructions: List[int]) -> int:\n        m = max(instructions)\n        tree = BinaryIndexedTree(m)\n        ans = 0\n        mod = 10**9 + 7\n        for i, x in enumerate(instructions):\n            cost = min(tree.query(x - 1), i - tree.query(x))\n            ans += cost\n            tree.update(x, 1)\n        return ans % mod\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1617, "slug": "count-subtrees-with-max-distance-between-cities", "solutions": ["class Solution:\n    def countSubgraphsForEachDiameter(\n        self, n: int, edges: List[List[int]]\n    ) -> List[int]:\n        def dfs(u: int, d: int = 0):\n            nonlocal mx, nxt, msk\n            if mx < d:\n                mx, nxt = d, u\n            msk ^= 1 << u\n            for v in g[u]:\n                if msk >> v & 1:\n                    dfs(v, d + 1)\n\n        g = defaultdict(list)\n        for u, v in edges:\n            u, v = u - 1, v - 1\n            g[u].append(v)\n            g[v].append(u)\n        ans = [0] * (n - 1)\n        nxt = mx = 0\n        for mask in range(1, 1 << n):\n            if mask & (mask - 1) == 0:\n                continue\n            msk, mx = mask, 0\n            cur = msk.bit_length() - 1\n            dfs(cur)\n            if msk == 0:\n                msk, mx = mask, 0\n                dfs(nxt)\n                ans[mx - 1] += 1\n        return ans\n", "class Solution:\n  def countSubgraphsForEachDiameter(\n      self,\n      n: int,\n      edges: list[list[int]],\n  ) -> list[int]:\n    maxMask = 1 << n\n    dist = self._floydWarshall(n, edges)\n    ans = [0] * (n - 1)\n\n    # mask := the subset of the cities\n    for mask in range(maxMask):\n      maxDist = self._getMaxDist(mask, dist, n)\n      if maxDist > 0:\n        ans[maxDist - 1] += 1\n\n    return ans\n\n  def _floydWarshall(self, n: int, edges: list[list[int]]) -> list[list[int]]:\n    dist = [[n] * n for _ in range(n)]\n\n    for i in range(n):\n      dist[i][i] = 0\n\n    for u, v in edges:\n      dist[u - 1][v - 1] = 1\n      dist[v - 1][u - 1] = 1\n\n    for k in range(n):\n      for i in range(n):\n        for j in range(n):\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    return dist\n\n  def _getMaxDist(self, mask: int, dist: list[list[int]], n: int) -> int:\n    maxDist = 0\n    edgeCount = 0\n    cityCount = 0\n    for u in range(n):\n      if (mask >> u) & 1 == 0:  # u is not in the subset.\n        continue\n      cityCount += 1\n      for v in range(u + 1, n):\n        if (mask >> v) & 1 == 0:  # v is not in the subset.\n          continue\n        if dist[u][v] == 1:  # u and v are connected.\n          edgeCount += 1\n        maxDist = max(maxDist, dist[u][v])\n\n    return maxDist if edgeCount == cityCount - 1 else 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1605, "slug": "find-valid-matrix-given-row-and-column-sums", "solutions": ["class Solution:\n    def restoreMatrix(self, rowSum: List[int], colSum: List[int]) -> List[List[int]]:\n        m, n = len(rowSum), len(colSum)\n        ans = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                x = min(rowSum[i], colSum[j])\n                ans[i][j] = x\n                rowSum[i] -= x\n                colSum[j] -= x\n        return ans\n", "class Solution:\n  def restoreMatrix(self, rowSum: list[int],\n                    colSum: list[int]) -> list[list[int]]:\n    m = len(rowSum)\n    n = len(colSum)\n    ans = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        ans[i][j] = min(rowSum[i], colSum[j])\n        rowSum[i] -= ans[i][j]\n        colSum[j] -= ans[i][j]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1668, "slug": "maximum-repeating-substring", "solutions": ["class Solution:\n    def maxRepeating(self, sequence: str, word: str) -> int:\n        for k in range(len(sequence) // len(word), -1, -1):\n            if word * k in sequence:\n                return k\n", "class Solution:\n  def maxRepeating(self, sequence: str, word: str) -> int:\n    ans = 1\n    while word * ans in sequence:\n      ans += 1\n    return ans - 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1611, "slug": "minimum-one-bit-operations-to-make-integers-zero", "solutions": ["class Solution:\n    def minimumOneBitOperations(self, n: int) -> int:\n        ans = 0\n        while n:\n            ans ^= n\n            n >>= 1\n        return ans\n", "class Solution:\n  def minimumOneBitOperations(self, n: int) -> int:\n    # Observation: e.g. n = 2^2\n    #        100 (2^2 needs 2^3 - 1 ops)\n    # op1 -> 101\n    # op2 -> 111\n    # op1 -> 110\n    # op2 -> 010 (2^1 needs 2^2 - 1 ops)\n    # op1 -> 011\n    # op2 -> 001 (2^0 needs 2^1 - 1 ops)\n    # op1 -> 000\n    #\n    # So 2^k needs 2^(k + 1) - 1 ops. Note this is reversible, i.e., 0 -> 2^k\n    # also takes 2^(k + 1) - 1 ops.\n\n    # e.g. n = 1XXX, our first goal is to change 1XXX -> 1100.\n    #   - If the second bit is 1, you only need to consider the cost of turning\n    #     the last 2 bits to 0.\n    #   - If the second bit is 0, you need to add up the cost of flipping the\n    #     second bit from 0 to 1.\n    # XOR determines the cost minimumOneBitOperations(1XXX^1100) accordingly.\n    # Then, 1100 -> 0100 needs 1 op. Finally, 0100 -> 0 needs 2^3 - 1 ops.\n    if n == 0:\n      return 0\n    # x is the largest 2^k <= n.\n    # x | x >> 1 -> x >> 1 needs 1 op.\n    #     x >> 1 -> 0      needs x = 2^k - 1 ops.\n    x = 1 << n.bit_length() - 1\n    return self.minimumOneBitOperations(n ^ (x | x >> 1)) + 1 + x - 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1684, "slug": "count-the-number-of-consistent-strings", "solutions": ["class Solution:\n    def countConsistentStrings(self, allowed: str, words: List[str]) -> int:\n        s = set(allowed)\n        return sum(all(c in s for c in w) for w in words)\n", "class Solution:\n  def countConsistentStrings(self, allowed: str, words: list[str]) -> int:\n    return sum(all(c in allowed for c in word)\n               for word in words)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1699, "slug": "number-of-calls-between-two-persons", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1653, "slug": "minimum-deletions-to-make-string-balanced", "solutions": ["class Solution:\n    def minimumDeletions(self, s: str) -> int:\n        n = len(s)\n        f = [0] * (n + 1)\n        b = 0\n        for i, c in enumerate(s, 1):\n            if c == 'b':\n                f[i] = f[i - 1]\n                b += 1\n            else:\n                f[i] = min(f[i - 1] + 1, b)\n        return f[n]\n", "class Solution:\n  # Same as 926. Flip String to Monotone Increasing\n  def minimumDeletions(self, s: str) -> int:\n    dp = 0  # the number of characters to be deleted to make subso far balanced\n    countB = 0\n\n    for c in s:\n      if c == 'a':\n        # 1. Delete 'a'.\n        # 2. Keep 'a' and delete the previous 'b's.\n        dp = min(dp + 1, countB)\n      else:\n        countB += 1\n\n    return dp\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1600, "slug": "throne-inheritance", "solutions": ["class ThroneInheritance:\n\n    def __init__(self, kingName: str):\n        self.king = kingName\n        self.dead = set()\n        self.g = defaultdict(list)\n\n    def birth(self, parentName: str, childName: str) -> None:\n        self.g[parentName].append(childName)\n\n    def death(self, name: str) -> None:\n        self.dead.add(name)\n\n    def getInheritanceOrder(self) -> List[str]:\n        def dfs(x: str):\n            x not in self.dead and ans.append(x)\n            for y in self.g[x]:\n                dfs(y)\n\n        ans = []\n        dfs(self.king)\n        return ans\n\n\n# Your ThroneInheritance object will be instantiated and called as such:\n# obj = ThroneInheritance(kingName)\n# obj.birth(parentName,childName)\n# obj.death(name)\n# param_3 = obj.getInheritanceOrder()\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1630, "slug": "arithmetic-subarrays", "solutions": ["class Solution:\n    def checkArithmeticSubarrays(\n        self, nums: List[int], l: List[int], r: List[int]\n    ) -> List[bool]:\n        def check(nums, l, r):\n            n = r - l + 1\n            s = set(nums[l : l + n])\n            a1, an = min(nums[l : l + n]), max(nums[l : l + n])\n            d, mod = divmod(an - a1, n - 1)\n            return mod == 0 and all((a1 + (i - 1) * d) in s for i in range(1, n))\n\n        return [check(nums, left, right) for left, right in zip(l, r)]\n", "class Solution:\n  def checkArithmeticSubarrays(\n      self,\n      nums: list[int],\n      l: list[int],\n      r: list[int],\n  ) -> list[bool]:\n    return [self._isArithmetic(nums, a, b) for a, b in zip(l, r)]\n\n  def _isArithmetic(self, nums: list[int], l: int, r: int) -> bool:\n    if r - l < 2:\n      return True\n\n    numsSet = set()\n    mn = math.inf\n    mx = -math.inf\n\n    for i in range(l, r+1):\n      mn = min(mn, nums[i])\n      mx = max(mx, nums[i])\n      numsSet.add(nums[i])\n\n    if (mx - mn) % (r - l) != 0:\n      return False\n\n    interval = (mx - mn) // (r - l)\n    return all(mn + k * interval in numsSet\n               for k in range(1, r - l + 1))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1620, "slug": "coordinate-with-maximum-network-quality", "solutions": ["class Solution:\n    def bestCoordinate(self, towers: List[List[int]], radius: int) -> List[int]:\n        mx = 0\n        ans = [0, 0]\n        for i in range(51):\n            for j in range(51):\n                t = 0\n                for x, y, q in towers:\n                    d = ((x - i) ** 2 + (y - j) ** 2) ** 0.5\n                    if d <= radius:\n                        t += floor(q / (1 + d))\n                if t > mx:\n                    mx = t\n                    ans = [i, j]\n        return ans\n", "class Solution:\n  def bestCoordinate(self, towers: list[list[int]], radius: int) -> list[int]:\n    MAX = 50\n    n = len(towers)\n    ans = [0] * 2\n    maxQuality = 0\n\n    def dist(tower: list[int], i: int, j: int) -> float:\n      \"\"\"Returns the distance between the tower and the coordinate.\"\"\"\n      return math.sqrt((tower[0] - i)**2 + (tower[1] - j)**2)\n\n    for i in range(MAX + 1):\n      for j in range(MAX + 1):\n        qualitySum = 0\n        for tower in towers:\n          q = tower[2]\n          d = dist(tower, i, j)\n          if d <= radius:\n            qualitySum += int(q / (1 + d))\n        if qualitySum > maxQuality:\n          maxQuality = qualitySum\n          ans = [i, j]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1655, "slug": "distribute-repeating-integers", "solutions": ["class Solution:\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\n        m = len(quantity)\n        s = [0] * (1 << m)\n        for i in range(1, 1 << m):\n            for j in range(m):\n                if i >> j & 1:\n                    s[i] = s[i ^ (1 << j)] + quantity[j]\n                    break\n        cnt = Counter(nums)\n        arr = list(cnt.values())\n        n = len(arr)\n        f = [[False] * (1 << m) for _ in range(n)]\n        for i in range(n):\n            f[i][0] = True\n        for i, x in enumerate(arr):\n            for j in range(1, 1 << m):\n                if i and f[i - 1][j]:\n                    f[i][j] = True\n                    continue\n                k = j\n                while k:\n                    ok1 = j == k if i == 0 else f[i - 1][j ^ k]\n                    ok2 = s[k] <= x\n                    if ok1 and ok2:\n                        f[i][j] = True\n                        break\n                    k = (k - 1) & j\n        return f[-1][-1]\n", "class Solution:\n  def canDistribute(self, nums: list[int], quantity: list[int]) -> bool:\n    freqs = list(collections.Counter(nums).values())\n    # validDistribution[i][j] := True if it's possible to distribute the i-th\n    # freq into a subset of quantity represented by the bitmask j\n    validDistribution = self._getValidDistribution(freqs, quantity)\n    n = len(freqs)\n    m = len(quantity)\n    maxMask = 1 << m\n    # dp[i][j] := true if it's possible to distribute freqs[i..n), where j is\n    # the bitmask of the selected quantity\n    dp = [[False] * maxMask for _ in range(n + 1)]\n    dp[n][maxMask - 1] = True\n\n    for i in range(n - 1, -1, -1):\n      for mask in range(maxMask):\n        dp[i][mask] = dp[i + 1][mask]\n        availableMask = ~mask & (maxMask - 1)\n        submask = availableMask\n        while submask > 0:\n          if validDistribution[i][submask]:\n            dp[i][mask] = dp[i][mask] or dp[i + 1][mask | submask]\n          submask = (submask - 1) & availableMask\n\n    return dp[0][0]\n\n  def _getValidDistribution(self, freqs: list[int],\n                            quantity: list[int]) -> list[list[bool]]:\n    maxMask = 1 << len(quantity)\n    validDistribution = [[False] * maxMask for _ in range(len(freqs))]\n    for i, freq in enumerate(freqs):\n      for mask in range(maxMask):\n        if freq >= self._getQuantitySum(quantity, mask):\n          validDistribution[i][mask] = True\n    return validDistribution\n\n  def _getQuantitySum(self, quantity: list[int], mask: int) -> int:\n    \"\"\"Returns the sum of the selected quantity represented by `mask`.\"\"\"\n    return sum(q for i, q in enumerate(quantity) if mask >> i & 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1601, "slug": "maximum-number-of-achievable-transfer-requests", "solutions": ["class Solution:\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\n        def check(mask: int) -> bool:\n            cnt = [0] * n\n            for i, (f, t) in enumerate(requests):\n                if mask >> i & 1:\n                    cnt[f] -= 1\n                    cnt[t] += 1\n            return all(v == 0 for v in cnt)\n\n        ans = 0\n        for mask in range(1 << len(requests)):\n            cnt = mask.bit_count()\n            if ans < cnt and check(mask):\n                ans = cnt\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1640, "slug": "check-array-formation-through-concatenation", "solutions": ["class Solution:\n    def canFormArray(self, arr: List[int], pieces: List[List[int]]) -> bool:\n        i = 0\n        while i < len(arr):\n            k = 0\n            while k < len(pieces) and pieces[k][0] != arr[i]:\n                k += 1\n            if k == len(pieces):\n                return False\n            j = 0\n            while j < len(pieces[k]) and arr[i] == pieces[k][j]:\n                i, j = i + 1, j + 1\n        return True\n", "class Solution:\n  def canFormArray(self, arr: list[int], pieces: list[list[int]]) -> bool:\n    concatenated = []\n    startToPiece = {piece[0]: piece for piece in pieces}\n\n    for a in arr:\n      concatenated += startToPiece.get(a, [])\n\n    return concatenated == arr\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1688, "slug": "count-of-matches-in-tournament", "solutions": ["class Solution:\n    def numberOfMatches(self, n: int) -> int:\n        return n - 1\n", "class Solution:\n  def numberOfMatches(self, n: int) -> int:\n    return n - 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1622, "slug": "fancy-sequence", "solutions": ["MOD = int(1e9 + 7)\n\n\nclass Node:\n    def __init__(self, l, r):\n        self.left = None\n        self.right = None\n        self.l = l\n        self.r = r\n        self.mid = (l + r) >> 1\n        self.v = 0\n        self.add = 0\n        self.mul = 1\n\n\nclass SegmentTree:\n    def __init__(self):\n        self.root = Node(1, int(1e5 + 1))\n\n    def modifyAdd(self, l, r, inc, node=None):\n        if l > r:\n            return\n        if node is None:\n            node = self.root\n        if node.l >= l and node.r <= r:\n            node.v = (node.v + (node.r - node.l + 1) * inc) % MOD\n            node.add += inc\n            return\n        self.pushdown(node)\n        if l <= node.mid:\n            self.modifyAdd(l, r, inc, node.left)\n        if r > node.mid:\n            self.modifyAdd(l, r, inc, node.right)\n        self.pushup(node)\n\n    def modifyMul(self, l, r, m, node=None):\n        if l > r:\n            return\n        if node is None:\n            node = self.root\n        if node.l >= l and node.r <= r:\n            node.v = (node.v * m) % MOD\n            node.add = (node.add * m) % MOD\n            node.mul = (node.mul * m) % MOD\n            return\n        self.pushdown(node)\n        if l <= node.mid:\n            self.modifyMul(l, r, m, node.left)\n        if r > node.mid:\n            self.modifyMul(l, r, m, node.right)\n        self.pushup(node)\n\n    def query(self, l, r, node=None):\n        if l > r:\n            return 0\n        if node is None:\n            node = self.root\n        if node.l >= l and node.r <= r:\n            return node.v\n        self.pushdown(node)\n        v = 0\n        if l <= node.mid:\n            v = (v + self.query(l, r, node.left)) % MOD\n        if r > node.mid:\n            v = (v + self.query(l, r, node.right)) % MOD\n        return v\n\n    def pushup(self, node):\n        node.v = (node.left.v + node.right.v) % MOD\n\n    def pushdown(self, node):\n        if node.left is None:\n            node.left = Node(node.l, node.mid)\n        if node.right is None:\n            node.right = Node(node.mid + 1, node.r)\n        left, right = node.left, node.right\n        if node.add != 0 or node.mul != 1:\n            left.v = (left.v * node.mul + (left.r - left.l + 1) * node.add) % MOD\n            right.v = (right.v * node.mul + (right.r - right.l + 1) * node.add) % MOD\n            left.add = (left.add * node.mul + node.add) % MOD\n            right.add = (right.add * node.mul + node.add) % MOD\n            left.mul = (left.mul * node.mul) % MOD\n            right.mul = (right.mul * node.mul) % MOD\n            node.add = 0\n            node.mul = 1\n\n\nclass Fancy:\n    def __init__(self):\n        self.n = 0\n        self.tree = SegmentTree()\n\n    def append(self, val: int) -> None:\n        self.n += 1\n        self.tree.modifyAdd(self.n, self.n, val)\n\n    def addAll(self, inc: int) -> None:\n        self.tree.modifyAdd(1, self.n, inc)\n\n    def multAll(self, m: int) -> None:\n        self.tree.modifyMul(1, self.n, m)\n\n    def getIndex(self, idx: int) -> int:\n        return -1 if idx >= self.n else self.tree.query(idx + 1, idx + 1)\n\n\n# Your Fancy object will be instantiated and called as such:\n# obj = Fancy()\n# obj.append(val)\n# obj.addAll(inc)\n# obj.multAll(m)\n# param_4 = obj.getIndex(idx)\n", "class Fancy:\n  def __init__(self):\n    self.MOD = 1_000_000_007\n    # For each `val` in `vals`, it actually represents a * val + b.\n    self.vals = []\n    self.a = 1\n    self.b = 0\n\n  # To undo a * val + b and get the original value, we append (val - b) // a.\n  # By Fermat's little theorem:\n  #   a^(p - 1)  1 (mod p)\n  #   a^(p - 2)  a^(-1) (mod p)\n  # So, (val - b) / a  (val - b) * a^(p - 2) (mod p)\n  def append(self, val: int) -> None:\n    x = (val - self.b + self.MOD) % self.MOD\n    self.vals.append(x * pow(self.a, self.MOD - 2, self.MOD))\n\n  # If the value is a * val + b, then the value after adding by `inc` will be\n  # a * val + b + inc. So, we adjust b to b + inc.\n  def addAll(self, inc: int) -> None:\n    self.b = (self.b + inc) % self.MOD\n\n  # If the value is a * val + b, then the value after multiplying by `m` will\n  # be a * m * val + b * m. So, we adjust a to a * m and b to b * m.\n  def multAll(self, m: int) -> None:\n    self.a = (self.a * m) % self.MOD\n    self.b = (self.b * m) % self.MOD\n\n  def getIndex(self, idx: int) -> int:\n    return (-1 if idx >= len(self.vals)\n            else (self.a * self.vals[idx] + self.b) % self.MOD)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1674, "slug": "minimum-moves-to-make-array-complementary", "solutions": ["class Solution:\n    def minMoves(self, nums: List[int], limit: int) -> int:\n        d = [0] * (2 * limit + 2)\n        n = len(nums)\n        for i in range(n // 2):\n            x, y = nums[i], nums[-i - 1]\n            if x > y:\n                x, y = y, x\n            d[2] += 2\n            d[x + 1] -= 2\n            d[x + 1] += 1\n            d[x + y] -= 1\n            d[x + y + 1] += 1\n            d[y + limit + 1] -= 1\n            d[y + limit + 1] += 2\n        return min(accumulate(d[2:]))\n", "class Solution:\n  def minMoves(self, nums: list[int], limit: int) -> int:\n    n = len(nums)\n    ans = n\n    # delta[i] := the number of moves needed when target goes from i - 1 to i\n    delta = [0] * (limit * 2 + 2)\n\n    for i in range(n // 2):\n      a = nums[i]\n      b = nums[n - 1 - i]\n      delta[min(a, b) + 1] -= 1\n      delta[a + b] -= 1\n      delta[a + b + 1] += 1\n      delta[max(a, b) + limit + 1] += 1\n\n    # Initially, we need `moves` when the target is 2.\n    moves = n\n    for i in range(2, limit * 2 + 1):\n      moves += delta[i]\n      ans = min(ans, moves)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1692, "slug": "count-ways-to-distribute-candies", "solutions": ["class Solution:\n    def waysToDistribute(self, n: int, k: int) -> int:\n        mod = 10**9 + 7\n        f = [[0] * (k + 1) for _ in range(n + 1)]\n        f[0][0] = 1\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                f[i][j] = (f[i - 1][j] * j + f[i - 1][j - 1]) % mod\n        return f[n][k]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1663, "slug": "smallest-string-with-a-given-numeric-value", "solutions": ["class Solution:\n    def getSmallestString(self, n: int, k: int) -> str:\n        ans = ['a'] * n\n        i, d = n - 1, k - n\n        while d > 25:\n            ans[i] = 'z'\n            d -= 25\n            i -= 1\n        ans[i] = chr(ord(ans[i]) + d)\n        return ''.join(ans)\n", "class Solution:\n  def getSmallestString(self, n: int, k: int) -> str:\n    ans = []\n\n    for i in range(n):\n      remainingLetters = n - 1 - i\n      rank = max(1, k - remainingLetters * 26)\n      ans.append(chr(ord('a') + rank - 1))\n      k -= rank\n\n    return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1621, "slug": "number-of-sets-of-k-non-overlapping-line-segments", "solutions": ["class Solution:\n    def numberOfSets(self, n: int, k: int) -> int:\n        mod = 10**9 + 7\n        f = [[0] * (k + 1) for _ in range(n + 1)]\n        g = [[0] * (k + 1) for _ in range(n + 1)]\n        f[1][0] = 1\n        for i in range(2, n + 1):\n            for j in range(k + 1):\n                f[i][j] = (f[i - 1][j] + g[i - 1][j]) % mod\n                g[i][j] = g[i - 1][j]\n                if j:\n                    g[i][j] += f[i - 1][j - 1]\n                    g[i][j] %= mod\n                    g[i][j] += g[i - 1][j - 1]\n                    g[i][j] %= mod\n        return (f[-1][-1] + g[-1][-1]) % mod\n", "class Solution:\n  def numberOfSets(self, n: int, k: int) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def dp(i: int, k: int, drawing: bool) -> int:\n      if k == 0:  # Find a way to draw k segments.\n        return 1\n      if i == n:  # Reach the end.\n        return 0\n      if drawing:\n        # 1. Keep drawing at i and move to i + 1.\n        # 2. Stop at i so decrease k. We can start from i for the next segment.\n        return (dp(i + 1, k, True) + dp(i, k - 1, False)) % MOD\n      # 1. Skip i and move to i + 1.\n      # 2. Start at i and move to i + 1.\n      return (dp(i + 1, k, False) + dp(i + 1, k, True)) % MOD\n\n    return dp(0, k, False)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1676, "slug": "lowest-common-ancestor-of-a-binary-tree-iv", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\n\nclass Solution:\n    def lowestCommonAncestor(\n        self, root: 'TreeNode', nodes: 'List[TreeNode]'\n    ) -> 'TreeNode':\n        def dfs(root):\n            if root is None or root.val in s:\n                return root\n            left, right = dfs(root.left), dfs(root.right)\n            if left and right:\n                return root\n            return left or right\n\n        s = {node.val for node in nodes}\n        return dfs(root)\n", "class Solution:\n  def lowestCommonAncestor(\n      self,\n      root: 'TreeNode',\n      nodes: 'list[TreeNode]',\n  ) -> 'TreeNode':\n    nodes = set(nodes)\n\n    def lca(root: 'TreeNode') -> 'TreeNode':\n      if not root:\n        return None\n      if root in nodes:\n        return root\n      left = lca(root.left)\n      right = lca(root.right)\n      if left and right:\n        return root\n      return left or right\n\n    return lca(root)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1683, "slug": "invalid-tweets", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1648, "slug": "sell-diminishing-valued-colored-balls", "solutions": ["class Solution:\n    def maxProfit(self, inventory: List[int], orders: int) -> int:\n        inventory.sort(reverse=True)\n        mod = 10**9 + 7\n        ans = i = 0\n        n = len(inventory)\n        while orders > 0:\n            while i < n and inventory[i] >= inventory[0]:\n                i += 1\n            nxt = 0\n            if i < n:\n                nxt = inventory[i]\n            cnt = i\n            x = inventory[0] - nxt\n            tot = cnt * x\n            if tot > orders:\n                decr = orders // cnt\n                a1, an = inventory[0] - decr + 1, inventory[0]\n                ans += (a1 + an) * decr // 2 * cnt\n                ans += (inventory[0] - decr) * (orders % cnt)\n            else:\n                a1, an = nxt + 1, inventory[0]\n                ans += (a1 + an) * x // 2 * cnt\n                inventory[0] = nxt\n            orders -= tot\n            ans %= mod\n        return ans\n", "class Solution:\n  def maxProfit(self, inventory: list[int], orders: int) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    largestCount = 1\n\n    def trapezoid(a: int, b: int) -> int:\n      return (a + b) * (a - b + 1) // 2\n\n    for a, b in itertools.pairwise(sorted(inventory, reverse=True) + [0]):\n      if a > b:\n        # If we are at the last inventory, or inventory[i] > inventory[i + 1].\n        # In either case, we will pick inventory[i - largestCount + 1..i].\n        pick = a - b\n        # We have run out of orders, so we need to recalculate the number of\n        # balls that we actually pick for inventory[i - largestCount + 1..i].\n        if largestCount * pick >= orders:\n          actualPick, remaining = divmod(orders, largestCount)\n          return (ans +\n                  largestCount * trapezoid(a, a - actualPick + 1) +\n                  remaining * (a - actualPick)) % MOD\n        ans += largestCount * trapezoid(a, a - pick + 1)\n        ans %= MOD\n        orders -= largestCount * pick\n      largestCount += 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1629, "slug": "slowest-key", "solutions": ["class Solution:\n    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:\n        ans = keysPressed[0]\n        mx = releaseTimes[0]\n        for i in range(1, len(keysPressed)):\n            d = releaseTimes[i] - releaseTimes[i - 1]\n            if d > mx or (d == mx and ord(keysPressed[i]) > ord(ans)):\n                mx = d\n                ans = keysPressed[i]\n        return ans\n", "class Solution:\n  def slowestKey(self, releaseTimes: list[int], keysPressed: str) -> str:\n    ans = keysPressed[0]\n    maxDuration = releaseTimes[0]\n\n    for i in range(1, len(keysPressed)):\n      duration = releaseTimes[i] - releaseTimes[i-1]\n      if duration > maxDuration or (\n              duration == maxDuration and keysPressed[i] > ans):\n        ans = keysPressed[i]\n        maxDuration = duration\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1602, "slug": "find-nearest-right-node-in-binary-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findNearestRightNode(self, root: TreeNode, u: TreeNode) -> Optional[TreeNode]:\n        q = deque([root])\n        while q:\n            for i in range(len(q) - 1, -1, -1):\n                root = q.popleft()\n                if root == u:\n                    return q[0] if i else None\n                if root.left:\n                    q.append(root.left)\n                if root.right:\n                    q.append(root.right)\n", "class Solution:\n  def findNearestRightNode(\n      self,\n      root: TreeNode,\n      u: TreeNode,\n  ) -> TreeNode | None:\n    ans = None\n    targetDepth = -1\n\n    def dfs(root: TreeNode, depth: int) -> None:\n      nonlocal ans\n      nonlocal targetDepth\n      if not root:\n        return\n      if root == u:\n        targetDepth = depth\n        return\n      if depth == targetDepth and not ans:\n        ans = root\n        return\n      dfs(root.left, depth + 1)\n      dfs(root.right, depth + 1)\n\n    dfs(root, 0)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1659, "slug": "maximize-grid-happiness", "solutions": ["class Solution:\n    def getMaxGridHappiness(\n        self, m: int, n: int, introvertsCount: int, extrovertsCount: int\n    ) -> int:\n        @cache\n        def dfs(i: int, pre: int, ic: int, ec: int) -> int:\n            if i == m or (ic == 0 and ec == 0):\n                return 0\n            ans = 0\n            for cur in range(mx):\n                if ix[cur] <= ic and ex[cur] <= ec:\n                    a = f[cur] + g[pre][cur]\n                    b = dfs(i + 1, cur, ic - ix[cur], ec - ex[cur])\n                    ans = max(ans, a + b)\n            return ans\n\n        mx = pow(3, n)\n        f = [0] * mx\n        g = [[0] * mx for _ in range(mx)]\n        h = [[0, 0, 0], [0, -60, -10], [0, -10, 40]]\n        bits = [[0] * n for _ in range(mx)]\n        ix = [0] * mx\n        ex = [0] * mx\n        for i in range(mx):\n            mask = i\n            for j in range(n):\n                mask, x = divmod(mask, 3)\n                bits[i][j] = x\n                if x == 1:\n                    ix[i] += 1\n                    f[i] += 120\n                elif x == 2:\n                    ex[i] += 1\n                    f[i] += 40\n                if j:\n                    f[i] += h[x][bits[i][j - 1]]\n        for i in range(mx):\n            for j in range(mx):\n                for k in range(n):\n                    g[i][j] += h[bits[i][k]][bits[j][k]]\n        return dfs(0, 0, introvertsCount, extrovertsCount)\n", "class Solution:\n  def getMaxGridHappiness(\n      self,\n      m: int,\n      n: int,\n      introvertsCount: int,\n      extrovertsCount: int,\n  ) -> int:\n    def getPlacementCost(\n        i: int,\n        j: int,\n        inMask: int,\n        exMask: int,\n        diff: int,\n    ) -> int:\n      \"\"\"Calculates the cost based on left and up neighbors.\n\n      The `diff` parameter represents the happiness change due to the current\n      placed person in (i, j). We add `diff` each time we encounter a neighbor\n      (left or up) who is already placed.\n\n      1. If the neighbor is an introvert, we subtract 30 from cost.\n      2. If the neighbor is an extrovert, we add 20 to from cost.\n      \"\"\"\n      cost = 0\n      if i > 0:\n        if (1 << (n - 1)) & inMask:\n          cost += diff - 30\n        if (1 << (n - 1)) & exMask:\n          cost += diff + 20\n      if j > 0:\n        if 1 & inMask:\n          cost += diff - 30\n        if 1 & exMask:\n          cost += diff + 20\n      return cost\n\n    @functools.lru_cache(None)\n    def dp(\n        pos: int, inMask: int, exMask: int, inCount: int, exCount: int\n    ) -> int:\n      # `inMask` is the placement of introvert people in the last n cells.\n      # e.g. if we have m = 2, n = 3, i = 1, j = 1, then inMask = 0b101 means\n      #\n      # ? 1 0\n      # 1 x ? (x := current position)\n      i, j = divmod(pos, n)\n      if i == m:\n        return 0\n\n      shiftedInMask = (inMask << 1) & ((1 << n) - 1)\n      shiftedExMask = (exMask << 1) & ((1 << n) - 1)\n\n      skip = dp(pos + 1, shiftedInMask, shiftedExMask, inCount, exCount)\n      placeIntrovert = (\n          120 + getPlacementCost(i, j, inMask, exMask, -30) +\n          dp(pos + 1, shiftedInMask + 1, shiftedExMask, inCount - 1, exCount)\n          if inCount > 0\n          else -math.inf)\n      placeExtrovert = (\n          40 + getPlacementCost(i, j, inMask, exMask, 20) +\n          dp(pos + 1, shiftedInMask, shiftedExMask + 1, inCount, exCount - 1)\n          if exCount > 0\n          else -math.inf)\n      return max(skip, placeIntrovert, placeExtrovert)\n\n    return dp(0, 0, 0, introvertsCount, extrovertsCount)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1695, "slug": "maximum-erasure-value", "solutions": ["class Solution:\n    def maximumUniqueSubarray(self, nums: List[int]) -> int:\n        d = defaultdict(int)\n        s = list(accumulate(nums, initial=0))\n        ans = j = 0\n        for i, v in enumerate(nums, 1):\n            j = max(j, d[v])\n            ans = max(ans, s[i] - s[j])\n            d[v] = i\n        return ans\n", "class Solution:\n  def maximumUniqueSubarray(self, nums: list[int]) -> int:\n    ans = 0\n    score = 0\n    seen = set()\n\n    l = 0\n    for r, num in enumerate(nums):\n      while num in seen:\n        score -= nums[l]\n        seen.remove(nums[l])\n        l += 1\n      seen.add(nums[r])\n      score += nums[r]\n      ans = max(ans, score)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1610, "slug": "maximum-number-of-visible-points", "solutions": ["class Solution:\n    def visiblePoints(\n        self, points: List[List[int]], angle: int, location: List[int]\n    ) -> int:\n        v = []\n        x, y = location\n        same = 0\n        for xi, yi in points:\n            if xi == x and yi == y:\n                same += 1\n            else:\n                v.append(atan2(yi - y, xi - x))\n        v.sort()\n        n = len(v)\n        v += [deg + 2 * pi for deg in v]\n        t = angle * pi / 180\n        mx = max((bisect_right(v, v[i] + t) - i for i in range(n)), default=0)\n        return mx + same\n", "class Solution:\n  def visiblePoints(\n      self,\n      points: list[list[int]],\n      angle: int,\n      location: list[int],\n  ) -> int:\n    posX, posY = location\n    maxVisible = 0\n    same = 0\n    A = []\n\n    for x, y in points:\n      if x == posX and y == posY:\n        same += 1\n      else:\n        A.append(math.atan2(y - posY, x - posX))\n\n    A.sort()\n    A = A + [a + 2.0 * math.pi for a in A]\n\n    angleInRadians = math.pi * (angle / 180)\n\n    l = 0\n    for r in range(len(A)):\n      while A[r] - A[l] > angleInRadians:\n        l += 1\n      maxVisible = max(maxVisible, r - l + 1)\n\n    return maxVisible + same\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1680, "slug": "concatenation-of-consecutive-binary-numbers", "solutions": ["class Solution:\n    def concatenatedBinary(self, n: int) -> int:\n        mod = 10**9 + 7\n        ans = 0\n        for i in range(1, n + 1):\n            ans = (ans << i.bit_length() | i) % mod\n        return ans\n", "class Solution:\n  def concatenatedBinary(self, n: int) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n\n    def numberOfBits(n: int) -> int:\n      return int(math.log2(n)) + 1\n\n    for i in range(1, n + 1):\n      ans = ((ans << numberOfBits(i)) + i) % MOD\n\n    return ans\n", "class Solution:\n  def concatenatedBinary(self, n: int) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    numberOfBits = 0\n\n    for i in range(1, n + 1):\n      if i.bit_count() == 1:\n        numberOfBits += 1\n      ans = ((ans << numberOfBits) + i) % MOD\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1614, "slug": "maximum-nesting-depth-of-the-parentheses", "solutions": ["class Solution:\n    def maxDepth(self, s: str) -> int:\n        ans = d = 0\n        for c in s:\n            if c == '(':\n                d += 1\n                ans = max(ans, d)\n            elif c == ')':\n                d -= 1\n        return ans\n", "class Solution:\n  def maxDepth(self, s: str) -> int:\n    ans = 0\n    opened = 0\n\n    for c in s:\n      if c == '(':\n        opened += 1\n        ans = max(ans, opened)\n      elif c == ')':\n        opened -= 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1633, "slug": "percentage-of-users-attended-a-contest", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1652, "slug": "defuse-the-bomb", "solutions": ["class Solution:\n    def decrypt(self, code: List[int], k: int) -> List[int]:\n        n = len(code)\n        ans = [0] * n\n        if k == 0:\n            return ans\n        for i in range(n):\n            if k > 0:\n                for j in range(i + 1, i + k + 1):\n                    ans[i] += code[j % n]\n            else:\n                for j in range(i + k, i):\n                    ans[i] += code[(j + n) % n]\n        return ans\n", "class Solution:\n  def decrypt(self, code: list[int], k: int) -> list[int]:\n    n = len(code)\n    ans = [0] * n\n    if k == 0:\n      return ans\n\n    summ = 0\n    start = 1 if k > 0 else n + k  # the start of the next k numbers\n    end = k if k > 0 else n - 1  # the end of the next k numbers\n\n    for i in range(start, end + 1):\n      summ += code[i]\n\n    for i in range(n):\n      ans[i] = summ\n      summ -= code[start % n]\n      start += 1\n      end += 1\n      summ += code[end % n]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1689, "slug": "partitioning-into-minimum-number-of-deci-binary-numbers", "solutions": ["class Solution:\n    def minPartitions(self, n: str) -> int:\n        return int(max(n))\n", "class Solution:\n  def minPartitions(self, n: str) -> int:\n    return int(max(n))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1642, "slug": "furthest-building-you-can-reach", "solutions": ["class Solution:\n    def furthestBuilding(self, heights: List[int], bricks: int, ladders: int) -> int:\n        h = []\n        for i, a in enumerate(heights[:-1]):\n            b = heights[i + 1]\n            d = b - a\n            if d > 0:\n                heappush(h, d)\n                if len(h) > ladders:\n                    bricks -= heappop(h)\n                    if bricks < 0:\n                        return i\n        return len(heights) - 1\n", "class Solution:\n  def furthestBuilding(\n      self,\n      heights: list[int],\n      bricks: int,\n      ladders: int,\n  ) -> int:\n    minHeap = []\n\n    for i, (a, b) in enumerate(itertools.pairwise(heights)):\n      diff = b - a\n      if diff <= 0:\n        continue\n      heapq.heappush(minHeap, diff)\n      # If we run out of ladders, greedily use as less bricks as possible.\n      if len(minHeap) > ladders:\n        bricks -= heapq.heappop(minHeap)\n      if bricks < 0:\n        return i\n\n    return len(heights) - 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1667, "slug": "fix-names-in-a-table", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1651, "slug": "hopper-company-queries-iii", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1696, "slug": "jump-game-vi", "solutions": ["class Solution:\n    def maxResult(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        f = [0] * n\n        q = deque([0])\n        for i in range(n):\n            if i - q[0] > k:\n                q.popleft()\n            f[i] = nums[i] + f[q[0]]\n            while q and f[q[-1]] <= f[i]:\n                q.pop()\n            q.append(i)\n        return f[-1]\n", "class Solution:\n  def maxResult(self, nums: list[int], k: int) -> int:\n    # Stores dp[i] within the bounds.\n    maxQ = collections.deque([0])\n    # dp[i] := the maximum score to consider nums[0..i]\n    dp = [0] * len(nums)\n    dp[0] = nums[0]\n\n    for i in range(1, len(nums)):\n      # Pop the index if it's out-of-bounds.\n      if maxQ[0] + k < i:\n        maxQ.popleft()\n      dp[i] = dp[maxQ[0]] + nums[i]\n      # Pop indices that won't be chosen in the future.\n      while maxQ and dp[maxQ[-1]] <= dp[i]:\n        maxQ.pop()\n      maxQ.append(i)\n\n    return dp[-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1679, "slug": "max-number-of-k-sum-pairs", "solutions": ["class Solution:\n    def maxOperations(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        l, r, ans = 0, len(nums) - 1, 0\n        while l < r:\n            s = nums[l] + nums[r]\n            if s == k:\n                ans += 1\n                l, r = l + 1, r - 1\n            elif s > k:\n                r -= 1\n            else:\n                l += 1\n        return ans\n", "class Solution:\n  def maxOperations(self, nums: list[int], k: int) -> int:\n    count = collections.Counter(nums)\n    return sum(min(count[num], count[k - num])\n               for num in count) // 2\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1603, "slug": "design-parking-system", "solutions": ["class ParkingSystem:\n    def __init__(self, big: int, medium: int, small: int):\n        self.cnt = [0, big, medium, small]\n\n    def addCar(self, carType: int) -> bool:\n        if self.cnt[carType] == 0:\n            return False\n        self.cnt[carType] -= 1\n        return True\n\n\n# Your ParkingSystem object will be instantiated and called as such:\n# obj = ParkingSystem(big, medium, small)\n# param_1 = obj.addCar(carType)\n", "class ParkingSystem:\n  def __init__(self, big: int, medium: int, small: int):\n    self.count = [big, medium, small]\n\n  def addCar(self, carType: int) -> bool:\n    self.count[carType - 1] -= 1\n    return self.count[carType - 1] >= 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1604, "slug": "alert-using-same-key-card-three-or-more-times-in-a-one-hour-period", "solutions": ["class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        d = defaultdict(list)\n        for name, t in zip(keyName, keyTime):\n            t = int(t[:2]) * 60 + int(t[3:])\n            d[name].append(t)\n        ans = []\n        for name, ts in d.items():\n            if (n := len(ts)) > 2:\n                ts.sort()\n                for i in range(n - 2):\n                    if ts[i + 2] - ts[i] <= 60:\n                        ans.append(name)\n                        break\n        ans.sort()\n        return ans\n", "class Solution:\n  def alertNames(self, keyName: list[str], keyTime: list[str]) -> list[str]:\n    nameToMinutes = collections.defaultdict(list)\n\n    for name, time in zip(keyName, keyTime):\n      minutes = self._getMinutes(time)\n      nameToMinutes[name].append(minutes)\n\n    return sorted([name for name, minutes in nameToMinutes.items()\n                   if self._hasAlert(minutes)])\n\n  def _hasAlert(self, minutes: list[int]) -> bool:\n    if len(minutes) > 70:\n      return True\n    minutes.sort()\n    for i in range(2, len(minutes)):\n      if minutes[i - 2] + 60 >= minutes[i]:\n        return True\n    return False\n\n  def _getMinutes(self, time: str) -> int:\n    h, m = map(int, time.split(':'))\n    return 60 * h + m\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1607, "slug": "sellers-with-no-sales", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1636, "slug": "sort-array-by-increasing-frequency", "solutions": ["class Solution:\n    def frequencySort(self, nums: List[int]) -> List[int]:\n        cnt = Counter(nums)\n        return sorted(nums, key=lambda x: (cnt[x], -x))\n", "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass T:\n  num: int\n  freq: int\n\n  def __lt__(self, other):\n    if self.freq == other.freq:\n      return self.num > other.num\n    return self.freq < other.freq\n\n\nclass Solution:\n  def frequencySort(self, nums: list[int]) -> list[int]:\n    ans = []\n    heap = []\n\n    for num, freq in collections.Counter(nums).items():\n      heapq.heappush(heap, T(num, freq))\n\n    while len(heap) > 0:\n      num = heap[0].num\n      freq = heapq.heappop(heap).freq\n      ans.extend([num] * freq)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1647, "slug": "minimum-deletions-to-make-character-frequencies-unique", "solutions": ["class Solution:\n    def minDeletions(self, s: str) -> int:\n        cnt = Counter(s)\n        ans, pre = 0, inf\n        for v in sorted(cnt.values(), reverse=True):\n            if pre == 0:\n                ans += v\n            elif v >= pre:\n                ans += v - pre + 1\n                pre -= 1\n            else:\n                pre = v\n        return ans\n", "class Solution:\n  def minDeletions(self, s: str) -> int:\n    ans = 0\n    count = collections.Counter(s)\n    usedFreq = set()\n\n    for freq in count.values():\n      while freq > 0 and freq in usedFreq:\n        freq -= 1  # Delete ('a' + i).\n        ans += 1\n      usedFreq.add(freq)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1691, "slug": "maximum-height-by-stacking-cuboids", "solutions": ["class Solution:\n    def maxHeight(self, cuboids: List[List[int]]) -> int:\n        for c in cuboids:\n            c.sort()\n        cuboids.sort()\n        n = len(cuboids)\n        f = [0] * n\n        for i in range(n):\n            for j in range(i):\n                if cuboids[j][1] <= cuboids[i][1] and cuboids[j][2] <= cuboids[i][2]:\n                    f[i] = max(f[i], f[j])\n            f[i] += cuboids[i][2]\n        return max(f)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1631, "slug": "path-with-minimum-effort", "solutions": ["class UnionFind:\n    def __init__(self, n):\n        self.p = list(range(n))\n        self.size = [1] * n\n\n    def find(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n\n    def union(self, a, b):\n        pa, pb = self.find(a), self.find(b)\n        if pa == pb:\n            return False\n        if self.size[pa] > self.size[pb]:\n            self.p[pb] = pa\n            self.size[pa] += self.size[pb]\n        else:\n            self.p[pa] = pb\n            self.size[pb] += self.size[pa]\n        return True\n\n    def connected(self, a, b):\n        return self.find(a) == self.find(b)\n\n\nclass Solution:\n    def minimumEffortPath(self, heights: List[List[int]]) -> int:\n        m, n = len(heights), len(heights[0])\n        uf = UnionFind(m * n)\n        e = []\n        dirs = (0, 1, 0)\n        for i in range(m):\n            for j in range(n):\n                for a, b in pairwise(dirs):\n                    x, y = i + a, j + b\n                    if 0 <= x < m and 0 <= y < n:\n                        e.append(\n                            (abs(heights[i][j] - heights[x][y]), i * n + j, x * n + y)\n                        )\n        e.sort()\n        for h, a, b in e:\n            uf.union(a, b)\n            if uf.connected(0, m * n - 1):\n                return h\n        return 0\n", "class Solution:\n  def minimumEffortPath(self, heights: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(heights)\n    n = len(heights[0])\n    # diff[i][j] := the maximum absolute difference to reach (i, j)\n    diff = [[math.inf] * n for _ in range(m)]\n    seen = set()\n\n    minHeap = [(0, 0, 0)]  # (d, i, j)\n    diff[0][0] = 0\n\n    while minHeap:\n      d, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        return d\n      seen.add((i, j))\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if (x, y) in seen:\n          continue\n        newDiff = abs(heights[i][j] - heights[x][y])\n        maxDiff = max(diff[i][j], newDiff)\n        if diff[x][y] > maxDiff:\n          diff[x][y] = maxDiff\n          heapq.heappush(minHeap, (diff[x][y], x, y))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1645, "slug": "hopper-company-queries-ii", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1608, "slug": "special-array-with-x-elements-greater-than-or-equal-x", "solutions": ["class Solution:\n    def specialArray(self, nums: List[int]) -> int:\n        for x in range(1, len(nums) + 1):\n            cnt = sum(v >= x for v in nums)\n            if cnt == x:\n                return x\n        return -1\n", "class Solution:\n  def specialArray(self, nums: list[int]) -> int:\n    nums.sort()\n\n    if nums[0] >= len(nums):\n      return len(nums)\n\n    for i, (a, b) in enumerate(itertools.pairwise(nums)):\n      count = len(nums) - i - 1\n      if a < count and b >= count:\n        return count\n\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1660, "slug": "correct-a-binary-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def correctBinaryTree(self, root: TreeNode) -> TreeNode:\n        def dfs(root):\n            if root is None or root.right in vis:\n                return None\n            vis.add(root)\n            root.right = dfs(root.right)\n            root.left = dfs(root.left)\n            return root\n\n        vis = set()\n        return dfs(root)\n", "class Solution:\n  def __init__(self):\n    self.seen = set()\n\n  def correctBinaryTree(self, root: TreeNode | None) -> TreeNode | None:\n    if root == None:\n      return None\n    if root.right and root.right.val in self.seen:\n      return None\n    self.seen.add(root.val)\n    root.right = self.correctBinaryTree(root.right)\n    root.left = self.correctBinaryTree(root.left)\n    return root\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1666, "slug": "change-the-root-of-a-binary-tree", "solutions": ["\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n        self.parent = None\n\"\"\"\n\n\nclass Solution:\n    def flipBinaryTree(self, root: \"Node\", leaf: \"Node\") -> \"Node\":\n        cur = leaf\n        p = cur.parent\n        while cur != root:\n            gp = p.parent\n            if cur.left:\n                cur.right = cur.left\n            cur.left = p\n            p.parent = cur\n            if p.left == cur:\n                p.left = None\n            elif p.right == cur:\n                p.right = None\n            cur = p\n            p = gp\n        leaf.parent = None\n        return leaf\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1606, "slug": "find-servers-that-handled-most-number-of-requests", "solutions": ["class Solution:\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\n        free = SortedList(range(k))\n        busy = []\n        cnt = [0] * k\n        for i, (start, t) in enumerate(zip(arrival, load)):\n            while busy and busy[0][0] <= start:\n                free.add(busy[0][1])\n                heappop(busy)\n            if not free:\n                continue\n            j = free.bisect_left(i % k)\n            if j == len(free):\n                j = 0\n            server = free[j]\n            cnt[server] += 1\n            heappush(busy, (start + t, server))\n            free.remove(server)\n\n        mx = max(cnt)\n        return [i for i, v in enumerate(cnt) if v == mx]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1664, "slug": "ways-to-make-a-fair-array", "solutions": ["class Solution:\n    def waysToMakeFair(self, nums: List[int]) -> int:\n        s1, s2 = sum(nums[::2]), sum(nums[1::2])\n        ans = t1 = t2 = 0\n        for i, v in enumerate(nums):\n            ans += i % 2 == 0 and t2 + s1 - t1 - v == t1 + s2 - t2\n            ans += i % 2 == 1 and t2 + s1 - t1 == t1 + s2 - t2 - v\n            t1 += v if i % 2 == 0 else 0\n            t2 += v if i % 2 == 1 else 0\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1624, "slug": "largest-substring-between-two-equal-characters", "solutions": ["class Solution:\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\n        d = {}\n        ans = -1\n        for i, c in enumerate(s):\n            if c in d:\n                ans = max(ans, i - d[c] - 1)\n            else:\n                d[c] = i\n        return ans\n", "class Solution:\n  def maxLengthBetweenEqualCharacters(self, s: str) -> int:\n    ans = -1\n    lastSeen = {}\n\n    for i, c in enumerate(s):\n      if c not in lastSeen:\n        lastSeen[c] = i\n      else:\n        ans = max(ans, i - lastSeen[c] - 1)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1625, "slug": "lexicographically-smallest-string-after-applying-operations", "solutions": ["class Solution:\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\n        q = deque([s])\n        vis = {s}\n        ans = s\n        while q:\n            s = q.popleft()\n            if ans > s:\n                ans = s\n            t1 = ''.join(\n                [str((int(c) + a) % 10) if i & 1 else c for i, c in enumerate(s)]\n            )\n            t2 = s[-b:] + s[:-b]\n            for t in (t1, t2):\n                if t not in vis:\n                    vis.add(t)\n                    q.append(t)\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1644, "slug": "lowest-common-ancestor-of-a-binary-tree-ii", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\n\nclass Solution:\n    def lowestCommonAncestor(\n        self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode'\n    ) -> 'TreeNode':\n        def dfs(root, p, q):\n            if root is None:\n                return False\n            l = dfs(root.left, p, q)\n            r = dfs(root.right, p, q)\n            nonlocal ans\n            if l and r:\n                ans = root\n            if (l or r) and (root.val == p.val or root.val == q.val):\n                ans = root\n            return l or r or root.val == p.val or root.val == q.val\n\n        ans = None\n        dfs(root, p, q)\n        return ans\n", "class Solution:\n  def lowestCommonAncestor(\n      self,\n      root: 'TreeNode',\n      p: 'TreeNode',\n      q: 'TreeNode',\n  ) -> 'TreeNode':\n    def getLCA(root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n      if not root or root == p or root == q:\n        return root\n      left = getLCA(root.left, p, q)\n      right = getLCA(root.right, p, q)\n      if left and right:\n        return root\n      return left or right\n\n    ans = getLCA(root, p, q)\n    if ans == p:  # Search q in the subtree rooted at p.\n      return ans if getLCA(p, q, q) else None\n    if ans == q:  # Search p in the subtree rooted at q.\n      return ans if getLCA(q, p, p) else None\n    return ans  # (ans != p and ans != q) or ans is None\n", "class Solution:\n  def lowestCommonAncestor(\n      self,\n      root: 'TreeNode',\n      p: 'TreeNode',\n      q: 'TreeNode',\n  ) -> 'TreeNode':\n    seenP = False\n    seenQ = False\n\n    def getLCA(root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n      nonlocal seenP\n      nonlocal seenQ\n      if not root:\n        return None\n      # Need to traverse the entire tree to update `seenP` and `seenQ`.\n      left = getLCA(root.left, p, q)\n      right = getLCA(root.right, p, q)\n      if root == p:\n        seenP = True\n        return root\n      if root == q:\n        seenQ = True\n        return root\n      if left and right:\n        return root\n      return left or right\n\n    lca = getLCA(root, p, q)\n    return lca if seenP and seenQ else None\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1677, "slug": "products-worth-over-invoices", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1657, "slug": "determine-if-two-strings-are-close", "solutions": ["class Solution:\n    def closeStrings(self, word1: str, word2: str) -> bool:\n        cnt1, cnt2 = Counter(word1), Counter(word2)\n        return sorted(cnt1.values()) == sorted(cnt2.values()) and set(\n            cnt1.keys()\n        ) == set(cnt2.keys())\n", "class Solution:\n  def closeStrings(self, word1: str, word2: str) -> bool:\n    if len(word1) != len(word2):\n      return False\n\n    count1 = collections.Counter(word1)\n    count2 = collections.Counter(word2)\n    if count1.keys() != count2.keys():\n      return False\n\n    return sorted(count1.values()) == sorted(count2.values())\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1612, "slug": "check-if-two-expression-trees-are-equivalent", "solutions": ["# Definition for a binary tree node.\n# class Node(object):\n#     def __init__(self, val=\" \", left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def checkEquivalence(self, root1: 'Node', root2: 'Node') -> bool:\n        def dfs(root, v):\n            if root is None:\n                return\n            if root.val != '+':\n                cnt[root.val] += v\n            dfs(root.left, v)\n            dfs(root.right, v)\n\n        cnt = Counter()\n        dfs(root1, 1)\n        dfs(root2, -1)\n        return all(x == 0 for x in cnt.values())\n", "class Solution:\n  def checkEquivalence(self, root1: 'Node', root2: 'Node') -> bool:\n    count = collections.Counter()\n\n    def dfs(root: 'Node', add: int) -> None:\n      if not root:\n        return\n      if 'a' <= root.val <= 'z':\n        count[root.val] += add\n      dfs(root.left, add)\n      dfs(root.right, add)\n\n    dfs(root1, 1)\n    dfs(root2, -1)\n    return all(value == 0 for value in count.values())\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1678, "slug": "goal-parser-interpretation", "solutions": ["class Solution:\n    def interpret(self, command: str) -> str:\n        return command.replace('()', 'o').replace('(al)', 'al')\n", "class Solution:\n  def interpret(self, command: str) -> str:\n    return command.replace('()', 'o').replace('(al)', 'al')\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1632, "slug": "rank-transform-of-a-matrix", "solutions": ["class UnionFind:\n    def __init__(self, n):\n        self.p = list(range(n))\n        self.size = [1] * n\n\n    def find(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n\n    def union(self, a, b):\n        pa, pb = self.find(a), self.find(b)\n        if pa != pb:\n            if self.size[pa] > self.size[pb]:\n                self.p[pb] = pa\n                self.size[pa] += self.size[pb]\n            else:\n                self.p[pa] = pb\n                self.size[pb] += self.size[pa]\n\n    def reset(self, x):\n        self.p[x] = x\n        self.size[x] = 1\n\n\nclass Solution:\n    def matrixRankTransform(self, matrix: List[List[int]]) -> List[List[int]]:\n        m, n = len(matrix), len(matrix[0])\n        d = defaultdict(list)\n        for i, row in enumerate(matrix):\n            for j, v in enumerate(row):\n                d[v].append((i, j))\n        row_max = [0] * m\n        col_max = [0] * n\n        ans = [[0] * n for _ in range(m)]\n        uf = UnionFind(m + n)\n        for v in sorted(d):\n            rank = defaultdict(int)\n            for i, j in d[v]:\n                uf.union(i, j + m)\n            for i, j in d[v]:\n                rank[uf.find(i)] = max(rank[uf.find(i)], row_max[i], col_max[j])\n            for i, j in d[v]:\n                ans[i][j] = row_max[i] = col_max[j] = 1 + rank[uf.find(i)]\n            for i, j in d[v]:\n                uf.reset(i)\n                uf.reset(j + m)\n        return ans\n", "class UnionFind:\n  def __init__(self):\n    self.id = {}\n\n  def union(self, u: int, v: int) -> None:\n    self.id.setdefault(u, u)\n    self.id.setdefault(v, v)\n    i = self._find(u)\n    j = self._find(v)\n    if i != j:\n      self.id[i] = j\n\n  def getGroupIdToValues(self) -> dict[int, list[int]]:\n    groupIdToValues = collections.defaultdict(list)\n    for u in self.id.keys():\n      groupIdToValues[self._find(u)].append(u)\n    return groupIdToValues\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def matrixRankTransform(self, matrix: list[list[int]]) -> list[list[int]]:\n    m = len(matrix)\n    n = len(matrix[0])\n    ans = [[0] * n for _ in range(m)]\n    # {val: [(i, j)]}\n    valToGrids = collections.defaultdict(list)\n    # rank[i] := the maximum rank of the row or column so far\n    maxRankSoFar = [0] * (m + n)\n\n    for i, row in enumerate(matrix):\n      for j, val in enumerate(row):\n        valToGrids[val].append((i, j))\n\n    for _, grids in sorted(valToGrids.items()):\n      uf = UnionFind()\n      for i, j in grids:\n        # Union i-th row with j-th col.\n        uf.union(i, j + m)\n      for values in uf.getGroupIdToValues().values():\n        # Get the maximum rank of all the included rows and columns.\n        maxRank = max(maxRankSoFar[i] for i in values)\n        for i in values:\n          # Update all the rows and columns to maxRank + 1.\n          maxRankSoFar[i] = maxRank + 1\n      for i, j in grids:\n        ans[i][j] = maxRankSoFar[i]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1671, "slug": "minimum-number-of-removals-to-make-mountain-array", "solutions": ["class Solution:\n    def minimumMountainRemovals(self, nums: List[int]) -> int:\n        n = len(nums)\n        left = [1] * n\n        right = [1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    left[i] = max(left[i], left[j] + 1)\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 1, n):\n                if nums[i] > nums[j]:\n                    right[i] = max(right[i], right[j] + 1)\n        return n - max(a + b - 1 for a, b in zip(left, right) if a > 1 and b > 1)\n", "class Solution:\n  def minimumMountainRemovals(self, nums: list[int]) -> int:\n    left = self._lengthOfLIS(nums)\n    right = self._lengthOfLIS(nums[::-1])[::-1]\n    maxMountainSeq = 0\n\n    for l, r in zip(left, right):\n      if l > 1 and r > 1:\n        maxMountainSeq = max(maxMountainSeq, l + r - 1)\n\n    return len(nums) - maxMountainSeq\n\n  # Similar to 300. Longest Increasing Subsequence\n  def _lengthOfLIS(self, nums: list[int]) -> list[int]:\n    # tails[i] := the minimum tail of all the increasing subsequences having\n    # length i + 1\n    tails = []\n    # dp[i] := the length of LIS ending in nums[i]\n    dp = []\n    for num in nums:\n      if not tails or num > tails[-1]:\n        tails.append(num)\n      else:\n        tails[bisect.bisect_left(tails, num)] = num\n      dp.append(len(tails))\n    return dp\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1669, "slug": "merge-in-between-linked-lists", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeInBetween(\n        self, list1: ListNode, a: int, b: int, list2: ListNode\n    ) -> ListNode:\n        p = q = list1\n        for _ in range(a - 1):\n            p = p.next\n        for _ in range(b):\n            q = q.next\n        p.next = list2\n        while p.next:\n            p = p.next\n        p.next = q.next\n        q.next = None\n        return list1\n", "class Solution:\n  def mergeInBetween(\n      self,\n      list1: ListNode,\n      a: int,\n      b: int,\n      list2: ListNode,\n  ) -> ListNode:\n    nodeBeforeA = list1\n    for i in range(a - 1):\n      nodeBeforeA = nodeBeforeA.next\n\n    nodeB = nodeBeforeA.next\n    for i in range(b - a):\n      nodeB = nodeB.next\n\n    nodeBeforeA.next = list2\n    lastNodeInList2 = list2\n\n    while lastNodeInList2.next:\n      lastNodeInList2 = lastNodeInList2.next\n\n    lastNodeInList2.next = nodeB.next\n    nodeB.next = None\n    return list1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1687, "slug": "delivering-boxes-from-storage-to-ports", "solutions": ["class Solution:\n    def boxDelivering(\n        self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int\n    ) -> int:\n        n = len(boxes)\n        ws = list(accumulate((box[1] for box in boxes), initial=0))\n        c = [int(a != b) for a, b in pairwise(box[0] for box in boxes)]\n        cs = list(accumulate(c, initial=0))\n        f = [0] * (n + 1)\n        q = deque([0])\n        for i in range(1, n + 1):\n            while q and (i - q[0] > maxBoxes or ws[i] - ws[q[0]] > maxWeight):\n                q.popleft()\n            if q:\n                f[i] = cs[i - 1] + f[q[0]] - cs[q[0]] + 2\n            if i < n:\n                while q and f[q[-1]] - cs[q[-1]] >= f[i] - cs[i]:\n                    q.pop()\n                q.append(i)\n        return f[n]\n", "class Solution:\n  def boxDelivering(\n      self,\n      boxes: list[list[int]],\n      portsCount: int,\n      maxBoxes: int,\n      maxWeight: int,\n  ) -> int:\n    n = len(boxes)\n    # dp[i] := the minimum trips to deliver boxes[0..i) and return to the\n    # storage\n    dp = [0] * (n + 1)\n    trips = 2\n    weight = 0\n\n    l = 0\n    for r in range(n):\n      weight += boxes[r][1]\n\n      # The current box is different from the previous one, need to make one\n      # more trip.\n      if r > 0 and boxes[r][0] != boxes[r - 1][0]:\n        trips += 1\n\n      # Loading boxes[l] in the previous turn is always no bad than loading it\n      # in this turn\n      while r - l + 1 > maxBoxes or weight > maxWeight or (\n              l < r and dp[l + 1] == dp[l]):\n        weight -= boxes[l][1]\n        if boxes[l][0] != boxes[l + 1][0]:\n          trips -= 1\n        l += 1\n\n      #   min trips to deliver boxes[0..r]\n      # = min trips to deliver boxes[0..l) + trips to deliver boxes[l..r]\n      dp[r + 1] = dp[l] + trips\n\n    return dp[n]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1637, "slug": "widest-vertical-area-between-two-points-containing-no-points", "solutions": ["class Solution:\n    def maxWidthOfVerticalArea(self, points: List[List[int]]) -> int:\n        points.sort()\n        return max(b[0] - a[0] for a, b in pairwise(points))\n", "class Solution:\n  def maxWidthOfVerticalArea(self, points: list[list[int]]) -> int:\n    xs = sorted([x for x, _ in points])\n    return max(b - a for a, b in itertools.pairwise(xs))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1650, "slug": "lowest-common-ancestor-of-a-binary-tree-iii", "solutions": ["\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n        self.parent = None\n\"\"\"\n\n\nclass Solution:\n    def lowestCommonAncestor(self, p: \"Node\", q: \"Node\") -> \"Node\":\n        vis = set()\n        node = p\n        while node:\n            vis.add(node)\n            node = node.parent\n        node = q\n        while node not in vis:\n            node = node.parent\n        return node\n", "class Solution:\n  # Same as 160. Intersection of Two Linked Lists\n  def lowestCommonAncestor(self, p: 'Node', q: 'Node') -> 'Node':\n    a = p\n    b = q\n\n    while a != b:\n      a = a.parent if a else q\n      b = b.parent if b else p\n\n    return a\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1613, "slug": "find-the-missing-ids", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1626, "slug": "best-team-with-no-conflicts", "solutions": ["class Solution:\n    def bestTeamScore(self, scores: List[int], ages: List[int]) -> int:\n        arr = sorted(zip(scores, ages))\n        n = len(arr)\n        f = [0] * n\n        for i, (score, age) in enumerate(arr):\n            for j in range(i):\n                if age >= arr[j][1]:\n                    f[i] = max(f[i], f[j])\n            f[i] += score\n        return max(f)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1627, "slug": "graph-connectivity-with-threshold", "solutions": ["class UnionFind:\n    def __init__(self, n):\n        self.p = list(range(n))\n        self.size = [1] * n\n\n    def find(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n\n    def union(self, a, b):\n        pa, pb = self.find(a), self.find(b)\n        if pa == pb:\n            return False\n        if self.size[pa] > self.size[pb]:\n            self.p[pb] = pa\n            self.size[pa] += self.size[pb]\n        else:\n            self.p[pa] = pb\n            self.size[pb] += self.size[pa]\n        return True\n\n\nclass Solution:\n    def areConnected(\n        self, n: int, threshold: int, queries: List[List[int]]\n    ) -> List[bool]:\n        uf = UnionFind(n + 1)\n        for a in range(threshold + 1, n + 1):\n            for b in range(a + a, n + 1, a):\n                uf.union(a, b)\n        return [uf.find(a) == uf.find(b) for a, b in queries]\n", "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def areConnected(\n      self,\n      n: int,\n      threshold: int,\n      queries: list[list[int]],\n  ) -> list[bool]:\n    uf = UnionFind(n + 1)\n\n    for z in range(threshold + 1, n + 1):\n      for x in range(z * 2, n + 1, z):\n        uf.unionByRank(z, x)\n\n    return [uf.find(a) == uf.find(b) for a, b in queries]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1634, "slug": "add-two-polynomials-represented-as-linked-lists", "solutions": ["# Definition for polynomial singly-linked list.\n# class PolyNode:\n#     def __init__(self, x=0, y=0, next=None):\n#         self.coefficient = x\n#         self.power = y\n#         self.next = next\n\n\nclass Solution:\n    def addPoly(self, poly1: \"PolyNode\", poly2: \"PolyNode\") -> \"PolyNode\":\n        dummy = curr = PolyNode()\n        while poly1 and poly2:\n            if poly1.power > poly2.power:\n                curr.next = poly1\n                poly1 = poly1.next\n                curr = curr.next\n            elif poly1.power < poly2.power:\n                curr.next = poly2\n                poly2 = poly2.next\n                curr = curr.next\n            else:\n                if c := poly1.coefficient + poly2.coefficient:\n                    curr.next = PolyNode(c, poly1.power)\n                    curr = curr.next\n                poly1 = poly1.next\n                poly2 = poly2.next\n        curr.next = poly1 or poly2\n        return dummy.next\n", "# Definition for polynomial singly-linked list.\n# class PolyNode:\n#   def __init__(self, x=0, y=0, next=None):\n#     self.coefficient = x\n#     self.power = y\n#     self.next = next\n\nclass Solution:\n  def addPoly(self, poly1: 'PolyNode', poly2: 'PolyNode') -> 'PolyNode':\n    dummy = PolyNode()\n    curr = dummy\n    p = poly1  # poly1's pointer\n    q = poly2  # poly2's pointer\n\n    while p and q:\n      if p.power > q.power:\n        curr.next = PolyNode(p.coefficient, p.power)\n        curr = curr.next\n        p = p.next\n      elif p.power < q.power:\n        curr.next = PolyNode(q.coefficient, q.power)\n        curr = curr.next\n        q = q.next\n      else:  # p.power == q.power\n        sumCoefficient = p.coefficient + q.coefficient\n        if sumCoefficient != 0:\n          curr.next = PolyNode(sumCoefficient, p.power)\n          curr = curr.next\n        p = p.next\n        q = q.next\n\n    while p:\n      curr.next = PolyNode(p.coefficient, p.power)\n      curr = curr.next\n      p = p.next\n\n    while q:\n      curr.next = PolyNode(q.coefficient, q.power)\n      curr = curr.next\n      q = q.next\n\n    return dummy.next\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1661, "slug": "average-time-of-process-per-machine", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1628, "slug": "design-an-expression-tree-with-evaluate-function", "solutions": ["import abc\nfrom abc import ABC, abstractmethod\n\n\"\"\"\nThis is the interface for the expression tree Node.\nYou should not remove it, and you can define some classes to implement it.\n\"\"\"\n\n\nclass Node(ABC):\n    @abstractmethod\n    # define your fields here\n    def evaluate(self) -> int:\n        pass\n\n\nclass MyNode(Node):\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\n    def evaluate(self) -> int:\n        x = self.val\n        if x.isdigit():\n            return int(x)\n\n        left, right = self.left.evaluate(), self.right.evaluate()\n        if x == '+':\n            return left + right\n        if x == '-':\n            return left - right\n        if x == '*':\n            return left * right\n        if x == '/':\n            return left // right\n\n\n\"\"\"\nThis is the TreeBuilder class.\nYou can treat it as the driver code that takes the postinfix input\nand returns the expression tree represnting it as a Node.\n\"\"\"\n\n\nclass TreeBuilder(object):\n    def buildTree(self, postfix: List[str]) -> 'Node':\n        stk = []\n        for s in postfix:\n            node = MyNode(s)\n            if not s.isdigit():\n                node.right = stk.pop()\n                node.left = stk.pop()\n            stk.append(node)\n        return stk[-1]\n\n\n\"\"\"\nYour TreeBuilder object will be instantiated and called as such:\nobj = TreeBuilder();\nexpTree = obj.buildTree(postfix);\nans = expTree.evaluate();\n\"\"\"\n", "from abc import ABC, abstractmethod\n\n\"\"\"\nThis is the interface for the expression tree Node.\nYou should not remove it, and you can define some classes to implement it.\n\"\"\"\n\n\nclass Node(ABC):\n  @abstractmethod\n  # define your fields here\n  def evaluate(self) -> int:\n    pass\n\n\nclass ExpNode(Node):\n  op = {\n      '+': lambda a, b: a + b,\n      '-': lambda a, b: a - b,\n      '*': lambda a, b: a * b,\n      '/': lambda a, b: int(a / b),\n  }\n\n  def __init__(\n      self,\n      val: str,\n      left: Optional['ExpNode'],\n      right: Optional['ExpNode'],\n  ):\n    self.val = val\n    self.left = left\n    self.right = right\n\n  def evaluate(self) -> int:\n    if not self.left and not self.right:\n      return int(self.val)\n    return ExpNode.op[self.val](self.left.evaluate(), self.right.evaluate())\n\n\n\"\"\"\nThis is the TreeBuilder class.\nYou can treat it as the driver code that takes the postinfix input\nand returns the expression tree represnting it as a Node.\n\"\"\"\n\n\nclass TreeBuilder(object):\n  def buildTree(self, postfix: list[str]) -> 'Node':\n    stack: list[ExpNode | None] = []\n\n    for val in postfix:\n      if val in '+-*/':\n        right = stack.pop()\n        left = stack.pop()\n        stack.append(ExpNode(val, left, right))\n      else:\n        stack.append(ExpNode(val, None, None))\n\n    return stack.pop()\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1665, "slug": "minimum-initial-energy-to-finish-tasks", "solutions": ["class Solution:\n    def minimumEffort(self, tasks: List[List[int]]) -> int:\n        ans = cur = 0\n        for a, m in sorted(tasks, key=lambda x: x[0] - x[1]):\n            if cur < m:\n                ans += m - cur\n                cur = m\n            cur -= a\n        return ans\n", "class Solution:\n  def minimumEffort(self, tasks: list[list[int]]) -> int:\n    ans = 0\n    prevSaved = 0\n\n    for actual, minimum in sorted(tasks, key=lambda x: x[0] - x[1]):\n      if prevSaved < minimum:\n        ans += minimum - prevSaved\n        prevSaved = minimum - actual\n      else:\n        prevSaved -= actual\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1690, "slug": "stone-game-vii", "solutions": ["class Solution:\n    def stoneGameVII(self, stones: List[int]) -> int:\n        @cache\n        def dfs(i: int, j: int) -> int:\n            if i > j:\n                return 0\n            a = s[j + 1] - s[i + 1] - dfs(i + 1, j)\n            b = s[j] - s[i] - dfs(i, j - 1)\n            return max(a, b)\n\n        s = list(accumulate(stones, initial=0))\n        ans = dfs(0, len(stones) - 1)\n        dfs.cache_clear()\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1643, "slug": "kth-smallest-instructions", "solutions": ["class Solution:\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\n        v, h = destination\n        ans = []\n        for _ in range(h + v):\n            if h == 0:\n                ans.append(\"V\")\n            else:\n                x = comb(h + v - 1, h - 1)\n                if k > x:\n                    ans.append(\"V\")\n                    v -= 1\n                    k -= x\n                else:\n                    ans.append(\"H\")\n                    h -= 1\n        return \"\".join(ans)\n", "class Solution:\n  def kthSmallestPath(self, destination: list[int], k: int) -> str:\n    ans = []\n    v, h = destination\n\n    for _ in range(h + v):\n      # If pick 'H', then we're able to reack 1, 2, ..., availableRank.\n      availableRank = math.comb(h + v - 1, v)\n      if availableRank >= k:  # Should pick 'H'.\n        ans.append('H')\n        h -= 1\n      else:  # Should pick 'V'.\n        k -= availableRank\n        ans.append('V')\n        v -= 1\n\n    return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1641, "slug": "count-sorted-vowel-strings", "solutions": ["class Solution:\n    def countVowelStrings(self, n: int) -> int:\n        @cache\n        def dfs(i, j):\n            return 1 if i >= n else sum(dfs(i + 1, k) for k in range(j, 5))\n\n        return dfs(0, 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1623, "slug": "all-valid-triplets-that-can-represent-a-country", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1694, "slug": "reformat-phone-number", "solutions": ["class Solution:\n    def reformatNumber(self, number: str) -> str:\n        number = number.replace(\"-\", \"\").replace(\" \", \"\")\n        n = len(number)\n        ans = [number[i * 3 : i * 3 + 3] for i in range(n // 3)]\n        if n % 3 == 1:\n            ans[-1] = ans[-1][:2]\n            ans.append(number[-2:])\n        elif n % 3 == 2:\n            ans.append(number[-2:])\n        return \"-\".join(ans)\n", "class Solution:\n  def reformatNumber(self, number: str) -> str:\n    ans = []\n\n    number = number.replace(\"-\", \"\").replace(\" \", \"\")\n\n    i = 0  # number's index\n    while i + 4 < len(number):\n      ans.append(number[i:i + 3] + '-')\n      i += 3\n\n    countFinalDigits = len(number) - i\n    if countFinalDigits < 4:\n      ans.append(number[i:])\n    else:  # countFinalDigits == 4\n      ans.append(number[i:i + 2] + '-' + number[i + 2:])\n\n    return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1670, "slug": "design-front-middle-back-queue", "solutions": ["class FrontMiddleBackQueue:\n    def __init__(self):\n        self.q1 = deque()\n        self.q2 = deque()\n\n    def pushFront(self, val: int) -> None:\n        self.q1.appendleft(val)\n        self.rebalance()\n\n    def pushMiddle(self, val: int) -> None:\n        self.q1.append(val)\n        self.rebalance()\n\n    def pushBack(self, val: int) -> None:\n        self.q2.append(val)\n        self.rebalance()\n\n    def popFront(self) -> int:\n        if not self.q1 and not self.q2:\n            return -1\n        if self.q1:\n            val = self.q1.popleft()\n        else:\n            val = self.q2.popleft()\n        self.rebalance()\n        return val\n\n    def popMiddle(self) -> int:\n        if not self.q1 and not self.q2:\n            return -1\n        if len(self.q1) == len(self.q2):\n            val = self.q1.pop()\n        else:\n            val = self.q2.popleft()\n        self.rebalance()\n        return val\n\n    def popBack(self) -> int:\n        if not self.q2:\n            return -1\n        val = self.q2.pop()\n        self.rebalance()\n        return val\n\n    def rebalance(self):\n        if len(self.q1) > len(self.q2):\n            self.q2.appendleft(self.q1.pop())\n        if len(self.q2) > len(self.q1) + 1:\n            self.q1.append(self.q2.popleft())\n\n\n# Your FrontMiddleBackQueue object will be instantiated and called as such:\n# obj = FrontMiddleBackQueue()\n# obj.pushFront(val)\n# obj.pushMiddle(val)\n# obj.pushBack(val)\n# param_4 = obj.popFront()\n# param_5 = obj.popMiddle()\n# param_6 = obj.popBack()\n", "class FrontMiddleBackQueue:\n  def __init__(self):\n    self.frontQueue = collections.deque()\n    self.backQueue = collections.deque()\n\n  def pushFront(self, val: int) -> None:\n    self.frontQueue.appendleft(val)\n    self._moveFrontToBackIfNeeded()\n\n  def pushMiddle(self, val: int) -> None:\n    if len(self.frontQueue) == len(self.backQueue):\n      self.backQueue.appendleft(val)\n    else:\n      self.frontQueue.append(val)\n\n  def pushBack(self, val: int) -> None:\n    self.backQueue.append(val)\n    self._moveBackToFrontIfNeeded()\n\n  def popFront(self) -> int:\n    if self.frontQueue:\n      x = self.frontQueue.popleft()\n      self._moveBackToFrontIfNeeded()\n      return x\n    if self.backQueue:\n      return self.backQueue.popleft()\n    return -1\n\n  def popMiddle(self) -> int:\n    if not self.frontQueue and not self.backQueue:\n      return -1\n    if len(self.frontQueue) + 1 == len(self.backQueue):\n      return self.backQueue.popleft()\n    return self.frontQueue.pop()\n\n  def popBack(self) -> int:\n    if self.backQueue:\n      x = self.backQueue.pop()\n      self._moveFrontToBackIfNeeded()\n      return x\n    return -1\n\n  def _moveFrontToBackIfNeeded(self) -> None:\n    if len(self.frontQueue) - 1 == len(self.backQueue):\n      self.backQueue.appendleft(self.frontQueue.pop())\n\n  def _moveBackToFrontIfNeeded(self) -> None:\n    if len(self.frontQueue) + 2 == len(self.backQueue):\n      self.frontQueue.append(self.backQueue.popleft())\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1673, "slug": "find-the-most-competitive-subsequence", "solutions": ["class Solution:\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\n        stk = []\n        n = len(nums)\n        for i, v in enumerate(nums):\n            while stk and stk[-1] > v and len(stk) + n - i > k:\n                stk.pop()\n            if len(stk) < k:\n                stk.append(v)\n        return stk\n", "class Solution:\n  def mostCompetitive(self, nums: list[int], k: int) -> list[int]:\n    ans = []\n\n    for i, num in enumerate(nums):\n      # If |ans| - 1 + |nums[i..n)| >= k, then it means we still have enough\n      # numbers, and we can safely pop an element from ans.\n      while ans and ans[-1] > nums[i] and len(ans) - 1 + len(nums) - i >= k:\n        ans.pop()\n      if len(ans) < k:\n        ans.append(nums[i])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1682, "slug": "longest-palindromic-subsequence-ii", "solutions": ["class Solution:\n    def longestPalindromeSubseq(self, s: str) -> int:\n        @cache\n        def dfs(i, j, x):\n            if i >= j:\n                return 0\n            if s[i] == s[j] and s[i] != x:\n                return dfs(i + 1, j - 1, s[i]) + 2\n            return max(dfs(i + 1, j, x), dfs(i, j - 1, x))\n\n        ans = dfs(0, len(s) - 1, '')\n        dfs.cache_clear()\n        return ans\n", "class Solution:\n  def longestPalindromeSubseq(self, s: str) -> int:\n    n = len(s)\n    # dp[i][j][k] := the length of LPS(s[i..j]), where the previous letter is\n    # ('a' + k).\n    dp = [[[0] * 27 for _ in range(n)] for _ in range(n)]\n\n    for d in range(1, n):\n      for i in range(n - d):\n        for k in range(27):\n          j = i + d\n          if s[i] == s[j] and s[i] != chr(ord('a') + k):\n            dp[i][j][k] = dp[i + 1][j - 1][ord(s[i]) - ord('a')] + 2\n          else:\n            dp[i][j][k] = max(dp[i + 1][j][k], dp[i][j - 1][k])\n\n    return dp[0][n - 1][26]\n", "class Solution:\n  def longestPalindromeSubseq(self, s: str) -> int:\n    n = len(s)\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, k: int) -> int:\n      \"\"\"\n      Returns the length of LPS(s[i..j]), where the previous letter is\n      ('a' + k).\n      \"\"\"\n      if i >= j:\n        return 0\n      if s[i] == s[j] and s[i] != chr(ord('a') + k):\n        return dp(i + 1, j - 1, ord(s[i]) - ord('a')) + 2\n      return max(dp(i + 1, j, k), dp(i, j - 1, k))\n\n    return dp(0, n - 1, 26)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1619, "slug": "mean-of-array-after-removing-some-elements", "solutions": ["class Solution:\n    def trimMean(self, arr: List[int]) -> float:\n        n = len(arr)\n        start, end = int(n * 0.05), int(n * 0.95)\n        arr.sort()\n        t = arr[start:end]\n        return round(sum(t) / len(t), 5)\n", "class Solution:\n  def trimMean(self, arr: list[int]) -> float:\n    arr.sort()\n    offset = len(arr) // 20\n    return mean(arr[offset:-offset])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1646, "slug": "get-maximum-in-generated-array", "solutions": ["class Solution:\n    def getMaximumGenerated(self, n: int) -> int:\n        if n < 2:\n            return n\n        nums = [0] * (n + 1)\n        nums[1] = 1\n        for i in range(2, n + 1):\n            nums[i] = nums[i >> 1] if i % 2 == 0 else nums[i >> 1] + nums[(i >> 1) + 1]\n        return max(nums)\n", "class Solution:\n  def getMaximumGenerated(self, n: int) -> int:\n    if n == 0:\n      return 0\n    if n == 1:\n      return 1\n\n    nums = [0] * (n + 1)\n    nums[1] = 1\n\n    i = 1\n    while 2 * i + 1 <= n:\n      nums[2 * i] = nums[i]\n      nums[2 * i + 1] = nums[i] + nums[i + 1]\n      i += 1\n\n    return max(nums)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1675, "slug": "minimize-deviation-in-array", "solutions": ["class Solution:\n    def minimumDeviation(self, nums: List[int]) -> int:\n        h = []\n        mi = inf\n        for v in nums:\n            if v & 1:\n                v <<= 1\n            h.append(-v)\n            mi = min(mi, v)\n        heapify(h)\n        ans = -h[0] - mi\n        while h[0] % 2 == 0:\n            x = heappop(h) // 2\n            heappush(h, x)\n            mi = min(mi, -x)\n            ans = min(ans, -h[0] - mi)\n        return ans\n", "class Solution:\n  def minimumDeviation(self, nums: list[int]) -> int:\n    ans = math.inf\n    mn = math.inf\n    maxHeap = []\n\n    for num in nums:\n      evenNum = num if num % 2 == 0 else num * 2\n      heapq.heappush(maxHeap, -evenNum)\n      mn = min(mn, evenNum)\n\n    while maxHeap[0] % 2 == 0:\n      mx = -heapq.heappop(maxHeap)\n      ans = min(ans, mx - mn)\n      mn = min(mn, mx // 2)\n      heapq.heappush(maxHeap, -mx // 2)\n\n    return min(ans, -maxHeap[0] - mn)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1697, "slug": "checking-existence-of-edge-length-limited-paths", "solutions": ["class Solution:\n    def distanceLimitedPathsExist(\n        self, n: int, edgeList: List[List[int]], queries: List[List[int]]\n    ) -> List[bool]:\n        def find(x):\n            if p[x] != x:\n                p[x] = find(p[x])\n            return p[x]\n\n        p = list(range(n))\n        edgeList.sort(key=lambda x: x[2])\n        j = 0\n        ans = [False] * len(queries)\n        for i, (a, b, limit) in sorted(enumerate(queries), key=lambda x: x[1][2]):\n            while j < len(edgeList) and edgeList[j][2] < limit:\n                u, v, _ = edgeList[j]\n                p[find(u)] = find(v)\n                j += 1\n            ans[i] = find(a) == find(b)\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2493, "slug": "divide-nodes-into-the-maximum-number-of-groups", "solutions": ["class Solution:\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\n        g = [[] for _ in range(n)]\n        for a, b in edges:\n            g[a - 1].append(b - 1)\n            g[b - 1].append(a - 1)\n        d = defaultdict(int)\n        for i in range(n):\n            q = deque([i])\n            dist = [0] * n\n            dist[i] = mx = 1\n            root = i\n            while q:\n                a = q.popleft()\n                root = min(root, a)\n                for b in g[a]:\n                    if dist[b] == 0:\n                        dist[b] = dist[a] + 1\n                        mx = max(mx, dist[b])\n                        q.append(b)\n                    elif abs(dist[b] - dist[a]) != 1:\n                        return -1\n            d[root] = max(d[root], mx)\n        return sum(d.values())\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2431, "slug": "maximize-total-tastiness-of-purchased-fruits", "solutions": ["class Solution:\n    def maxTastiness(\n        self, price: List[int], tastiness: List[int], maxAmount: int, maxCoupons: int\n    ) -> int:\n        @cache\n        def dfs(i, j, k):\n            if i == len(price):\n                return 0\n            ans = dfs(i + 1, j, k)\n            if j >= price[i]:\n                ans = max(ans, dfs(i + 1, j - price[i], k) + tastiness[i])\n            if j >= price[i] // 2 and k:\n                ans = max(ans, dfs(i + 1, j - price[i] // 2, k - 1) + tastiness[i])\n            return ans\n\n        return dfs(0, maxAmount, maxCoupons)\n", "class Solution:\n  def maxTastiness(\n      self,\n      price: list[int],\n      tastiness: list[int],\n      maxAmount: int,\n      maxCoupons: int,\n  ) -> int:\n    # dp[j][k] := the maximum tastiness of price so far with j amount of money and k coupons\n    dp = [[0] * (maxCoupons + 1) for _ in range(maxAmount + 1)]\n\n    for p, t in zip(price, tastiness):\n      for j in range(maxAmount, p // 2 - 1, -1):\n        for k in range(maxCoupons, -1, -1):\n          buyWithCoupon = 0 if k == 0 else dp[j - p // 2][k - 1] + t\n          buyWithoutCoupon = 0 if j < p else dp[j - p][k] + t\n          dp[j][k] = max(dp[j][k], buyWithCoupon, buyWithoutCoupon)\n\n    return dp[maxAmount][maxCoupons]\n", "class Solution:\n  def maxTastiness(\n      self,\n      price: list[int],\n      tastiness: list[int],\n      maxAmount: int,\n      maxCoupons: int,\n  ) -> int:\n    n = len(price)\n    # dp[i][j][k] := the maximum tastiness of the first i price with j amount of\n    # money and k coupons\n    dp = [[[0] * (maxCoupons + 1)\n           for j in range(maxAmount + 1)]\n          for i in range(n + 1)]\n\n    for i in range(1, n + 1):\n      # 1-indexed\n      currPrice = price[i - 1]\n      currTastiness = tastiness[i - 1]\n      for amount in range(maxAmount + 1):\n        for coupon in range(maxCoupons + 1):\n          # 1. Don't buy, the tastiness will be the same as the first i - 1\n          # price.\n          dp[i][amount][coupon] = dp[i - 1][amount][coupon]\n\n          # 2. Buy without coupon if have enough money.\n          if amount >= currPrice:\n            dp[i][amount][coupon] = max(\n                dp[i][amount][coupon],\n                dp[i - 1][amount - currPrice][coupon] + currTastiness)\n\n          # 3. Buy with coupon if have coupon and enough money.\n          if coupon > 0 and amount >= currPrice // 2:\n            dp[i][amount][coupon] = max(\n                dp[i][amount][coupon],\n                dp[i - 1][amount - currPrice // 2][coupon - 1] + currTastiness)\n\n    return dp[n][maxAmount][maxCoupons]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2419, "slug": "longest-subarray-with-maximum-bitwise-and", "solutions": ["class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        mx = max(nums)\n        ans = cnt = 0\n        for x in nums:\n            if x == mx:\n                cnt += 1\n                ans = max(ans, cnt)\n            else:\n                cnt = 0\n        return ans\n", "class Solution:\n  def longestSubarray(self, nums: list[int]) -> int:\n    ans = 0\n    maxIndex = 0\n    sameNumLength = 0\n\n    for i, num in enumerate(nums):\n      if nums[i] == nums[maxIndex]:\n        sameNumLength += 1\n        ans = max(ans, sameNumLength)\n      elif nums[i] > nums[maxIndex]:\n        maxIndex = i\n        sameNumLength = 1\n        ans = 1\n      else:\n        sameNumLength = 0\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2480, "slug": "form-a-chemical-bond", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2410, "slug": "maximum-matching-of-players-with-trainers", "solutions": ["class Solution:\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\n        players.sort()\n        trainers.sort()\n        j, n = 0, len(trainers)\n        for i, p in enumerate(players):\n            while j < n and trainers[j] < p:\n                j += 1\n            if j == n:\n                return i\n            j += 1\n        return len(players)\n", "class Solution:\n  def matchPlayersAndTrainers(\n      self,\n      players: list[int],\n      trainers: list[int],\n  ) -> int:\n    ans = 0\n\n    players.sort()\n    trainers.sort()\n\n    for i, trainer in enumerate(trainers):\n      if players[ans] <= trainer:\n        ans += 1\n        if ans == len(players):\n          return ans\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2441, "slug": "largest-positive-integer-that-exists-with-its-negative", "solutions": ["class Solution:\n    def findMaxK(self, nums: List[int]) -> int:\n        s = set(nums)\n        return max((x for x in s if -x in s), default=-1)\n", "class Solution:\n  def findMaxK(self, nums: list[int]) -> int:\n    ans = -1\n    seen = set()\n\n    for num in nums:\n      if -num in seen:\n        ans = max(ans, abs(num))\n      else:\n        seen.add(num)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2404, "slug": "most-frequent-even-element", "solutions": ["class Solution:\n    def mostFrequentEven(self, nums: List[int]) -> int:\n        cnt = Counter(x for x in nums if x % 2 == 0)\n        ans, mx = -1, 0\n        for x, v in cnt.items():\n            if v > mx or (v == mx and ans > x):\n                ans, mx = x, v\n        return ans\n", "class Solution:\n  def mostFrequentEven(self, nums: list[int]) -> int:\n    ans = -1\n    count = collections.Counter()\n\n    for num in nums:\n      if num % 2 == 1:\n        continue\n      count[num] += 1\n      newCount = count[num]\n      maxCount = count[ans]\n      if newCount > maxCount or newCount == maxCount and num < ans:\n        ans = num\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2496, "slug": "maximum-value-of-a-string-in-an-array", "solutions": ["class Solution:\n    def maximumValue(self, strs: List[str]) -> int:\n        def f(s: str) -> int:\n            return int(s) if all(c.isdigit() for c in s) else len(s)\n\n        return max(f(s) for s in strs)\n", "class Solution:\n  def maximumValue(self, strs: list[str]) -> int:\n    return max(len(s) if any(c.isalpha() for c in s) else int(s)\n               for s in strs)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2458, "slug": "height-of-binary-tree-after-subtree-removal-queries", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\n        def f(root):\n            if root is None:\n                return 0\n            l, r = f(root.left), f(root.right)\n            d[root] = 1 + max(l, r)\n            return d[root]\n\n        def dfs(root, depth, rest):\n            if root is None:\n                return\n            depth += 1\n            res[root.val] = rest\n            dfs(root.left, depth, max(rest, depth + d[root.right]))\n            dfs(root.right, depth, max(rest, depth + d[root.left]))\n\n        d = defaultdict(int)\n        f(root)\n        res = [0] * (len(d) + 1)\n        dfs(root, -1, 0)\n        return [res[v] for v in queries]\n", "class Solution:\n  def treeQueries(self, root: TreeNode | None, queries: list[int]) -> list[int]:\n    @lru_cache(None)\n    def height(root: TreeNode | None) -> int:\n      if not root:\n        return 0\n      return 1 + max(height(root.left), height(root.right))\n\n    # valToMaxHeight[val] := the maximum height without the node with `val`\n    valToMaxHeight = {}\n\n    # maxHeight := the maximum height without the current node `root`\n    def dfs(root: TreeNode | None, depth: int, maxHeight: int) -> None:\n      if not root:\n        return\n      valToMaxHeight[root.val] = maxHeight\n      dfs(root.left, depth + 1, max(maxHeight, depth + height(root.right)))\n      dfs(root.right, depth + 1, max(maxHeight, depth + height(root.left)))\n\n    dfs(root, 0, 0)\n    return [valToMaxHeight[query] for query in queries]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2495, "slug": "number-of-subarrays-having-even-product", "solutions": ["class Solution:\n    def evenProduct(self, nums: List[int]) -> int:\n        ans, last = 0, -1\n        for i, v in enumerate(nums):\n            if v % 2 == 0:\n                last = i\n            ans += last + 1\n        return ans\n", "class Solution:\n  def evenProduct(self, nums: list[int]) -> int:\n    ans = 0\n    numsBeforeEven = 0  # inclusively\n\n    # e.g. nums = [1, 0, 1, 1, 0].\n    # After meeting the first 0, set `numsBeforeEven` to 2. So, the number\n    # between index 1 to index 3 (the one before next 0) will contribute 2 to\n    # `ans`.\n    for i, num in enumerate(nums):\n      if num % 2 == 0:\n        numsBeforeEven = i + 1\n      ans += numsBeforeEven\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2403, "slug": "minimum-time-to-kill-all-monsters", "solutions": ["class Solution:\n    def minimumTime(self, power: List[int]) -> int:\n        @cache\n        def dfs(mask: int) -> int:\n            if mask == 0:\n                return 0\n            ans = inf\n            gain = 1 + (n - mask.bit_count())\n            for i, x in enumerate(power):\n                if mask >> i & 1:\n                    ans = min(ans, dfs(mask ^ (1 << i)) + (x + gain - 1) // gain)\n            return ans\n\n        n = len(power)\n        return dfs((1 << n) - 1)\n", "class Solution:\n  def minimumTime(self, power: list[int]) -> int:\n    n = len(power)\n    maxMask = 1 << n\n    # dp[i] := the minimum number of days needed to defeat the monsters, where\n    # i is the bitmask of the monsters\n    dp = [math.inf] * maxMask\n    dp[0] = 0\n\n    for mask in range(1, maxMask):\n      currentGain = mask.bit_count()\n      for i in range(n):\n        if mask >> i & 1:\n          dp[mask] = min(dp[mask], dp[mask & ~(1 << i)] +\n                         int(math.ceil(power[i] / currentGain)))\n\n    return dp[-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2478, "slug": "number-of-beautiful-partitions", "solutions": ["class Solution:\n    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\n        primes = '2357'\n        if s[0] not in primes or s[-1] in primes:\n            return 0\n        mod = 10**9 + 7\n        n = len(s)\n        f = [[0] * (k + 1) for _ in range(n + 1)]\n        g = [[0] * (k + 1) for _ in range(n + 1)]\n        f[0][0] = g[0][0] = 1\n        for i, c in enumerate(s, 1):\n            if i >= minLength and c not in primes and (i == n or s[i] in primes):\n                for j in range(1, k + 1):\n                    f[i][j] = g[i - minLength][j - 1]\n            for j in range(k + 1):\n                g[i][j] = (g[i - 1][j] + f[i][j]) % mod\n        return f[n][k]\n", "class Solution:\n  def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\n    def isPrime(c: str) -> bool:\n      return c in '2357'\n\n    if not isPrime(s[0]) or isPrime(s[-1]):\n      return 0\n\n    MOD = 1_000_000_007\n\n    @lru_cache(None)\n    def dp(i: int, k: int) -> int:\n      \"\"\"\n      Returns the number of beautiful partitions of s[i..n) with k bars (|)\n      left.\n      \"\"\"\n      if i <= len(s) and k == 0:\n        return 1\n      if i >= len(s):\n        return 0\n\n      # Don't split between s[i - 1] and s[i].\n      ans = dp(i + 1, k) % MOD\n\n      # Split between s[i - 1] and s[i].\n      if isPrime(s[i]) and not isPrime(s[i - 1]):\n        ans += dp(i + minLength, k - 1)\n\n      return ans % MOD\n\n    return dp(minLength, k - 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2490, "slug": "circular-sentence", "solutions": ["class Solution:\n    def isCircularSentence(self, sentence: str) -> bool:\n        ss = sentence.split()\n        n = len(ss)\n        return all(s[-1] == ss[(i + 1) % n][0] for i, s in enumerate(ss))\n", "class Solution:\n  def isCircularSentence(self, sentence: str) -> bool:\n    for i, c in enumerate(sentence):\n      if c == ' ' and sentence[i - 1] != sentence[i + 1]:\n        return False\n    return sentence[0] == sentence[-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2451, "slug": "odd-string-difference", "solutions": ["class Solution:\n    def oddString(self, words: List[str]) -> str:\n        d = defaultdict(list)\n        for s in words:\n            t = tuple(ord(b) - ord(a) for a, b in pairwise(s))\n            d[t].append(s)\n        return next(ss[0] for ss in d.values() if len(ss) == 1)\n", "class Solution:\n  def oddString(self, words: list[str]) -> str:\n    def getDiff(s: str) -> list[int]:\n      return [ord(b) - ord(a) for a, b in zip(s, s[1:])]\n\n    wordAndDiffTuples = [(word, tuple(getDiff(word))) for word in words]\n    diffTupleCount = collections.Counter()\n\n    for _, diffTuple in wordAndDiffTuples:\n      diffTupleCount[diffTuple] += 1\n\n    for word, diffTuple in wordAndDiffTuples:\n      if diffTupleCount[diffTuple] == 1:\n        return word\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2492, "slug": "minimum-score-of-a-path-between-two-cities", "solutions": ["class Solution:\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\n        def dfs(i):\n            nonlocal ans\n            for j, d in g[i]:\n                ans = min(ans, d)\n                if not vis[j]:\n                    vis[j] = True\n                    dfs(j)\n\n        g = defaultdict(list)\n        for a, b, d in roads:\n            g[a].append((b, d))\n            g[b].append((a, d))\n        vis = [False] * (n + 1)\n        ans = inf\n        dfs(1)\n        return ans\n", "class Solution:\n  def minScore(self, n: int, roads: list[list[int]]) -> int:\n    ans = math.inf\n    graph = [[] for _ in range(n + 1)]  # graph[u] := [(v, distance)]\n    q = collections.deque([1])\n    seen = {1}\n\n    for u, v, distance in roads:\n      graph[u].append((v, distance))\n      graph[v].append((u, distance))\n\n    while q:\n      u = q.popleft()\n      for v, d in graph[u]:\n        ans = min(ans, d)\n        if v in seen:\n          continue\n        q.append(v)\n        seen.add(v)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2446, "slug": "determine-if-two-events-have-conflict", "solutions": ["class Solution:\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\n        return not (event1[0] > event2[1] or event1[1] < event2[0])\n", ""], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2425, "slug": "bitwise-xor-of-all-pairings", "solutions": ["class Solution:\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\n        ans = 0\n        if len(nums2) & 1:\n            for v in nums1:\n                ans ^= v\n        if len(nums1) & 1:\n            for v in nums2:\n                ans ^= v\n        return ans\n", "class Solution:\n  def xorAllNums(self, nums1: list[int], nums2: list[int]) -> int:\n    xors1 = functools.reduce(operator.xor, nums1)\n    xors2 = functools.reduce(operator.xor, nums2)\n    # If the size of nums1 is m and the size of nums2 is n, then each number in\n    # nums1 is repeated n times and each number in nums2 is repeated m times.\n    return (len(nums1) % 2 * xors2) ^ (len(nums2) % 2 * xors1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2413, "slug": "smallest-even-multiple", "solutions": ["class Solution:\n    def smallestEvenMultiple(self, n: int) -> int:\n        return n if n % 2 == 0 else n * 2\n", "class Solution:\n  def smallestEvenMultiple(self, n: int) -> int:\n    return n * (n % 2 + 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2483, "slug": "minimum-penalty-for-a-shop", "solutions": ["class Solution:\n    def bestClosingTime(self, customers: str) -> int:\n        n = len(customers)\n        s = [0] * (n + 1)\n        for i, c in enumerate(customers):\n            s[i + 1] = s[i] + int(c == 'Y')\n        ans, cost = 0, inf\n        for j in range(n + 1):\n            t = j - s[j] + s[-1] - s[j]\n            if cost > t:\n                ans, cost = j, t\n        return ans\n", "class Solution:\n  def bestClosingTime(self, customers: str) -> int:\n    # Instead of computing the minimum penalty, we can compute the maximum profit.\n    ans = 0\n    profit = 0\n    maxProfit = 0\n\n    for i, customer in enumerate(customers):\n      profit += 1 if customer == 'Y' else -1\n      if profit > maxProfit:\n        maxProfit = profit\n        ans = i + 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2424, "slug": "longest-uploaded-prefix", "solutions": ["class LUPrefix:\n    def __init__(self, n: int):\n        self.r = 0\n        self.s = set()\n\n    def upload(self, video: int) -> None:\n        self.s.add(video)\n        while self.r + 1 in self.s:\n            self.r += 1\n\n    def longest(self) -> int:\n        return self.r\n\n\n# Your LUPrefix object will be instantiated and called as such:\n# obj = LUPrefix(n)\n# obj.upload(video)\n# param_2 = obj.longest()\n", "class LUPrefix:\n  def __init__(self, n: int):\n    self.seen = set()\n    self.longestPrefix = 0\n\n  def upload(self, video: int) -> None:\n    self.seen.add(video)\n    while self.longestPrefix + 1 in self.seen:\n      self.longestPrefix += 1\n\n  def longest(self) -> int:\n    return self.longestPrefix\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2450, "slug": "number-of-distinct-binary-strings-after-applying-operations", "solutions": ["class Solution:\n    def countDistinctStrings(self, s: str, k: int) -> int:\n        return pow(2, len(s) - k + 1) % (10**9 + 7)\n", "class Solution:\n  def countDistinctStrings(self, s: str, k: int) -> int:\n    # Since the content of `s` doesn't matter, for each i in [0, n - k], we can\n    # flip s[i..i + k] or don't flip it. Therefore, there's 2^(n - k + 1) ways.\n    return pow(2, len(s) - k + 1, 1_000_000_007)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2468, "slug": "split-message-based-on-limit", "solutions": ["class Solution:\n    def splitMessage(self, message: str, limit: int) -> List[str]:\n        n = len(message)\n        sa = 0\n        for k in range(1, n + 1):\n            sa += len(str(k))\n            sb = len(str(k)) * k\n            sc = 3 * k\n            if limit * k - (sa + sb + sc) >= n:\n                ans = []\n                i = 0\n                for j in range(1, k + 1):\n                    tail = f'<{j}/{k}>'\n                    t = message[i : i + limit - len(tail)] + tail\n                    ans.append(t)\n                    i += limit - len(tail)\n                return ans\n        return []\n", "class Solution:\n  def splitMessage(self, message: str, limit: int) -> list[str]:\n    MESSAGE_LENGTH = len(message)\n\n    def sz(num: int):\n      return len(str(num))\n\n    b = 1\n    # the total length of a: initialized with the length of \"1\"\n    aLength = sz(1)\n\n    # the total length of b := b * sz(b)\n    # The total length of \"</>\" := b * 3\n    while b * limit < b * (sz(b) + 3) + aLength + MESSAGE_LENGTH:\n      # If the length of the last suffix \"<b/b>\" := sz(b) * 2 + 3 >= limit,\n      # then it's impossible that the length of \"*<b/b>\" <= limit.\n      if sz(b) * 2 + 3 >= limit:\n        return []\n      b += 1\n      aLength += sz(b)\n\n    ans = []\n\n    i = 0\n    for a in range(1, b + 1):\n      # the length of \"<a/b>\" := sz(a) + sz(b) + 3\n      j = limit - (sz(a) + sz(b) + 3)\n      ans.append(f'{message[i:i + j]}<{a}/{b}>')\n      i += j\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2415, "slug": "reverse-odd-levels-of-binary-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def reverseOddLevels(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        q = deque([root])\n        i = 0\n        while q:\n            if i & 1:\n                l, r = 0, len(q) - 1\n                while l < r:\n                    q[l].val, q[r].val = q[r].val, q[l].val\n                    l, r = l + 1, r - 1\n            for _ in range(len(q)):\n                node = q.popleft()\n                if node.left:\n                    q.append(node.left)\n                    q.append(node.right)\n            i += 1\n        return root\n", "class Solution:\n  def reverseOddLevels(self, root: TreeNode | None) -> TreeNode | None:\n    def dfs(left: TreeNode | None, right: TreeNode | None, isOddLevel: bool) -> None:\n      if not left:\n        return\n      if isOddLevel:\n        left.val, right.val = right.val, left.val\n      dfs(left.left, right.right, not isOddLevel)\n      dfs(left.right, right.left, not isOddLevel)\n\n    dfs(root.left, root.right, True)\n    return root\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2432, "slug": "the-employee-that-worked-on-the-longest-task", "solutions": ["class Solution:\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\n        last = mx = ans = 0\n        for uid, t in logs:\n            t -= last\n            if mx < t or (mx == t and ans > uid):\n                ans, mx = uid, t\n            last += t\n        return ans\n", "class Solution:\n  def hardestWorker(self, n: int, logs: list[list[int]]) -> int:\n    ans = logs[0][0]\n    maxWorkingTime = logs[0][1]\n\n    for (_, prevLeaveTime), (id, leaveTime) in zip(logs, logs[1:]):\n      workingTime = leaveTime - prevLeaveTime\n      if workingTime > maxWorkingTime:\n        ans = id\n        maxWorkingTime = workingTime\n      elif workingTime == maxWorkingTime:\n        ans = min(ans, id)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2414, "slug": "length-of-the-longest-alphabetical-continuous-substring", "solutions": ["class Solution:\n    def longestContinuousSubstring(self, s: str) -> int:\n        ans = cnt = 1\n        for x, y in pairwise(map(ord, s)):\n            if y - x == 1:\n                cnt += 1\n                ans = max(ans, cnt)\n            else:\n                cnt = 1\n        return ans\n", "class Solution:\n  def longestContinuousSubstring(self, s: str) -> int:\n    ans = 1\n    runningLen = 1\n\n    for a, b in zip(s, s[1:]):\n      if ord(a) + 1 == ord(b):\n        runningLen += 1\n        ans = max(ans, runningLen)\n      else:\n        runningLen = 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2437, "slug": "number-of-valid-clock-times", "solutions": ["class Solution:\n    def countTime(self, time: str) -> int:\n        def check(s: str, t: str) -> bool:\n            return all(a == b or b == '?' for a, b in zip(s, t))\n\n        return sum(\n            check(f'{h:02d}:{m:02d}', time) for h in range(24) for m in range(60)\n        )\n", "class Solution:\n  def countTime(self, time: str) -> int:\n    ans = 1\n    if time[3] == '?':\n      ans *= 6\n    if time[4] == '?':\n      ans *= 10\n\n    if time[0] == '?' and time[1] == '?':\n      return ans * 24\n    if time[0] == '?':\n      return ans * 3 if time[1] < '4' else ans * 2\n    if time[1] == '?':\n      return ans * 4 if time[0] == '2' else ans * 10\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2486, "slug": "append-characters-to-string-to-make-subsequence", "solutions": ["class Solution:\n    def appendCharacters(self, s: str, t: str) -> int:\n        n, j = len(t), 0\n        for c in s:\n            if j < n and c == t[j]:\n                j += 1\n        return n - j\n", "class Solution:\n  def appendCharacters(self, s: str, t: str) -> int:\n    i = 0  # t's index\n\n    for c in s:\n      if c == t[i]:\n        i += 1\n        if i == len(t):\n          return 0\n\n    return len(t) - i\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2401, "slug": "longest-nice-subarray", "solutions": ["class Solution:\n    def longestNiceSubarray(self, nums: List[int]) -> int:\n        ans = mask = l = 0\n        for r, x in enumerate(nums):\n            while mask & x:\n                mask ^= nums[l]\n                l += 1\n            mask |= x\n            ans = max(ans, r - l + 1)\n        return ans\n", "class Solution:\n  def longestNiceSubarray(self, nums: list[int]) -> int:\n    ans = 0\n    used = 0\n\n    l = 0\n    for r, num in enumerate(nums):\n      while used & num:\n        used ^= nums[l]\n        l += 1\n      used |= num\n      ans = max(ans, r - l + 1)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2454, "slug": "next-greater-element-iv", "solutions": ["class Solution:\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\n        arr = [(x, i) for i, x in enumerate(nums)]\n        arr.sort(key=lambda x: -x[0])\n        sl = SortedList()\n        n = len(nums)\n        ans = [-1] * n\n        for _, i in arr:\n            j = sl.bisect_right(i)\n            if j + 1 < len(sl):\n                ans[i] = nums[sl[j + 1]]\n            sl.add(i)\n        return ans\n", "class Solution:\n  def secondGreaterElement(self, nums: list[int]) -> list[int]:\n    ans = [-1] * len(nums)\n    # a decreasing stack that stores indices that met the first greater number.\n    prevStack = []\n    # a decreasing stack that stores indices.\n    currStack = []\n\n    for i, num in enumerate(nums):\n      # Indices in prevStack meet the second greater num.\n      while prevStack and nums[prevStack[-1]] < num:\n        ans[prevStack.pop()] = num\n      # Push indices that meet the first greater number from `currStack` to\n      # `prevStack`. We need a temporary array to make the indices in the\n      # `prevStack` increasing.\n      decreasingIndices = []\n      while currStack and nums[currStack[-1]] < num:\n        decreasingIndices.append(currStack.pop())\n      while decreasingIndices:\n        prevStack.append(decreasingIndices.pop())\n      currStack.append(i)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2400, "slug": "number-of-ways-to-reach-a-position-after-exactly-k-steps", "solutions": ["class Solution:\n    def numberOfWays(self, startPos: int, endPos: int, k: int) -> int:\n        @cache\n        def dfs(i: int, j: int) -> int:\n            if i > j or j < 0:\n                return 0\n            if j == 0:\n                return 1 if i == 0 else 0\n            return (dfs(i + 1, j - 1) + dfs(abs(i - 1), j - 1)) % mod\n\n        mod = 10**9 + 7\n        return dfs(abs(startPos - endPos), k)\n", "class Solution:\n  def numberOfWays(self, startPos: int, endPos: int, k: int) -> int:\n    # leftStep + rightStep = k\n    # rightStep - leftStep = endPos - startPos\n    #        2 * rightStep = k + endPos - startPos\n    #            rightStep = (k + endPos - startPos) // 2\n    val = k + endPos - startPos\n    if val < 0 or val % 2 == 1:\n      return 0\n    rightStep = val // 2\n    leftStep = k - rightStep\n    if leftStep < 0:\n      return 0\n    return self._nCk(leftStep + rightStep, min(leftStep, rightStep))\n\n  # C(n, k) = C(n - 1, k) + C(n - 1, k - 1)\n  def _nCk(self, n: int, k: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i] := C(n so far, i)\n    dp = [1] + [0] * k\n\n    for _ in range(n):  # Calculate n times.\n      for j in range(k, 0, -1):\n        dp[j] += dp[j - 1]\n        dp[j] %= MOD\n\n    return dp[k]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2485, "slug": "find-the-pivot-integer", "solutions": ["class Solution:\n    def pivotInteger(self, n: int) -> int:\n        for x in range(1, n + 1):\n            if (1 + x) * x == (x + n) * (n - x + 1):\n                return x\n        return -1\n", "class Solution:\n  def pivotInteger(self, n: int) -> int:\n    # 1 + 2 + ... + x = x + ... + n\n    # (1 + x) * x // 2 = (x + n) * (n - x + 1) // 2\n    #         x + x^2 = nx - x^2 + x + n^2 - nx + n\n    #         2 * x^2 = n^2 + n\n    #               x = sqrt((n^2 + n) // 2)\n    y = (n * n + n) // 2\n    x = math.isqrt(y)\n    return x if x * x == y else -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2464, "slug": "minimum-subarrays-in-a-valid-split", "solutions": ["class Solution:\n    def validSubarraySplit(self, nums: List[int]) -> int:\n        @cache\n        def dfs(i):\n            if i >= n:\n                return 0\n            ans = inf\n            for j in range(i, n):\n                if gcd(nums[i], nums[j]) > 1:\n                    ans = min(ans, 1 + dfs(j + 1))\n            return ans\n\n        n = len(nums)\n        ans = dfs(0)\n        dfs.cache_clear()\n        return ans if ans < inf else -1\n", "class Solution:\n  def validSubarraySplit(self, nums: list[int]) -> int:\n    # dp[i] := the minimum number of subarrays to validly split nums[0..i]\n    dp = [math.inf] * len(nums)\n\n    for i, num in enumerate(nums):\n      for j in range(i + 1):\n        if math.gcd(nums[j], num) > 1:\n          dp[i] = min(dp[i], 1 if j == 0 else dp[j - 1] + 1)\n\n    return -1 if dp[-1] == math.inf else dp[-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2438, "slug": "range-product-queries-of-powers", "solutions": ["class Solution:\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        powers = []\n        while n:\n            x = n & -n\n            powers.append(x)\n            n -= x\n        mod = 10**9 + 7\n        ans = []\n        for l, r in queries:\n            x = 1\n            for y in powers[l : r + 1]:\n                x = (x * y) % mod\n            ans.append(x)\n        return ans\n", "class Solution:\n  def productQueries(self, n: int, queries: list[list[int]]) -> list[int]:\n    MOD = 1_000_000_007\n    MAX_BIT = 30\n    ans = []\n    powers = [1 << i for i in range(MAX_BIT) if n >> i & 1]\n\n    for left, right in queries:\n      prod = 1\n      for i in range(left, right + 1):\n        prod *= powers[i]\n        prod %= MOD\n      ans.append(prod)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2440, "slug": "create-components-with-same-value", "solutions": ["class Solution:\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\n        def dfs(i, fa):\n            x = nums[i]\n            for j in g[i]:\n                if j != fa:\n                    y = dfs(j, i)\n                    if y == -1:\n                        return -1\n                    x += y\n            if x > t:\n                return -1\n            return x if x < t else 0\n\n        n = len(nums)\n        g = defaultdict(list)\n        for a, b in edges:\n            g[a].append(b)\n            g[b].append(a)\n        s = sum(nums)\n        mx = max(nums)\n        for k in range(min(n, s // mx), 1, -1):\n            if s % k == 0:\n                t = s // k\n                if dfs(0, -1) == 0:\n                    return k - 1\n        return 0\n", "class Solution:\n  def componentValue(self, nums: list[int], edges: list[list[int]]) -> int:\n    MAX = 1_000_000_000\n    n = len(nums)\n    summ = sum(nums)\n    tree = [[] for _ in range(n)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, target: int, seen: set[bool]) -> int:\n      \"\"\"\n      Returns the sum of the subtree rooted at u substracting the sum of the\n      deleted subtrees.\n      \"\"\"\n      summ = nums[u]\n      seen.add(u)\n\n      for v in tree[u]:\n        if v in seen:\n          continue\n        summ += dfs(v, target, seen)\n        if summ > target:\n          return MAX\n\n      # Delete the tree that has sum == target.\n      if summ == target:\n        return 0\n      return summ\n\n    for i in range(n, 1, -1):\n      # Split the tree into i parts, i.e. delete (i - 1) edges.\n      if summ % i == 0 and dfs(0, summ // i, set()) == 0:\n        return i - 1\n\n    return 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2470, "slug": "number-of-subarrays-with-lcm-equal-to-k", "solutions": ["class Solution:\n    def subarrayLCM(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        ans = 0\n        for i in range(n):\n            a = nums[i]\n            for b in nums[i:]:\n                x = lcm(a, b)\n                ans += x == k\n                a = x\n        return ans\n", "class Solution:\n  def subarrayLCM(self, nums: list[int], k: int) -> int:\n    ans = 0\n\n    for i, runningLcm in enumerate(nums):\n      for j in range(i, len(nums)):\n        runningLcm = math.lcm(runningLcm, nums[j])\n        if runningLcm > k:\n          break\n        if runningLcm == k:\n          ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2439, "slug": "minimize-maximum-of-array", "solutions": ["class Solution:\n    def minimizeArrayValue(self, nums: List[int]) -> int:\n        def check(mx):\n            d = 0\n            for x in nums[:0:-1]:\n                d = max(0, d + x - mx)\n            return nums[0] + d <= mx\n\n        left, right = 0, max(nums)\n        while left < right:\n            mid = (left + right) >> 1\n            if check(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n", "class Solution:\n  def minimizeArrayValue(self, nums: list[int]) -> int:\n    ans = 0\n    prefix = 0\n\n    for i, num in enumerate(nums):\n      prefix += num\n      prefixAvg = math.ceil(prefix / (i + 1))\n      ans = max(ans, prefixAvg)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2462, "slug": "total-cost-to-hire-k-workers", "solutions": ["class Solution:\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\n        n = len(costs)\n        if candidates * 2 >= n:\n            return sum(sorted(costs)[:k])\n        pq = []\n        for i, c in enumerate(costs[:candidates]):\n            heappush(pq, (c, i))\n        for i in range(n - candidates, n):\n            heappush(pq, (costs[i], i))\n        heapify(pq)\n        l, r = candidates, n - candidates - 1\n        ans = 0\n        for _ in range(k):\n            c, i = heappop(pq)\n            ans += c\n            if l > r:\n                continue\n            if i < l:\n                heappush(pq, (costs[l], l))\n                l += 1\n            else:\n                heappush(pq, (costs[r], r))\n                r -= 1\n        return ans\n", "class Solution:\n  def totalCost(self, costs: list[int], k: int, candidates: int) -> int:\n    ans = 0\n    i = 0\n    j = len(costs) - 1\n    minHeapL = []  # First half\n    minHeapR = []  # Second half\n\n    for _ in range(k):\n      while len(minHeapL) < candidates and i <= j:\n        heapq.heappush(minHeapL, costs[i])\n        i += 1\n      while len(minHeapR) < candidates and i <= j:\n        heapq.heappush(minHeapR, costs[j])\n        j -= 1\n      if not minHeapL:\n        ans += heapq.heappop(minHeapR)\n      elif not minHeapR:\n        ans += heapq.heappop(minHeapL)\n      # Both `minHeapL` and `minHeapR` are not empty.\n      elif minHeapL[0] <= minHeapR[0]:\n        ans += heapq.heappop(minHeapL)\n      else:\n        ans += heapq.heappop(minHeapR)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2418, "slug": "sort-the-people", "solutions": ["class Solution:\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\n        idx = list(range(len(heights)))\n        idx.sort(key=lambda i: -heights[i])\n        return [names[i] for i in idx]\n", "class Solution:\n  def sortPeople(self, names: list[str], heights: list[int]) -> list[str]:\n    return [height for _, height in\n            sorted([(height, name) for name, height in zip(names, heights)], reverse=True)]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2409, "slug": "count-days-spent-together", "solutions": ["class Solution:\n    def countDaysTogether(\n        self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str\n    ) -> int:\n        a = max(arriveAlice, arriveBob)\n        b = min(leaveAlice, leaveBob)\n        days = (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n        x = sum(days[: int(a[:2]) - 1]) + int(a[3:])\n        y = sum(days[: int(b[:2]) - 1]) + int(b[3:])\n        return max(y - x + 1, 0)\n", "class Solution:\n  def countDaysTogether(\n      self,\n      arriveAlice: str,\n      leaveAlice: str,\n      arriveBob: str,\n      leaveBob: str,\n  ) -> int:\n    days = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n    def toDays(s: str) -> int:\n      month = int(s[:2])\n      day = int(s[3:])\n      prevDays = 0\n      for m in range(1, month):\n        prevDays += days[m]\n      return prevDays + day\n\n    arriveA = toDays(arriveAlice)\n    leaveA = toDays(leaveAlice)\n    arriveB = toDays(arriveBob)\n    leaveB = toDays(leaveBob)\n    ans = 0\n\n    for day in range(1, 366):\n      if arriveA <= day and day <= leaveA and arriveB <= day and day <= leaveB:\n        ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2469, "slug": "convert-the-temperature", "solutions": ["class Solution:\n    def convertTemperature(self, celsius: float) -> List[float]:\n        return [celsius + 273.15, celsius * 1.8 + 32]\n", "class Solution:\n  def convertTemperature(self, celsius: float) -> list[float]:\n    return [celsius + 273.15, celsius * 1.8 + 32]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2436, "slug": "minimum-split-into-subarrays-with-gcd-greater-than-one", "solutions": ["class Solution:\n    def minimumSplits(self, nums: List[int]) -> int:\n        ans, g = 1, 0\n        for x in nums:\n            g = gcd(g, x)\n            if g == 1:\n                ans += 1\n                g = x\n        return ans\n", "class Solution:\n  def minimumSplits(self, nums: list[int]) -> int:\n    ans = 1\n    gcd = nums[0]\n\n    for num in nums:\n      newGcd = math.gcd(gcd, num)\n      if newGcd > 1:\n        gcd = newGcd\n      else:\n        gcd = num\n        ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2463, "slug": "minimum-total-distance-traveled", "solutions": ["class Solution:\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\n        @cache\n        def dfs(i, j):\n            if i == len(robot):\n                return 0\n            if j == len(factory):\n                return inf\n            ans = dfs(i, j + 1)\n            t = 0\n            for k in range(factory[j][1]):\n                if i + k == len(robot):\n                    break\n                t += abs(robot[i + k] - factory[j][0])\n                ans = min(ans, t + dfs(i + k + 1, j + 1))\n            return ans\n\n        robot.sort()\n        factory.sort()\n        ans = dfs(0, 0)\n        dfs.cache_clear()\n        return ans\n", "class Solution:\n  def minimumTotalDistance(\n      self,\n      robot: list[int],\n      factory: list[list[int]],\n  ) -> int:\n    robot.sort()\n    factory.sort()\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, k: int) -> int:\n      \"\"\"\n      Returns the minimum distance to fix robot[i..n) with factory[j..n), where\n      factory[j] already fixed k robots.\n      \"\"\"\n      if i == len(robot):\n        return 0\n      if j == len(factory):\n        return math.inf\n      skipFactory = dp(i, j + 1, 0)\n      position, limit = factory[j]\n      useFactory = (dp(i + 1, j, k + 1) + abs(robot[i] - position)\n                    if limit > k else math.inf)\n      return min(skipFactory, useFactory)\n\n    return dp(0, 0, 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2406, "slug": "divide-intervals-into-minimum-number-of-groups", "solutions": ["class Solution:\n    def minGroups(self, intervals: List[List[int]]) -> int:\n        q = []\n        for left, right in sorted(intervals):\n            if q and q[0] < left:\n                heappop(q)\n            heappush(q, right)\n        return len(q)\n", "class Solution:\n  # Similar to 253. Meeting Rooms II\n  def minGroups(self, intervals: list[list[int]]) -> int:\n    minHeap = []  # Stores `right`s.\n\n    for left, right in sorted(intervals):\n      # There's no overlap, so we can reuse the same group.\n      if minHeap and left > minHeap[0]:\n        heapq.heappop(minHeap)\n      heapq.heappush(minHeap, right)\n\n    return len(minHeap)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2445, "slug": "number-of-nodes-with-value-one", "solutions": ["class Solution:\n    def numberOfNodes(self, n: int, queries: List[int]) -> int:\n        def dfs(i):\n            if i > n:\n                return\n            tree[i] ^= 1\n            dfs(i << 1)\n            dfs(i << 1 | 1)\n\n        tree = [0] * (n + 1)\n        cnt = Counter(queries)\n        for i, v in cnt.items():\n            if v & 1:\n                dfs(i)\n        return sum(tree)\n", "class Solution:\n  def numberOfNodes(self, n: int, queries: list[int]) -> int:\n    # flipped[i] := True if we should flip all the values in the subtree rooted\n    # at i\n    flipped = [False] * (n + 1)\n\n    for query in queries:\n      flipped[query] = flipped[query] ^ True\n\n    def dfs(label: int, value: int) -> int:\n      if label > n:\n        return 0\n      value ^= flipped[label]\n      return value + dfs(label * 2, value) + dfs(label * 2 + 1, value)\n\n    return dfs(1, 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2449, "slug": "minimum-number-of-operations-to-make-arrays-similar", "solutions": ["class Solution:\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\n        nums.sort(key=lambda x: (x & 1, x))\n        target.sort(key=lambda x: (x & 1, x))\n        return sum(abs(a - b) for a, b in zip(nums, target)) // 4\n", "class Solution:\n  def makeSimilar(self, nums: list[int], target: list[int]) -> int:\n    nums.sort(key=lambda x: (x % 2, x))\n    target.sort(key=lambda x: (x % 2, x))\n    return sum(abs(a - b) for a, b in zip(nums, target)) // 4\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2494, "slug": "merge-overlapping-events-in-the-same-hall", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2402, "slug": "meeting-rooms-iii", "solutions": ["class Solution:\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\n        meetings.sort()\n        busy = []\n        idle = list(range(n))\n        heapify(idle)\n        cnt = [0] * n\n        for s, e in meetings:\n            while busy and busy[0][0] <= s:\n                heappush(idle, heappop(busy)[1])\n            if idle:\n                i = heappop(idle)\n                cnt[i] += 1\n                heappush(busy, (e, i))\n            else:\n                a, i = heappop(busy)\n                cnt[i] += 1\n                heappush(busy, (a + e - s, i))\n        ans = 0\n        for i, v in enumerate(cnt):\n            if cnt[ans] < v:\n                ans = i\n        return ans\n", "class Solution:\n  def mostBooked(self, n: int, meetings: list[list[int]]) -> int:\n    count = [0] * n\n\n    meetings.sort()\n\n    occupied = []  # (endTime, roomId)\n    availableRoomIds = [i for i in range(n)]\n    heapq.heapify(availableRoomIds)\n\n    for start, end in meetings:\n      # Push meetings ending before this `meeting` in occupied to the\n      # `availableRoomsIds`.\n      while occupied and occupied[0][0] <= start:\n        heapq.heappush(availableRoomIds, heapq.heappop(occupied)[1])\n      if availableRoomIds:\n        roomId = heapq.heappop(availableRoomIds)\n        count[roomId] += 1\n        heapq.heappush(occupied, (end, roomId))\n      else:\n        newStart, roomId = heapq.heappop(occupied)\n        count[roomId] += 1\n        heapq.heappush(occupied, (newStart + (end - start), roomId))\n\n    return count.index(max(count))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2435, "slug": "paths-in-matrix-whose-sum-is-divisible-by-k", "solutions": ["class Solution:\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\n        @cache\n        def dfs(i, j, s):\n            if i < 0 or i >= m or j < 0 or j >= n:\n                return 0\n            s = (s + grid[i][j]) % k\n            if i == m - 1 and j == n - 1:\n                return int(s == 0)\n            ans = dfs(i + 1, j, s) + dfs(i, j + 1, s)\n            return ans % mod\n\n        m, n = len(grid), len(grid[0])\n        mod = 10**9 + 7\n        ans = dfs(0, 0, 0)\n        dfs.cache_clear()\n        return ans\n", "class Solution:\n  def numberOfPaths(self, grid: list[list[int]], k: int) -> int:\n    MOD = 1_000_000_007\n    m = len(grid)\n    n = len(grid[0])\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, summ: int) -> int:\n      \"\"\"\n      Returns the number of paths to (i, j), where the sum / k == `summ`.\n      \"\"\"\n      if i == m or j == n:\n        return 0\n      if i == m - 1 and j == n - 1:\n        return 1 if (summ + grid[i][j]) % k == 0 else 0\n      newSum = (summ + grid[i][j]) % k\n      return (dp(i + 1, j, newSum) + dp(i, j + 1, newSum)) % MOD\n\n    return dp(0, 0, 0)\n", "class Solution:\n  def numberOfPaths(self, grid: list[list[int]], k: int) -> int:\n    MOD = 1_000_000_007\n    m = len(grid)\n    n = len(grid[0])\n    # dp[i][j][sum] := the number of paths to (i, j), where the sum / k == sum\n    dp = [[[0] * k for j in range(n)] for i in range(m)]\n    dp[0][0][grid[0][0] % k] = 1\n\n    for i in range(m):\n      for j in range(n):\n        for summ in range(k):\n          newSum = (summ + grid[i][j]) % k\n          if i > 0:\n            dp[i][j][newSum] += dp[i - 1][j][summ]\n          if j > 0:\n            dp[i][j][newSum] += dp[i][j - 1][summ]\n          dp[i][j][newSum] %= MOD\n\n    return dp[m - 1][n - 1][0]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2443, "slug": "sum-of-number-and-its-reverse", "solutions": ["class Solution:\n    def sumOfNumberAndReverse(self, num: int) -> bool:\n        return any(k + int(str(k)[::-1]) == num for k in range(num + 1))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2479, "slug": "maximum-xor-of-two-non-overlapping-subtrees", "solutions": ["class Trie:\n    def __init__(self):\n        self.children = [None] * 2\n\n    def insert(self, x):\n        node = self\n        for i in range(47, -1, -1):\n            v = (x >> i) & 1\n            if node.children[v] is None:\n                node.children[v] = Trie()\n            node = node.children[v]\n\n    def search(self, x):\n        node = self\n        res = 0\n        for i in range(47, -1, -1):\n            v = (x >> i) & 1\n            if node is None:\n                return res\n            if node.children[v ^ 1]:\n                res = res << 1 | 1\n                node = node.children[v ^ 1]\n            else:\n                res <<= 1\n                node = node.children[v]\n        return res\n\n\nclass Solution:\n    def maxXor(self, n: int, edges: List[List[int]], values: List[int]) -> int:\n        def dfs1(i, fa):\n            t = values[i]\n            for j in g[i]:\n                if j != fa:\n                    t += dfs1(j, i)\n            s[i] = t\n            return t\n\n        def dfs2(i, fa):\n            nonlocal ans\n            ans = max(ans, tree.search(s[i]))\n            for j in g[i]:\n                if j != fa:\n                    dfs2(j, i)\n            tree.insert(s[i])\n\n        g = defaultdict(list)\n        for a, b in edges:\n            g[a].append(b)\n            g[b].append(a)\n        s = [0] * n\n        dfs1(0, -1)\n        ans = 0\n        tree = Trie()\n        dfs2(0, -1)\n        return ans\n", "class TrieNode:\n  def __init__(self):\n    self.children: list[TrieNode | None] = [None] * 2\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n\n  def getMaxXor(self, num: int) -> int:\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      toggleBit = bit ^ 1\n      if node.children[toggleBit]:\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:  # There's nothing in the Bit Trie.\n        return 0\n    return maxXor\n\n\nclass Solution:\n  def maxXor(self, n: int, edges: list[list[int]], values: list[int]) -> int:\n    ans = 0\n    tree = [[] for _ in range(n)]\n    treeSums = [0] * n\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    # Gets the tree sum rooted at node u.\n    def getTreeSum(u: int, prev: int) -> int:\n      treeSum = values[u] + sum(getTreeSum(v, u) for v in tree[u] if v != prev)\n      treeSums[u] = treeSum\n      return treeSum\n\n    def dfs(u: int, prev: int, bitTrie: BitTrie) -> None:\n      nonlocal ans\n      for v in tree[u]:\n        if v == prev:\n          continue\n        # Preorder to get the ans.\n        ans = max(ans, bitTrie.getMaxXor(treeSums[v]))\n        # Recursively call on the subtree rooted at node v.\n        dfs(v, u, bitTrie)\n        # Postorder to insert the tree sum rooted at node v.\n        bitTrie.insert(treeSums[v])\n\n    getTreeSum(0, -1)\n    maxBit = int(math.log2(max(treeSums[1:])))\n    # Similar to 421. Maximum XOR of Two Numbers in an Array\n    dfs(0, -1, BitTrie(maxBit))\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2412, "slug": "minimum-money-required-before-transactions", "solutions": ["class Solution:\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\n        s = sum(max(0, a - b) for a, b in transactions)\n        ans = 0\n        for a, b in transactions:\n            if a > b:\n                ans = max(ans, s + b)\n            else:\n                ans = max(ans, s + a)\n        return ans\n", "class Solution:\n  def minimumMoney(self, transactions: list[list[int]]) -> int:\n    ans = 0\n    losses = 0\n\n    # Before picking the final transaction, perform any transaction that raises\n    # the required money.\n    for cost, cashback in transactions:\n      losses += max(0, cost - cashback)\n\n    # Now, pick a transaction to be the final one.\n    for cost, cashback in transactions:\n      if cost > cashback:\n        # The losses except this transaction: losses - (cost - cashback), so\n        # add the cost of this transaction = losses - (cost - cashback) + cost.\n        ans = max(ans, losses + cashback)\n      else:\n        # The losses except this transaction: losses, so add the cost of this\n        # transaction = losses + cost.\n        ans = max(ans, losses + cost)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2428, "slug": "maximum-sum-of-an-hourglass", "solutions": ["class Solution:\n    def maxSum(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        ans = 0\n        for i in range(1, m - 1):\n            for j in range(1, n - 1):\n                s = -grid[i][j - 1] - grid[i][j + 1]\n                s += sum(\n                    grid[x][y] for x in range(i - 1, i + 2) for y in range(j - 1, j + 2)\n                )\n                ans = max(ans, s)\n        return ans\n", "class Solution:\n  def maxSum(self, grid: list[list[int]]) -> int:\n    return max(\n        grid[i - 1][j - 1] + grid[i - 1][j] + grid[i - 1][j + 1] + grid[i][j] +\n        grid[i + 1][j - 1] + grid[i + 1][j] + grid[i + 1][j + 1]\n        for i in range(1, len(grid) - 1) for j in range(1, len(grid[0]) - 1))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2416, "slug": "sum-of-prefix-scores-of-strings", "solutions": ["class Trie:\n    __slots__ = \"children\", \"cnt\"\n\n    def __init__(self):\n        self.children = [None] * 26\n        self.cnt = 0\n\n    def insert(self, w):\n        node = self\n        for c in w:\n            idx = ord(c) - ord(\"a\")\n            if node.children[idx] is None:\n                node.children[idx] = Trie()\n            node = node.children[idx]\n            node.cnt += 1\n\n    def search(self, w):\n        node = self\n        ans = 0\n        for c in w:\n            idx = ord(c) - ord(\"a\")\n            if node.children[idx] is None:\n                return ans\n            node = node.children[idx]\n            ans += node.cnt\n        return ans\n\n\nclass Solution:\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\n        trie = Trie()\n        for w in words:\n            trie.insert(w)\n        return [trie.search(w) for w in words]\n", "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.count = 0\n\n\nclass Solution:\n  def sumPrefixScores(self, words: list[str]) -> list[int]:\n    root = TrieNode()\n\n    def insert(word: str) -> None:\n      node: TrieNode = root\n      for c in word:\n        node = node.children.setdefault(c, TrieNode())\n        node.count += 1\n\n    for word in words:\n      insert(word)\n\n    def getScore(word: str) -> int:\n      node: TrieNode = root\n      score = 0\n      for c in word:\n        node = node.children[c]\n        score += node.count\n      return score\n\n    return [getScore(word) for word in words]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2484, "slug": "count-palindromic-subsequences", "solutions": ["class Solution:\n    def countPalindromes(self, s: str) -> int:\n        mod = 10**9 + 7\n        n = len(s)\n        pre = [[[0] * 10 for _ in range(10)] for _ in range(n + 2)]\n        suf = [[[0] * 10 for _ in range(10)] for _ in range(n + 2)]\n        t = list(map(int, s))\n        c = [0] * 10\n        for i, v in enumerate(t, 1):\n            for j in range(10):\n                for k in range(10):\n                    pre[i][j][k] = pre[i - 1][j][k]\n            for j in range(10):\n                pre[i][j][v] += c[j]\n            c[v] += 1\n        c = [0] * 10\n        for i in range(n, 0, -1):\n            v = t[i - 1]\n            for j in range(10):\n                for k in range(10):\n                    suf[i][j][k] = suf[i + 1][j][k]\n            for j in range(10):\n                suf[i][j][v] += c[j]\n            c[v] += 1\n        ans = 0\n        for i in range(1, n + 1):\n            for j in range(10):\n                for k in range(10):\n                    ans += pre[i - 1][j][k] * suf[i + 1][j][k]\n                    ans %= mod\n        return ans\n", "class Solution:\n  def countPalindromes(self, s: str) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n\n    for a in range(10):\n      for b in range(10):\n        pattern = f'{a}{b}.{b}{a}'\n        # dp[i] := the number of subsequences of pattern[i..n) in s, where\n        # pattern[2] can be any character\n        dp = [0] * 5 + [1]\n        for c in s:\n          for i, p in enumerate(pattern):\n            if p == '.' or p == c:\n              dp[i] += dp[i + 1]\n        ans += dp[0]\n        ans %= MOD\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2421, "slug": "number-of-good-paths", "solutions": ["class Solution:\n    def numberOfGoodPaths(self, vals: List[int], edges: List[List[int]]) -> int:\n        def find(x):\n            if p[x] != x:\n                p[x] = find(p[x])\n            return p[x]\n\n        g = defaultdict(list)\n        for a, b in edges:\n            g[a].append(b)\n            g[b].append(a)\n\n        n = len(vals)\n        p = list(range(n))\n        size = defaultdict(Counter)\n        for i, v in enumerate(vals):\n            size[i][v] = 1\n\n        ans = n\n        for v, a in sorted(zip(vals, range(n))):\n            for b in g[a]:\n                if vals[b] > v:\n                    continue\n                pa, pb = find(a), find(b)\n                if pa != pb:\n                    ans += size[pa][v] * size[pb][v]\n                    p[pa] = pb\n                    size[pb][v] += size[pa][v]\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2475, "slug": "number-of-unequal-triplets-in-array", "solutions": ["class Solution:\n    def unequalTriplets(self, nums: List[int]) -> int:\n        n = len(nums)\n        ans = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(j + 1, n):\n                    ans += (\n                        nums[i] != nums[j] and nums[j] != nums[k] and nums[i] != nums[k]\n                    )\n        return ans\n", "# Assume that we have 4 kinds of numbers a, b, c, and d in the count map.\n#\n# What we want is:\n#   cnt[a] * cnt[b] * cnt[c]\n#   cnt[a] * cnt[b] * cnt[d]\n#   cnt[a] * cnt[c] * cnt[d]\n#   cnt[b] * cnt[c] * cnt[d]\n#\n# The above combinations can be reduced as:\n#\n# prev                       | curr   | next\n#\n# (0)                        * cnt[a] * (cnt[b] + cnt[c] + cnt[d])\n# (cnt[a])                   * cnt[b] * (cnt[c] + cnt[d])\n# (cnt[a] + cnt[b])          * cnt[c] * (cnt[d])\n# (cnt[a] + cnt[b] + cnt[c]) * cnt[d] * (0)\n\nclass Solution:\n  def unequalTriplets(self, nums: list[int]) -> int:\n    ans = 0\n    prev = 0\n    next = len(nums)\n\n    for freq in collections.Counter(nums).values():\n      next -= freq\n      ans += prev * freq * next\n      prev += freq\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2453, "slug": "destroy-sequential-targets", "solutions": ["class Solution:\n    def destroyTargets(self, nums: List[int], space: int) -> int:\n        cnt = Counter(v % space for v in nums)\n        ans = mx = 0\n        for v in nums:\n            t = cnt[v % space]\n            if t > mx or (t == mx and v < ans):\n                ans = v\n                mx = t\n        return ans\n", "class Solution:\n  def destroyTargets(self, nums: list[int], space: int) -> int:\n    count = collections.Counter([num % space for num in nums])\n    maxCount = max(count.values())\n    return min(num for num in nums if count[num % space] == maxCount)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2417, "slug": "closest-fair-integer", "solutions": ["class Solution:\n    def closestFair(self, n: int) -> int:\n        a = b = k = 0\n        t = n\n        while t:\n            if (t % 10) & 1:\n                a += 1\n            else:\n                b += 1\n            t //= 10\n            k += 1\n        if k & 1:\n            x = 10**k\n            y = int('1' * (k >> 1) or '0')\n            return x + y\n        if a == b:\n            return n\n        return self.closestFair(n + 1)\n", "class Solution:\n  def closestFair(self, n: int) -> int:\n    digitsCount = len(str(n))\n    return (self._getEvenDigits(n) if digitsCount % 2 == 0 else\n            self._getOddDigits(digitsCount))\n\n  def _getOddDigits(self, digitsCount: int) -> int:\n    zeros = (digitsCount + 1) // 2\n    ones = (digitsCount - 1) // 2\n    return int('1' + '0' * zeros + '1' * ones)\n\n  def _getEvenDigits(self, n: int) -> int:\n    digitsCount = len(str(n))\n    maxNum = int('1' + '0' * digitsCount)\n    for num in range(n, maxNum):\n      if self._isValidNum(num):\n        return num\n    return self._getOddDigits(digitsCount + 1)\n\n  def _isValidNum(self, num: int) -> bool:\n    count = 0\n    for c in str(num):\n      count += 1 if int(c) % 2 == 0 else -1\n    return count == 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2459, "slug": "sort-array-by-moving-items-to-empty-space", "solutions": ["class Solution:\n    def sortArray(self, nums: List[int]) -> int:\n        def f(nums, k):\n            vis = [False] * n\n            cnt = 0\n            for i, v in enumerate(nums):\n                if i == v or vis[i]:\n                    continue\n                cnt += 1\n                j = i\n                while not vis[j]:\n                    vis[j] = True\n                    cnt += 1\n                    j = nums[j]\n            return cnt - 2 * (nums[k] != k)\n\n        n = len(nums)\n        a = f(nums, 0)\n        b = f([(v - 1 + n) % n for v in nums], n - 1)\n        return min(a, b)\n", "class Solution:\n  def sortArray(self, nums: list[int]) -> int:\n    n = len(nums)\n    numToIndex = [0] * n\n\n    for i, num in enumerate(nums):\n      numToIndex[num] = i\n\n    def minOps(numToIndex: list[int], zeroInBeginning: bool) -> int:\n      ops = 0\n      num = 1\n      # If zeroInBeginning, the correct index of each num is num.\n      # If not zeroInBeginning, the correct index of each num is num - 1.\n      offset = 0 if zeroInBeginning else 1\n      while num < n:\n        # 0 is in the correct index, so swap 0 with the first `numInWrongIndex`.\n        if (zeroInBeginning and numToIndex[0] == 0 or\n                not zeroInBeginning and numToIndex[0] == n - 1):\n          while numToIndex[num] == num - offset:  # num is in correct position\n            num += 1\n            if num == n:\n              return ops\n          numInWrongIndex = num\n        # 0 is in the wrong index. e.g. numToIndex[0] == 2, that means 2 is not\n        # in nums[2] because nums[2] == 0.\n        else:\n          numInWrongIndex = numToIndex[0] + offset\n        numToIndex[0], numToIndex[numInWrongIndex] = (\n            numToIndex[numInWrongIndex], numToIndex[0])\n        ops += 1\n\n    return min(minOps(numToIndex.copy(), True),\n               minOps(numToIndex.copy(), False))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2497, "slug": "maximum-star-sum-of-a-graph", "solutions": ["class Solution:\n    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:\n        g = defaultdict(list)\n        for a, b in edges:\n            if vals[b] > 0:\n                g[a].append(vals[b])\n            if vals[a] > 0:\n                g[b].append(vals[a])\n        for bs in g.values():\n            bs.sort(reverse=True)\n        return max(v + sum(g[i][:k]) for i, v in enumerate(vals))\n", "class Solution:\n  def maxStarSum(self, vals: list[int], edges: list[list[int]], k: int) -> int:\n    n = len(vals)\n    ans = -math.inf\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append((v, vals[v]))\n      graph[v].append((u, vals[u]))\n\n    for i, starSum in enumerate(vals):\n      maxHeap = []\n      for _, val in graph[i]:\n        if val > 0:\n          heapq.heappush(maxHeap, -val)\n      j = 0\n      while j < k and maxHeap:\n        starSum -= heapq.heappop(maxHeap)\n        j += 1\n      ans = max(ans, starSum)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2477, "slug": "minimum-fuel-cost-to-report-to-the-capital", "solutions": ["class Solution:\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\n        def dfs(a: int, fa: int) -> int:\n            nonlocal ans\n            sz = 1\n            for b in g[a]:\n                if b != fa:\n                    t = dfs(b, a)\n                    ans += ceil(t / seats)\n                    sz += t\n            return sz\n\n        g = defaultdict(list)\n        for a, b in roads:\n            g[a].append(b)\n            g[b].append(a)\n        ans = 0\n        dfs(0, -1)\n        return ans\n", "class Solution:\n  def minimumFuelCost(self, roads: list[list[int]], seats: int) -> int:\n    ans = 0\n    tree = [[] for _ in range(len(roads) + 1)]\n\n    for u, v in roads:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, prev: int) -> int:\n      nonlocal ans\n      people = 1 + sum(dfs(v, u) for v in tree[u] if v != prev)\n      if u > 0:\n        # the number of cars needed\n        ans += int(math.ceil(people / seats))\n      return people\n\n    dfs(0, -1)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2487, "slug": "remove-nodes-from-linked-list", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        nums = []\n        while head:\n            nums.append(head.val)\n            head = head.next\n        stk = []\n        for v in nums:\n            while stk and stk[-1] < v:\n                stk.pop()\n            stk.append(v)\n        dummy = ListNode()\n        head = dummy\n        for v in stk:\n            head.next = ListNode(v)\n            head = head.next\n        return dummy.next\n", "class Solution:\n  def removeNodes(self, head: ListNode | None) -> ListNode | None:\n    if not head:\n      return None\n    head.next = self.removeNodes(head.next)\n    return head.next if head.next and head.val < head.next.val else head\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2471, "slug": "minimum-number-of-operations-to-sort-a-binary-tree-by-level", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\n        def swap(arr, i, j):\n            arr[i], arr[j] = arr[j], arr[i]\n\n        def f(t):\n            n = len(t)\n            m = {v: i for i, v in enumerate(sorted(t))}\n            for i in range(n):\n                t[i] = m[t[i]]\n            ans = 0\n            for i in range(n):\n                while t[i] != i:\n                    swap(t, i, t[i])\n                    ans += 1\n            return ans\n\n        q = deque([root])\n        ans = 0\n        while q:\n            t = []\n            for _ in range(len(q)):\n                node = q.popleft()\n                t.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            ans += f(t)\n        return ans\n", "class Solution:\n  def minimumOperations(self, root: TreeNode | None) -> int:\n    ans = 0\n    q = collections.deque([root])\n\n    # e.g. vals = [7, 6, 8, 5]\n    # [2, 1, 3, 0]: Initialize the ids based on the order of vals.\n    # [3, 1, 2, 0]: Swap 2 with 3, so 2 is in the right place (i == ids[i]).\n    # [0, 1, 2, 3]: Swap 3 with 0, so 3 is in the right place.\n    while q:\n      vals = []\n      for _ in range(len(q)):\n        node = q.popleft()\n        vals.append(node.val)\n        if node.left:\n          q.append(node.left)\n        if node.right:\n          q.append(node.right)\n      # O(n^2logn), which is not great and leads to TLE.\n      ids = [sorted(vals).index(val) for val in vals]\n      for i in range(len(ids)):\n        while ids[i] != i:\n          j = ids[i]\n          ids[i] = ids[j]\n          ids[j] = j\n          ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2434, "slug": "using-a-robot-to-print-the-lexicographically-smallest-string", "solutions": ["class Solution:\n    def robotWithString(self, s: str) -> str:\n        cnt = Counter(s)\n        ans = []\n        stk = []\n        mi = 'a'\n        for c in s:\n            cnt[c] -= 1\n            while mi < 'z' and cnt[mi] == 0:\n                mi = chr(ord(mi) + 1)\n            stk.append(c)\n            while stk and stk[-1] <= mi:\n                ans.append(stk.pop())\n        return ''.join(ans)\n", "class Solution:\n  def robotWithString(self, s: str) -> str:\n    ans = []\n    count = collections.Counter(s)\n    stack = []\n\n    for c in s:\n      stack.append(c)\n      count[c] -= 1\n      minChar = self._getMinChar(count)\n      while stack and stack[-1] <= minChar:\n        ans.append(stack.pop())\n\n    return ''.join(ans + stack[::-1])\n\n  def _getMinChar(self, count: list[int]) -> str:\n    for c in string.ascii_lowercase:\n      if count[c]:\n        return c\n    return 'a'\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2498, "slug": "frog-jump-ii", "solutions": ["class Solution:\n    def maxJump(self, stones: List[int]) -> int:\n        ans = stones[1] - stones[0]\n        for i in range(2, len(stones)):\n            ans = max(ans, stones[i] - stones[i - 2])\n        return ans\n", "class Solution:\n  def maxJump(self, stones: list[int]) -> int:\n    # Let's denote the forwarding path as F and the backwarding path as B.\n    # 'F1 B2 B1 F2' is no better than 'F1 B2 F2 B1' since the distance between\n    # F1 and F2 increase, resulting a larger `ans`.\n    if len(stones) == 2:\n      return stones[1] - stones[0]\n    return max(stones[i] - stones[i - 2]\n               for i in range(2, len(stones)))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2474, "slug": "customers-with-strictly-increasing-purchases", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2491, "slug": "divide-players-into-teams-of-equal-skill", "solutions": ["class Solution:\n    def dividePlayers(self, skill: List[int]) -> int:\n        skill.sort()\n        t = skill[0] + skill[-1]\n        i, j = 0, len(skill) - 1\n        ans = 0\n        while i < j:\n            if skill[i] + skill[j] != t:\n                return -1\n            ans += skill[i] * skill[j]\n            i, j = i + 1, j - 1\n        return ans\n", "class Solution:\n  def dividePlayers(self, skill: list[int]) -> int:\n    n = len(skill)\n    teamSkill = sum(skill) // (n // 2)\n    ans = 0\n    count = collections.Counter(skill)\n\n    for s, freq in count.items():\n      requiredSkill = teamSkill - s\n      if count[requiredSkill] != freq:\n        return -1\n      ans += s * requiredSkill * freq\n\n    return ans // 2\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2427, "slug": "number-of-common-factors", "solutions": ["class Solution:\n    def commonFactors(self, a: int, b: int) -> int:\n        g = gcd(a, b)\n        return sum(g % x == 0 for x in range(1, g + 1))\n", "class Solution:\n  def commonFactors(self, a: int, b: int) -> int:\n    gcd = math.gcd(a, b)\n    return sum(a % i == 0 and b % i == 0\n               for i in range(1, gcd + 1))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2461, "slug": "maximum-sum-of-distinct-subarrays-with-length-k", "solutions": ["class Solution:\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\n        cnt = Counter(nums[:k])\n        s = sum(nums[:k])\n        ans = s if len(cnt) == k else 0\n        for i in range(k, len(nums)):\n            cnt[nums[i]] += 1\n            cnt[nums[i - k]] -= 1\n            if cnt[nums[i - k]] == 0:\n                cnt.pop(nums[i - k])\n            s += nums[i] - nums[i - k]\n            if len(cnt) == k:\n                ans = max(ans, s)\n        return ans\n", "class Solution:\n  def maximumSubarraySum(self, nums: list[int], k: int) -> int:\n    ans = 0\n    summ = 0\n    distinct = 0\n    count = collections.Counter()\n\n    for i, num in enumerate(nums):\n      summ += num\n      count[num] += 1\n      if count[num] == 1:\n        distinct += 1\n      if i >= k:\n        count[nums[i - k]] -= 1\n        if count[nums[i - k]] == 0:\n          distinct -= 1\n        summ -= nums[i - k]\n      if i >= k - 1 and distinct == k:\n        ans = max(ans, summ)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2430, "slug": "maximum-deletions-on-a-string", "solutions": ["class Solution:\n    def deleteString(self, s: str) -> int:\n        @cache\n        def dfs(i: int) -> int:\n            if i == n:\n                return 0\n            ans = 1\n            for j in range(1, (n - i) // 2 + 1):\n                if s[i : i + j] == s[i + j : i + j + j]:\n                    ans = max(ans, 1 + dfs(i + j))\n            return ans\n\n        n = len(s)\n        return dfs(0)\n", "class Solution:\n  def deleteString(self, s: str) -> int:\n    n = len(s)\n    # lcs[i][j] := the number of the same letters of s[i..n) and s[j..n)\n    lcs = [[0] * (n + 1) for _ in range(n + 1)]\n    # dp[i] := the maximum number of operations needed to delete s[i..n)\n    dp = [1] * n\n\n    for i in reversed(range(n)):\n      for j in range(i + 1, n):\n        if s[i] == s[j]:\n          lcs[i][j] = lcs[i + 1][j + 1] + 1\n        if lcs[i][j] >= j - i:\n          dp[i] = max(dp[i], dp[j] + 1)\n\n    return dp[0]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2499, "slug": "minimum-total-cost-to-make-arrays-unequal", "solutions": ["class Solution:\n    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\n        ans = same = 0\n        cnt = Counter()\n        for i, (a, b) in enumerate(zip(nums1, nums2)):\n            if a == b:\n                same += 1\n                ans += i\n                cnt[a] += 1\n\n        m = lead = 0\n        for k, v in cnt.items():\n            if v * 2 > same:\n                m = v * 2 - same\n                lead = k\n                break\n        for i, (a, b) in enumerate(zip(nums1, nums2)):\n            if m and a != b and a != lead and b != lead:\n                ans += i\n                m -= 1\n        return -1 if m else ans\n", "class Solution:\n  def minimumTotalCost(self, nums1: list[int], nums2: list[int]) -> int:\n    n = len(nums1)\n    ans = 0\n    maxFreq = 0\n    maxFreqNum = 0\n    shouldBeSwapped = 0\n    conflictedNumCount = [0] * (n + 1)\n\n    # Collect the indices i s.t. num1 == num2 and record their `maxFreq`\n    # and `maxFreqNum`.\n    for i, (num1, num2) in enumerate(zip(nums1, nums2)):\n      if num1 == num2:\n        conflictedNum = num1\n        conflictedNumCount[conflictedNum] += 1\n        if conflictedNumCount[conflictedNum] > maxFreq:\n          maxFreq = conflictedNumCount[conflictedNum]\n          maxFreqNum = conflictedNum\n        shouldBeSwapped += 1\n        ans += i\n\n    # Collect the indices with num1 != num2 that contribute less cost.\n    # This can be greedily achieved by iterating from 0 to n - 1.\n    for i, (num1, num2) in enumerate(zip(nums1, nums2)):\n      # Since we have over `maxFreq * 2` spaces, `maxFreqNum` can be\n      # successfully distributed, so no need to collectextra spaces.\n      if maxFreq * 2 <= shouldBeSwapped:\n        break\n      if num1 == num2:\n        continue\n      # The numbers == `maxFreqNum` worsen the result since they increase the\n      # `maxFreq`.\n      if num1 == maxFreqNum or num2 == maxFreqNum:\n        continue\n      shouldBeSwapped += 1\n      ans += i\n\n    return -1 if maxFreq * 2 > shouldBeSwapped else ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2473, "slug": "minimum-cost-to-buy-apples", "solutions": ["class Solution:\n    def minCost(\n        self, n: int, roads: List[List[int]], appleCost: List[int], k: int\n    ) -> List[int]:\n        def dijkstra(i):\n            q = [(0, i)]\n            dist = [inf] * n\n            dist[i] = 0\n            ans = inf\n            while q:\n                d, u = heappop(q)\n                ans = min(ans, appleCost[u] + d * (k + 1))\n                for v, w in g[u]:\n                    if dist[v] > dist[u] + w:\n                        dist[v] = dist[u] + w\n                        heappush(q, (dist[v], v))\n            return ans\n\n        g = defaultdict(list)\n        for a, b, c in roads:\n            a, b = a - 1, b - 1\n            g[a].append((b, c))\n            g[b].append((a, c))\n        return [dijkstra(i) for i in range(n)]\n", "class Solution:\n  def minCost(\n      self,\n      n: int,\n      roads: list[list[int]],\n      appleCost: list[int],\n      k: int,\n  ) -> list[int]:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in roads:\n      graph[u - 1].append((v - 1, w))\n      graph[v - 1].append((u - 1, w))\n\n    return [self._dijkstra(graph, i, appleCost, k) for i in range(n)]\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n      appleCost: list[int],\n      k: int\n  ) -> int:\n    ans = math.inf\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      ans = min(ans, appleCost[u] + (k + 1) * d)\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2472, "slug": "maximum-number-of-non-overlapping-palindrome-substrings", "solutions": ["class Solution:\n    def maxPalindromes(self, s: str, k: int) -> int:\n        @cache\n        def dfs(i):\n            if i >= n:\n                return 0\n            ans = dfs(i + 1)\n            for j in range(i + k - 1, n):\n                if dp[i][j]:\n                    ans = max(ans, 1 + dfs(j + 1))\n            return ans\n\n        n = len(s)\n        dp = [[True] * n for _ in range(n)]\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                dp[i][j] = s[i] == s[j] and dp[i + 1][j - 1]\n        ans = dfs(0)\n        dfs.cache_clear()\n        return ans\n", "class Solution:\n  def maxPalindromes(self, s: str, k: int) -> int:\n    n = len(s)\n    # dp[i] := the maximum number of substrings in the first i chars of s\n    dp = [0] * (n + 1)\n\n    def isPalindrome(l: int, r: int) -> bool:\n      \"\"\"Returns True is s[i..j) is a palindrome.\"\"\"\n      if l < 0:\n        return False\n      while l < r:\n        if s[l] != s[r]:\n          return False\n        l += 1\n        r -= 1\n      return True\n\n    # If a palindrome is a subof another palindrome, then considering\n    # the longer palindrome won't increase the number of non-overlapping\n    # palindromes. So, we only need to consider the shorter one. Also,\n    # considering palindromes with both k length and k + 1 length ensures that\n    # we look for both even and odd length palindromes.\n    for i in range(k, n + 1):\n      dp[i] = dp[i - 1]\n      # Consider palindrome with length k.\n      if isPalindrome(i - k, i - 1):\n        dp[i] = max(dp[i], 1 + dp[i - k])\n      # Consider palindrome with length k + 1.\n      if isPalindrome(i - k - 1, i - 1):\n        dp[i] = max(dp[i], 1 + dp[i - k - 1])\n\n    return dp[n]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2456, "slug": "most-popular-video-creator", "solutions": ["class Solution:\n    def mostPopularCreator(\n        self, creators: List[str], ids: List[str], views: List[int]\n    ) -> List[List[str]]:\n        cnt = defaultdict(int)\n        d = defaultdict(int)\n        for k, (c, i, v) in enumerate(zip(creators, ids, views)):\n            cnt[c] += v\n            if c not in d or views[d[c]] < v or (views[d[c]] == v and ids[d[c]] > i):\n                d[c] = k\n        mx = max(cnt.values())\n        return [[c, ids[d[c]]] for c, x in cnt.items() if x == mx]\n", "class Creator:\n  def __init__(self, popularity: int, videoId: str, maxView: int):\n    self.popularity = popularity  # the popularity sum\n    self.videoId = videoId        # the video id that has the maximum view\n    self.maxView = maxView        # the maximum view of the creator\n\n\nclass Solution:\n  def mostPopularCreator(self, creators: list[str],\n                         ids: list[str],\n                         views: list[int]) -> list[list[str]]:\n    ans = []\n    maxPopularity = 0\n    nameToCreator = {}\n\n    for name, id, view in zip(creators, ids, views):\n      if name not in nameToCreator:\n        nameToCreator[name] = Creator(view, id, view)\n        maxPopularity = max(maxPopularity, view)\n        continue\n      creator = nameToCreator[name]\n      creator.popularity += view\n      maxPopularity = max(maxPopularity, creator.popularity)\n      if (creator.maxView < view or\n              creator.maxView == view and creator.videoId > id):\n        creator.videoId = id\n        creator.maxView = view\n\n    for name, creator in nameToCreator.items():\n      if creator.popularity == maxPopularity:\n        ans.append([name, creator.videoId])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2457, "slug": "minimum-addition-to-make-integer-beautiful", "solutions": ["class Solution:\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\n        def f(x: int) -> int:\n            y = 0\n            while x:\n                y += x % 10\n                x //= 10\n            return y\n\n        x = 0\n        while f(n + x) > target:\n            y = n + x\n            p = 10\n            while y % 10 == 0:\n                y //= 10\n                p *= 10\n            x = (y // 10 + 1) * p - n\n        return x\n", "class Solution:\n  def makeIntegerBeautiful(self, n: int, target: int) -> int:\n    ans = 0\n    power = 1\n\n    # e.g. n = 123. After tunning off the last bit by adding 7, n = 130.\n    # Effectively, we can think n as 13. That's why we do n = (n / 10) + 1.\n    while sum(map(int, str(n))) > target:\n      # the cost to turn off the last digit\n      ans += power * (10 - n % 10)\n      n = n // 10 + 1\n      power *= 10\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2447, "slug": "number-of-subarrays-with-gcd-equal-to-k", "solutions": ["class Solution:\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\n        ans = 0\n        for i in range(len(nums)):\n            g = 0\n            for x in nums[i:]:\n                g = gcd(g, x)\n                ans += g == k\n        return ans\n", "class Solution:\n  def subarrayGCD(self, nums: list[int], k: int) -> int:\n    ans = 0\n    gcds = collections.Counter()\n\n    for num in nums:\n      if num % k == 0:\n        nextGcds = collections.defaultdict(int)\n        nextGcds[num] += 1\n        for prevGcd, count in gcds.items():\n          nextGcds[math.gcd(prevGcd, num)] += count\n        ans += nextGcds.get(k, 0)\n        gcds = nextGcds\n      else:\n        # The GCD streak stops, so fresh start from the next number.\n        gcds.clear()\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2407, "slug": "longest-increasing-subsequence-ii", "solutions": ["class Node:\n    def __init__(self):\n        self.l = 0\n        self.r = 0\n        self.v = 0\n\n\nclass SegmentTree:\n    def __init__(self, n):\n        self.tr = [Node() for _ in range(4 * n)]\n        self.build(1, 1, n)\n\n    def build(self, u, l, r):\n        self.tr[u].l = l\n        self.tr[u].r = r\n        if l == r:\n            return\n        mid = (l + r) >> 1\n        self.build(u << 1, l, mid)\n        self.build(u << 1 | 1, mid + 1, r)\n\n    def modify(self, u, x, v):\n        if self.tr[u].l == x and self.tr[u].r == x:\n            self.tr[u].v = v\n            return\n        mid = (self.tr[u].l + self.tr[u].r) >> 1\n        if x <= mid:\n            self.modify(u << 1, x, v)\n        else:\n            self.modify(u << 1 | 1, x, v)\n        self.pushup(u)\n\n    def pushup(self, u):\n        self.tr[u].v = max(self.tr[u << 1].v, self.tr[u << 1 | 1].v)\n\n    def query(self, u, l, r):\n        if self.tr[u].l >= l and self.tr[u].r <= r:\n            return self.tr[u].v\n        mid = (self.tr[u].l + self.tr[u].r) >> 1\n        v = 0\n        if l <= mid:\n            v = self.query(u << 1, l, r)\n        if r > mid:\n            v = max(v, self.query(u << 1 | 1, l, r))\n        return v\n\n\nclass Solution:\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\n        tree = SegmentTree(max(nums))\n        ans = 1\n        for v in nums:\n            t = tree.query(1, v - k, v - 1) + 1\n            ans = max(ans, t)\n            tree.modify(1, v, t)\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2481, "slug": "minimum-cuts-to-divide-a-circle", "solutions": ["class Solution:\n    def numberOfCuts(self, n: int) -> int:\n        return n if (n > 1 and n & 1) else n >> 1\n", "class Solution:\n  def numberOfCuts(self, n: int) -> int:\n    if n == 1:\n      return 0\n    return n // 2 if n % 2 == 0 else n\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2422, "slug": "merge-operations-to-turn-array-into-a-palindrome", "solutions": ["class Solution:\n    def minimumOperations(self, nums: List[int]) -> int:\n        i, j = 0, len(nums) - 1\n        a, b = nums[i], nums[j]\n        ans = 0\n        while i < j:\n            if a < b:\n                i += 1\n                a += nums[i]\n                ans += 1\n            elif b < a:\n                j -= 1\n                b += nums[j]\n                ans += 1\n            else:\n                i, j = i + 1, j - 1\n                a, b = nums[i], nums[j]\n        return ans\n", "class Solution:\n  def minimumOperations(self, nums: list[int]) -> int:\n    ans = 0\n    l = 0\n    r = len(nums) - 1\n    leftSum = nums[0]\n    rightSum = nums[-1]\n\n    while l < r:\n      if leftSum < rightSum:\n        l += 1\n        leftSum += nums[l]\n        ans += 1\n      elif leftSum > rightSum:\n        r -= 1\n        rightSum += nums[r]\n        ans += 1\n      else:  # leftSum == rightSum\n        l += 1\n        r -= 1\n        leftSum = nums[l]\n        rightSum = nums[r]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2444, "slug": "count-subarrays-with-fixed-bounds", "solutions": ["class Solution:\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\n        j1 = j2 = k = -1\n        ans = 0\n        for i, v in enumerate(nums):\n            if v < minK or v > maxK:\n                k = i\n            if v == minK:\n                j1 = i\n            if v == maxK:\n                j2 = i\n            ans += max(0, min(j1, j2) - k)\n        return ans\n", "class Solution:\n  def countSubarrays(self, nums: list[int], minK: int, maxK: int) -> int:\n    ans = 0\n    j = -1\n    prevMinKIndex = -1\n    prevMaxKIndex = -1\n\n    for i, num in enumerate(nums):\n      if num < minK or num > maxK:\n        j = i\n      if num == minK:\n        prevMinKIndex = i\n      if num == maxK:\n        prevMaxKIndex = i\n      # Any index k in [j + 1, min(prevMinKIndex, prevMaxKIndex)] can be the\n      # start of the subarray s.t. nums[k..i] satisfies the conditions.\n      ans += max(0, min(prevMinKIndex, prevMaxKIndex) - j)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2408, "slug": "design-sql", "solutions": ["class SQL:\n    def __init__(self, names: List[str], columns: List[int]):\n        self.tables = defaultdict(list)\n\n    def insertRow(self, name: str, row: List[str]) -> None:\n        self.tables[name].append(row)\n\n    def deleteRow(self, name: str, rowId: int) -> None:\n        pass\n\n    def selectCell(self, name: str, rowId: int, columnId: int) -> str:\n        return self.tables[name][rowId - 1][columnId - 1]\n\n\n# Your SQL object will be instantiated and called as such:\n# obj = SQL(names, columns)\n# obj.insertRow(name,row)\n# obj.deleteRow(name,rowId)\n# param_3 = obj.selectCell(name,rowId,columnId)\n", "class SQL:\n  def __init__(self, names: list[str], columns: list[int]):\n    self.db: dict[str, list[list[str]]] = collections.defaultdict(list)\n\n  def insertRow(self, name: str, row: list[str]) -> None:\n    self.db[name].append(row)\n\n  def deleteRow(self, name: str, rowId: int) -> None:\n    pass\n\n  def selectCell(self, name: str, rowId: int, columnId: int) -> str:\n    return self.db[name][rowId - 1][columnId - 1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2467, "slug": "most-profitable-path-in-a-tree", "solutions": ["class Solution:\n    def mostProfitablePath(\n        self, edges: List[List[int]], bob: int, amount: List[int]\n    ) -> int:\n        def dfs1(i, fa, t):\n            if i == 0:\n                ts[i] = min(ts[i], t)\n                return True\n            for j in g[i]:\n                if j != fa and dfs1(j, i, t + 1):\n                    ts[j] = min(ts[j], t + 1)\n                    return True\n            return False\n\n        def dfs2(i, fa, t, v):\n            if t == ts[i]:\n                v += amount[i] // 2\n            elif t < ts[i]:\n                v += amount[i]\n            nonlocal ans\n            if len(g[i]) == 1 and g[i][0] == fa:\n                ans = max(ans, v)\n                return\n            for j in g[i]:\n                if j != fa:\n                    dfs2(j, i, t + 1, v)\n\n        n = len(edges) + 1\n        g = defaultdict(list)\n        ts = [n] * n\n        for a, b in edges:\n            g[a].append(b)\n            g[b].append(a)\n        dfs1(bob, -1, 0)\n        ts[bob] = 0\n        ans = -inf\n        dfs2(0, -1, 0, 0)\n        return ans\n", "class Solution:\n  def mostProfitablePath(\n      self,\n      edges: list[list[int]],\n      bob: int,\n      amount: list[int],\n  ) -> int:\n    n = len(amount)\n    tree = [[] for _ in range(n)]\n    parent = [0] * n\n    aliceDist = [-1] * n\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    # Fills `parent` and `aliceDist`.\n    def dfs(u: int, prev: int, d: int) -> None:\n      parent[u] = prev\n      aliceDist[u] = d\n      for v in tree[u]:\n        if aliceDist[v] == -1:\n          dfs(v, u, d + 1)\n\n    dfs(0, -1, 0)\n\n    # Modify amount athe path from node bob to node 0.\n    # For each node,\n    #   1. If Bob reaches earlier than Alice does, change the amount to 0.\n    #   2. If Bob and Alice reach simultaneously, devide the amount by 2.\n    u = bob\n    bobDist = 0\n    while u != 0:\n      if bobDist < aliceDist[u]:\n        amount[u] = 0\n      elif bobDist == aliceDist[u]:\n        amount[u] //= 2\n      u = parent[u]\n      bobDist += 1\n\n    return self._getMoney(tree, 0, -1, amount)\n\n  def _getMoney(\n      self,\n      tree: list[list[int]],\n      u: int,\n      prev: int,\n      amount: list[int],\n  ) -> int:\n    # a leaf node\n    if len(tree[u]) == 1 and tree[u][0] == prev:\n      return amount[u]\n\n    maxPath = -math.inf\n    for v in tree[u]:\n      if v != prev:\n        maxPath = max(maxPath, self._getMoney(tree, v, u, amount))\n\n    return amount[u] + maxPath\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2488, "slug": "count-subarrays-with-median-k", "solutions": ["class Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        i = nums.index(k)\n        cnt = Counter()\n        ans = 1\n        x = 0\n        for v in nums[i + 1 :]:\n            x += 1 if v > k else -1\n            ans += 0 <= x <= 1\n            cnt[x] += 1\n        x = 0\n        for j in range(i - 1, -1, -1):\n            x += 1 if nums[j] > k else -1\n            ans += 0 <= x <= 1\n            ans += cnt[-x] + cnt[-x + 1]\n        return ans\n", "class Solution:\n  def countSubarrays(self, nums: list[int], k: int) -> int:\n    INDEX = nums.index(k)\n    ans = 0\n    count = collections.Counter()\n\n    balance = 0\n    for i in range(INDEX, -1, -1):\n      if nums[i] < k:\n        balance -= 1\n      elif nums[i] > k:\n        balance += 1\n      count[balance] += 1\n\n    balance = 0\n    for i in range(INDEX, len(nums)):\n      if nums[i] < k:\n        balance -= 1\n      elif nums[i] > k:\n        balance += 1\n      # The subarray that has balance == 0 or 1 having median equal to k.\n      # So, add count[0 - balance] and count[1 - balance] to `ans`.\n      ans += count[-balance] + count[1 - balance]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2465, "slug": "number-of-distinct-averages", "solutions": ["class Solution:\n    def distinctAverages(self, nums: List[int]) -> int:\n        nums.sort()\n        return len(set(nums[i] + nums[-i - 1] for i in range(len(nums) >> 1)))\n", "class Solution:\n  def distinctAverages(self, nums: list[int]) -> int:\n    n = len(nums)\n    sums = set()\n\n    nums.sort()\n\n    for i in range(n // 2):\n      sums.add(nums[i] + nums[n - 1 - i])\n\n    return len(sums)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2429, "slug": "minimize-xor", "solutions": ["class Solution:\n    def minimizeXor(self, num1: int, num2: int) -> int:\n        cnt = num2.bit_count()\n        x = 0\n        for i in range(30, -1, -1):\n            if num1 >> i & 1 and cnt:\n                x |= 1 << i\n                cnt -= 1\n        for i in range(30):\n            if num1 >> i & 1 ^ 1 and cnt:\n                x |= 1 << i\n                cnt -= 1\n        return x\n", "class Solution:\n  def minimizeXor(self, num1: int, num2: int) -> int:\n    MAX_BIT = 30\n    bits = num2.bit_count()\n    # Can turn off all the bits in `num1`.\n    if num1.bit_count() == bits:\n      return num1\n\n    ans = 0\n\n    # Turn off the MSB if we have `bits` quota.\n    for i in reversed(range(MAX_BIT)):\n      if num1 >> i & 1:\n        ans |= 1 << i\n        bits -= 1\n        if bits == 0:\n          return ans\n\n    # Turn on the LSB if we still have `bits`.\n    for i in range(MAX_BIT):\n      if (num1 >> i & 1) == 0:\n        ans |= 1 << i\n        bits -= 1\n        if bits == 0:\n          return ans\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2420, "slug": "find-all-good-indices", "solutions": ["class Solution:\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        decr = [1] * (n + 1)\n        incr = [1] * (n + 1)\n        for i in range(2, n - 1):\n            if nums[i - 1] <= nums[i - 2]:\n                decr[i] = decr[i - 1] + 1\n        for i in range(n - 3, -1, -1):\n            if nums[i + 1] <= nums[i + 2]:\n                incr[i] = incr[i + 1] + 1\n        return [i for i in range(k, n - k) if decr[i] >= k and incr[i] >= k]\n", "class Solution:\n  # Same as 2100. Find Good Days to Rob the Bank\n  def goodIndices(self, nums: list[int], k: int) -> list[int]:\n    n = len(nums)\n    dec = [1] * n  # 1 + the number of continuous decreasing numbers before i\n    inc = [1] * n  # 1 + the number of continuous increasing numbers after i\n\n    for i in range(1, n):\n      if nums[i - 1] >= nums[i]:\n        dec[i] = dec[i - 1] + 1\n\n    for i in range(n - 2, -1, -1):\n      if nums[i] <= nums[i + 1]:\n        inc[i] = inc[i + 1] + 1\n\n    return [i for i in range(k, n - k)\n            if dec[i - 1] >= k and inc[i + 1] >= k]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2460, "slug": "apply-operations-to-an-array", "solutions": ["class Solution:\n    def applyOperations(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        for i in range(n - 1):\n            if nums[i] == nums[i + 1]:\n                nums[i] <<= 1\n                nums[i + 1] = 0\n        ans = [0] * n\n        i = 0\n        for x in nums:\n            if x:\n                ans[i] = x\n                i += 1\n        return ans\n", "class Solution:\n  def applyOperations(self, nums: list[int]) -> list[int]:\n    j = 0\n    for i in range(len(nums)):\n      if i + 1 < len(nums) and nums[i] == nums[i + 1]:\n        nums[i] *= 2\n        nums[i + 1] = 0\n      if nums[i] > 0:\n        nums[i], nums[j] = nums[j], nums[i]\n        j += 1\n    return nums\n", "class Solution:\n  def applyOperations(self, nums: list[int]) -> list[int]:\n    ans = [0] * len(nums)\n\n    for i in range(len(nums) - 1):\n      if nums[i] == nums[i + 1]:\n        nums[i] *= 2\n        nums[i + 1] = 0\n\n    i = 0\n    for num in nums:\n      if num > 0:\n        ans[i] = num\n        i += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2489, "slug": "number-of-substrings-with-fixed-ratio", "solutions": ["class Solution:\n    def fixedRatio(self, s: str, num1: int, num2: int) -> int:\n        n0 = n1 = 0\n        ans = 0\n        cnt = Counter({0: 1})\n        for c in s:\n            n0 += c == '0'\n            n1 += c == '1'\n            x = n1 * num1 - n0 * num2\n            ans += cnt[x]\n            cnt[x] += 1\n        return ans\n", "class Solution:\n  def fixedRatio(self, s: str, num1: int, num2: int) -> int:\n    # Let x := the number of 0s and y := the number of 1s in the subarray.\n    # We want x : y = num1 : num2, so our goal is to find number of subarrays\n    # with x * num2 - y * num1 = 0. To achieve this, we can use a prefix count\n    # map to record the count of the running x * num2 - y * num1. If the\n    # running x * num2 - y * num1 = prefix, then add count[prefix] to the\n    # `ans`.\n    ans = 0\n    prefix = 0\n    prefixCount = collections.Counter({0: 1})\n\n    for c in s:\n      if c == '0':\n        prefix += num2\n      else:  # c == '1'\n        prefix -= num1\n      ans += prefixCount[prefix]\n      prefixCount[prefix] += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2482, "slug": "difference-between-ones-and-zeros-in-row-and-column", "solutions": ["class Solution:\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\n        m, n = len(grid), len(grid[0])\n        rows = [0] * m\n        cols = [0] * n\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                rows[i] += v\n                cols[j] += v\n        diff = [[0] * n for _ in range(m)]\n        for i, r in enumerate(rows):\n            for j, c in enumerate(cols):\n                diff[i][j] = r + c - (n - r) - (m - c)\n        return diff\n", "class Solution:\n  def onesMinusZeros(self, grid: list[list[int]]) -> list[list[int]]:\n    m = len(grid)\n    n = len(grid[0])\n    ans = [[0] * n for _ in range(m)]\n    onesRow = [row.count(1) for row in grid]\n    onesCol = [col.count(1) for col in zip(*grid)]\n\n    for i in range(m):\n      for j in range(n):\n        ans[i][j] = (onesRow[i] + onesCol[j] -\n                     (n - onesRow[i]) - (m - onesCol[j]))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2442, "slug": "count-number-of-distinct-integers-after-reverse-operations", "solutions": ["class Solution:\n    def countDistinctIntegers(self, nums: List[int]) -> int:\n        s = set(nums)\n        for x in nums:\n            y = int(str(x)[::-1])\n            s.add(y)\n        return len(s)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2476, "slug": "closest-nodes-queries-in-a-binary-search-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def closestNodes(\n        self, root: Optional[TreeNode], queries: List[int]\n    ) -> List[List[int]]:\n        def dfs(root: Optional[TreeNode]):\n            if root is None:\n                return\n            dfs(root.left)\n            nums.append(root.val)\n            dfs(root.right)\n\n        nums = []\n        dfs(root)\n        ans = []\n        for x in queries:\n            i = bisect_left(nums, x + 1) - 1\n            j = bisect_left(nums, x)\n            mi = nums[i] if 0 <= i < len(nums) else -1\n            mx = nums[j] if 0 <= j < len(nums) else -1\n            ans.append([mi, mx])\n        return ans\n", "class Solution:\n  def closestNodes(self, root: TreeNode | None, queries: list[int]) -> list[list[int]]:\n    sortedVals = []\n    self._inorder(root, sortedVals)\n\n    def getClosestPair(query: int) -> list[int]:\n      i = bisect_left(sortedVals, query)\n      # query is presented in the tree, so just use [query, query].\n      if i != len(sortedVals) and sortedVals[i] == query:\n        return [query, query]\n      # query isn't presented in the tree, so find the cloest one if possible.\n      return [-1 if i == 0 else sortedVals[i - 1],\n              -1 if i == len(sortedVals) else sortedVals[i]]\n\n    return [getClosestPair(query) for query in queries]\n\n  def _inorder(self, root: TreeNode | None, sortedVals: list[int]) -> None:\n    \"\"\"Walks the BST to collect the sorted numbers.\"\"\"\n    if not root:\n      return\n    self._inorder(root.left, sortedVals)\n    sortedVals.append(root.val)\n    self._inorder(root.right, sortedVals)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2405, "slug": "optimal-partition-of-string", "solutions": ["class Solution:\n    def partitionString(self, s: str) -> int:\n        ans, mask = 1, 0\n        for x in map(lambda c: ord(c) - ord(\"a\"), s):\n            if mask >> x & 1:\n                ans += 1\n                mask = 0\n            mask |= 1 << x\n        return ans\n", "class Solution:\n  def partitionString(self, s: str) -> int:\n    ans = 1\n    used = 0\n\n    for c in s:\n      i = ord(c) - ord('a')\n      if used >> i & 1:\n        used = 1 << i\n        ans += 1\n      else:\n        used |= 1 << i\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2452, "slug": "words-within-two-edits-of-dictionary", "solutions": ["class Solution:\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\n        ans = []\n        for s in queries:\n            for t in dictionary:\n                if sum(a != b for a, b in zip(s, t)) < 3:\n                    ans.append(s)\n                    break\n        return ans\n", "class Solution:\n  def twoEditWords(\n      self,\n      queries: list[str],\n      dictionary: list[str],\n  ) -> list[str]:\n    return [query for query in queries\n            if any(sum(a != b for a, b in zip(query, word)) < 3\n                   for word in dictionary)]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2448, "slug": "minimum-cost-to-make-array-equal", "solutions": ["class Solution:\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\n        arr = sorted(zip(nums, cost))\n        n = len(arr)\n        f = [0] * (n + 1)\n        g = [0] * (n + 1)\n        for i in range(1, n + 1):\n            a, b = arr[i - 1]\n            f[i] = f[i - 1] + a * b\n            g[i] = g[i - 1] + b\n        ans = inf\n        for i in range(1, n + 1):\n            a = arr[i - 1][0]\n            l = a * g[i - 1] - f[i - 1]\n            r = f[n] - f[i] - a * (g[n] - g[i])\n            ans = min(ans, l + r)\n        return ans\n", "class Solution:\n  def minCost(self, nums: list[int], cost: list[int]) -> int:\n    ans = 0\n    l = min(nums)\n    r = max(nums)\n\n    def getCost(target: int) -> int:\n      return sum(abs(num - target) * c for num, c in zip(nums, cost))\n\n    while l < r:\n      m = (l + r) // 2\n      cost1 = getCost(m)\n      cost2 = getCost(m + 1)\n      ans = min(cost1, cost2)\n      if cost1 < cost2:\n        r = m\n      else:\n        l = m + 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2433, "slug": "find-the-original-array-of-prefix-xor", "solutions": ["class Solution:\n    def findArray(self, pref: List[int]) -> List[int]:\n        return [a ^ b for a, b in pairwise([0] + pref)]\n", "class Solution:\n  def findArray(self, pref: list[int]) -> list[int]:\n    ans = [0] * len(pref)\n\n    ans[0] = pref[0]\n    for i in range(1, len(ans)):\n      ans[i] = pref[i] ^ pref[i - 1]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2423, "slug": "remove-letter-to-equalize-frequency", "solutions": ["class Solution:\n    def equalFrequency(self, word: str) -> bool:\n        cnt = Counter(word)\n        for c in cnt.keys():\n            cnt[c] -= 1\n            if len(set(v for v in cnt.values() if v)) == 1:\n                return True\n            cnt[c] += 1\n        return False\n", "class Solution:\n  def equalFrequency(self, word: str) -> bool:\n    count = collections.Counter(word)\n\n    # Try to remove each letter, then check if the frequency of all the letters\n    # in `word` are equal.\n    for c in word:\n      count[c] -= 1\n      if count[c] == 0:\n        del count[c]\n      if min(count.values()) == max(count.values()):\n        return True\n      count[c] += 1\n\n    return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2426, "slug": "number-of-pairs-satisfying-inequality", "solutions": ["class BinaryIndexedTree:\n    def __init__(self, n):\n        self.n = n\n        self.c = [0] * (n + 1)\n\n    @staticmethod\n    def lowbit(x):\n        return x & -x\n\n    def update(self, x, delta):\n        while x <= self.n:\n            self.c[x] += delta\n            x += BinaryIndexedTree.lowbit(x)\n\n    def query(self, x):\n        s = 0\n        while x:\n            s += self.c[x]\n            x -= BinaryIndexedTree.lowbit(x)\n        return s\n\n\nclass Solution:\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\n        tree = BinaryIndexedTree(10**5)\n        ans = 0\n        for a, b in zip(nums1, nums2):\n            v = a - b\n            ans += tree.query(v + diff + 40000)\n            tree.update(v + 40000, 1)\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2466, "slug": "count-ways-to-build-good-strings", "solutions": ["class Solution:\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\n        @cache\n        def dfs(i):\n            if i > high:\n                return 0\n            ans = 0\n            if low <= i <= high:\n                ans += 1\n            ans += dfs(i + zero) + dfs(i + one)\n            return ans % mod\n\n        mod = 10**9 + 7\n        return dfs(0)\n", "class Solution:\n  def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    # dp[i] := the number of good strings with length i\n    dp = [1] + [0] * high\n\n    for i in range(1, high + 1):\n      if i >= zero:\n        dp[i] = (dp[i] + dp[i - zero]) % MOD\n      if i >= one:\n        dp[i] = (dp[i] + dp[i - one]) % MOD\n      if i >= low:\n        ans = (ans + dp[i]) % MOD\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2455, "slug": "average-value-of-even-numbers-that-are-divisible-by-three", "solutions": ["class Solution:\n    def averageValue(self, nums: List[int]) -> int:\n        s = n = 0\n        for x in nums:\n            if x % 6 == 0:\n                s += x\n                n += 1\n        return 0 if n == 0 else s // n\n", "class Solution:\n  def averageValue(self, nums: list[int]) -> int:\n    summ = 0\n    count = 0\n\n    for num in nums:\n      if num % 6 == 0:\n        summ += num\n        count += 1\n\n    return 0 if count == 0 else summ // count\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2411, "slug": "smallest-subarrays-with-maximum-bitwise-or", "solutions": ["class Solution:\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        ans = [1] * n\n        f = [-1] * 32\n        for i in range(n - 1, -1, -1):\n            t = 1\n            for j in range(32):\n                if (nums[i] >> j) & 1:\n                    f[j] = i\n                elif f[j] != -1:\n                    t = max(t, f[j] - i + 1)\n            ans[i] = t\n        return ans\n", "class Solution:\n  def smallestSubarrays(self, nums: list[int]) -> list[int]:\n    MAX_BIT = 30\n    ans = [1] * len(nums)\n    # closest[j] := the closest index i s.t. the j-th bit of nums[i] is 1\n    closest = [0] * MAX_BIT\n\n    for i in reversed(range(len(nums))):\n      for j in range(MAX_BIT):\n        if nums[i] >> j & 1:\n          closest[j] = i\n        ans[i] = max(ans[i], closest[j] - i + 1)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3473, "slug": "sum-of-k-subarrays-with-length-at-least-m", "solutions": ["class Solution:\n  def maxSum(self, nums: list[int], k: int, m: int) -> int:\n    INF = 20_000_000\n    n = len(nums)\n    prefix = list(itertools.accumulate(nums, initial=0))\n\n    @functools.lru_cache(None)\n    def dp(i: int, ongoing: int, k: int) -> int:\n      if k < 0:\n        return -INF\n      if i == n:\n        return 0 if k == 0 else -INF\n      if ongoing == 1:\n        # 1. End the current subarray (transition to state 0, same index i)\n        # 2. Extend the current subarray by picking nums[i] and move to i + 1\n        return max(dp(i, 0, k),\n                   dp(i + 1, 1, k) + nums[i])\n      # ongoing == 0\n      # 1. Skip nums[i]\n      # 2. Pick nums[i:i+m] (only if k > 0 and there're enough elements)\n      res = dp(i + 1, 0, k)\n      if i + m <= n:  # If we have enough elements for a new segment\n        res = max(res,\n                  dp(i + m, 1, k - 1) + (prefix[i + m] - prefix[i]))\n      return res\n\n    return dp(0, 0, k)\n", "class Solution:\n  def maxSum(self, nums: list[int], k: int, m: int) -> int:\n    INF = 20_000_000\n    n = len(nums)\n    prefix = list(itertools.accumulate(nums, initial=0))\n\n    # dp[i][ongoing][r] := the maximum sum of nums[i:], with `ongoing`\n    # indicating if a subarray is currently being extended (1) or not (0),\n    # and `r` segments left to choose\n    dp = [[[-INF] * (k + 1) for _ in range(2)] for _ in range(n + 1)]\n\n    # Base case: At the end of the array, if no segments are left, score is 0\n    dp[n][0][0] = dp[n][1][0] = 0\n\n    for i in range(n - 1, -1, -1):\n      for rem in range(k + 1):\n        # When no subarray is ongoing:\n        # 1. Skip nums[i]\n        dp[i][0][rem] = dp[i + 1][0][rem]\n        # 2. Start a new segment of length m (only if rem > 0 and there're enough elements)\n        if rem > 0 and i + m <= n:\n          dp[i][0][rem] = max(\n              dp[i][0][rem],\n              dp[i + m][1][rem - 1] + (prefix[i + m] - prefix[i]))\n        # When a subarray is ongoing:\n        # 1. End the current subarray (transition to state 0, same index i)\n        # 2. Extend the current subarray by picking nums[i] and move to i + 1\n        dp[i][1][rem] = max(dp[i][0][rem], dp[i + 1][1][rem] + nums[i])\n\n    return dp[0][0][k]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3430, "slug": "maximum-and-minimum-sums-of-at-most-size-k-subarrays", "solutions": ["class Solution:\n  # Similar to 2104. Sum of Subarray Ranges\n  def minMaxSubarraySum(self, nums: list[int], k: int) -> int:\n    prevGt, nextGt = self._getPrevNext(nums, operator.lt)\n    prevLt, nextLt = self._getPrevNext(nums, operator.gt)\n    return (self._subarraySum(nums, prevGt, nextGt, k) +\n            self._subarraySum(nums, prevLt, nextLt, k))\n\n  def _subarraySum(\n      self,\n      nums: list[int],\n      prev: list[int],\n      next: list[int],\n      k: int\n  ) -> int:\n    \"\"\"\n    Returns the sum of all subarrays with a size <= k, The `prev` and `next`\n    arrays are used to store the indices of the nearest numbers that are\n    smaller or larger than the current number, respectively.\n    \"\"\"\n    res = 0\n    for i, num in enumerate(nums):\n      l = min(i - prev[i], k)\n      r = min(next[i] - i, k)\n      extra = max(0, l + r - 1 - k)\n      res += num * (l * r - extra * (extra + 1) // 2)\n    return res\n\n  def _getPrevNext(\n      self,\n      nums: list[int],\n      op: callable\n  ) -> tuple[list[int], list[int]]:\n    \"\"\"\n    Returns `prev` and `next`, that store the indices of the nearest numbers\n    that are smaller or larger than the current number depending on `op`.\n    \"\"\"\n    n = len(nums)\n    prev = [-1] * n\n    next = [n] * n\n    stack = []\n    for i, num in enumerate(nums):\n      while stack and op(nums[stack[-1]], num):\n        index = stack.pop()\n        next[index] = i\n      if stack:\n        prev[i] = stack[-1]\n      stack.append(i)\n    return prev, next\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3466, "slug": "maximum-coin-collection", "solutions": ["class Solution:\n    def maxCoins(self, lane1: List[int], lane2: List[int]) -> int:\n        @cache\n        def dfs(i: int, j: int, k: int) -> int:\n            if i >= n:\n                return 0\n            x = lane1[i] if j == 0 else lane2[i]\n            ans = max(x, dfs(i + 1, j, k) + x)\n            if k > 0:\n                ans = max(ans, dfs(i + 1, j ^ 1, k - 1) + x)\n                ans = max(ans, dfs(i, j ^ 1, k - 1))\n            return ans\n\n        n = len(lane1)\n        ans = -inf\n        for i in range(n):\n            ans = max(ans, dfs(i, 0, 2))\n        return ans\n", "class Solution:\n  def maxCoins(self, lane1: list[int], lane2: list[int]) -> int:\n    # dp[k] := the maximum number of coins at mile so far with k switches\n    dp = (lane1[0], lane2[0], -math.inf)\n    ans = max(dp)\n\n    for i in range(1, len(lane1)):\n      dp = (max(0, dp[0]) + lane1[i],\n            max(0, dp[0], dp[1]) + lane2[i],\n            max(dp[1], dp[2]) + lane1[i])\n      ans = max(ans, max(dp))\n\n    return ans\n", "class Solution:\n  def maxCoins(self, lane1: list[int], lane2: list[int]) -> int:\n    n = len(lane1)\n    # dp[i][k] := the maximum number of coins at i-th mile with k switches\n    dp = [[-math.inf] * 3 for _ in range(n)]\n    dp[0][0] = lane1[0]\n    dp[0][1] = lane2[0]\n\n    for i in range(1, n):\n      dp[i][0] = max(0, dp[i - 1][0]) + lane1[i]\n      dp[i][1] = max(0, dp[i - 1][0], dp[i - 1][1]) + lane2[i]\n      dp[i][2] = max(dp[i - 1][1], dp[i - 1][2]) + lane1[i]\n\n    return max(map(max, dp))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3419, "slug": "minimize-the-maximum-edge-weight-of-graph", "solutions": ["class Solution:\n  def minMaxWeight(self, n: int, edges: list[list[int]], threshold: int) -> int:\n    MAX = 1000000\n    reversedGraph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      reversedGraph[v].append((u, w))\n\n    l = 1\n    r = MAX + 1\n\n    while l < r:\n      m = (l + r) // 2\n      if self._dfs(reversedGraph, 0, m, set()) == n:\n        r = m\n      else:\n        l = m + 1\n\n    return -1 if l == MAX + 1 else l\n\n  def _dfs(\n      self,\n      reversedGraph: list[list[tuple]],\n      u: int,\n      maxWeight: int,\n      seen: set[int]\n  ) -> int:\n    \"\"\"Returns the number of nodes reachable from u with weight <= maxWeight.\"\"\"\n    res = 1\n    seen.add(u)\n    for v, w in reversedGraph[u]:\n      if w > maxWeight or v in seen:\n        continue\n      res += self._dfs(reversedGraph, v, maxWeight, seen)\n    return res\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3486, "slug": "longest-special-path-ii", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3410, "slug": "maximize-subarray-sum-after-removing-all-occurrences-of-one-element", "solutions": ["class Solution:\n  def maxSubarraySum(self, nums: list[int]) -> int:\n    ans = max(nums)\n    prefix = 0\n    minPrefix = 0\n    # the minimum prefix sum that can have a negative number removed\n    modifiedMinPrefix = 0\n    count = collections.Counter()\n    # minPrefixPlusRemoval[num] := the minimum prefix sum plus removed `num`\n    minPrefixPlusRemoval = {}\n\n    for num in nums:\n      prefix += num\n      ans = max(ans, prefix - modifiedMinPrefix)\n      if num < 0:\n        count[num] += 1\n        minPrefixPlusRemoval[num] = (\n            min(minPrefixPlusRemoval.get(num, 0), minPrefix) + num)\n        modifiedMinPrefix = min(modifiedMinPrefix,\n                                count[num] * num,\n                                minPrefixPlusRemoval[num])\n      minPrefix = min(minPrefix, prefix)\n      modifiedMinPrefix = min(modifiedMinPrefix, minPrefix)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3468, "slug": "find-the-number-of-copy-arrays", "solutions": ["class Solution:\n  def countArrays(self, original: List[int], bounds: List[List[int]]) -> int:\n    mn, mx = bounds[0]\n\n    for i in range(1, len(original)):\n      diff = original[i] - original[i - 1]\n      mn = max(mn + diff, bounds[i][0])\n      mx = min(mx + diff, bounds[i][1])\n\n    return max(0, mx - mn + 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3487, "slug": "maximum-unique-subarray-sum-after-deletion", "solutions": ["class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        mx = max(nums)\n        if mx <= 0:\n            return mx\n        ans = 0\n        s = set()\n        for x in nums:\n            if x < 0 or x in s:\n                continue\n            ans += x\n            s.add(x)\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3488, "slug": "closest-equal-element-queries", "solutions": ["class Solution:\n    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        m = n << 1\n        d = [m] * m\n        left = {}\n        for i in range(m):\n            x = nums[i % n]\n            if x in left:\n                d[i] = min(d[i], i - left[x])\n            left[x] = i\n        right = {}\n        for i in range(m - 1, -1, -1):\n            x = nums[i % n]\n            if x in right:\n                d[i] = min(d[i], right[x] - i)\n            right[x] = i\n        for i in range(n):\n            d[i] = min(d[i], d[i + n])\n        return [-1 if d[i] >= n else d[i] for i in queries]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3445, "slug": "maximum-difference-between-even-and-odd-frequency-ii", "solutions": ["class Solution:\n  def maxDifference(self, s: str, k: int) -> int:\n    ans = -math.inf\n    permutations = [(a, b) for a in '01234' for b in '01234' if a != b]\n\n    for a, b in permutations:\n      # minDiff[(parityA, parityB)] := min(a - b) of all valid windows with\n      # parityA and parityB\n      minDiff = collections.defaultdict(lambda: math.inf)\n      prefixA = [0]  # prefixA[i] := the number of 'a's in s[0..i)\n      prefixB = [0]  # prefixB[i] := the number of 'b's in s[0..i)\n\n      l = 0\n      for r, c in enumerate(s):\n        prefixA.append(prefixA[-1] + int(c == a))\n        prefixB.append(prefixB[-1] + int(c == b))\n        while (r - l + 1 >= k and  # the window size >= k\n               prefixA[l] < prefixA[-1] and  # the number of 'a's > 0\n               prefixB[l] < prefixB[-1]):  # the number of 'b's > 0\n          paritiesKey = (prefixA[l] % 2, prefixB[l] % 2)\n          minDiff[paritiesKey] = min(minDiff[paritiesKey],\n                                     prefixA[l] - prefixB[l])\n          l += 1\n        ans = max(ans, (prefixA[-1] - prefixB[-1]) -\n                  minDiff[(1 - prefixA[-1] % 2, prefixB[-1] % 2)])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3417, "slug": "zigzag-grid-traversal-with-skip", "solutions": ["class Solution:\n    def zigzagTraversal(self, grid: List[List[int]]) -> List[int]:\n        ok = True\n        ans = []\n        for i, row in enumerate(grid):\n            if i % 2:\n                row.reverse()\n            for x in row:\n                if ok:\n                    ans.append(x)\n                ok = not ok\n        return ans\n", "class Solution:\n  def zigzagTraversal(self, grid: list[list[int]]) -> list[int]:\n    zigzag = [row[::-1] if i % 2 else row for i, row in enumerate(grid)]\n    return [num for row in zigzag for num in row][::2]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3429, "slug": "paint-house-iv", "solutions": ["class Solution:\n  def minCost(self, n: int, costs: list[list[int]]) -> int:\n    INVALID_COLOR = 3\n\n    def getValidColors(prevColor: int) -> list[int]:\n      return [color for color in range(3) if color != prevColor]\n\n    @functools.lru_cache(None)\n    def minCost(i: int, prevLeftColor: int, prevRightColor: int) -> int:\n      if i == len(costs) // 2:\n        return 0\n      res = math.inf\n      for leftColor in getValidColors(prevLeftColor):\n        for rightColor in getValidColors(prevRightColor):\n          if leftColor == rightColor:\n            continue\n          leftCost = costs[i][leftColor]\n          rightCost = costs[-1 - i][rightColor]\n          res = min(res, leftCost + rightCost +\n                    minCost(i + 1, leftColor, rightColor))\n      return res\n\n    return minCost(0, INVALID_COLOR, INVALID_COLOR)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3460, "slug": "longest-common-prefix-after-at-most-one-removal", "solutions": ["class Solution:\n    def longestCommonPrefix(self, s: str, t: str) -> int:\n        n, m = len(s), len(t)\n        i = j = 0\n        rem = False\n        while i < n and j < m:\n            if s[i] != t[j]:\n                if rem:\n                    break\n                rem = True\n            else:\n                j += 1\n            i += 1\n        return j\n", "class Solution:\n  def longestCommonPrefix(self, s: str, t: str) -> int:\n    i = 0  # s's index\n    j = 0  # t's index\n    canSkip = True\n\n    while i < len(s) and j < len(t):\n      if s[i] == t[j]:\n        i += 1\n        j += 1\n      elif canSkip:\n        i += 1\n        canSkip = False\n      else:\n        return j\n\n    return j\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3481, "slug": "apply-substitutions", "solutions": ["class Solution:\n    def applySubstitutions(self, replacements: List[List[str]], text: str) -> str:\n        def dfs(s: str) -> str:\n            i = s.find(\"%\")\n            if i == -1:\n                return s\n            j = s.find(\"%\", i + 1)\n            if j == -1:\n                return s\n            key = s[i + 1 : j]\n            replacement = dfs(d[key])\n            return s[:i] + replacement + dfs(s[j + 1 :])\n\n        d = {s: t for s, t in replacements}\n        return dfs(text)\n", "class Solution:\n  def applySubstitutions(self, replacements: list[list[str]], text: str) -> str:\n    replaceMap = {key: value for key, value in replacements}\n\n    def evaluate(text: str) -> str:\n      \"\"\"\n      Evaluates the text and replaces the placeholders with the values\n      from the replace_map recursively.\n      \"\"\"\n      res = []\n      i = 0\n      while i < len(text):\n        if text[i] == '%':\n          j = i + 1 + text[i + 1:].find('%')\n          key = text[i + 1:j]\n          value = replaceMap[key]\n          res.append(evaluate(value))\n          i = j + 1\n        else:\n          res.append(text[i])\n          i += 1\n      return ''.join(res)\n\n    return evaluate(text)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3479, "slug": "fruits-into-baskets-iii", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3448, "slug": "count-substrings-divisible-by-last-digit", "solutions": ["class Solution:\n  def countSubstrings(self, s: str) -> int:\n    ans = 0\n    # dp[i][num][rem] := the number of first `i` digits of s that have a\n    # remainder of `rem` when divided by `num`\n    dp = [[[0] * 10 for _ in range(10)] for _ in range(len(s) + 1)]\n\n    for i in range(1, len(s) + 1):\n      digit = int(s[i - 1])\n      for num in range(1, 10):\n        for rem in range(num):\n          dp[i][num][(rem * 10 + digit) % num] += dp[i - 1][num][rem]\n        dp[i][num][digit % num] += 1\n      ans += dp[i][digit][0]\n\n    return ans\n", "class Solution:\n  def countSubstrings(self, s: str) -> int:\n    ans = 0\n    # dp[num][rem] := the number of substrings so far that have a remainder of\n    # `rem` when divided by `num`\n    dp = [[0] * 10 for _ in range(10)]\n\n    for c in s:\n      digit = int(c)\n      newDp = [[0] * 10 for _ in range(10)]\n      for num in range(1, 10):\n        for rem in range(num):\n          newDp[num][(rem * 10 + digit) % num] += dp[num][rem]\n        newDp[num][digit % num] += 1\n      dp = newDp\n      ans += dp[digit][0]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3491, "slug": "phone-number-prefix", "solutions": ["class Solution:\n    def phonePrefix(self, numbers: List[str]) -> bool:\n        numbers.sort(key=len)\n        for i, s in enumerate(numbers):\n            if any(s.startswith(t) for t in numbers[:i]):\n                return False\n        return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3449, "slug": "maximize-the-minimum-game-score", "solutions": ["class Solution:\n  def maxScore(self, points: list[int], m: int) -> int:\n    def isPossible(minVal: int, m: int) -> bool:\n      \"\"\"\n      Returns True if it is possible to achieve the maximum minimum value `x`\n      with `m` number of moves.\n      \"\"\"\n      moves = 0\n      prevMoves = 0  # to track remaining moves from the previous point\n      for i, point in enumerate(points):\n        required = (minVal + point - 1) // point  # ceil(minVal / point)\n        required = max(0, required - prevMoves)\n        if required > 0:\n          moves += 2 * required - 1\n          prevMoves = required - 1\n        elif i + 1 < len(points):\n          moves += 1\n          prevMoves = 0\n        if moves > m:\n          return False\n      return True\n\n    l = 0\n    r = (m + 1) // 2 * points[0] + 1\n\n    while l < r:\n      mid = (l + r + 1) // 2\n      if isPossible(mid, m):\n        l = mid\n      else:\n        r = mid - 1\n\n    return l\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3495, "slug": "minimum-operations-to-make-array-elements-zero", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3431, "slug": "minimum-unlocked-indices-to-sort-nums", "solutions": ["class Solution:\n    def minUnlockedIndices(self, nums: List[int], locked: List[int]) -> int:\n        n = len(nums)\n        first2 = first3 = n\n        last1 = last2 = -1\n        for i, x in enumerate(nums):\n            if x == 1:\n                last1 = i\n            elif x == 2:\n                first2 = min(first2, i)\n                last2 = i\n            else:\n                first3 = min(first3, i)\n        if first3 < last1:\n            return -1\n        return sum(\n            st and (first2 <= i < last1 or first3 <= i < last2)\n            for i, st in enumerate(locked)\n        )\n", "class Solution:\n  def minUnlockedIndices(self, nums: list[int], locked: list[int]) -> int:\n    first2 = next((i for i, x in enumerate(nums) if x == 2), -1)\n    first3 = next((i for i, x in enumerate(nums) if x == 3), -1)\n    last1 = next((i for i, x in reversed(list(enumerate(nums))) if x == 1), -1)\n    last2 = next((i for i, x in reversed(list(enumerate(nums))) if x == 2), -1)\n    if first3 != -1 and last1 != -1 and first3 < last1:\n      return -1\n    return (sum(locked[i] == 1 for i in range(first2, last1)\n                if first2 != -1 and last1 != -1) +\n            sum(locked[i] == 1 for i in range(first3, last2)\n                if first3 != -1 and last2 != -1))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3459, "slug": "length-of-longest-v-shaped-diagonal-segment", "solutions": ["class Solution:\n    def lenOfVDiagonal(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        next_digit = {1: 2, 2: 0, 0: 2}\n\n        def within_bounds(i, j):\n            return 0 <= i < m and 0 <= j < n\n\n        @cache\n        def f(i, j, di, dj, turned):\n            result = 1\n            successor = next_digit[grid[i][j]]\n\n            if within_bounds(i + di, j + dj) and grid[i + di][j + dj] == successor:\n                result = 1 + f(i + di, j + dj, di, dj, turned)\n\n            if not turned:\n                di, dj = dj, -di\n                if within_bounds(i + di, j + dj) and grid[i + di][j + dj] == successor:\n                    result = max(result, 1 + f(i + di, j + dj, di, dj, True))\n\n            return result\n\n        directions = ((1, 1), (-1, 1), (1, -1), (-1, -1))\n        result = 0\n\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] != 1:\n                    continue\n                for di, dj in directions:\n                    result = max(result, f(i, j, di, dj, False))\n\n        return result\n", "class Solution:\n  def lenOfVDiagonal(self, grid: list[list[int]]) -> int:\n    DIRS = ((-1, 1), (1, 1), (1, -1), (-1, -1))\n\n    @functools.lru_cache(None)\n    def dfs(i: int, j: int, turned: bool, num: int, dir: int) -> int:\n      if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]):\n        return 0\n      if grid[i][j] != num:\n        return 0\n\n      nextNum = 0 if num == 2 else 2\n      dx, dy = DIRS[dir]\n      res = 1 + dfs(i + dx, j + dy, turned, nextNum, dir)\n\n      if not turned:\n        nextDir = (dir + 1) % 4\n        nextDx, nextDy = DIRS[nextDir]\n        res = max(res, 1 + dfs(i + nextDx, j + nextDy, 1, nextNum, nextDir))\n\n      return res\n\n    return max((1 + dfs(i + dx, j + dy, 0, 2, d)\n                for i, row in enumerate(grid)\n                for j, num in enumerate(row)\n                if num == 1\n                for d, (dx, dy) in enumerate(DIRS)),\n               default=0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3442, "slug": "maximum-difference-between-even-and-odd-frequency-i", "solutions": ["class Solution:\n    def maxDifference(self, s: str) -> int:\n        cnt = Counter(s)\n        a, b = 0, inf\n        for v in cnt.values():\n            if v % 2:\n                a = max(a, v)\n            else:\n                b = min(b, v)\n        return a - b\n", "class Solution:\n  def maxDifference(self, s: str) -> int:\n    count = collections.Counter(s)\n    maxOdd = max((freq for freq in count.values()\n                  if freq % 2 == 1), default=0)\n    minEven = min((freq for freq in count.values()\n                   if freq % 2 == 0), default=len(s))\n    return maxOdd - minEven\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3444, "slug": "minimum-increments-for-target-multiples-in-an-array", "solutions": ["class Solution:\n  def minimumIncrements(self, nums: list[int], target: list[int]) -> int:\n    maxMask = 1 << len(target)\n    maskToLcm = {}\n\n    for mask in range(1, maxMask):\n      subset = [num for i, num in enumerate(target) if mask >> i & 1]\n      maskToLcm[mask] = functools.reduce(math.lcm, subset, 1)\n\n    # dp[mask] := the minimum number of increments to make each number in the\n    # subset of target have at least one number that is a multiple in `num`,\n    # where `mask` is the bitmask of the subset of target\n    dp = [math.inf] * maxMask\n    dp[0] = 0\n\n    for num in nums:\n      # maskToCost := (mask, cost), where `mask` is the bitmask of the subset\n      # of target and `cost` is the minimum number of increments to make each\n      # number in the subset of target have at least one number that is a\n      # multiple in `num`\n      maskToCost = [\n          (mask, 0 if (remainder := num % lcm) == 0 else lcm - remainder) for mask,\n          lcm in maskToLcm.items()]\n      newDp = dp[:]\n      for prevMask in range(maxMask):\n        if dp[prevMask] == float('inf'):\n          continue\n        for mask, cost in maskToCost:\n          nextMask = prevMask | mask\n          newDp[nextMask] = min(newDp[nextMask], dp[prevMask] + cost)\n      dp = newDp\n\n    return -1 if dp[-1] == math.inf else dp[-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3413, "slug": "maximum-coins-from-k-consecutive-bags", "solutions": ["class Solution:\n  def maximumCoins(self, coins: list[list[int]], k: int) -> int:\n    return max(self._slide(coins, k),\n               self._slide([[-r, -l, c] for l, r, c in coins], k))\n\n  def _slide(self, coins: list[list[int]], k: int) -> int:\n    coins.sort()\n    res = 0\n    windowSum = 0\n    j = 0\n    for li, ri, ci in coins:  # Consider the number line [li..li + k).\n      rightBoundary = li + k\n\n      # [lj, rj] is fully in [li..li + k).\n      while j + 1 < len(coins) and coins[j + 1][0] < rightBoundary:\n        lj, rj, cj = coins[j]\n        windowSum += (rj - lj + 1) * cj\n        j += 1\n\n      # [lj, rj] may be partially in [l..l + k).\n      last = 0\n      if j < len(coins) and coins[j][0] < rightBoundary:\n        lj, rj, cj = coins[j]\n        last = (min(rightBoundary - 1, rj) - lj + 1) * cj\n\n      res = max(res, windowSum + last)\n      windowSum -= (ri - li + 1) * ci\n    return res\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3407, "slug": "substring-matching-pattern", "solutions": ["class Solution:\n    def hasMatch(self, s: str, p: str) -> bool:\n        i = 0\n        for t in p.split(\"*\"):\n            j = s.find(t, i)\n            if j == -1:\n                return False\n            i = j + len(t)\n        return True\n", "class Solution:\n  def hasMatch(self, s: str, p: str) -> bool:\n    prefix, suffix = p.split('*')\n    i = s.find(prefix)\n    return i != -1 and s.find(suffix, i + len(prefix)) != -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3453, "slug": "separate-squares-i", "solutions": ["class Solution:\n  def separateSquares(self, squares: list[list[int]]) -> float:\n    halfArea = sum((l**2 for _, _, l in squares)) / 2\n    events = sorted([(y, True, l) for _, y, l in squares] +\n                    [(y + l, False, l) for _, y, l in squares])\n    area = 0\n    width = 0\n    prevY = 0\n\n    for y, isStart, l in events:\n      areaGain = width * (y - prevY)\n      if area + areaGain >= halfArea:\n        return prevY + (halfArea - area) / width\n      area += areaGain\n      width += l if isStart else -l\n      prevY = y\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3422, "slug": "minimum-operations-to-make-subarray-elements-equal", "solutions": ["class Solution:\n    def minOperations(self, nums: List[int], k: int) -> int:\n        l = SortedList()\n        r = SortedList()\n        s1 = s2 = 0\n        ans = inf\n        for i, x in enumerate(nums):\n            l.add(x)\n            s1 += x\n            y = l.pop()\n            s1 -= y\n            r.add(y)\n            s2 += y\n            if len(r) - len(l) > 1:\n                y = r.pop(0)\n                s2 -= y\n                l.add(y)\n                s1 += y\n            if i >= k - 1:\n                ans = min(ans, s2 - r[0] * len(r) + r[0] * len(l) - s1)\n                j = i - k + 1\n                if nums[j] in r:\n                    r.remove(nums[j])\n                    s2 -= nums[j]\n                else:\n                    l.remove(nums[j])\n                    s1 -= nums[j]\n        return ans\n", "class Solution:\n  def minOperations(self, nums: list[int], k: int) -> int:\n    window = SortedList(nums[:k])\n    median = window[(k - 1) // 2]\n    ops = sum(abs(median - nums[j]) for j in range(k))\n    ans = ops\n\n    for i in range(k, len(nums)):\n      window.remove(nums[i - k])\n      window.add(nums[i])\n      ops -= abs(median - nums[i - k])\n      ops += abs(median - nums[i])\n      newMedian = window[(k - 1) // 2]\n      medianMultiplier = (\n          2\n          if k % 2 == 0 and median <= newMedian <= window[k // 2]\n          else k % 2)\n      ops -= abs(newMedian - median) * medianMultiplier\n      median = newMedian\n      ans = min(ans, ops)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3458, "slug": "select-k-disjoint-special-substrings", "solutions": ["class Solution:\n  def maxSubstringLength(self, s: str, k: int) -> bool:\n    n = len(s)\n    first = [n] * 26\n    last = [-1] * 26\n    # dp[i] := the maximum disjoint special substrings for the first i letters\n    dp = [0] * (n + 1)\n    seenOrder = []\n\n    for i, c in enumerate(s):\n      a = ord(c) - ord('a')\n      if first[a] == n:\n        first[a] = i\n        seenOrder.append(c)\n      last[a] = i\n\n    for c in seenOrder:\n      a = ord(c) - ord('a')\n      for j in range(first[a], last[a]):\n        b = ord(s[j]) - ord('a')\n        first[a] = min(first[a], first[b])\n        last[a] = max(last[a], last[b])\n\n    for i, c in enumerate(s):\n      a = ord(c) - ord('a')\n      if last[a] != i or (first[a] == 0 and i == n - 1):\n        dp[i + 1] = dp[i]\n      else:  # Start a new special substring.\n        dp[i + 1] = max(dp[i], 1 + dp[first[a]])\n\n    return dp[n] >= k\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3461, "slug": "check-if-digits-are-equal-in-string-after-operations-i", "solutions": ["class Solution:\n    def hasSameDigits(self, s: str) -> bool:\n        t = list(map(int, s))\n        n = len(t)\n        for k in range(n - 1, 1, -1):\n            for i in range(k):\n                t[i] = (t[i] + t[i + 1]) % 10\n        return t[0] == t[1]\n", "class Solution:\n  def hasSameDigits(self, s: str) -> bool:\n    n = len(s)\n    num1 = 0\n    num2 = 0\n\n    for i in range(n - 1):\n      coefficient = self._nCMOD10(n - 2, i)\n      num1 += (coefficient * (int(s[i]) - 0)) % 10\n      num1 %= 10\n      num2 += (coefficient * (int(s[i + 1]) - 0)) % 10\n      num2 %= 10\n\n    return num1 == num2\n\n  def _nCMOD10(self, n: int, k: int) -> int:\n    \"\"\"Returns (n, k) % 10.\"\"\"\n    mod2 = self._lucasTheorem(n, k, 2)\n    mod5 = self._lucasTheorem(n, k, 5)\n    lookup = [\n        [0, 6, 2, 8, 4],  # mod2 == 0\n        [5, 1, 7, 3, 9]   # mod2 == 1\n    ]\n    return lookup[mod2][mod5]\n\n  def _lucasTheorem(self, n: int, k: int, prime: int) -> int:\n    \"\"\"Returns (n, k) % prime.\"\"\"\n    res = 1\n    while n > 0 or k > 0:\n      nMod = n % prime\n      MOD = k % prime\n      res *= math.comb(nMod, MOD)\n      res %= prime\n      n //= prime\n      k //= prime\n    return res\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3471, "slug": "find-the-largest-almost-missing-integer", "solutions": ["class Solution:\n    def largestInteger(self, nums: List[int], k: int) -> int:\n        def f(k: int) -> int:\n            for i, x in enumerate(nums):\n                if i != k and x == nums[k]:\n                    return -1\n            return nums[k]\n\n        if k == 1:\n            cnt = Counter(nums)\n            return max((x for x, v in cnt.items() if v == 1), default=-1)\n        if k == len(nums):\n            return max(nums)\n        return max(f(0), f(len(nums) - 1))\n", "class Solution:\n  def largestInteger(self, nums: list[int], k: int) -> int:\n    if k == len(nums):\n      return max(nums)\n    count = collections.Counter(nums)\n    if k == 1:\n      return max([num for num in nums if count[num] == 1], default=-1)\n    return max(\n        nums[0] if count[nums[0]] == 1 else -1,\n        nums[-1] if count[nums[-1]] == 1 else -1\n    )\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3463, "slug": "check-if-digits-are-equal-in-string-after-operations-ii", "solutions": ["class Solution:\n  # Same as 3461. Check If Digits Are Equal in String After Operations I\n  def hasSameDigits(self, s: str) -> bool:\n    n = len(s)\n    num1 = 0\n    num2 = 0\n\n    for i in range(n - 1):\n      coefficient = self._nCMOD10(n - 2, i)\n      num1 += (coefficient * (int(s[i]) - 0)) % 10\n      num1 %= 10\n      num2 += (coefficient * (int(s[i + 1]) - 0)) % 10\n      num2 %= 10\n\n    return num1 == num2\n\n  def _nCMOD10(self, n: int, k: int) -> int:\n    \"\"\"Returns (n, k) % 10.\"\"\"\n    mod2 = self._lucasTheorem(n, k, 2)\n    mod5 = self._lucasTheorem(n, k, 5)\n    lookup = [\n        [0, 6, 2, 8, 4],  # mod2 == 0\n        [5, 1, 7, 3, 9]   # mod2 == 1\n    ]\n    return lookup[mod2][mod5]\n\n  def _lucasTheorem(self, n: int, k: int, prime: int) -> int:\n    \"\"\"Returns (n, k) % prime.\"\"\"\n    res = 1\n    while n > 0 or k > 0:\n      nMod = n % prime\n      MOD = k % prime\n      res *= math.comb(nMod, MOD)\n      res %= prime\n      n //= prime\n      k //= prime\n    return res\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3414, "slug": "maximum-score-of-non-overlapping-intervals", "solutions": ["from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass T:\n  weight: int\n  selected: tuple[int]\n\n  def __iter__(self):\n    yield self.weight\n    yield self.selected\n\n\nclass Solution:\n  def maximumWeight(self, intervals: list[list[int]]) -> list[int]:\n    intervals = sorted((*interval, i) for i, interval in enumerate(intervals))\n\n    @functools.lru_cache(None)\n    def dp(i: int, quota: int) -> T:\n      \"\"\"\n      Returns the maximum weight and the selected intervals for intervals[i..n),\n      where `quota` is the number of intervals that can be selected.\n      \"\"\"\n      if i == len(intervals) or quota == 0:\n        return T(0, ())\n\n      skip = dp(i + 1, quota)\n\n      _, r, weight, originalIndex = intervals[i]\n      j = bisect.bisect_right(intervals, (r, math.inf))\n      nextRes = dp(j, quota - 1)\n      pick = T(weight + nextRes.weight,\n               sorted((originalIndex, *nextRes.selected)))\n      return (pick if (pick.weight > skip.weight or\n                       pick.weight == skip.weight and pick.selected < skip.selected)\n              else skip)\n\n    return list(dp(0, 4).selected)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3477, "slug": "fruits-into-baskets-ii", "solutions": ["class Solution:\n    def numOfUnplacedFruits(self, fruits: List[int], baskets: List[int]) -> int:\n        n = len(fruits)\n        vis = [False] * n\n        ans = n\n        for x in fruits:\n            for i, y in enumerate(baskets):\n                if y >= x and not vis[i]:\n                    vis[i] = True\n                    ans -= 1\n                    break\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3437, "slug": "permutations-iii", "solutions": ["class Solution:\n    def permute(self, n: int) -> List[List[int]]:\n        def dfs(i: int) -> None:\n            if i >= n:\n                ans.append(t[:])\n                return\n            for j in range(1, n + 1):\n                if not vis[j] and (i == 0 or t[-1] % 2 != j % 2):\n                    t.append(j)\n                    vis[j] = True\n                    dfs(i + 1)\n                    vis[j] = False\n                    t.pop()\n\n        ans = []\n        t = []\n        vis = [False] * (n + 1)\n        dfs(0)\n        return ans\n", "class Solution:\n  def permute(self, n: int) -> list[list[int]]:\n    ans = []\n    used = [False] * (n + 1)\n\n    def dfs(path: list[int]) -> None:\n      if len(path) == n:\n        ans.append(path.copy())\n        return\n      for num in range(1, n + 1):\n        if used[num]:\n          continue\n        if path and path[-1] % 2 == num % 2:\n          continue\n        used[num] = True\n        path.append(num)\n        dfs(path)\n        path.pop()\n        used[num] = False\n\n    dfs([])\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3418, "slug": "maximum-amount-of-money-robot-can-earn", "solutions": ["class Solution:\n    def maximumAmount(self, coins: List[List[int]]) -> int:\n        @cache\n        def dfs(i: int, j: int, k: int) -> int:\n            if i >= m or j >= n:\n                return -inf\n            if i == m - 1 and j == n - 1:\n                return max(coins[i][j], 0) if k else coins[i][j]\n            ans = coins[i][j] + max(dfs(i + 1, j, k), dfs(i, j + 1, k))\n            if coins[i][j] < 0 and k:\n                ans = max(ans, dfs(i + 1, j, k - 1), dfs(i, j + 1, k - 1))\n            return ans\n\n        m, n = len(coins), len(coins[0])\n        return dfs(0, 0, 2)\n", "class Solution:\n  def maximumAmount(self, coins: list[list[int]]) -> int:\n    m = len(coins)\n    n = len(coins[0])\n    # dp[i][j][k] := the maximum profit at position (i, j) with k remaining\n    # neutralizations\n    dp = [[[-math.inf] * 4 for _ in range(n)] for _ in range(m)]\n\n    # Base case: the robot starts at the top-left corner.\n    dp[0][0][2] = coins[0][0]\n    if coins[0][0] < 0:\n      dp[0][0][1] = 0  # Neutralize the robber.\n\n    for i in range(m):\n      for j in range(n):\n        for k in range(3):  # for each number of remaining neutralizations\n          if i > 0:\n            dp[i][j][k] = max(dp[i][j][k],\n                              dp[i - 1][j][k] + coins[i][j],\n                              dp[i - 1][j][k + 1])\n          if j > 0:\n            dp[i][j][k] = max(dp[i][j][k],\n                              dp[i][j - 1][k] + coins[i][j],\n                              dp[i][j - 1][k + 1])\n\n    return max(dp[-1][-1])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3450, "slug": "maximum-students-on-a-single-bench", "solutions": ["class Solution:\n    def maxStudentsOnBench(self, students: List[List[int]]) -> int:\n        if not students:\n            return 0\n        d = defaultdict(set)\n        for student_id, bench_id in students:\n            d[bench_id].add(student_id)\n        return max(map(len, d.values()))\n", "class Solution:\n  def maxStudentsOnBench(self, students: list[list[int]]) -> int:\n    benchToStudents = collections.defaultdict(set)\n    for studentId, benchId in students:\n      benchToStudents[benchId].add(studentId)\n    return max(map(len, benchToStudents .values()), default=0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3440, "slug": "reschedule-meetings-for-maximum-free-time-ii", "solutions": ["class Solution:\n    def maxFreeTime(\n        self, eventTime: int, startTime: List[int], endTime: List[int]\n    ) -> int:\n        n = len(startTime)\n        res = 0\n\n        left_gaps = [0] * n\n        left_gaps[0] = startTime[0]\n        for meet in range(1, n):\n            left_gaps[meet] = max(\n                left_gaps[meet - 1], startTime[meet] - endTime[meet - 1]\n            )\n\n        right_gaps = [0] * n\n        right_gaps[n - 1] = eventTime - endTime[-1]\n        for meet in range(n - 2, -1, -1):\n            right_gaps[meet] = max(\n                right_gaps[meet + 1], startTime[meet + 1] - endTime[meet]\n            )\n\n        for meet in range(n):\n            left_gap = (\n                left_gaps[meet] if meet == 0 else startTime[meet] - endTime[meet - 1]\n            )\n            right_gap = (\n                right_gaps[meet]\n                if meet == n - 1\n                else startTime[meet + 1] - endTime[meet]\n            )\n\n            interval = 0\n\n            if (\n                meet != 0\n                and left_gaps[meet - 1] >= (endTime[meet] - startTime[meet])\n                or meet != n - 1\n                and right_gaps[meet + 1] >= (endTime[meet] - startTime[meet])\n            ):\n                interval = endTime[meet] - startTime[meet]\n\n            res = max(res, left_gap + interval + right_gap)\n\n        return res\n", "class Solution:\n  def maxFreeTime(\n      self,\n      eventTime: int,\n      startTime: list[int],\n      endTime: list[int]\n  ) -> int:\n    n = len(startTime)\n    gaps = ([startTime[0]] +\n            [startTime[i] - endTime[i - 1] for i in range(1, len(startTime))] +\n            [eventTime - endTime[-1]])\n    ans = 0\n    maxLeft = [gaps[0]] + [0] * n  # maxLeft[i] := max(gaps[0..i])\n    maxRight = [0] * n + [gaps[n]]  # maxRight[i] := max(gaps[i..n])\n\n    for i in range(1, n + 1):\n      maxLeft[i] = max(gaps[i], maxLeft[i - 1])\n\n    for i in range(n - 1, -1, -1):\n      maxRight[i] = max(gaps[i], maxRight[i + 1])\n\n    for i, (start, end) in enumerate(zip(startTime, endTime)):\n      currMeetingTime = end - start\n      adjacentGapsSum = gaps[i] + gaps[i + 1]\n      canMoveMeeting = currMeetingTime <= max(\n          maxLeft[i - 1] if i > 0 else 0,\n          maxRight[i + 2] if i + 2 < n + 1 else 0\n      )\n      ans = max(ans, adjacentGapsSum +\n                (currMeetingTime if canMoveMeeting else 0))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3423, "slug": "maximum-difference-between-adjacent-elements-in-a-circular-array", "solutions": ["class Solution:\n    def maxAdjacentDistance(self, nums: List[int]) -> int:\n        return max(max(abs(a - b) for a, b in pairwise(nums)), abs(nums[0] - nums[-1]))\n", "class Solution:\n  def maxAdjacentDistance(self, nums: list[int]) -> int:\n    return max(abs(nums[i] - nums[i - 1])\n               for i in range(len(nums)))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3482, "slug": "analyze-organization-hierarchy", "solutions": ["import pandas as pd\n\n\ndef analyze_organization_hierarchy(employees: pd.DataFrame) -> pd.DataFrame:\n    # Copy the input DataFrame to avoid modifying the original\n    employees = employees.copy()\n    employees[\"level\"] = None\n\n    # Identify the CEO (level 1)\n    ceo_id = employees.loc[employees[\"manager_id\"].isna(), \"employee_id\"].values[0]\n    employees.loc[employees[\"employee_id\"] == ceo_id, \"level\"] = 1\n\n    # Recursively compute employee levels\n    def compute_levels(emp_df, level):\n        next_level_ids = emp_df[emp_df[\"level\"] == level][\"employee_id\"].tolist()\n        if not next_level_ids:\n            return\n        emp_df.loc[emp_df[\"manager_id\"].isin(next_level_ids), \"level\"] = level + 1\n        compute_levels(emp_df, level + 1)\n\n    compute_levels(employees, 1)\n\n    # Initialize team size and budget dictionaries\n    team_size = {eid: 0 for eid in employees[\"employee_id\"]}\n    budget = {\n        eid: salary\n        for eid, salary in zip(employees[\"employee_id\"], employees[\"salary\"])\n    }\n\n    # Compute team size and budget for each employee\n    for eid in sorted(employees[\"employee_id\"], reverse=True):\n        manager_id = employees.loc[\n            employees[\"employee_id\"] == eid, \"manager_id\"\n        ].values[0]\n        if pd.notna(manager_id):\n            team_size[manager_id] += team_size[eid] + 1\n            budget[manager_id] += budget[eid]\n\n    # Map computed team size and budget to employees DataFrame\n    employees[\"team_size\"] = employees[\"employee_id\"].map(team_size)\n    employees[\"budget\"] = employees[\"employee_id\"].map(budget)\n\n    # Sort the final result by level (ascending), budget (descending), and employee name (ascending)\n    employees = employees.sort_values(\n        by=[\"level\", \"budget\", \"employee_name\"], ascending=[True, False, True]\n    )\n\n    return employees[[\"employee_id\", \"employee_name\", \"level\", \"team_size\", \"budget\"]]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3456, "slug": "find-special-substring-of-length-k", "solutions": ["class Solution:\n    def hasSpecialSubstring(self, s: str, k: int) -> bool:\n        l, n = 0, len(s)\n        while l < n:\n            r = l\n            while r < n and s[r] == s[l]:\n                r += 1\n            if r - l == k:\n                return True\n            l = r\n        return False\n", "class Solution:\n  def hasSpecialSubstring(self, s: str, k: int) -> bool:\n    return any(len(list(group)) == k for _, group in groupby(s))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3474, "slug": "lexicographically-smallest-generated-string", "solutions": ["class Solution:\n  def generateString(self, str1: str, str2: str) -> str:\n    n = len(str1)\n    m = len(str2)\n    sz = n + m - 1\n    ans = [None] * sz\n    modifiable = [True] * sz\n\n    # 1. Handle all 'T' positions first.\n    for i, tf in enumerate(str1):\n      if tf == 'T':\n        for j, c in enumerate(str2):\n          pos = i + j\n          if ans[pos] and ans[pos] != c:\n            return ''\n          ans[pos] = c\n          modifiable[pos] = False\n\n    # 2. Fill all remaining positions with 'a'.\n    for i in range(sz):\n      if not ans[i]:\n        ans[i] = 'a'\n\n    # 3. Handle all 'F' positions.\n    for i in range(n):\n      if str1[i] == 'F' and self._match(ans, i, str2):\n        modifiablePos = self._lastModifiablePosition(i, m, modifiable)\n        if modifiablePos == -1:\n          return ''\n        ans[modifiablePos] = 'b'\n        modifiable[modifiablePos] = False\n\n    return ''.join(ans)\n\n  def _match(self, ans: list, i: int, s: str) -> bool:\n    \"\"\"Returns True if the substring of ans starting at `i` matches `s`.\"\"\"\n    for j, c in enumerate(s):\n      if ans[i + j] != c:\n        return False\n    return True\n\n  def _lastModifiablePosition(self, i: int, m: int, modifiable: list) -> int:\n    \"\"\"\n    Finds the last modifiable position in the substring of ans starting at `i`.\n    \"\"\"\n    modifiablePos = -1\n    for j in range(m):\n      pos = i + j\n      if modifiable[pos]:\n        modifiablePos = pos\n    return modifiablePos\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3435, "slug": "frequencies-of-shortest-supersequences", "solutions": ["from enum import Enum\n\n\nclass State(Enum):\n  INIT = 0\n  VISITING = 1\n  VISITED = 2\n\n\nclass Solution:\n  def supersequences(self, words: list[str]) -> list[list[int]]:\n    ans = []\n    edges = [(string.ascii_lowercase.index(words[0]),\n              string.ascii_lowercase.index(words[1]))\n             for words in words]\n    nodes = sorted({u for u, _ in edges} | {v for _, v in edges})\n    letterToIndex = {letter: i for i, letter in enumerate(nodes)}\n    graph = [[] for _ in range(len(nodes))]\n\n    for u, v in edges:\n      graph[letterToIndex[u]].append(letterToIndex[v])\n\n    for doubledSubset in self._getMinimumSubsets(graph):\n      freq = [0] * 26\n      for letter in nodes:\n        freq[letter] = 1\n      for index in doubledSubset:\n        freq[nodes[index]] = 2\n      ans.append(freq)\n\n    return ans\n\n  def _getMinimumSubsets(self, graph: list[list[int]]) -> list[tuple[int]]:\n    \"\"\"\n    Returns a list of the minimum subsets of nodes that do not create a cycle\n    when skipped.\n    \"\"\"\n    n = len(graph)\n    for subsetSize in range(n + 1):\n      doubleSubsets = []\n      for doubledSubset in itertools.combinations(range(n), subsetSize):\n        if not self._hasCycleSkipping(graph, set(doubledSubset)):\n          doubleSubsets.append(doubledSubset)\n      if doubleSubsets:\n        return doubleSubsets\n    return []\n\n  def _hasCycleSkipping(\n      self,\n      graph: list[list[int]],\n      doubledSubset: set[int]\n  ) -> bool:\n    \"\"\"\n    Returns True if there is a cycle in the `graph` when skipping any edges\n    whose both endpoints are in `doubledSubset`.\n    \"\"\"\n    states = [State.INIT] * len(graph)\n\n    def hasCycle(u: int) -> bool:\n      if states[u] == State.VISITING:\n        return True\n      if states[u] == State.VISITED:\n        return False\n      states[u] = State.VISITING\n      if u not in doubledSubset:\n        for v in graph[u]:\n          if v in doubledSubset:\n            continue\n          if hasCycle(v):\n            return True\n      states[u] = State.VISITED\n      return False\n\n    return any(hasCycle(i) for i in range(len(graph)))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3402, "slug": "minimum-operations-to-make-columns-strictly-increasing", "solutions": ["class Solution:\n    def minimumOperations(self, grid: List[List[int]]) -> int:\n        ans = 0\n        for col in zip(*grid):\n            pre = -1\n            for cur in col:\n                if pre < cur:\n                    pre = cur\n                else:\n                    pre += 1\n                    ans += pre - cur\n        return ans\n", "class Solution:\n  def minimumOperations(self, grid: list[list[int]]) -> int:\n    ans = 0\n\n    for j in range(len(grid[0])):\n      for i in range(1, len(grid)):\n        if grid[i][j] <= grid[i - 1][j]:\n          ans += grid[i - 1][j] - grid[i][j] + 1\n          grid[i][j] = grid[i - 1][j] + 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3434, "slug": "maximum-frequency-after-subarray-operation", "solutions": ["class Solution:\n  def maxFrequency(self, nums: list[int], k: int) -> int:\n    return nums.count(k) + max(self._kadane(nums, target, k)\n                               for target in range(1, 51)\n                               if target != k)\n\n  def _kadane(self, nums: list[int], target: int, k: int) -> int:\n    \"\"\"\n    Returns the maximum achievable frequency of `k` by Kakane's algorithm,\n    where each `target` in subarrays is transformed to `k`.\n    \"\"\"\n    maxSum = 0\n    sum = 0\n    for num in nums:\n      if num == target:\n        sum += 1\n      elif num == k:\n        sum -= 1\n      if sum < 0:  # Reset sum if it becomes negative (Kadane's spirit).\n        sum = 0\n      maxSum = max(maxSum, sum)\n    return maxSum\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3433, "slug": "count-mentions-per-user", "solutions": ["class Solution:\n    def countMentions(self, numberOfUsers: int, events: List[List[str]]) -> List[int]:\n        events.sort(key=lambda e: (int(e[1]), e[0][2]))\n        ans = [0] * numberOfUsers\n        online_t = [0] * numberOfUsers\n        lazy = 0\n        for etype, ts, s in events:\n            cur = int(ts)\n            if etype[0] == \"O\":\n                online_t[int(s)] = cur + 60\n            elif s[0] == \"A\":\n                lazy += 1\n            elif s[0] == \"H\":\n                for i, t in enumerate(online_t):\n                    if t <= cur:\n                        ans[i] += 1\n            else:\n                for a in s.split():\n                    ans[int(a[2:])] += 1\n        if lazy:\n            for i in range(numberOfUsers):\n                ans[i] += lazy\n        return ans\n", "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass OfflineUser:\n  returnTimestamp: int\n  userId: int\n\n  def __lt__(self, other):\n    return self.returnTimestamp < other.returnTimestamp\n\n\nclass Solution:\n  def countMentions(\n      self,\n      numberOfUsers: int,\n      events: list[list[str]]\n  ) -> list[int]:\n    ans = [0] * numberOfUsers\n    online = [True] * numberOfUsers\n    offlineQueue = []  # min-heap to track users that are offline\n    allMentionsCount = 0\n\n    events.sort(key=lambda x: (int(x[1]), -ord(x[0][0])))\n\n    for eventType, t, messageContent in events:\n      timestamp = int(t)\n      # Bring users back online if their offline period has ended.\n      while offlineQueue and offlineQueue[0].returnTimestamp <= timestamp:\n        user = heapq.heappop(offlineQueue)\n        online[user.userId] = True\n      if eventType == \"MESSAGE\":\n        match messageContent:\n          case \"ALL\":\n            allMentionsCount += 1\n          case \"HERE\":\n            for userId in range(numberOfUsers):\n              if online[userId]:\n                ans[userId] += 1\n          case _:\n            for userId in [int(part[2:]) for part in messageContent.split()]:\n              ans[userId] += 1\n      elif eventType == \"OFFLINE\":\n        userId = int(messageContent)\n        online[userId] = False\n        # Add to queue to bring back online after 60 units.\n        heapq.heappush(offlineQueue, OfflineUser(timestamp + 60, userId))\n\n    # Add the \"ALL\" mentions to all users.\n    for userId in range(numberOfUsers):\n      ans[userId] += allMentionsCount\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3439, "slug": "reschedule-meetings-for-maximum-free-time-i", "solutions": ["class Solution:\n  def maxFreeTime(\n      self,\n      eventTime: int,\n      k: int,\n      startTime: list[int],\n      endTime: list[int]\n  ) -> int:\n    gaps = ([startTime[0]] +\n            [startTime[i] - endTime[i - 1] for i in range(1, len(startTime))] +\n            [eventTime - endTime[-1]])\n    windowSum = sum(gaps[:k + 1])\n    ans = windowSum\n\n    for i in range(k + 1, len(gaps)):\n      windowSum += gaps[i] - gaps[i - k - 1]\n      ans = max(ans, windowSum)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3447, "slug": "assign-elements-to-groups-with-constraints", "solutions": ["class Solution:\n    def assignElements(self, groups: List[int], elements: List[int]) -> List[int]:\n        mx = max(groups)\n        d = [-1] * (mx + 1)\n        for j, x in enumerate(elements):\n            if x > mx or d[x] != -1:\n                continue\n            for y in range(x, mx + 1, x):\n                if d[y] == -1:\n                    d[y] = j\n        return [d[x] for x in groups]\n", "class Solution:\n  def assignElements(self, groups: list[int], elements: list[int]) -> list[int]:\n    ans = []\n    elementToMinIndex = {}\n\n    for i, element in enumerate(elements):\n      if element not in elementToMinIndex:\n        elementToMinIndex[element] = i\n\n    for num in groups:\n      ans.append(self._getMinIndex(num, elementToMinIndex))\n\n    return ans\n\n  def _getMinIndex(self, num: int, elementToMinIndex: dict[int, int]) -> int:\n    res = math.inf\n    i = 1\n    while i * i <= num:\n      if num % i != 0:\n        continue\n      if i in elementToMinIndex:\n        res = min(res, elementToMinIndex[i])\n      if num // i != i and (num // i) in elementToMinIndex:\n        res = min(res, elementToMinIndex[num // i])\n      i += 1\n    return -1 if res == math.inf else res\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3492, "slug": "maximum-containers-on-a-ship", "solutions": ["class Solution:\n    def maxContainers(self, n: int, w: int, maxWeight: int) -> int:\n        return min(n * n * w, maxWeight) // w\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3416, "slug": "subsequences-with-a-unique-middle-mode-ii", "solutions": ["# Recall from solution 1 that after counting all the subsequences with `a` as\n# the middle mode number, we need to subtract the cases where `a` is not a\n# unique mode or not a mode.\n#\n# To avoid the need of looping through all numbers that are not `a`, we can\n# maintain the sums that are not related to `a` in the loop.\n#\n# So, during the simplification of the formula, keep the running sums of\n# pss, spp, pp, ss, and ps as the first item.\n# (for cleaner notation, abbreviate p[b] and s[b] to just p and s)\n#\n#   sum(b != a) (p[a] * p * s) * (r - s[a] - s)\n#             + (s[a] * s * p) * (l - p[a] - p)\n#             + (p, 2) * s[a] * (r - s[a])\n#             + (s, 2) * p[a] * (l - p[a])\n#\n#   sum(b != a) (p * s) * (p[a] * (r - s[a])) + (p * s^2) * (-p[a])\n#             + (s * p) * (s[a] * (l - p[a])) + (s * p^2) * (-s[a])\n#             + (p^2 - p) * (s[a] * (r - s[a]) / 2)\n#             + (s^2 - s) * (p[a] * (l - p[a]) / 2)\n\n\nclass Solution:\n  # Same as 3395. Subsequences with a Unique Middle Mode I\n  def subsequencesWithMiddleMode(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    p = collections.Counter()  # prefix counter\n    s = collections.Counter(nums)  # suffix counter\n\n    def nC2(n: int) -> int:\n      return n * (n - 1) // 2\n\n    pss = 0\n    spp = 0\n    pp = 0\n    ss = sum(freq**2 for freq in s.values())\n    ps = 0\n\n    for i, a in enumerate(nums):\n      # Update running sums after decrementing s[a].\n      pss += p[a] * (-s[a]**2 + (s[a] - 1)**2)\n      spp += -p[a]**2  # (-s[a] + (s[a] - 1)) * p[a]**2\n      ss += -s[a]**2 + (s[a] - 1)**2\n      ps += -p[a]  # -p[a] * (-s[a] + (s[a] - 1))\n\n      s[a] -= 1\n\n      l = i\n      r = len(nums) - i - 1\n\n      # Start with all possible subsequences with `a` as the middle number.\n      ans += nC2(l) * nC2(r)\n\n      # Minus the cases where the frequency of `a` is 1, so it's not a mode.\n      ans -= nC2(l - p[a]) * nC2(r - s[a])\n\n      # Minus the values where `b != a`.\n      pss_ = pss - p[a] * s[a]**2\n      spp_ = spp - s[a] * p[a]**2\n      pp_ = pp - p[a]**2\n      ss_ = ss - s[a]**2\n      ps_ = ps - p[a] * s[a]\n      p_ = l - p[a]\n      s_ = r - s[a]\n\n      # Minus the cases where the `a` is not a \"unique\" mode or not a mode.\n      ans -= ps_ * (p[a] * (r - s[a])) + pss_ * (-p[a])\n      ans -= ps_ * (s[a] * (l - p[a])) + spp_ * (-s[a])\n      ans -= (pp_ - p_) * s[a] * (r - s[a]) // 2\n      ans -= (ss_ - s_) * p[a] * (l - p[a]) // 2\n      ans %= MOD\n\n      # Update running sums after incrementing p[a].\n      pss += s[a]**2  # (-p[a] + (p[a] + 1)) * s[a]**2\n      spp += s[a] * (-p[a]**2 + (p[a] + 1)**2)\n      pp += -p[a]**2 + (p[a] + 1)**2\n      ps += s[a]  # (-p[a] + (p[a] + 1)) * s[a]\n\n      p[a] += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3467, "slug": "transform-array-by-parity", "solutions": ["class Solution:\n    def transformArray(self, nums: List[int]) -> List[int]:\n        even = sum(x % 2 == 0 for x in nums)\n        for i in range(even):\n            nums[i] = 0\n        for i in range(even, len(nums)):\n            nums[i] = 1\n        return nums\n", "class Solution:\n  def transformArray(self, nums: list[int]) -> list[int]:\n    return ([0] * sum(num % 2 == 0 for num in nums) +\n            [1] * sum(num % 2 == 1 for num in nums))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3424, "slug": "minimum-cost-to-make-arrays-identical", "solutions": ["class Solution:\n    def minCost(self, arr: List[int], brr: List[int], k: int) -> int:\n        c1 = sum(abs(a - b) for a, b in zip(arr, brr))\n        arr.sort()\n        brr.sort()\n        c2 = k + sum(abs(a - b) for a, b in zip(arr, brr))\n        return min(c1, c2)\n", "class Solution:\n  def minCost(self, arr: list[int], brr: list[int], k: int) -> int:\n    def cost(arr: list[int], brr: list[int]) -> int:\n      return sum(abs(a - b) for a, b in zip(arr, brr))\n    return min(cost(arr, brr), cost(sorted(arr), sorted(brr)) + k)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3489, "slug": "zero-array-transformation-iv", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3412, "slug": "find-mirror-score-of-a-string", "solutions": ["class Solution:\n    def calculateScore(self, s: str) -> int:\n        d = defaultdict(list)\n        ans = 0\n        for i, x in enumerate(s):\n            y = chr(ord(\"a\") + ord(\"z\") - ord(x))\n            if d[y]:\n                j = d[y].pop()\n                ans += i - j\n            else:\n                d[x].append(i)\n        return ans\n", "class Solution:\n  def calculateScore(self, s: str) -> int:\n    ans = 0\n    indices = [[] for _ in range(26)]\n\n    for i, c in enumerate(s):\n      index = ord(c) - ord('a')\n      oppositeIndex = 25 - index\n      if indices[oppositeIndex]:\n        ans += i - indices[oppositeIndex].pop()\n      else:\n        indices[index].append(i)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3415, "slug": "find-products-with-three-consecutive-digits", "solutions": ["import pandas as pd\n\n\ndef find_products(products: pd.DataFrame) -> pd.DataFrame:\n    filtered = products[\n        products[\"name\"].str.contains(r\"(^|[^0-9])[0-9]{3}([^0-9]|$)\", regex=True)\n    ]\n    return filtered.sort_values(by=\"product_id\")\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3420, "slug": "count-non-decreasing-subarrays-after-k-operations", "solutions": ["class Solution:\n  def countNonDecreasingSubarrays(self, nums: list[int], k: int) -> int:\n    ans = 0\n    cost = 0\n    # Store (number, count) pairs in non-increasing order. The numbers in the\n    # queue represent what nums[i..j] look like after adjustments.\n    dq = collections.deque()\n\n    j = len(nums) - 1\n    for i, num in reversed(list(enumerate(nums))):\n      count = 1\n      while dq and dq[-1][0] < num:\n        nextNum, nextCount = dq.pop()\n        count += nextCount\n        cost += (num - nextNum) * nextCount  # Adjust `nextNum`s to `num`.\n      dq.append((num, count))\n      while cost > k:  # Remove the rightmost number.\n        rightmostNum, rightmostCount = dq.popleft()\n        cost -= (rightmostNum - nums[j])\n        j -= 1\n        if rightmostCount > 1:\n          dq.appendleft((rightmostNum, rightmostCount - 1))\n      ans += j - i + 1\n\n    return ans\n", "class Solution:\n  def countNonDecreasingSubarrays(self, nums: list[int], k: int) -> int:\n    ans = 0\n    cost = 0\n    # Store indices (i) of nums with nums[i] in non-increasing order.\n    dq = collections.deque()\n\n    j = len(nums) - 1\n    for i, num in reversed(list(enumerate(nums))):\n      while dq and nums[dq[-1]] < num:\n        l = dq.pop()\n        r = dq[-1] if dq else j + 1\n        cost += (r - l) * (num - nums[l])  # Adjust `nums[l]` to `num`.\n      dq.append(i)\n      while cost > k:  # Remove the rightmost number.\n        cost -= nums[dq[0]] - nums[j]\n        if dq[0] == j:\n          dq.popleft()\n        j -= 1\n      ans += j - i + 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3455, "slug": "shortest-matching-substring", "solutions": ["class Solution:\n  def shortestMatchingSubstring(self, s: str, p: str) -> int:\n    n = len(s)\n    a, b, c = p.split('*')\n    lpsA = self._getLPS(a + '#' + s)[len(a) + 1:]\n    lpsB = self._getLPS(b + '#' + s)[len(b) + 1:]\n    lpsC = self._getLPS(c + '#' + s)[len(c) + 1:]\n    ans = math.inf\n\n    i = 0  # lpsA's index\n    j = 0  # lpsB's index\n    k = 0  # lpsC's index\n    while i + len(b) + len(c) < n:\n      while i < n and lpsA[i] != len(a):\n        i += 1\n      while j < n and (j < i + len(b) or lpsB[j] != len(b)):\n        j += 1\n      while k < n and (k < j + len(c) or lpsC[k] != len(c)):\n        k += 1\n      if k == n:\n        break\n      ans = min(ans, k - i + len(a))\n      i += 1\n\n    return -1 if ans == math.inf else ans\n\n  def _getLPS(self, pattern: str) -> list[int]:\n    \"\"\"\n    Returns the lps array, where lps[i] is the length of the longest prefix of\n    pattern[0..i] which is also a suffix of this substring.\n    \"\"\"\n    lps = [0] * len(pattern)\n    j = 0\n    for i in range(1, len(pattern)):\n      while j > 0 and pattern[j] != pattern[i]:\n        j = lps[j - 1]\n      if pattern[i] == pattern[j]:\n        lps[i] = j + 1\n        j += 1\n    return lps\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3475, "slug": "dna-pattern-recognition", "solutions": ["import pandas as pd\n\n\ndef analyze_dna_patterns(samples: pd.DataFrame) -> pd.DataFrame:\n    samples[\"has_start\"] = samples[\"dna_sequence\"].str.startswith(\"ATG\").astype(int)\n    samples[\"has_stop\"] = (\n        samples[\"dna_sequence\"].str.endswith((\"TAA\", \"TAG\", \"TGA\")).astype(int)\n    )\n    samples[\"has_atat\"] = samples[\"dna_sequence\"].str.contains(\"ATAT\").astype(int)\n    samples[\"has_ggg\"] = samples[\"dna_sequence\"].str.contains(\"GGG+\").astype(int)\n    return samples.sort_values(by=\"sample_id\").reset_index(drop=True)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3452, "slug": "sum-of-good-numbers", "solutions": ["class Solution:\n    def sumOfGoodNumbers(self, nums: List[int], k: int) -> int:\n        ans = 0\n        for i, x in enumerate(nums):\n            if i >= k and x <= nums[i - k]:\n                continue\n            if i + k < len(nums) and x <= nums[i + k]:\n                continue\n            ans += x\n        return ans\n", "class Solution:\n  def sumOfGoodNumbers(self, nums: list[int], k: int) -> int:\n    return sum(num for i, num in enumerate(nums)\n               if (i - k < 0 or num > nums[i - k])\n               and (i + k >= len(nums) or num > nums[i + k]))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3409, "slug": "longest-subsequence-with-decreasing-adjacent-difference", "solutions": ["class Solution:\n  def longestSubsequence(self, nums: list[int]) -> int:\n    mx = max(nums)\n    # dp[num][diff] := the length of the longest subsequence ending in `num`\n    # s.t. the last absolute difference between consecutive elements is `diff`\n    dp = [[0] * (mx + 1) for _ in range(mx + 1)]\n\n    for num in nums:\n      for prev in range(1, mx + 1):\n        diff = abs(num - prev)\n        dp[num][diff] = max(dp[num][diff], dp[prev][diff] + 1)\n      # dp[num][diff] := max(dp[num][j]) for j >= diff\n      for j in range(mx - 1, -1, -1):\n        dp[num][j] = max(dp[num][j], dp[num][j + 1])\n\n    return max(map(max, dp))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3427, "slug": "sum-of-variable-length-subarrays", "solutions": ["class Solution:\n    def subarraySum(self, nums: List[int]) -> int:\n        s = list(accumulate(nums, initial=0))\n        return sum(s[i + 1] - s[max(0, i - x)] for i, x in enumerate(nums))\n", "class Solution:\n  def subarraySum(self, nums: list[int]) -> int:\n    prefix = list(itertools.accumulate(nums, initial=0))\n    return sum(prefix[i + 1] - prefix[max(0, i - num)]\n               for i, num in enumerate((nums)))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3421, "slug": "find-students-who-improved", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3406, "slug": "find-the-lexicographically-largest-string-from-the-box-ii", "solutions": ["class Solution:\n  def answerString(self, word: str, numFriends: int) -> str:\n    if numFriends == 1:\n      return word\n    s = self._lastSubstring(word)\n    sz = len(word) - numFriends + 1\n    return s[:min(len(s), sz)]\n\n  # Same as 1163. Last Substring in Lexicographical Order\n  def _lastSubstring(self, s: str) -> str:\n    i = 0\n    j = 1\n    k = 0  # the number of the same letters of s[i..n) and s[j..n)\n\n    while j + k < len(s):\n      if s[i + k] == s[j + k]:\n        k += 1\n      elif s[i + k] > s[j + k]:\n        # Skip s[j..j + k) and advance to s[j + k + 1] to find a possible\n        # lexicographically larger substring since s[i..i + k) == s[j..j + k)\n        # and s[i + k] > s[j + k).\n        j = j + k + 1\n        k = 0\n      else:\n        # Skip s[i..i + k) and advance to s[i + k + 1] or s[j] to find a\n        # possible lexicographically larger substring since\n        # s[i..i + k) == s[j..j + k) and s[i + k] < s[j + k).\n        # Note that it's unnecessary to explore s[i + k + 1..j) if\n        # i + k + 1 < j since they are already explored by j.\n        i = max(i + k + 1, j)\n        j = i + 1\n        k = 0\n\n    return s[i:]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3465, "slug": "find-products-with-valid-serial-numbers", "solutions": ["import pandas as pd\n\n\ndef find_valid_serial_products(products: pd.DataFrame) -> pd.DataFrame:\n    valid_pattern = r\"\\bSN[0-9]{4}-[0-9]{4}\\b\"\n    valid_products = products[\n        products[\"description\"].str.contains(valid_pattern, regex=True)\n    ]\n    valid_products = valid_products.sort_values(by=\"product_id\")\n    return valid_products\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3472, "slug": "longest-palindromic-subsequence-after-at-most-k-operations", "solutions": ["class Solution:\n    def longestPalindromicSubsequence(self, s: str, k: int) -> int:\n        @cache\n        def dfs(i: int, j: int, k: int) -> int:\n            if i > j:\n                return 0\n            if i == j:\n                return 1\n            res = max(dfs(i + 1, j, k), dfs(i, j - 1, k))\n            d = abs(s[i] - s[j])\n            t = min(d, 26 - d)\n            if t <= k:\n                res = max(res, dfs(i + 1, j - 1, k - t) + 2)\n            return res\n\n        s = list(map(ord, s))\n        n = len(s)\n        ans = dfs(0, n - 1, k)\n        dfs.cache_clear()\n        return ans\n", "class Solution:\n  # Similar to 516. Longest Palindromic Subsequence\n  def longestPalindromicSubsequence(self, s: str, k: int) -> int:\n    n = len(s)\n    # dp[i][j][op] := the length of LPS(s[i..j]) with at most `op` operations\n    dp = [[[0] * (k + 1) for _ in range(n)] for _ in range(n)]\n\n    for i in range(n):\n      for op in range(k + 1):\n        dp[i][i][op] = 1\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        for op in range(k + 1):\n          if s[i] == s[j]:\n            dp[i][j][op] = 2 + dp[i + 1][j - 1][op]\n          else:\n            dp[i][j][op] = max(dp[i + 1][j][op], dp[i][j - 1][op])\n            cost = self._getCost(s[i], s[j])\n            if cost <= op:\n              dp[i][j][op] = max(dp[i][j][op], 2 + dp[i + 1][j - 1][op - cost])\n\n    return dp[0][n - 1][k]\n\n  def _getCost(self, a: str, b: str) -> int:\n    dist = abs(ord(a) - ord(b))\n    return min(dist, 26 - dist)\n", "class Solution:\n  # Similar to 516. Longest Palindromic Subsequence\n  def longestPalindromicSubsequence(self, s: str, k: int) -> int:\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, op: int) -> int:\n      \"\"\"Returns the length of LPS(s[i..j]) with at most `op` operations.\"\"\"\n      if i > j:\n        return 0\n      if i == j:\n        return 1\n      if s[i] == s[j]:\n        return 2 + dp(i + 1, j - 1, op)\n      res = max(dp(i + 1, j, op), dp(i, j - 1, op))\n      cost = self._getCost(s[i], s[j])\n      if cost <= op:\n        res = max(res, 2 + dp(i + 1, j - 1, op - cost))\n      return res\n\n    return dp(0, len(s) - 1, k)\n\n  def _getCost(self, a: str, b: str) -> int:\n    dist = abs(ord(a) - ord(b))\n    return min(dist, 26 - dist)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3428, "slug": "maximum-and-minimum-sums-of-at-most-size-k-subsequences", "solutions": ["class Solution:\n  def minMaxSums(self, nums: list[int], k: int) -> int:\n    # In a sorted array, nums[i] will be\n    #   1. The maximum for subsequences formed by nums[0..i].\n    #   2. The minimum for subsequences formed by nums[i..n - 1].\n    #\n    # The number of times nums[i] is the maximum is the same as the number of\n    # times nums[n - 1 - i] is the minimum, due to the symmetry in subsequences\n    # derived from the sorted order.\n    #\n    # To calculate the contribution of nums[i], we need to find the number of\n    # ways to select at most (k - 1) elements from the range of indices where\n    # nums[i] is the smallest or nums[n - 1 - i] is the largest.\n    MOD = 1_000_000_007\n    n = len(nums)\n\n    def getComb(n: int, k: int) -> list[list[int]]:\n      \"\"\"C(n, k) = C(n - 1, k) + C(n - 1, k - 1)\"\"\"\n      comb = [[0] * (k + 1) for _ in range(n + 1)]\n      for i in range(n + 1):\n        comb[i][0] = 1\n      for i in range(1, n + 1):\n        for j in range(1, k + 1):\n          comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % MOD\n      return comb\n\n    comb = getComb(n, k - 1)\n    ans = 0\n\n    nums.sort()\n\n    # i: available numbers from the left of nums[i] or\n    #    available numbers from the right of nums[-1 - i]\n    for i in range(n):\n      count = 0\n      for j in range(k):  # selected numbers\n        count = (count + comb[i][j]) % MOD\n      ans += nums[i] * count\n      ans += nums[-1 - i] * count\n      ans %= MOD\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3469, "slug": "find-minimum-cost-to-remove-array-elements", "solutions": ["class Solution:\n  def minCost(self, nums: list[int]) -> int:\n    n = len(nums)\n\n    @functools.lru_cache(None)\n    def dp(last: int, i: int) -> int:\n      if i == n:  # Single element left.\n        return nums[last]\n      if i == n - 1:  # Two elements left.\n        return max(nums[last], nums[i])\n      a = max(nums[i], nums[i + 1]) + dp(last, i + 2)\n      b = max(nums[last], nums[i]) + dp(i + 1, i + 2)\n      c = max(nums[last], nums[i + 1]) + dp(i, i + 2)\n      return min(a, b, c)\n\n    return dp(0, 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3476, "slug": "maximize-profit-from-task-assignment", "solutions": ["class Solution:\n    def maxProfit(self, workers: List[int], tasks: List[List[int]]) -> int:\n        d = defaultdict(SortedList)\n        for skill, profit in tasks:\n            d[skill].add(profit)\n        ans = 0\n        for skill in workers:\n            if not d[skill]:\n                continue\n            ans += d[skill].pop()\n        mx = 0\n        for ls in d.values():\n            if ls:\n                mx = max(mx, ls[-1])\n        ans += mx\n        return ans\n", "class Solution:\n  def maxProfit(self, workers: list[int], tasks: list[list[int]]) -> int:\n    totalProfit = 0\n    skillToProfits = collections.defaultdict(list)\n\n    for skill, profit in tasks:\n      skillToProfits[skill].append(profit)\n\n    for skill in skillToProfits:\n      skillToProfits[skill].sort(reverse=True)\n\n    for workerSkill in workers:\n      if workerSkill in skillToProfits and skillToProfits[workerSkill]:\n        profit = skillToProfits[workerSkill][0]\n        skillToProfits[workerSkill].pop(0)\n        totalProfit += profit\n\n    return totalProfit + max(max(profits, default=0)\n                             for profits in skillToProfits.values())\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3490, "slug": "count-beautiful-numbers", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3425, "slug": "longest-special-path", "solutions": ["class Solution:\n  def longestSpecialPath(\n      self,\n      edges: list[list[int]],\n      nums: list[int]\n  ) -> list[int]:\n    graph = [[] for _ in range(len(nums))]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    def dfs(\n        u: int,\n        prev: int,\n        leftBoundary: int,\n        currentDepth: int,\n    ) -> None:\n      nonlocal maxLength, minNodes\n      prevDepth = lastSeenDepth.get(nums[u], 0)\n      lastSeenDepth[nums[u]] = currentDepth\n      leftBoundary = max(leftBoundary, prevDepth)\n\n      length = prefix[-1] - prefix[leftBoundary]\n      nodes = currentDepth - leftBoundary\n\n      if length > maxLength or (length == maxLength and nodes < minNodes):\n        maxLength = length\n        minNodes = nodes\n\n      for v, w in graph[u]:\n        if v == prev:\n          continue\n        prefix.append(prefix[-1] + w)\n        dfs(v, u, leftBoundary, currentDepth + 1)\n        prefix.pop()\n\n      lastSeenDepth[nums[u]] = prevDepth\n\n    maxLength = 0\n    minNodes = 1\n    prefix = [0]\n    lastSeenDepth = {}\n    dfs(0, -1, 0, 1)\n    return [maxLength, minNodes]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3483, "slug": "unique-3-digit-even-numbers", "solutions": ["class Solution:\n    def totalNumbers(self, digits: List[int]) -> int:\n        s = set()\n        for i, a in enumerate(digits):\n            if a & 1:\n                continue\n            for j, b in enumerate(digits):\n                if i == j:\n                    continue\n                for k, c in enumerate(digits):\n                    if c == 0 or k in (i, j):\n                        continue\n                    s.add(c * 100 + b * 10 + a)\n        return len(s)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3443, "slug": "maximum-manhattan-distance-after-k-changes", "solutions": ["class Solution:\n    def maxDistance(self, s: str, k: int) -> int:\n        def calc(a: str, b: str) -> int:\n            ans = mx = cnt = 0\n            for c in s:\n                if c == a or c == b:\n                    mx += 1\n                elif cnt < k:\n                    cnt += 1\n                    mx += 1\n                else:\n                    mx -= 1\n                ans = max(ans, mx)\n            return ans\n\n        a = calc(\"S\", \"E\")\n        b = calc(\"S\", \"W\")\n        c = calc(\"N\", \"E\")\n        d = calc(\"N\", \"W\")\n        return max(a, b, c, d)\n", "class Solution:\n  def maxDistance(self, s: str, k: int) -> int:\n    return max(self._flip(s, k, 'NE'), self._flip(s, k, 'NW'),\n               self._flip(s, k, 'SE'), self._flip(s, k, 'SW'))\n\n  def _flip(self, s: str, k: int, direction: str) -> int:\n    res = 0\n    pos = 0\n    opposite = 0\n\n    for c in s:\n      if c in direction:\n        pos += 1\n      else:\n        pos -= 1\n        opposite += 1\n      res = max(res, pos + 2 * min(k, opposite))\n\n    return res\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3480, "slug": "maximize-subarrays-after-removing-one-conflicting-pair", "solutions": ["class Solution:\n  def maxSubarrays(self, n: int, conflictingPairs: list[list[int]]) -> int:\n    validSubarrays = 0\n    maxLeft = 0\n    secondMaxLeft = 0\n    # gains[i] := the number of additional valid subarrays we can gain if the\n    # restriction at index `i` is removed\n    gains = [0] * (n + 1)\n    # conflicts[r] := left endpoints that conflict with subarrays ending in r\n    conflicts = [[] for _ in range(n + 1)]\n\n    for a, b in conflictingPairs:\n      conflicts[max(a, b)].append(min(a, b))\n\n    for right in range(1, n + 1):\n      for left in conflicts[right]:\n        if left > maxLeft:\n          secondMaxLeft = maxLeft\n          maxLeft = left\n        elif left > secondMaxLeft:\n          secondMaxLeft = left\n      # Subarrays [maxLeft + 1..right],\n      #           [maxLeft + 2..right],\n      #           ...\n      #           [right..right] are valid.\n      validSubarrays += right - maxLeft\n      # If we remove `maxLeft` (the most restrictive conflict), we gain\n      # `maxLeft - secondMaxLeft` new subarrays:\n      # [secondMaxLeft + 1..right],\n      # [secondMaxLeft + 2..right],\n      # ...\n      # [maxLeft..right].\n      gains[maxLeft] += maxLeft - secondMaxLeft\n\n    return validSubarrays + max(gains)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3454, "slug": "separate-squares-ii", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3401, "slug": "find-circular-gift-exchange-chains", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3478, "slug": "choose-k-elements-with-maximum-sum", "solutions": ["class Solution:\n    def findMaxSum(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\n        arr = [(x, i) for i, x in enumerate(nums1)]\n        arr.sort()\n        pq = []\n        s = j = 0\n        n = len(arr)\n        ans = [0] * n\n        for h, (x, i) in enumerate(arr):\n            while j < h and arr[j][0] < x:\n                y = nums2[arr[j][1]]\n                heappush(pq, y)\n                s += y\n                if len(pq) > k:\n                    s -= heappop(pq)\n                j += 1\n            ans[i] = s\n        return ans\n", "class Solution:\n  def findMaxSum(self, nums1: list[int], nums2: list[int], k: int) -> list[int]:\n    ans = [0] * len(nums1)\n    numAndIndexes = sorted([(num, i) for i, num in enumerate(nums1)])\n    minHeap = []\n\n    firstIndex = numAndIndexes[0][1]\n    heapq.heappush(minHeap, nums2[firstIndex])\n    summ = nums2[firstIndex]\n\n    for (prevNum, prevIndex), (currNum, currIndex) in itertools.pairwise(numAndIndexes):\n      if currNum == prevNum:\n        ans[currIndex] = ans[prevIndex]\n      else:\n        ans[currIndex] = summ\n      heapq.heappush(minHeap, nums2[currIndex])\n      summ += nums2[currIndex]\n      if len(minHeap) == k + 1:\n        summ -= heapq.heappop(minHeap)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3470, "slug": "permutations-iv", "solutions": ["class Solution:\n  def permute(self, n: int, k: int) -> list[int]:\n    ans = []\n    isLookingForEven = True\n    remainingNumbers = list(range(1, n + 1))\n\n    for turn in range(n):\n      remainingPermutations = (math.factorial((n - 1 - turn) // 2) *\n                               math.factorial((n - turn) // 2))\n      found = False\n      for index, number in enumerate(remainingNumbers):\n        if number % 2 != isLookingForEven and (turn > 0 or n % 2 == 1):\n          continue\n        if k <= remainingPermutations:\n          ans.append(remainingNumbers.pop(index))\n          isLookingForEven = ans[-1] % 2 == 0\n          found = True\n          break\n        k -= remainingPermutations\n      if not found:\n        return []\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3494, "slug": "find-the-minimum-amount-of-time-to-brew-potions", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3411, "slug": "maximum-subarray-with-equal-products", "solutions": ["class Solution:\n    def maxLength(self, nums: List[int]) -> int:\n        n = len(nums)\n        ans = 0\n        max_p = lcm(*nums) * max(nums)\n        for i in range(n):\n            p, g, l = 1, 0, 1\n            for j in range(i, n):\n                p *= nums[j]\n                g = gcd(g, nums[j])\n                l = lcm(l, nums[j])\n                if p == g * l:\n                    ans = max(ans, j - i + 1)\n                if p > max_p:\n                    break\n        return ans\n", "class Solution:\n  def maxLength(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = 0\n\n    for i in range(n):\n      prod = 1\n      l = 1\n      g = 0\n      for j in range(i, n):\n        prod *= nums[j]\n        l = math.lcm(l, nums[j])\n        g = math.gcd(g, nums[j])\n        if prod == l * g:\n          ans = max(ans, j - i + 1)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3441, "slug": "minimum-cost-good-caption", "solutions": ["class Solution:\n\n  def minCostGoodCaption(self, caption: str) -> str:\n    n = len(caption)\n    if n < 3:\n      return ''\n\n    MAX_COST = 1_000_000_000\n    # dp[i][j][k] := the minimum cost of caption[i..n - 1], where j is the last\n    # letter used, and k is the count of consecutive letters\n    dp = [[[MAX_COST] * 3 for _ in range(26)] for _ in range(n)]\n\n    for c in range(26):\n      dp[-1][c][0] = abs(string.ascii_lowercase.index(caption[-1]) - c)\n\n    minCost = MAX_COST\n\n    for i in range(n - 2, -1, -1):\n      newMinCost = MAX_COST\n      for c in range(26):\n        changeCost = abs(string.ascii_lowercase.index(caption[i]) - c)\n        dp[i][c][0] = changeCost + minCost\n        dp[i][c][1] = changeCost + dp[i + 1][c][0]\n        dp[i][c][2] = changeCost + min(dp[i + 1][c][1], dp[i + 1][c][2])\n        newMinCost = min(newMinCost, dp[i][c][2])\n      minCost = newMinCost\n\n    # Reconstruct the string.\n    ans = []\n    cost = MAX_COST\n    letter = -1\n\n    # Find the initial best letter.\n    for c in range(25, -1, -1):\n      if dp[0][c][2] <= cost:\n        letter = c\n        cost = dp[0][c][2]\n\n    # Add the initial triplet.\n    cost -= self._appendLetter(caption, 0, chr(ord('a') + letter), ans)\n    cost -= self._appendLetter(caption, 1, chr(ord('a') + letter), ans)\n    cost -= self._appendLetter(caption, 2, chr(ord('a') + letter), ans)\n\n    # Build the rest of the string.\n    i = 3\n    while i < n:\n      nextLetter = self._getNextLetter(dp, i, cost)\n      if nextLetter < letter or min(dp[i][letter]) > cost:\n        letter = nextLetter\n        cost -= self._appendLetter(caption, i, chr(ord('a') + letter), ans)\n        cost -= self._appendLetter(caption, i + 1, chr(ord('a') + letter), ans)\n        cost -= self._appendLetter(caption, i + 2, chr(ord('a') + letter), ans)\n        i += 3\n      else:\n        cost -= self._appendLetter(caption, i, chr(ord('a') + letter), ans)\n        i += 1\n\n    return ''.join(ans)\n\n  def _getNextLetter(self, dp: list[list[list[int]]], i: int, cost: int) -> int:\n    nextLetter = 26\n    for c in range(25, -1, -1):\n      if cost == dp[i][c][2]:\n        nextLetter = c\n    return nextLetter\n\n  def _appendLetter(\n      self,\n      caption: str,\n      i: int,\n      letter: str,\n      ans: list[str]\n  ) -> int:\n    ans.append(letter)\n    return abs(ord(caption[i]) - ord(letter))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3446, "slug": "sort-matrix-by-diagonals", "solutions": ["class Solution:\n    def sortMatrix(self, grid: List[List[int]]) -> List[List[int]]:\n        n = len(grid)\n        for k in range(n - 2, -1, -1):\n            i, j = k, 0\n            t = []\n            while i < n and j < n:\n                t.append(grid[i][j])\n                i += 1\n                j += 1\n            t.sort()\n            i, j = k, 0\n            while i < n and j < n:\n                grid[i][j] = t.pop()\n                i += 1\n                j += 1\n        for k in range(n - 2, 0, -1):\n            i, j = k, n - 1\n            t = []\n            while i >= 0 and j >= 0:\n                t.append(grid[i][j])\n                i -= 1\n                j -= 1\n            t.sort()\n            i, j = k, n - 1\n            while i >= 0 and j >= 0:\n                grid[i][j] = t.pop()\n                i -= 1\n                j -= 1\n        return grid\n", "class Solution:\n  def sortMatrix(self, grid: list[list[int]]) -> list[list[int]]:\n    n = len(grid)\n    ans = [[0] * n for _ in range(n)]\n    diag = collections.defaultdict(list)\n\n    for i, row in enumerate(grid):\n      for j, num in enumerate(row):\n        diag[i - j].append(num)\n\n    for key in diag:\n      diag[key].sort(reverse=key < 0)\n\n    for i in range(n):\n      for j in range(n):\n        ans[i][j] = diag[i - j].pop()\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3432, "slug": "count-partitions-with-even-sum-difference", "solutions": ["class Solution:\n    def countPartitions(self, nums: List[int]) -> int:\n        l, r = 0, sum(nums)\n        ans = 0\n        for x in nums[:-1]:\n            l += x\n            r -= x\n            ans += (l - r) % 2 == 0\n        return ans\n", "class Solution:\n  def countPartitions(self, nums: list[int]) -> int:\n    # If we add the same number in the left subarray and remove it from the\n    # right subarray, then the difference remains the same parity. So, just\n    # return the number of ways to partition the array into two subarrays when\n    # the array sum is even.\n    return len(nums) - 1 if sum(nums) % 2 == 0 else 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3426, "slug": "manhattan-distances-of-all-arrangements-of-pieces", "solutions": ["class Solution:\n  def distanceSum(self, m: int, n: int, k: int) -> int:\n    # For each distance d, where 1 < d < m, there are `m - d` ways to choose\n    # the two columns that the two pieces are on. For each of the two pieces,\n    # there are `n` ways to choose the row that the piece is on.\n    # Therefore, the contribution of row differences is\n    #   sum(d * (m - d) * n^2), where 1 < d <= m - 1\n    # = n^2 * sum(d * m - d^2)\n    # = n^2 * (d * m * (m - 1) / 2 - m * (m - 1) * (2m - 1) / 6)\n    # = n^2 * (m^3 - m) / 6\n    # Similarly, the contribution of column differences is\n    #   m^2 * (n^3 - n) / 6\n    MOD = 1_000_000_007\n    return (n**2 * (m**3 - m) // 6 +\n            m**2 * (n**3 - n) // 6) * math.comb(m * n - 2, k - 2) % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3496, "slug": "maximize-score-after-pair-deletions", "solutions": ["class Solution:\n    def maxScore(self, nums: List[int]) -> int:\n        s = sum(nums)\n        if len(nums) & 1:\n            return s - min(nums)\n        return s - min(a + b for a, b in pairwise(nums))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3485, "slug": "longest-common-prefix-of-k-strings-after-removal", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3408, "slug": "design-task-manager", "solutions": ["class TaskManager:\n    def __init__(self, tasks: List[List[int]]):\n        self.d = {}\n        self.st = SortedList()\n        for task in tasks:\n            self.add(*task)\n\n    def add(self, userId: int, taskId: int, priority: int) -> None:\n        self.d[taskId] = (userId, priority)\n        self.st.add((-priority, -taskId))\n\n    def edit(self, taskId: int, newPriority: int) -> None:\n        userId, priority = self.d[taskId]\n        self.st.discard((-priority, -taskId))\n        self.d[taskId] = (userId, newPriority)\n        self.st.add((-newPriority, -taskId))\n\n    def rmv(self, taskId: int) -> None:\n        _, priority = self.d[taskId]\n        self.d.pop(taskId)\n        self.st.remove((-priority, -taskId))\n\n    def execTop(self) -> int:\n        if not self.st:\n            return -1\n        taskId = -self.st.pop(0)[1]\n        userId, _ = self.d[taskId]\n        self.d.pop(taskId)\n        return userId\n\n\n# Your TaskManager object will be instantiated and called as such:\n# obj = TaskManager(tasks)\n# obj.add(userId,taskId,priority)\n# obj.edit(taskId,newPriority)\n# obj.rmv(taskId)\n# param_4 = obj.execTop()\n", "from dataclasses import dataclass\nfrom sortedcontainers import SortedDict, SortedSet\n\n\n@dataclass(frozen=True)\nclass Task:\n  userId: int\n  taskId: int\n  priority: int\n\n  def __lt__(self, other):\n    if self.priority == other.priority:\n      return self.taskId > other.taskId\n    return self.priority > other.priority\n\n\nclass TaskManager:\n  def __init__(self, tasks: list[list[int]]):\n    self.taskMap = SortedDict()  # {taskId: Task}, keeps tasks sorted by taskId\n    self.taskSet = SortedSet()  # Stores tasks sorted by priority and taskId\n    for task in tasks:\n      self.add(task[0], task[1], task[2])\n\n  def add(self, userId: int, taskId: int, priority: int) -> None:\n    task = Task(userId, taskId, priority)\n    self.taskMap[taskId] = task\n    self.taskSet.add(task)\n\n  def edit(self, taskId: int, newPriority: int) -> None:\n    task = self.taskMap[taskId]\n    self.taskSet.remove(task)\n    editedTask = Task(task.userId, taskId, newPriority)\n    self.taskSet.add(editedTask)\n    self.taskMap[taskId] = editedTask\n\n  def rmv(self, taskId: int) -> None:\n    task = self.taskMap[taskId]\n    self.taskSet.remove(task)\n    del self.taskMap[taskId]\n\n  def execTop(self):\n    if not self.taskSet:\n      return -1\n    task = self.taskSet.pop(0)\n    del self.taskMap[task.taskId]\n    return task.userId\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3484, "slug": "design-spreadsheet", "solutions": ["class Spreadsheet:\n    def __init__(self, rows: int):\n        self.d = {}\n\n    def setCell(self, cell: str, value: int) -> None:\n        self.d[cell] = value\n\n    def resetCell(self, cell: str) -> None:\n        self.d.pop(cell, None)\n\n    def getValue(self, formula: str) -> int:\n        ans = 0\n        for cell in formula[1:].split(\"+\"):\n            ans += int(cell) if cell[0].isdigit() else self.d.get(cell, 0)\n        return ans\n\n\n# Your Spreadsheet object will be instantiated and called as such:\n# obj = Spreadsheet(rows)\n# obj.setCell(cell,value)\n# obj.resetCell(cell)\n# param_3 = obj.getValue(formula)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3405, "slug": "count-the-number-of-arrays-with-k-matching-adjacent-elements", "solutions": ["class Solution:\n  def countGoodArrays(self, n: int, m: int, k: int) -> int:\n    MOD = 1_000_000_007\n    return m * pow(m - 1, n - k - 1, MOD) * math.comb(n - 1, k) % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3400, "slug": "maximum-number-of-matching-indices-after-right-shifts", "solutions": ["class Solution:\n    def maximumMatchingIndices(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        ans = 0\n        for k in range(n):\n            t = sum(nums1[(i + k) % n] == x for i, x in enumerate(nums2))\n            ans = max(ans, t)\n        return ans\n", "class Solution:\n  def maximumMatchingIndices(self, nums1: list[int], nums2: list[int]) -> int:\n    n = len(nums1)\n    ans = 0\n\n    for shift in range(n):\n      matches = 0\n      for i, num2 in enumerate(nums2):\n        if nums1[(i + shift) % n] == num2:\n          matches += 1\n      ans = max(ans, matches)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3404, "slug": "count-special-subsequences", "solutions": ["class Solution:\n    def numberOfSubsequences(self, nums: List[int]) -> int:\n        n = len(nums)\n        cnt = defaultdict(int)\n        for r in range(4, n - 2):\n            c = nums[r]\n            for s in range(r + 2, n):\n                d = nums[s]\n                g = gcd(c, d)\n                cnt[(d // g, c // g)] += 1\n        ans = 0\n        for q in range(2, n - 4):\n            b = nums[q]\n            for p in range(q - 1):\n                a = nums[p]\n                g = gcd(a, b)\n                ans += cnt[(a // g, b // g)]\n            c = nums[q + 2]\n            for s in range(q + 4, n):\n                d = nums[s]\n                g = gcd(c, d)\n                cnt[(d // g, c // g)] -= 1\n        return ans\n", "class Solution:\n  def numberOfSubsequences(self, nums: list[int]) -> int:\n    n = len(nums)\n    mx = max(nums)\n    ans = 0\n    count = [[0] * (mx + 1) for _ in range(mx + 1)]\n\n    # nums[p] * nums[r] == nums[q] * nums[s]\n    # nums[p] / nums[q] == nums[s] / nums[r]\n    for r in range(4, n - 1 - 2 + 1):\n      q = r - 2\n      for p in range(0, q - 2 + 1):\n        g = math.gcd(nums[p], nums[q])\n        count[nums[p] // g][nums[q] // g] += 1\n      for s in range(r + 2, n):\n        g = math.gcd(nums[s], nums[r])\n        ans += count[nums[s] // g][nums[r] // g]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3464, "slug": "maximize-the-distance-between-points-on-a-square", "solutions": ["from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass Sequence:\n  startX: int\n  startY: int\n  endX: int\n  endY: int\n  length: int\n\n  def __iter__(self):\n    yield self.startX\n    yield self.startY\n    yield self.endX\n    yield self.endY\n    yield self.length\n\n\nclass Solution:\n  def maxDistance(self, side: int, points: list[list[int]], k: int) -> int:\n    ordered = self._getOrderedPoints(side, points)\n\n    def isValidDistance(m: int) -> bool:\n      \"\"\"\n      Returns True if we can select `k` points such that the minimum Manhattan\n      distance between any two consecutive chosen points is at least `m`.\n      \"\"\"\n      dq = collections.deque([Sequence(*ordered[0], *ordered[0], 1)])\n      maxLength = 1\n\n      for i in range(1, len(ordered)):\n        x, y = ordered[i]\n        startX, startY = ordered[i]\n        length = 1\n        while dq and abs(x - dq[0].endX) + abs(y - dq[0].endY) >= m:\n          if (abs(x - dq[0].startX) + abs(y - dq[0].startY) >= m\n                  and dq[0].length + 1 >= length):\n            startX = dq[0].startX\n            startY = dq[0].startY\n            length = dq[0].length + 1\n            maxLength = max(maxLength, length)\n          dq.popleft()\n        dq.append(Sequence(startX, startY, x, y, length))\n\n      return maxLength >= k\n\n    l = 0\n    r = side\n\n    while l < r:\n      m = (l + r + 1) // 2\n      if isValidDistance(m):\n        l = m\n      else:\n        r = m - 1\n\n    return l\n\n  def _getOrderedPoints(self, side: int, points: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Returns the ordered points on the perimeter of a square of side length\n    `side`, starting from left, top, right, and bottom boundaries.\n    \"\"\"\n    left = sorted([(x, y) for x, y in points if x == 0 and y > 0])\n    top = sorted([(x, y) for x, y in points if x > 0 and y == side])\n    right = sorted([(x, y) for x, y in points if x == side and y < side],\n                   reverse=True)\n    bottom = sorted([(x, y) for x, y in points if y == 0], reverse=True)\n    return left + top + right + bottom\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3462, "slug": "maximum-sum-with-at-most-k-elements", "solutions": ["class Solution:\n    def maxSum(self, grid: List[List[int]], limits: List[int], k: int) -> int:\n        pq = []\n        for nums, limit in zip(grid, limits):\n            nums.sort()\n            for _ in range(limit):\n                heappush(pq, nums.pop())\n                if len(pq) > k:\n                    heappop(pq)\n        return sum(pq)\n", "class Solution:\n  def maxSum(self, grid: list[list[int]], limits: list[int], k: int) -> int:\n    minHeap = []\n\n    for row, limit in zip(grid, limits):\n      row.sort(reverse=True)\n      for i in range(limit):\n        heapq.heappush(minHeap, row[i])\n        if len(minHeap) == k + 1:\n          heapq.heappop(minHeap)\n\n    return sum(minHeap)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3403, "slug": "find-the-lexicographically-largest-string-from-the-box-i", "solutions": ["class Solution:\n    def answerString(self, word: str, numFriends: int) -> str:\n        if numFriends == 1:\n            return word\n        n = len(word)\n        ans = \"\"\n        for i in range(n):\n            k = min(n - i, n - numFriends + 1)\n            ans = max(ans, word[i : i + k])\n        return ans\n", "class Solution:\n  def answerString(self, word: str, numFriends: int) -> str:\n    if numFriends == 1:\n      return word\n    s = self._lastSubstring(word)\n    sz = len(word) - numFriends + 1\n    return s[:min(len(s), sz)]\n\n  # Same as 1163. Last Substring in Lexicographical Order\n  def _lastSubstring(self, s: str) -> str:\n    i = 0\n    j = 1\n    k = 0  # the number of the same letters of s[i..n) and s[j..n)\n\n    while j + k < len(s):\n      if s[i + k] == s[j + k]:\n        k += 1\n      elif s[i + k] > s[j + k]:\n        # Skip s[j..j + k) and advance to s[j + k + 1] to find a possible\n        # lexicographically larger substring since s[i..i + k) == s[j..j + k)\n        # and s[i + k] > s[j + k).\n        j = j + k + 1\n        k = 0\n      else:\n        # Skip s[i..i + k) and advance to s[i + k + 1] or s[j] to find a\n        # possible lexicographically larger substring since\n        # s[i..i + k) == s[j..j + k) and s[i + k] < s[j + k).\n        # Note that it's unnecessary to explore s[i + k + 1..j) if\n        # i + k + 1 < j since they are already explored by j.\n        i = max(i + k + 1, j)\n        j = i + 1\n        k = 0\n\n    return s[i:]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3457, "slug": "eat-pizzas", "solutions": ["class Solution:\n    def maxWeight(self, pizzas: List[int]) -> int:\n        days = len(pizzas) // 4\n        pizzas.sort()\n        odd = (days + 1) // 2\n        even = days - odd\n        ans = sum(pizzas[-odd:])\n        i = len(pizzas) - odd - 2\n        for _ in range(even):\n            ans += pizzas[i]\n            i -= 2\n        return ans\n", "class Solution:\n  def maxWeight(self, pizzas: list[int]) -> int:\n    eat = len(pizzas) // 4\n    odd = math.ceil(eat / 2)\n    even = eat - odd\n    pizzas.sort(reverse=True)\n    return (sum(pizzas[:odd]) +\n            sum(pizzas[odd + 1:odd + 1 + even * 2:2]))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3438, "slug": "find-valid-pair-of-adjacent-digits-in-string", "solutions": ["class Solution:\n    def findValidPair(self, s: str) -> str:\n        cnt = [0] * 10\n        for x in map(int, s):\n            cnt[x] += 1\n        for x, y in pairwise(map(int, s)):\n            if x != y and cnt[x] == x and cnt[y] == y:\n                return f\"{x}{y}\"\n        return \"\"\n", "class Solution:\n  def findValidPair(self, s: str) -> str:\n    count = collections.Counter(s)\n    return next((a + b\n                for a, b in itertools.pairwise(s)\n                if a != b and count[a] == int(a) and count[b] == int(b)), '')\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3451, "slug": "find-invalid-ip-addresses", "solutions": ["import pandas as pd\n\n\ndef find_invalid_ips(logs: pd.DataFrame) -> pd.DataFrame:\n    def is_valid_ip(ip: str) -> bool:\n        octets = ip.split(\".\")\n        if len(octets) != 4:\n            return False\n        for octet in octets:\n            if not octet.isdigit():\n                return False\n            value = int(octet)\n            if not 0 <= value <= 255 or octet != str(value):\n                return False\n        return True\n\n    logs[\"is_valid\"] = logs[\"ip\"].apply(is_valid_ip)\n    invalid_ips = logs[~logs[\"is_valid\"]]\n    invalid_count = invalid_ips[\"ip\"].value_counts().reset_index()\n    invalid_count.columns = [\"ip\", \"invalid_count\"]\n    result = invalid_count.sort_values(\n        by=[\"invalid_count\", \"ip\"], ascending=[False, False]\n    )\n    return result\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3493, "slug": "properties-graph", "solutions": ["class Solution:\n    def numberOfComponents(self, properties: List[List[int]], k: int) -> int:\n        def dfs(i: int) -> None:\n            vis[i] = True\n            for j in g[i]:\n                if not vis[j]:\n                    dfs(j)\n\n        n = len(properties)\n        ss = list(map(set, properties))\n        g = [[] for _ in range(n)]\n        for i, s1 in enumerate(ss):\n            for j in range(i):\n                s2 = ss[j]\n                if len(s1 & s2) >= k:\n                    g[i].append(j)\n                    g[j].append(i)\n        ans = 0\n        vis = [False] * n\n        for i in range(n):\n            if not vis[i]:\n                dfs(i)\n                ans += 1\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3436, "slug": "find-valid-emails", "solutions": ["import pandas as pd\n\n\ndef find_valid_emails(users: pd.DataFrame) -> pd.DataFrame:\n    email_pattern = r\"^[A-Za-z0-9_]+@[A-Za-z][A-Za-z0-9]*\\.com$\"\n    valid_emails = users[users[\"email\"].str.match(email_pattern)]\n    valid_emails = valid_emails.sort_values(by=\"user_id\")\n    return valid_emails\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2159, "slug": "order-two-columns-independently", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2174, "slug": "remove-all-ones-with-row-and-column-flips-ii", "solutions": ["class Solution:\n    def removeOnes(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        state = sum(1 << (i * n + j) for i in range(m) for j in range(n) if grid[i][j])\n        q = deque([state])\n        vis = {state}\n        ans = 0\n        while q:\n            for _ in range(len(q)):\n                state = q.popleft()\n                if state == 0:\n                    return ans\n                for i in range(m):\n                    for j in range(n):\n                        if grid[i][j] == 0:\n                            continue\n                        nxt = state\n                        for r in range(m):\n                            nxt &= ~(1 << (r * n + j))\n                        for c in range(n):\n                            nxt &= ~(1 << (i * n + c))\n                        if nxt not in vis:\n                            vis.add(nxt)\n                            q.append(nxt)\n            ans += 1\n        return -1\n", "class Solution:\n  def removeOnes(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    maxMask = 1 << m * n\n    # dp[i] := the minimum number of operations to remove all 1s from the grid,\n    # where `i` is the bitmask of the state of the grid\n    dp = [math.inf] * maxMask\n    dp[0] = 0\n\n    for mask in range(maxMask):\n      for i in range(m):\n        for j in range(n):\n          if grid[i][j] == 1:\n            nextMask = mask\n            # Set the cells in the same row with 0.\n            for k in range(n):\n              nextMask &= ~(1 << i * n + k)\n            # Set the cells in the same column with 0.\n            for k in range(m):\n              nextMask &= ~(1 << k * n + j)\n            dp[mask] = min(dp[mask], 1 + dp[nextMask])\n\n    return dp[self.encode(grid, m, n)]\n\n  def encode(self, grid: list[list[int]], m: int, n: int) -> int:\n    encoded = 0\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j]:\n          encoded |= 1 << i * n + j\n    return encoded\n", "class Solution:\n  def removeOnes(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    @functools.lru_cache(None)\n    def dp(mask: int) -> int:\n      \"\"\"\n      Returns the minimum number of operations to remove all 1s from the grid,\n      where `mask` is the bitmask of the state of the grid.\n      \"\"\"\n      if mask == 0:\n        return 0\n      ans = math.inf\n      for i in range(m):\n        for j in range(n):\n          if mask >> i * n + j & 1:  # grid[i][j] == 1\n            nextMask = mask\n            for k in range(n):  # Set the cells in the same row with 0.\n              nextMask &= ~(1 << i * n + k)\n            for k in range(m):  # Set the cells in the same column with 0.\n              nextMask &= ~(1 << k * n + j)\n            ans = min(ans, 1 + dp(nextMask))\n      return ans\n\n    return dp(self.encode(grid, m, n))\n\n  def encode(self, grid: list[list[int]], m: int, n: int) -> int:\n    encoded = 0\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j]:\n          encoded |= 1 << i * n + j\n    return encoded\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2102, "slug": "sequentially-ordinal-rank-tracker", "solutions": ["class SORTracker:\n    def __init__(self):\n        self.sl = SortedList()\n        self.i = -1\n\n    def add(self, name: str, score: int) -> None:\n        self.sl.add((-score, name))\n\n    def get(self) -> str:\n        self.i += 1\n        return self.sl[self.i][1]\n\n\n# Your SORTracker object will be instantiated and called as such:\n# obj = SORTracker()\n# obj.add(name,score)\n# param_2 = obj.get()\n", "class Location:\n  def __init__(self, name: str, score: int):\n    self.name = name\n    self.score = score\n\n  def __lt__(self, location):\n    if self.score == location.score:\n      return self.name > location.name\n    return self.score < location.score\n\n\nclass SORTracker:\n  def __init__(self):\n    self.l = []\n    self.r = []\n    self.k = 0  the number of times get() called\n\n  def add(self, name: str, score: int) -> None:\n    heapq.heappush(self.l, Location(name, score))\n    if len(self.l) > self.k + 1:\n      location = heapq.heappop(self.l)\n      heapq.heappush(self.r, (-location.score, location.name))\n\n  def get(self) -> str:\n    name = self.l[0].name\n    if self.r:\n      topScore, topName = heapq.heappop(self.r)\n      heapq.heappush(self.l, Location(topName, -topScore))\n    self.k += 1\n    return name\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2107, "slug": "number-of-unique-flavors-after-sharing-k-candies", "solutions": ["class Solution:\n    def shareCandies(self, candies: List[int], k: int) -> int:\n        cnt = Counter(candies[k:])\n        ans = len(cnt)\n        for i in range(k, len(candies)):\n            cnt[candies[i - k]] += 1\n            cnt[candies[i]] -= 1\n            if cnt[candies[i]] == 0:\n                cnt.pop(candies[i])\n            ans = max(ans, len(cnt))\n        return ans\n", "class Solution:\n  def shareCandies(self, candies: list[int], k: int) -> int:\n    ans = 0\n    count = collections.Counter(candies)\n    unique = len(count)\n\n    for i, candy in enumerate(candies):\n      count[candy] -= 1\n      if count[candy] == 0:\n        del count[candy]\n        unique -= 1\n      if i >= k:\n        count[candies[i - k]] += 1\n        if count[candies[i - k]] == 1:\n          unique += 1\n      if i >= k - 1:\n        ans = max(ans, unique)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2158, "slug": "amount-of-new-area-painted-each-day", "solutions": ["class Node:\n    def __init__(self, l, r):\n        self.left = None\n        self.right = None\n        self.l = l\n        self.r = r\n        self.mid = (l + r) >> 1\n        self.v = 0\n        self.add = 0\n\n\nclass SegmentTree:\n    def __init__(self):\n        self.root = Node(1, 10**5 + 10)\n\n    def modify(self, l, r, v, node=None):\n        if l > r:\n            return\n        if node is None:\n            node = self.root\n        if node.l >= l and node.r <= r:\n            node.v = node.r - node.l + 1\n            node.add = v\n            return\n        self.pushdown(node)\n        if l <= node.mid:\n            self.modify(l, r, v, node.left)\n        if r > node.mid:\n            self.modify(l, r, v, node.right)\n        self.pushup(node)\n\n    def query(self, l, r, node=None):\n        if l > r:\n            return 0\n        if node is None:\n            node = self.root\n        if node.l >= l and node.r <= r:\n            return node.v\n        self.pushdown(node)\n        v = 0\n        if l <= node.mid:\n            v += self.query(l, r, node.left)\n        if r > node.mid:\n            v += self.query(l, r, node.right)\n        return v\n\n    def pushup(self, node):\n        node.v = node.left.v + node.right.v\n\n    def pushdown(self, node):\n        if node.left is None:\n            node.left = Node(node.l, node.mid)\n        if node.right is None:\n            node.right = Node(node.mid + 1, node.r)\n        if node.add:\n            left, right = node.left, node.right\n            left.v = left.r - left.l + 1\n            right.v = right.r - right.l + 1\n            left.add = node.add\n            right.add = node.add\n            node.add = 0\n\n\nclass Solution:\n    def amountPainted(self, paint: List[List[int]]) -> List[int]:\n        tree = SegmentTree()\n        ans = []\n        for i, (start, end) in enumerate(paint):\n            l, r = start + 1, end\n            v = tree.query(l, r)\n            ans.append(r - l + 1 - v)\n            tree.modify(l, r, 1)\n        return ans\n", "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def amountPainted(self, paint: list[list[int]]) -> list[int]:\n    minDay = min(s for s, e in paint)\n    maxDay = max(e for s, e in paint)\n    ans = [0] * len(paint)\n    # Stores the indices of paints that are available now.\n    runningIndices = SortedList()\n    events = []  # (day, index, type)\n\n    for i, (start, end) in enumerate(paint):\n      events.append((start, i, 1))  # 1 := entering\n      events.append((end, i, -1))  # -1 := leaving\n\n    events.sort()\n\n    i = 0  # events' index\n    for day in range(minDay, maxDay):\n      while i < len(events) and events[i][0] == day:\n        day, index, type = events[i]\n        if type == 1:\n          runningIndices.add(index)\n        else:\n          runningIndices.remove(index)\n        i += 1\n      if runningIndices:\n        ans[runningIndices[0]] += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2155, "slug": "all-divisions-with-the-highest-score-of-a-binary-array", "solutions": ["class Solution:\n    def maxScoreIndices(self, nums: List[int]) -> List[int]:\n        l0, r1 = 0, sum(nums)\n        mx = r1\n        ans = [0]\n        for i, x in enumerate(nums, 1):\n            l0 += x ^ 1\n            r1 -= x\n            t = l0 + r1\n            if mx == t:\n                ans.append(i)\n            elif mx < t:\n                mx = t\n                ans = [i]\n        return ans\n", "class Solution:\n  def maxScoreIndices(self, nums: list[int]) -> list[int]:\n    zeros = nums.count(0)\n    ones = len(nums) - zeros\n    ans = [0]  # the division at index 0\n    leftZeros = 0\n    leftOnes = 0\n    maxScore = ones  # `leftZeros` + `rightOnes`\n\n    for i, num in enumerate(nums):\n      leftZeros += num == 0\n      leftOnes += num == 1\n      rightOnes = ones - leftOnes\n      score = leftZeros + rightOnes\n      if maxScore == score:\n        ans.append(i + 1)\n      elif maxScore < score:\n        maxScore = score\n        ans = [i + 1]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2151, "slug": "maximum-good-people-based-on-statements", "solutions": ["class Solution:\n    def maximumGood(self, statements: List[List[int]]) -> int:\n        def check(mask: int) -> int:\n            cnt = 0\n            for i, row in enumerate(statements):\n                if mask >> i & 1:\n                    for j, x in enumerate(row):\n                        if x < 2 and (mask >> j & 1) != x:\n                            return 0\n                    cnt += 1\n            return cnt\n\n        return max(check(i) for i in range(1, 1 << len(statements)))\n", "class Solution:\n  def maximumGood(self, statements: list[list[int]]) -> int:\n    n = len(statements)\n\n    def isValid(mask: int) -> bool:\n      for i in range(n):\n        # The i-th person is bad, so no need to check.\n        if (mask >> i & 1) == 0:\n          continue\n        for j in range(n):\n          if statements[i][j] == 2:\n            continue\n          if statements[i][j] != (mask >> j & 1):\n            return False\n      return True\n\n    return max(mask.bit_count()\n               for mask in range(1 << n)\n               if isValid(mask))\n", "class Solution:\n  def maximumGood(self, statements: list[list[int]]) -> int:\n    n = len(statements)\n    ans = 0\n\n    def isValid(good: list[int]) -> bool:\n      for i, g in enumerate(good):\n        if not g:  # The i-th person is bad, so no need to check.\n          continue\n        for j in range(n):\n          if statements[i][j] == 2:\n            continue\n          if statements[i][j] != good[j]:\n            return False\n      return True\n\n    def dfs(good: list[int], i: int, count: int) -> None:\n      nonlocal ans\n      if i == n:\n        if isValid(good):\n          ans = max(ans, count)\n        return\n\n      good.append(0)  # Assume the i-th person is bad.\n      dfs(good, i + 1, count)\n      good[-1] = 1  # Assume the i-th person is good.\n      dfs(good, i + 1, count + 1)\n      good.pop()\n\n    dfs([], 0, 0)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2170, "slug": "minimum-operations-to-make-the-array-alternating", "solutions": ["class Solution:\n    def minimumOperations(self, nums: List[int]) -> int:\n        def f(i: int) -> Tuple[int, int, int, int]:\n            k1 = k2 = 0\n            cnt = Counter(nums[i::2])\n            for k, v in cnt.items():\n                if cnt[k1] < v:\n                    k2, k1 = k1, k\n                elif cnt[k2] < v:\n                    k2 = k\n            return k1, cnt[k1], k2, cnt[k2]\n\n        a, b = f(0), f(1)\n        n = len(nums)\n        if a[0] != b[0]:\n            return n - (a[1] + b[1])\n        return n - max(a[1] + b[3], a[3] + b[1])\n", "class T:\n  def __init__(self):\n    self.count = collections.Counter()\n    self.mx = 0\n    self.secondMax = 0\n    self.maxFreq = 0\n    self.secondMaxFreq = 0\n\n\nclass Solution:\n  def minimumOperations(self, nums: list[int]) -> int:\n    # 0 := odd indices, 1 := even indices\n    ts = [T() for _ in range(2)]\n\n    for i, num in enumerate(nums):\n      t = ts[i % 2]\n      t.count[num] += 1\n      freq = t.count[num]\n      if freq > t.maxFreq:\n        t.maxFreq = freq\n        t.mx = num\n      elif freq > t.secondMaxFreq:\n        t.secondMaxFreq = freq\n        t.secondMax = num\n\n    if ts[0].mx == ts[1].mx:\n      return len(nums) - max(ts[0].maxFreq + ts[1].secondMaxFreq,\n                             ts[1].maxFreq + ts[0].secondMaxFreq)\n    return len(nums) - (ts[0].maxFreq + ts[1].maxFreq)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2139, "slug": "minimum-moves-to-reach-target-score", "solutions": ["class Solution:\n    def minMoves(self, target: int, maxDoubles: int) -> int:\n        if target == 1:\n            return 0\n        if maxDoubles == 0:\n            return target - 1\n        if target % 2 == 0 and maxDoubles:\n            return 1 + self.minMoves(target >> 1, maxDoubles - 1)\n        return 1 + self.minMoves(target - 1, maxDoubles)\n", "class Solution:\n  def minMoves(self, target: int, maxDoubles: int) -> int:\n    steps = 0\n\n    while target > 1 and maxDoubles:\n      if target % 2 == 1:\n        target -= 1\n      else:\n        target //= 2\n        maxDoubles -= 1\n      steps += 1\n\n    return steps + target - 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2176, "slug": "count-equal-and-divisible-pairs-in-an-array", "solutions": ["class Solution:\n    def countPairs(self, nums: List[int], k: int) -> int:\n        ans = 0\n        for j in range(1, len(nums)):\n            for i, x in enumerate(nums[:j]):\n                ans += int(x == nums[j] and i * j % k == 0)\n        return ans\n", "class Solution:\n  def countPairs(self, nums: list[int], k: int) -> int:\n    ans = 0\n    numToIndices = collections.defaultdict(list)\n\n    for i, num in enumerate(nums):\n      numToIndices[num].append(i)\n\n    for indices in numToIndices.values():\n      gcds = collections.Counter()\n      for i in indices:\n        gcd_i = math.gcd(i, k)\n        for gcd_j, count in gcds.items():\n          if gcd_i * gcd_j % k == 0:\n            ans += count\n        gcds[gcd_i] += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2124, "slug": "check-if-all-as-appears-before-all-bs", "solutions": ["class Solution:\n    def checkString(self, s: str) -> bool:\n        return \"ba\" not in s\n", "class Solution:\n  def checkString(self, s: str) -> bool:\n    return 'ba' not in s\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2161, "slug": "partition-array-according-to-given-pivot", "solutions": ["class Solution:\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\n        a, b, c = [], [], []\n        for x in nums:\n            if x < pivot:\n                a.append(x)\n            elif x == pivot:\n                b.append(x)\n            else:\n                c.append(x)\n        return a + b + c\n", "class Solution:\n  def pivotArray(self, nums: list[int], pivot: int) -> list[int]:\n    return ([num for num in nums if num < pivot] +\n            [num for num in nums if num == pivot] +\n            [num for num in nums if num > pivot])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2169, "slug": "count-operations-to-obtain-zero", "solutions": ["class Solution:\n    def countOperations(self, num1: int, num2: int) -> int:\n        ans = 0\n        while num1 and num2:\n            if num1 >= num2:\n                num1 -= num2\n            else:\n                num2 -= num1\n            ans += 1\n        return ans\n", "class Solution:\n  def countOperations(self, num1: int, num2: int) -> int:\n    ans = 0\n\n    while num1 and num2:\n      if num1 < num2:\n        num1, num2 = num2, num1\n      ans += num1 // num2\n      num1 %= num2\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2165, "slug": "smallest-value-of-the-rearranged-number", "solutions": ["class Solution:\n    def smallestNumber(self, num: int) -> int:\n        neg = num < 0\n        num = abs(num)\n        cnt = [0] * 10\n        while num:\n            cnt[num % 10] += 1\n            num //= 10\n        ans = 0\n        if neg:\n            for i in reversed(range(10)):\n                for _ in range(cnt[i]):\n                    ans *= 10\n                    ans += i\n            return -ans\n        if cnt[0]:\n            for i in range(1, 10):\n                if cnt[i]:\n                    ans = i\n                    cnt[i] -= 1\n                    break\n        for i in range(10):\n            for _ in range(cnt[i]):\n                ans *= 10\n                ans += i\n        return ans\n", "class Solution:\n  def smallestNumber(self, num: int) -> int:\n    s = sorted(str(abs(num)), reverse=num < 0)\n    firstNonZeroIndex = next((i for i, c in enumerate(s) if c != '0'), 0)\n    s[0], s[firstNonZeroIndex] = s[firstNonZeroIndex], s[0]\n    return int(''.join(s)) * (-1 if num < 0 else 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2115, "slug": "find-all-possible-recipes-from-given-supplies", "solutions": ["class Solution:\n    def findAllRecipes(\n        self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]\n    ) -> List[str]:\n        g = defaultdict(list)\n        indeg = defaultdict(int)\n        for a, b in zip(recipes, ingredients):\n            for v in b:\n                g[v].append(a)\n            indeg[a] += len(b)\n        q = supplies\n        ans = []\n        for i in q:\n            for j in g[i]:\n                indeg[j] -= 1\n                if indeg[j] == 0:\n                    ans.append(j)\n                    q.append(j)\n        return ans\n", "class Solution:\n  def findAllRecipes(\n      self,\n      recipes: list[str],\n      ingredients: list[list[str]],\n      supplies: list[str],\n  ) -> list[str]:\n    ans = []\n    supplies = set(supplies)\n    graph = collections.defaultdict(list)\n    inDegrees = collections.Counter()\n    q = collections.deque()\n\n    # Build the graph.\n    for i, recipe in enumerate(recipes):\n      for ingredient in ingredients[i]:\n        if ingredient not in supplies:\n          graph[ingredient].append(recipe)\n          inDegrees[recipe] += 1\n\n    # Perform topological sorting.\n    for recipe in recipes:\n      if inDegrees[recipe] == 0:\n        q.append(recipe)\n\n    while q:\n      u = q.popleft()\n      ans.append(u)\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2187, "slug": "minimum-time-to-complete-trips", "solutions": ["class Solution:\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\n        mx = min(time) * totalTrips\n        return bisect_left(\n            range(mx), totalTrips, key=lambda x: sum(x // v for v in time)\n        )\n", "class Solution:\n  def minimumTime(self, time: list[int], totalTrips: int) -> int:\n    l = 1\n    r = min(time) * totalTrips\n\n    while l < r:\n      m = (l + r) // 2\n      if sum(m // t for t in time) >= totalTrips:\n        r = m\n      else:\n        l = m + 1\n\n    return l\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2185, "slug": "counting-words-with-a-given-prefix", "solutions": ["class Solution:\n    def prefixCount(self, words: List[str], pref: str) -> int:\n        return sum(w.startswith(pref) for w in words)\n", "class Solution:\n  def prefixCount(self, words: list[str], pref: str) -> int:\n    return sum(word.startswith(pref) for word in words)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2118, "slug": "build-the-equation", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2121, "slug": "intervals-between-identical-elements", "solutions": ["class Solution:\n    def getDistances(self, arr: List[int]) -> List[int]:\n        d = defaultdict(list)\n        n = len(arr)\n        for i, v in enumerate(arr):\n            d[v].append(i)\n        ans = [0] * n\n        for v in d.values():\n            m = len(v)\n            val = sum(v) - v[0] * m\n            for i, p in enumerate(v):\n                delta = v[i] - v[i - 1] if i >= 1 else 0\n                val += i * delta - (m - i) * delta\n                ans[p] = val\n        return ans\n", "class Solution:\n  def getDistances(self, arr: list[int]) -> list[int]:\n    prefix = [0] * len(arr)\n    suffix = [0] * len(arr)\n    numToIndices = collections.defaultdict(list)\n\n    for i, a in enumerate(arr):\n      numToIndices[a].append(i)\n\n    for indices in numToIndices.values():\n      for i in range(1, len(indices)):\n        currIndex = indices[i]\n        prevIndex = indices[i - 1]\n        prefix[currIndex] += prefix[prevIndex] + i * (currIndex - prevIndex)\n      for i in range(len(indices) - 2, -1, -1):\n        currIndex = indices[i]\n        prevIndex = indices[i + 1]\n        suffix[currIndex] += (suffix[prevIndex] +\n                              (len(indices) - i - 1) * (prevIndex - currIndex))\n\n    return [p + s for p, s in zip(prefix, suffix)]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2125, "slug": "number-of-laser-beams-in-a-bank", "solutions": ["class Solution:\n    def numberOfBeams(self, bank: List[str]) -> int:\n        ans = pre = 0\n        for row in bank:\n            if (cur := row.count(\"1\")) > 0:\n                ans += pre * cur\n                pre = cur\n        return ans\n", "class Solution:\n  def numberOfBeams(self, bank: list[str]) -> int:\n    ans = 0\n    prevOnes = 0\n\n    for row in bank:\n      ones = row.count('1')\n      if ones:\n        ans += prevOnes * ones\n        prevOnes = ones\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2105, "slug": "watering-plants-ii", "solutions": ["class Solution:\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\n        a, b = capacityA, capacityB\n        ans = 0\n        i, j = 0, len(plants) - 1\n        while i < j:\n            if a < plants[i]:\n                ans += 1\n                a = capacityA\n            a -= plants[i]\n            if b < plants[j]:\n                ans += 1\n                b = capacityB\n            b -= plants[j]\n            i, j = i + 1, j - 1\n        ans += i == j and max(a, b) < plants[i]\n        return ans\n", "class Solution:\n  def minimumRefill(\n      self,\n      plants: list[int],\n      capacityA: int,\n      capacityB: int,\n  ) -> int:\n    ans = 0\n    i = 0\n    j = len(plants) - 1\n    canA = capacityA\n    canB = capacityB\n\n    while i < j:\n      ans += (canA < plants[i]) + (canB < plants[j])\n      if canA < plants[i]:\n        canA = capacityA\n      if canB < plants[j]:\n        canB = capacityB\n      canA -= plants[i]\n      canB -= plants[j]\n      i += 1\n      j -= 1\n\n    return ans + (i == j and max(canA, canB) < plants[i])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2149, "slug": "rearrange-array-elements-by-sign", "solutions": ["class Solution:\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\n        ans = [0] * len(nums)\n        i, j = 0, 1\n        for x in nums:\n            if x > 0:\n                ans[i] = x\n                i += 2\n            else:\n                ans[j] = x\n                j += 2\n        return ans\n", "class Solution:\n  def rearrangeArray(self, nums: list[int]) -> list[int]:\n    ans = []\n    pos = []\n    neg = []\n\n    for num in nums:\n      (pos if num > 0 else neg).append(num)\n\n    for p, n in zip(pos, neg):\n      ans += [p, n]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2134, "slug": "minimum-swaps-to-group-all-1s-together-ii", "solutions": ["class Solution:\n    def minSwaps(self, nums: List[int]) -> int:\n        k = nums.count(1)\n        mx = cnt = sum(nums[:k])\n        n = len(nums)\n        for i in range(k, n + k):\n            cnt += nums[i % n]\n            cnt -= nums[(i - k + n) % n]\n            mx = max(mx, cnt)\n        return k - mx\n", "class Solution:\n  def minSwaps(self, nums: list[int]) -> int:\n    n = len(nums)\n    k = nums.count(1)\n    ones = 0  # the number of ones in the window\n    maxOnes = 0  # the maximum number of ones in the window\n\n    for i in range(n * 2):\n      if i >= k and nums[i % n - k]:  # Magic in Python :)\n        ones -= 1\n      if nums[i % n]:\n        ones += 1\n      maxOnes = max(maxOnes, ones)\n\n    return k - maxOnes\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2144, "slug": "minimum-cost-of-buying-candies-with-discount", "solutions": ["class Solution:\n    def minimumCost(self, cost: List[int]) -> int:\n        cost.sort(reverse=True)\n        return sum(cost) - sum(cost[2::3])\n", "class Solution:\n  def minimumCost(self, cost: list[int]) -> int:\n    return sum(cost) - sum(sorted(cost)[-3::-3])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2113, "slug": "elements-in-array-after-removing-and-replacing-elements", "solutions": ["class Solution:\n    def elementInNums(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        n, m = len(nums), len(queries)\n        ans = [-1] * m\n        for j, (t, i) in enumerate(queries):\n            t %= 2 * n\n            if t < n and i < n - t:\n                ans[j] = nums[i + t]\n            elif t > n and i < t - n:\n                ans[j] = nums[i]\n        return ans\n", "class Solution:\n  def elementInNums(\n      self,\n      nums: list[int],\n      queries: list[list[int]],\n  ) -> list[int]:\n    n = len(nums)\n\n    def f(time: int, index: int) -> int:\n      if time < n:  # [0, 1, 2] -> [1, 2] -> [2]\n        index += time\n        return -1 if index >= n else nums[index]\n      else:  # [] -> [0] -> [0, 1]\n        return -1 if index >= time - n else nums[index]\n\n    return [f(time % (2 * n), index) for time, index in queries]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2138, "slug": "divide-a-string-into-groups-of-size-k", "solutions": ["class Solution:\n    def divideString(self, s: str, k: int, fill: str) -> List[str]:\n        return [s[i : i + k].ljust(k, fill) for i in range(0, len(s), k)]\n", "class Solution:\n  def divideString(self, s: str, k: int, fill: str) -> list[str]:\n    return [\n        s[i:] + fill * (i + k - len(s)) if i + k > len(s)\n        else s[i:i + k]\n        for i in range(0, len(s), k)\n    ]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2189, "slug": "number-of-ways-to-build-house-of-cards", "solutions": ["class Solution:\n    def houseOfCards(self, n: int) -> int:\n        @cache\n        def dfs(n: int, k: int) -> int:\n            x = 3 * k + 2\n            if x > n:\n                return 0\n            if x == n:\n                return 1\n            return dfs(n - x, k + 1) + dfs(n, k + 1)\n\n        return dfs(n, 0)\n", "class Solution:\n  def houseOfCards(self, n: int) -> int:\n    # dp[i] := the number of valid result for i cards\n    dp = [1] + [0] * n\n\n    for baseCards in range(2, n + 1, 3):\n      for i in range(n, baseCards - 1, -1):\n        # Use `baseCards` as the base, so we're left with `i - baseCards` cards.\n        dp[i] += dp[i - baseCards]\n\n    return dp[n]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2108, "slug": "find-first-palindromic-string-in-the-array", "solutions": ["class Solution:\n    def firstPalindrome(self, words: List[str]) -> str:\n        return next((w for w in words if w == w[::-1]), \"\")\n", "class Solution:\n  def firstPalindrome(self, words: list[str]) -> str:\n    def isPalindrome(s: str) -> bool:\n      i = 0\n      j = len(s) - 1\n      while i < j:\n        if s[i] != s[j]:\n          return False\n        i += 1\n        j -= 1\n      return True\n    return next((word for word in words if isPalindrome(word)), '')\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2154, "slug": "keep-multiplying-found-values-by-two", "solutions": ["class Solution:\n    def findFinalValue(self, nums: List[int], original: int) -> int:\n        s = set(nums)\n        while original in s:\n            original <<= 1\n        return original\n", "class Solution:\n  def findFinalValue(self, nums: list[int], original: int) -> int:\n    seen = [False] * 1001\n\n    for num in nums:\n      seen[num] = True\n\n    while original < 1001 and seen[original]:\n      original *= 2\n\n    return original\n", "class Solution:\n  def findFinalValue(self, nums: list[int], original: int) -> int:\n    numsSet = set(nums)\n    while original in numsSet:\n      original *= 2\n    return original\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2100, "slug": "find-good-days-to-rob-the-bank", "solutions": ["class Solution:\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\n        n = len(security)\n        if n <= time * 2:\n            return []\n        left, right = [0] * n, [0] * n\n        for i in range(1, n):\n            if security[i] <= security[i - 1]:\n                left[i] = left[i - 1] + 1\n        for i in range(n - 2, -1, -1):\n            if security[i] <= security[i + 1]:\n                right[i] = right[i + 1] + 1\n        return [i for i in range(n) if time <= min(left[i], right[i])]\n", "class Solution:\n  def goodDaysToRobBank(self, security: list[int], time: int) -> list[int]:\n    n = len(security)\n    dec = [0] * n  # dec[i] := the number of continuous decreasing numbers before i\n    inc = [0] * n  # inc[i] := the number of continuous increasing numbers after i\n\n    for i in range(1, n):\n      if security[i - 1] >= security[i]:\n        dec[i] = dec[i - 1] + 1\n\n    for i in range(n - 2, -1, -1):\n      if security[i] <= security[i + 1]:\n        inc[i] = inc[i + 1] + 1\n\n    return [i for i, (a, b) in enumerate(zip(dec, inc))\n            if a >= time and b >= time]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2164, "slug": "sort-even-and-odd-indices-independently", "solutions": ["class Solution:\n    def sortEvenOdd(self, nums: List[int]) -> List[int]:\n        a = sorted(nums[::2])\n        b = sorted(nums[1::2], reverse=True)\n        nums[::2] = a\n        nums[1::2] = b\n        return nums\n", "class Solution:\n  def sortEvenOdd(self, nums: list[int]) -> list[int]:\n    nums[::2] = sorted(nums[::2])\n    nums[1::2] = sorted(nums[1::2])[::-1]\n    return nums\n", "class Solution:\n  def sortEvenOdd(self, nums: list[int]) -> list[int]:\n    ans = [0] * len(nums)\n    evenCount = collections.Counter(nums[::2])\n    oddCount = collections.Counter(nums[1::2])\n\n    ansIndex = 0\n    for i in range(1, 101):\n      while evenCount[i] > 0:\n        ans[ansIndex] = i\n        ansIndex += 2\n        evenCount[i] -= 1\n\n    ansIndex = 1\n    for i in range(100, 0, -1):\n      while oddCount[i] > 0:\n        ans[ansIndex] = i\n        ansIndex += 2\n        oddCount[i] -= 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2162, "slug": "minimum-cost-to-set-cooking-time", "solutions": ["class Solution:\n    def minCostSetTime(\n        self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int\n    ) -> int:\n        def f(m, s):\n            if not 0 <= m < 100 or not 0 <= s < 100:\n                return inf\n            arr = [m // 10, m % 10, s // 10, s % 10]\n            i = 0\n            while i < 4 and arr[i] == 0:\n                i += 1\n            t = 0\n            prev = startAt\n            for v in arr[i:]:\n                if v != prev:\n                    t += moveCost\n                t += pushCost\n                prev = v\n            return t\n\n        m, s = divmod(targetSeconds, 60)\n        ans = min(f(m, s), f(m - 1, s + 60))\n        return ans\n", "class Solution:\n  def minCostSetTime(\n      self,\n      startAt: int,\n      moveCost: int,\n      pushCost: int,\n      targetSeconds: int,\n  ) -> int:\n    ans = math.inf\n    mins = 99 if targetSeconds > 5999 else targetSeconds // 60\n    secs = targetSeconds - mins * 60\n\n    def getCost(mins: int, secs: int) -> int:\n      cost = 0\n      curr = str(startAt)\n      for c in str(mins * 100 + secs):\n        if c == curr:\n          cost += pushCost\n        else:\n          cost += moveCost + pushCost\n          curr = c\n      return cost\n\n    while secs < 100:\n      ans = min(ans, getCost(mins, secs))\n      mins -= 1\n      secs += 60\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2130, "slug": "maximum-twin-sum-of-a-linked-list", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def pairSum(self, head: Optional[ListNode]) -> int:\n        s = []\n        while head:\n            s.append(head.val)\n            head = head.next\n        n = len(s)\n        return max(s[i] + s[-(i + 1)] for i in range(n >> 1))\n", "class Solution:\n  def pairSum(self, head: ListNode | None) -> int:\n    def reverseList(head: ListNode) -> ListNode:\n      prev = None\n      while head:\n        next = head.next\n        head.next = prev\n        prev = head\n        head = next\n      return prev\n\n    ans = 0\n    slow = head\n    fast = head\n\n    # `slow` points to the start of the second half.\n    while fast and fast.next:\n      slow = slow.next\n      fast = fast.next.next\n\n    # `tail` points to the end of the reversed second half.\n    tail = reverseList(slow)\n\n    while tail:\n      ans = max(ans, head.val + tail.val)\n      head = head.next\n      tail = tail.next\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2133, "slug": "check-if-every-row-and-column-contains-all-numbers", "solutions": ["class Solution:\n    def checkValid(self, matrix: List[List[int]]) -> bool:\n        n = len(matrix)\n        return all(len(set(row)) == n for row in chain(matrix, zip(*matrix)))\n", "class Solution:\n  def checkValid(self, matrix: list[list[int]]) -> bool:\n    return all(min(len(set(row)), len(set(col))) == len(matrix)\n               for row, col in zip(matrix, zip(*matrix)))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2180, "slug": "count-integers-with-even-digit-sum", "solutions": ["class Solution:\n    def countEven(self, num: int) -> int:\n        ans = 0\n        for x in range(1, num + 1):\n            s = 0\n            while x:\n                s += x % 10\n                x //= 10\n            ans += s % 2 == 0\n        return ans\n", "class Solution:\n  def countEven(self, num: int) -> int:\n    return (num - self._getDigitSum(num) % 2) // 2\n\n  def _getDigitSum(self, num: int) -> int:\n    return sum(int(digit) for digit in str(num))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2116, "slug": "check-if-a-parentheses-string-can-be-valid", "solutions": ["class Solution:\n    def canBeValid(self, s: str, locked: str) -> bool:\n        n = len(s)\n        if n & 1:\n            return False\n        x = 0\n        for i in range(n):\n            if s[i] == '(' or locked[i] == '0':\n                x += 1\n            elif x:\n                x -= 1\n            else:\n                return False\n        x = 0\n        for i in range(n - 1, -1, -1):\n            if s[i] == ')' or locked[i] == '0':\n                x += 1\n            elif x:\n                x -= 1\n            else:\n                return False\n        return True\n", "class Solution:\n  def canBeValid(self, s: str, locked: str) -> bool:\n    if len(s) % 2 == 1:\n      return False\n\n    def check(s: str, locked: str, isForward: bool) -> bool:\n      changeable = 0\n      l = 0\n      r = 0\n\n      for c, lock in zip(s, locked):\n        if lock == '0':\n          changeable += 1\n        elif c == '(':\n          l += 1\n        else:  # c == ')'\n          r += 1\n        if isForward and changeable + l - r < 0:\n          return False\n        if not isForward and changeable + r - l < 0:\n          return False\n\n      return True\n\n    return check(s, locked, True) and check(s[::-1], locked[::-1], False)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2177, "slug": "find-three-consecutive-integers-that-sum-to-a-given-number", "solutions": ["class Solution:\n    def sumOfThree(self, num: int) -> List[int]:\n        x, mod = divmod(num, 3)\n        return [] if mod else [x - 1, x, x + 1]\n", "class Solution:\n  def sumOfThree(self, num: int) -> list[int]:\n    if num % 3:\n      return []\n    x = num // 3\n    return [x - 1, x, x + 1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2129, "slug": "capitalize-the-title", "solutions": ["class Solution:\n    def capitalizeTitle(self, title: str) -> str:\n        words = [w.lower() if len(w) < 3 else w.capitalize() for w in title.split()]\n        return \" \".join(words)\n", "class Solution:\n  def capitalizeTitle(self, title: str) -> str:\n    return ' '.join(s.lower() if len(s) < 3\n                    else s.capitalize() for s in title.split())\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2114, "slug": "maximum-number-of-words-found-in-sentences", "solutions": ["class Solution:\n    def mostWordsFound(self, sentences: List[str]) -> int:\n        return 1 + max(s.count(' ') for s in sentences)\n", "class Solution:\n  def mostWordsFound(self, sentences: list[str]) -> int:\n    return max(s.count(' ') for s in sentences) + 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2104, "slug": "sum-of-subarray-ranges", "solutions": ["class Solution:\n    def subArrayRanges(self, nums: List[int]) -> int:\n        ans, n = 0, len(nums)\n        for i in range(n - 1):\n            mi = mx = nums[i]\n            for j in range(i + 1, n):\n                mi = min(mi, nums[j])\n                mx = max(mx, nums[j])\n                ans += mx - mi\n        return ans\n", "class Solution:\n  def subArrayRanges(self, nums: list[int]) -> int:\n    prevGt, nextGt = self._getPrevNext(nums, operator.lt)\n    prevLt, nextLt = self._getPrevNext(nums, operator.gt)\n    return sum(num * (i - prevGt[i]) * (nextGt[i] - i) -\n               num * (i - prevLt[i]) * (nextLt[i] - i)\n               for i, num in enumerate(nums))\n\n  def _getPrevNext(\n      self,\n      nums: list[int],\n      op: callable\n  ) -> tuple[list[int], list[int]]:\n    \"\"\"\n    Returns `prev` and `next`, that store the indices of the nearest numbers\n    that are smaller or larger than the current number depending on `op`.\n    \"\"\"\n    n = len(nums)\n    prev = [-1] * n\n    next = [n] * n\n    stack = []\n    for i, num in enumerate(nums):\n      while stack and op(nums[stack[-1]], num):\n        next[stack.pop()] = i\n      if stack:\n        prev[i] = stack[-1]\n      stack.append(i)\n    return prev, next\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2183, "slug": "count-array-pairs-divisible-by-k", "solutions": ["class Solution:\n  def countPairs(self, nums: list[int], k: int) -> int:\n    ans = 0\n    gcds = collections.Counter()\n\n    for num in nums:\n      gcd_i = math.gcd(num, k)\n      for gcd_j, count in gcds.items():\n        if gcd_i * gcd_j % k == 0:\n          ans += count\n      gcds[gcd_i] += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2135, "slug": "count-words-obtained-after-adding-a-letter", "solutions": ["class Solution:\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\n        s = {sum(1 << (ord(c) - 97) for c in w) for w in startWords}\n        ans = 0\n        for w in targetWords:\n            x = sum(1 << (ord(c) - 97) for c in w)\n            for c in w:\n                if x ^ (1 << (ord(c) - 97)) in s:\n                    ans += 1\n                    break\n        return ans\n", "class Solution:\n  def wordCount(self, startWords: list[str], targetWords: list[str]) -> int:\n    def getMask(s: str) -> int:\n      mask = 0\n      for c in s:\n        mask ^= 1 << ord(c) - ord('a')\n      return mask\n\n    ans = 0\n    seen = set(getMask(w) for w in startWords)\n\n    for targetWord in targetWords:\n      mask = getMask(targetWord)\n      for c in targetWord:\n        # Toggle one character.\n        if mask ^ 1 << ord(c) - ord('a') in seen:\n          ans += 1\n          break\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2143, "slug": "choose-numbers-from-two-arrays-in-range", "solutions": ["class Solution:\n    def countSubranges(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        s1, s2 = sum(nums1), sum(nums2)\n        f = [[0] * (s1 + s2 + 1) for _ in range(n)]\n        ans = 0\n        mod = 10**9 + 7\n        for i, (a, b) in enumerate(zip(nums1, nums2)):\n            f[i][a + s2] += 1\n            f[i][-b + s2] += 1\n            if i:\n                for j in range(s1 + s2 + 1):\n                    if j >= a:\n                        f[i][j] = (f[i][j] + f[i - 1][j - a]) % mod\n                    if j + b < s1 + s2 + 1:\n                        f[i][j] = (f[i][j] + f[i - 1][j + b]) % mod\n            ans = (ans + f[i][s2]) % mod\n        return ans\n", "class Solution:\n  def countSubranges(self, nums1: list[int], nums2: list[int]) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    # {sum, count}, add if choose from nums1, minus if choose from nums2\n    dp = collections.Counter()\n\n    for a, b in zip(nums1, nums2):\n      newDp = collections.Counter()\n      newDp[a] += 1\n      newDp[-b] += 1\n\n      for prevSum, count in dp.items():\n        # Choose nums1[i]\n        newDp[prevSum + a] += count\n        newDp[prevSum + a] %= MOD\n        # Choose nums2[i]\n        newDp[prevSum - b] += count\n        newDp[prevSum - b] %= MOD\n\n      dp = newDp\n      ans += dp[0]\n      ans %= MOD\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2136, "slug": "earliest-possible-day-of-full-bloom", "solutions": ["class Solution:\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\n        ans = t = 0\n        for pt, gt in sorted(zip(plantTime, growTime), key=lambda x: -x[1]):\n            t += pt\n            ans = max(ans, t + gt)\n        return ans\n", "class Solution:\n  def earliestFullBloom(self, plantTime: list[int], growTime: list[int]) -> int:\n    ans = 0\n    time = 0\n\n    for p, g in sorted(\n        [(p, g) for (p, g) in zip(plantTime, growTime)],\n            key=lambda x: -x[1]):\n      time += p\n      ans = max(ans, time + g)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2199, "slug": "finding-the-topic-of-each-post", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2163, "slug": "minimum-difference-in-sums-after-removal-of-elements", "solutions": ["class Solution:\n    def minimumDifference(self, nums: List[int]) -> int:\n        m = len(nums)\n        n = m // 3\n\n        s = 0\n        pre = [0] * (m + 1)\n        q1 = []\n        for i, x in enumerate(nums[: n * 2], 1):\n            s += x\n            heappush(q1, -x)\n            if len(q1) > n:\n                s -= -heappop(q1)\n            pre[i] = s\n\n        s = 0\n        suf = [0] * (m + 1)\n        q2 = []\n        for i in range(m, n, -1):\n            x = nums[i - 1]\n            s += x\n            heappush(q2, x)\n            if len(q2) > n:\n                s -= heappop(q2)\n            suf[i] = s\n\n        return min(pre[i] - suf[i + 1] for i in range(n, n * 2 + 1))\n", "class Solution:\n  def minimumDifference(self, nums: list[int]) -> int:\n    n = len(nums) // 3\n    ans = math.inf\n    leftSum = 0\n    rightSum = 0\n    maxHeap = []  # Left part, as small as possible\n    minHeap = []  # Right part, as big as possible\n    # minLeftSum[i] := the minimum of the sum of n nums in nums[0..i)\n    minLeftSum = [0] * len(nums)\n\n    for i in range(2 * n):\n      heapq.heappush(maxHeap, -nums[i])\n      leftSum += nums[i]\n      if len(maxHeap) == n + 1:\n        leftSum += heapq.heappop(maxHeap)\n      if len(maxHeap) == n:\n        minLeftSum[i] = leftSum\n\n    for i in range(len(nums) - 1, n - 1, -1):\n      heapq.heappush(minHeap, nums[i])\n      rightSum += nums[i]\n      if len(minHeap) == n + 1:\n        rightSum -= heapq.heappop(minHeap)\n      if len(minHeap) == n:\n        ans = min(ans, minLeftSum[i - 1] - rightSum)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2150, "slug": "find-all-lonely-numbers-in-the-array", "solutions": ["class Solution:\n    def findLonely(self, nums: List[int]) -> List[int]:\n        cnt = Counter(nums)\n        return [\n            x for x, v in cnt.items() if v == 1 and cnt[x - 1] == 0 and cnt[x + 1] == 0\n        ]\n", "class Solution:\n  def findLonely(self, nums: list[int]) -> list[int]:\n    count = collections.Counter(nums)\n    return [num for num, freq in count.items()\n            if freq == 1 and\n            count[num - 1] == 0 and\n            count[num + 1] == 0]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2166, "slug": "design-bitset", "solutions": ["class Bitset:\n    def __init__(self, size: int):\n        self.a = ['0'] * size\n        self.b = ['1'] * size\n        self.cnt = 0\n\n    def fix(self, idx: int) -> None:\n        if self.a[idx] == '0':\n            self.a[idx] = '1'\n            self.cnt += 1\n        self.b[idx] = '0'\n\n    def unfix(self, idx: int) -> None:\n        if self.a[idx] == '1':\n            self.a[idx] = '0'\n            self.cnt -= 1\n        self.b[idx] = '1'\n\n    def flip(self) -> None:\n        self.a, self.b = self.b, self.a\n        self.cnt = len(self.a) - self.cnt\n\n    def all(self) -> bool:\n        return self.cnt == len(self.a)\n\n    def one(self) -> bool:\n        return self.cnt > 0\n\n    def count(self) -> int:\n        return self.cnt\n\n    def toString(self) -> str:\n        return ''.join(self.a)\n\n\n# Your Bitset object will be instantiated and called as such:\n# obj = Bitset(size)\n# obj.fix(idx)\n# obj.unfix(idx)\n# obj.flip()\n# param_4 = obj.all()\n# param_5 = obj.one()\n# param_6 = obj.count()\n# param_7 = obj.toString()\n", "class Bitset:\n  def __init__(self, size: int):\n    self.s = ['0'] * size  # the original\n    self.r = ['1'] * size  # the reversed\n    self.cnt = 0\n\n  def fix(self, idx: int) -> None:\n    if self.s[idx] == '0':\n      self.cnt += 1\n    self.s[idx] = '1'\n    self.r[idx] = '0'\n\n  def unfix(self, idx: int) -> None:\n    if self.s[idx] == '1':\n      self.cnt -= 1\n    self.s[idx] = '0'\n    self.r[idx] = '1'\n\n  def flip(self) -> None:\n    self.s, self.r = self.r, self.s\n    self.cnt = len(self.s) - self.cnt\n\n  def all(self) -> bool:\n    return self.cnt == len(self.s)\n\n  def one(self) -> bool:\n    return self.cnt\n\n  def count(self) -> int:\n    return self.cnt\n\n  def toString(self) -> str:\n    return ''.join(self.s)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2152, "slug": "minimum-number-of-lines-to-cover-points", "solutions": ["class Solution:\n    def minimumLines(self, points: List[List[int]]) -> int:\n        def check(i, j, k):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            x3, y3 = points[k]\n            return (x2 - x1) * (y3 - y1) == (x3 - x1) * (y2 - y1)\n\n        @cache\n        def dfs(state):\n            if state == (1 << n) - 1:\n                return 0\n            ans = inf\n            for i in range(n):\n                if not (state >> i & 1):\n                    for j in range(i + 1, n):\n                        nxt = state | 1 << i | 1 << j\n                        for k in range(j + 1, n):\n                            if not (nxt >> k & 1) and check(i, j, k):\n                                nxt |= 1 << k\n                        ans = min(ans, dfs(nxt) + 1)\n                    if i == n - 1:\n                        ans = min(ans, dfs(state | 1 << i) + 1)\n            return ans\n\n        n = len(points)\n        return dfs(0)\n", "class Solution:\n  def minimumLines(self, points: list[list[int]]) -> int:\n    n = len(points)\n    allCovered = (1 << n) - 1\n    maxLines = n // 2 + (n & 1)\n\n    def getSlope(p: list[int], q: list[int]) -> tuple[int, int]:\n      dx = p[0] - q[0]\n      dy = p[1] - q[1]\n      if dx == 0:\n        return (0, p[0])\n      if dy == 0:\n        return (p[1], 0)\n      d = gcd(dx, dy)\n      x = dx // d\n      y = dy // d\n      return (x, y) if x > 0 else (-x, -y)\n\n    @functools.lru_cache(None)\n    def dfs(covered: int) -> int:\n      if covered == allCovered:\n        return 0\n\n      ans = maxLines\n\n      for i in range(n):\n        if covered >> i & 1:\n          continue\n        for j in range(n):\n          if i == j:\n            continue\n          # Connect the points[i] with the points[j].\n          newCovered = covered | 1 << i | 1 << j\n          slope = getSlope(points[i], points[j])\n          # Mark the points covered by this line.\n          for k in range(n):\n            if getSlope(points[i], points[k]) == slope:\n              newCovered |= 1 << k\n          ans = min(ans, 1 + dfs(newCovered))\n\n      return ans\n\n    return dfs(0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2191, "slug": "sort-the-jumbled-numbers", "solutions": ["class Solution:\n    def sortJumbled(self, mapping: List[int], nums: List[int]) -> List[int]:\n        def f(x: int) -> int:\n            if x == 0:\n                return mapping[0]\n            y, k = 0, 1\n            while x:\n                x, v = divmod(x, 10)\n                v = mapping[v]\n                y = k * v + y\n                k *= 10\n            return y\n\n        arr = sorted((f(x), i) for i, x in enumerate(nums))\n        return [nums[i] for _, i in arr]\n", "class Solution:\n  def sortJumbled(self, mapping: list[int], nums: list[int]) -> list[int]:\n    def getMapped(num: int) -> int:\n      mapped = []\n      for c in str(num):\n        mapped.append(str(mapping[int(c)]))\n      return int(''.join(mapped))\n    A = [(getMapped(num), i, num) for i, num in enumerate(nums)]\n    return [num for _, i, num in sorted(A)]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2181, "slug": "merge-nodes-in-between-zeros", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = tail = ListNode()\n        s = 0\n        cur = head.next\n        while cur:\n            if cur.val:\n                s += cur.val\n            else:\n                tail.next = ListNode(s)\n                tail = tail.next\n                s = 0\n            cur = cur.next\n        return dummy.next\n", "class Solution:\n  def mergeNodes(self, head: ListNode | None) -> ListNode | None:\n    if not head:\n      return None\n    if not head.next.val:\n      node = ListNode(head.val)\n      node.next = self.mergeNodes(head.next.next)\n      return node\n\n    next = self.mergeNodes(head.next)\n    next.val += head.val\n    return next\n", "class Solution:\n  def mergeNodes(self, head: ListNode | None) -> ListNode | None:\n    curr = head.next\n\n    while curr:\n      running = curr\n      summ = 0\n      while running.val > 0:\n        summ += running.val\n        running = running.next\n\n      curr.val = summ\n      curr.next = running.next\n      curr = running.next\n\n    return head.next\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2122, "slug": "recover-the-original-array", "solutions": ["class Solution:\n    def recoverArray(self, nums: List[int]) -> List[int]:\n        nums.sort()\n        n = len(nums)\n        for i in range(1, n):\n            d = nums[i] - nums[0]\n            if d == 0 or d % 2 == 1:\n                continue\n            vis = [False] * n\n            vis[i] = True\n            ans = [(nums[0] + nums[i]) >> 1]\n            l, r = 1, i + 1\n            while r < n:\n                while l < n and vis[l]:\n                    l += 1\n                while r < n and nums[r] - nums[l] < d:\n                    r += 1\n                if r == n or nums[r] - nums[l] > d:\n                    break\n                vis[r] = True\n                ans.append((nums[l] + nums[r]) >> 1)\n                l, r = l + 1, r + 1\n            if len(ans) == (n >> 1):\n                return ans\n        return []\n", "class Solution:\n  def recoverArray(self, nums: list[int]) -> list[int]:\n    nums = sorted(nums)\n\n    def getArray(x: int, count: collections.Counter) -> list[int]:\n      arr = []\n      for num in nums:\n        if count[num] == 0:\n          continue\n        if count[num + x] == 0:\n          return []\n        count[num] -= 1\n        count[num + x] -= 1\n        arr.append(num + x // 2)\n      return arr\n\n    count = collections.Counter(nums)\n\n    for i in range(1, len(nums)):\n      x = nums[i] - nums[0]  # 2 * k\n      if x <= 0 or x % 2 == 1:\n        continue\n      arr = getArray(x, count.copy())\n      if arr:\n        return arr\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2160, "slug": "minimum-sum-of-four-digit-number-after-splitting-digits", "solutions": ["class Solution:\n    def minimumSum(self, num: int) -> int:\n        nums = []\n        while num:\n            nums.append(num % 10)\n            num //= 10\n        nums.sort()\n        return 10 * (nums[0] + nums[1]) + nums[2] + nums[3]\n", "class Solution:\n  def minimumSum(self, num: int) -> int:\n    s = sorted(str(num))\n    return int(s[0] + s[2]) + int(s[1] + s[3])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2184, "slug": "number-of-ways-to-build-sturdy-brick-wall", "solutions": ["class Solution:\n    def buildWall(self, height: int, width: int, bricks: List[int]) -> int:\n        def dfs(v):\n            if v > width:\n                return\n            if v == width:\n                s.append(t[:])\n                return\n            for x in bricks:\n                t.append(x)\n                dfs(v + x)\n                t.pop()\n\n        def check(a, b):\n            s1, s2 = a[0], b[0]\n            i = j = 1\n            while i < len(a) and j < len(b):\n                if s1 == s2:\n                    return False\n                if s1 < s2:\n                    s1 += a[i]\n                    i += 1\n                else:\n                    s2 += b[j]\n                    j += 1\n            return True\n\n        mod = 10**9 + 7\n        s = []\n        t = []\n        dfs(0)\n        g = defaultdict(list)\n        n = len(s)\n        for i in range(n):\n            if check(s[i], s[i]):\n                g[i].append(i)\n            for j in range(i + 1, n):\n                if check(s[i], s[j]):\n                    g[i].append(j)\n                    g[j].append(i)\n        dp = [[0] * n for _ in range(height)]\n        for j in range(n):\n            dp[0][j] = 1\n        for i in range(1, height):\n            for j in range(n):\n                for k in g[j]:\n                    dp[i][j] += dp[i - 1][k]\n                    dp[i][j] %= mod\n        return sum(dp[-1]) % mod\n", "class Solution:\n  def buildWall(self, height: int, width: int, bricks: list[int]) -> int:\n    MOD = 1_000_000_007\n    # Stores the valid rows in bitmask.\n    rows = []\n    self._buildRows(width, bricks, 0, rows)\n\n    n = len(rows)\n    # dp[i] := the number of ways to build `h` height walls with rows[i] in the bottom\n    dp = [1] * n\n    # graph[i] := the valid neighbors of rows[i]\n    graph = [[] for _ in range(n)]\n\n    for i, a in enumerate(rows):\n      for j, b in enumerate(rows):\n        if not a & b:\n          graph[i].append(j)\n\n    for _ in range(2, height + 1):\n      newDp = [0] * n\n      for i in range(n):\n        for v in graph[i]:\n          newDp[i] += dp[v]\n          newDp[i] %= MOD\n      dp = newDp\n\n    return sum(dp) % MOD\n\n  def _buildRows(\n      self,\n      width: int,\n      bricks: list[int],\n      path: int,\n      rows: list[int],\n  ):\n    for brick in bricks:\n      if brick == width:\n        rows.append(path)\n      elif brick < width:\n        newWidth = width - brick\n        self._buildRows(newWidth, bricks, path | 2 << newWidth, rows)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2198, "slug": "number-of-single-divisor-triplets", "solutions": ["class Solution:\n    def singleDivisorTriplet(self, nums: List[int]) -> int:\n        cnt = Counter(nums)\n        ans = 0\n        for a, x in cnt.items():\n            for b, y in cnt.items():\n                for c, z in cnt.items():\n                    s = a + b + c\n                    if sum(s % v == 0 for v in (a, b, c)) == 1:\n                        if a == b:\n                            ans += x * (x - 1) * z\n                        elif a == c:\n                            ans += x * (x - 1) * y\n                        elif b == c:\n                            ans += x * y * (y - 1)\n                        else:\n                            ans += x * y * z\n        return ans\n", "class Solution:\n  def singleDivisorTriplet(self, nums: list[int]) -> int:\n    ans = 0\n    count = collections.Counter(nums)\n\n    def divisible(summ: int, num: int) -> int:\n      return summ % num == 0\n\n    for a in range(1, 101):\n      if count[a] == 0:\n        continue\n      for b in range(a, 101):\n        if count[b] == 0:\n          continue\n        for c in range(b, 101):\n          if count[c] == 0:\n            continue\n          summ = a + b + c\n          if divisible(summ, a) + divisible(summ, b) + divisible(summ, c) != 1:\n            continue\n          if a == b:\n            ans += count[a] * (count[a] - 1) // 2 * count[c]\n          elif b == c:\n            ans += count[b] * (count[b] - 1) // 2 * count[a]\n          else:\n            ans += count[a] * count[b] * count[c]\n\n    return ans * 6\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2127, "slug": "maximum-employees-to-be-invited-to-a-meeting", "solutions": ["class Solution:\n    def maximumInvitations(self, favorite: List[int]) -> int:\n        def max_cycle(fa: List[int]) -> int:\n            n = len(fa)\n            vis = [False] * n\n            ans = 0\n            for i in range(n):\n                if vis[i]:\n                    continue\n                cycle = []\n                j = i\n                while not vis[j]:\n                    cycle.append(j)\n                    vis[j] = True\n                    j = fa[j]\n                for k, v in enumerate(cycle):\n                    if v == j:\n                        ans = max(ans, len(cycle) - k)\n                        break\n            return ans\n\n        def topological_sort(fa: List[int]) -> int:\n            n = len(fa)\n            indeg = [0] * n\n            dist = [1] * n\n            for v in fa:\n                indeg[v] += 1\n            q = deque(i for i, v in enumerate(indeg) if v == 0)\n            while q:\n                i = q.popleft()\n                dist[fa[i]] = max(dist[fa[i]], dist[i] + 1)\n                indeg[fa[i]] -= 1\n                if indeg[fa[i]] == 0:\n                    q.append(fa[i])\n            return sum(dist[i] for i, v in enumerate(fa) if i == fa[fa[i]])\n\n        return max(max_cycle(favorite), topological_sort(favorite))\n", "from enum import Enum\n\n\nclass State(Enum):\n  INIT = 0\n  VISITING = 1\n  VISITED = 2\n\n\nclass Solution:\n  def maximumInvitations(self, favorite: list[int]) -> int:\n    n = len(favorite)\n    sumComponentsLength = 0  # the component: a -> b -> c <-> x <- y\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n    maxChainLength = [1] * n\n\n    # Build the graph.\n    for i, f in enumerate(favorite):\n      graph[i].append(f)\n      inDegrees[f] += 1\n\n    # Perform topological sorting.\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    while q:\n      u = q.popleft()\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n        maxChainLength[v] = max(maxChainLength[v], 1 + maxChainLength[u])\n\n    for i in range(n):\n      if favorite[favorite[i]] == i:\n        # i <-> favorite[i] (the cycle's length = 2)\n        sumComponentsLength += maxChainLength[i] + maxChainLength[favorite[i]]\n\n    maxCycleLength = 0  # Cycle: a -> b -> c -> a\n    parent = [-1] * n\n    seen = set()\n    states = [State.INIT] * n\n\n    def findCycle(u: int) -> None:\n      nonlocal maxCycleLength\n      seen.add(u)\n      states[u] = State.VISITING\n      for v in graph[u]:\n        if v not in seen:\n          parent[v] = u\n          findCycle(v)\n        elif states[v] == State.VISITING:\n          # Find the cycle's length.\n          curr = u\n          cycleLength = 1\n          while curr != v:\n            curr = parent[curr]\n            cycleLength += 1\n          maxCycleLength = max(maxCycleLength, cycleLength)\n      states[u] = State.VISITED\n\n    for i in range(n):\n      if i not in seen:\n        findCycle(i)\n\n    return max(sumComponentsLength // 2, maxCycleLength)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2146, "slug": "k-highest-ranked-items-within-a-price-range", "solutions": ["class Solution:\n    def highestRankedKItems(\n        self, grid: List[List[int]], pricing: List[int], start: List[int], k: int\n    ) -> List[List[int]]:\n        m, n = len(grid), len(grid[0])\n        row, col = start\n        low, high = pricing\n        q = deque([(row, col)])\n        pq = []\n        if low <= grid[row][col] <= high:\n            pq.append((0, grid[row][col], row, col))\n        grid[row][col] = 0\n        dirs = (-1, 0, 1, 0, -1)\n        step = 0\n        while q:\n            step += 1\n            for _ in range(len(q)):\n                x, y = q.popleft()\n                for a, b in pairwise(dirs):\n                    nx, ny = x + a, y + b\n                    if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] > 0:\n                        if low <= grid[nx][ny] <= high:\n                            pq.append((step, grid[nx][ny], nx, ny))\n                        grid[nx][ny] = 0\n                        q.append((nx, ny))\n        pq.sort()\n        return [list(x[2:]) for x in pq[:k]]\n", "class Solution:\n  def highestRankedKItems(\n      self,\n      grid: list[list[int]],\n      pricing: list[int],\n      start: list[int],\n      k: int\n  ) -> list[list[int]]:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    low, high = pricing\n    row, col = start\n    ans = []\n\n    if low <= grid[row][col] <= high:\n      ans.append([row, col])\n      if k == 1:\n        return ans\n\n    q = collections.deque([(row, col)])\n    seen = {(row, col)}  # Mark as visited.\n\n    while q:\n      neighbors = []\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for t in range(4):\n          x = i + DIRS[t][0]\n          y = j + DIRS[t][1]\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if not grid[x][y] or (x, y) in seen:\n            continue\n          if low <= grid[x][y] <= high:\n            neighbors.append([x, y])\n          q.append((x, y))\n          seen.add((x, y))\n      neighbors.sort(key=lambda x: (grid[x[0]][x[1]], x[0], x[1]))\n      for neighbor in neighbors:\n        if len(ans) < k:\n          ans.append(neighbor)\n        if len(ans) == k:\n          return ans\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2112, "slug": "the-airport-with-the-most-traffic", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2147, "slug": "number-of-ways-to-divide-a-long-corridor", "solutions": ["class Solution:\n    def numberOfWays(self, corridor: str) -> int:\n        @cache\n        def dfs(i: int, k: int) -> int:\n            if i >= len(corridor):\n                return int(k == 2)\n            k += int(corridor[i] == \"S\")\n            if k > 2:\n                return 0\n            ans = dfs(i + 1, k)\n            if k == 2:\n                ans = (ans + dfs(i + 1, 0)) % mod\n            return ans\n\n        mod = 10**9 + 7\n        ans = dfs(0, 0)\n        dfs.cache_clear()\n        return ans\n", "class Solution:\n  def numberOfWays(self, corridor: str) -> int:\n    MOD = 1_000_000_007\n    ans = 1\n    prevSeat = -1\n    numSeats = 0\n\n    for i, c in enumerate(corridor):\n      if c == 'S':\n        numSeats += 1\n        if numSeats > 2 and numSeats % 2 == 1:\n          ans = ans * (i - prevSeat) % MOD\n        prevSeat = i\n\n    return ans if numSeats > 1 and numSeats % 2 == 0 else 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2120, "slug": "execution-of-all-suffix-instructions-staying-in-a-grid", "solutions": ["class Solution:\n    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:\n        ans = []\n        m = len(s)\n        mp = {\"L\": [0, -1], \"R\": [0, 1], \"U\": [-1, 0], \"D\": [1, 0]}\n        for i in range(m):\n            x, y = startPos\n            t = 0\n            for j in range(i, m):\n                a, b = mp[s[j]]\n                if 0 <= x + a < n and 0 <= y + b < n:\n                    x, y, t = x + a, y + b, t + 1\n                else:\n                    break\n            ans.append(t)\n        return ans\n", "class Solution:\n  def executeInstructions(\n      self,\n      n: int,\n      startPos: list[int],\n      s: str,\n  ) -> list[int]:\n    moves = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    m = len(s)\n    uMost = startPos[0] + 1\n    dMost = n - startPos[0]\n    lMost = startPos[1] + 1\n    rMost = n - startPos[1]\n\n    ans = [0] * m\n    reach = {(0, None): m, (None, 0): m}\n    x = 0\n    y = 0\n\n    for i in reversed(range(m)):\n      dx, dy = moves[s[i]]\n      x -= dx\n      y -= dy\n      reach[(x, None)] = i\n      reach[(None, y)] = i\n      out = min(reach.get((x - uMost, None), math.inf),\n                reach.get((x + dMost, None), math.inf),\n                reach.get((None, y - lMost), math.inf),\n                reach.get((None, y + rMost), math.inf))\n      ans[i] = m - i if out == math.inf else out - i - 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2171, "slug": "removing-minimum-number-of-magic-beans", "solutions": ["class Solution:\n    def minimumRemoval(self, beans: List[int]) -> int:\n        beans.sort()\n        s, n = sum(beans), len(beans)\n        return min(s - x * (n - i) for i, x in enumerate(beans))\n", "class Solution:\n  def minimumRemoval(self, beans: list[int]) -> int:\n    n = len(beans)\n    summ = sum(beans)\n    return min(summ - (n - i) * bean\n               for i, bean in enumerate(sorted(beans)))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2140, "slug": "solving-questions-with-brainpower", "solutions": ["class Solution:\n    def mostPoints(self, questions: List[List[int]]) -> int:\n        @cache\n        def dfs(i: int) -> int:\n            if i >= len(questions):\n                return 0\n            p, b = questions[i]\n            return max(p + dfs(i + b + 1), dfs(i + 1))\n\n        return dfs(0)\n", "class Solution:\n  def mostPoints(self, questions: list[list[int]]) -> int:\n    n = len(questions)\n    # dp[i] := the maximum points starting from questions[i]\n    dp = [0] * (n + 1)\n\n    for i in reversed(range(n)):\n      points, brainpower = questions[i]\n      nextIndex = i + brainpower + 1\n      nextPoints = dp[nextIndex] if nextIndex < n else 0\n      dp[i] = max(points + nextPoints, dp[i + 1])\n\n    return dp[0]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2106, "slug": "maximum-fruits-harvested-after-at-most-k-steps", "solutions": ["class Solution:\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\n        ans = i = s = 0\n        for j, (pj, fj) in enumerate(fruits):\n            s += fj\n            while (\n                i <= j\n                and pj\n                - fruits[i][0]\n                + min(abs(startPos - fruits[i][0]), abs(startPos - fruits[j][0]))\n                > k\n            ):\n                s -= fruits[i][1]\n                i += 1\n            ans = max(ans, s)\n        return ans\n", "class Solution:\n  def maxTotalFruits(\n      self,\n      fruits: list[list[int]],\n      startPos: int,\n      k: int,\n  ) -> int:\n    ans = 0\n    maxRight = max(startPos, fruits[-1][0])\n    amounts = [0] * (1 + maxRight)\n    for position, amount in fruits:\n      amounts[position] = amount\n    prefix = list(itertools.accumulate(amounts, initial=0))\n\n    def getFruits(leftSteps: int, rightSteps: int) -> int:\n      l = max(0, startPos - leftSteps)\n      r = min(maxRight, startPos + rightSteps)\n      return prefix[r + 1] - prefix[l]\n\n    # Go right first.\n    for rightSteps in range(min(maxRight - startPos, k) + 1):\n      leftSteps = max(0, k - 2 * rightSteps)  # Turn left\n      ans = max(ans, getFruits(leftSteps, rightSteps))\n\n    # Go left first.\n    for leftSteps in range(min(startPos, k) + 1):\n      rightSteps = max(0, k - 2 * leftSteps)  # Turn right\n      ans = max(ans, getFruits(leftSteps, rightSteps))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2172, "slug": "maximum-and-sum-of-array", "solutions": ["class Solution:\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\n        n = len(nums)\n        m = numSlots << 1\n        f = [0] * (1 << m)\n        for i in range(1 << m):\n            cnt = i.bit_count()\n            if cnt > n:\n                continue\n            for j in range(m):\n                if i >> j & 1:\n                    f[i] = max(f[i], f[i ^ (1 << j)] + (nums[cnt - 1] & (j // 2 + 1)))\n        return max(f)\n", "class Solution:\n  def maximumANDSum(self, nums: list[int], numSlots: int) -> int:\n    n = 2 * numSlots\n    nSelected = 1 << n\n    # dp[i] := the maximum value, where i is the bitmask of the selected\n    # numbers\n    dp = [0] * nSelected\n\n    nums += [0] * (n - len(nums))\n\n    for mask in range(1, nSelected):\n      selected = mask.bit_count()\n      slot = (selected + 1) // 2  # (1, 2) -> 1, (3, 4) -> 2\n      for i, num in enumerate(nums):\n        if mask >> i & 1:  # Assign `nums[i]` to the `slot`-th slot.\n          dp[mask] = max(dp[mask], dp[mask ^ 1 << i] + (slot & num))\n\n    return dp[-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2119, "slug": "a-number-after-a-double-reversal", "solutions": ["class Solution:\n    def isSameAfterReversals(self, num: int) -> bool:\n        return num == 0 or num % 10 != 0\n", "class Solution:\n  def isSameAfterReversals(self, num: int) -> bool:\n    def getReversed(num: int) -> int:\n      reversed = 0\n      while num > 0:\n        reversed = reversed * 10 + num % 10\n        num //= 10\n      return reversed\n\n    reversed1 = getReversed(num)\n    reversed2 = getReversed(reversed1)\n    return reversed2 == num\n", "class Solution:\n  def isSameAfterReversals(self, num: int) -> bool:\n    return num == 0 or num % 10\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2195, "slug": "append-k-integers-with-minimal-sum", "solutions": ["class Solution:\n    def minimalKSum(self, nums: List[int], k: int) -> int:\n        nums.extend([0, 2 * 10**9])\n        nums.sort()\n        ans = 0\n        for a, b in pairwise(nums):\n            m = max(0, min(k, b - a - 1))\n            ans += (a + 1 + a + m) * m // 2\n            k -= m\n        return ans\n", "class Solution:\n  def minimalKSum(self, nums: list[int], k: int) -> int:\n    ans = 0\n    nums.append(0)\n    nums.sort()\n\n    for a, b in zip(nums, nums[1:]):\n      if a == b:\n        continue\n      l = a + 1\n      r = min(a + k, b - 1)\n      ans += (l + r) * (r - l + 1) // 2\n      k -= r - l + 1\n      if k == 0:\n        return ans\n\n    if k > 0:\n      l = nums[-1] + 1\n      r = nums[-1] + k\n      ans += (l + r) * (r - l + 1) // 2\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2142, "slug": "the-number-of-passengers-in-each-bus-i", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2117, "slug": "abbreviating-the-product-of-a-range", "solutions": ["class Solution:\n    def abbreviateProduct(self, left: int, right: int) -> str:\n        cnt2 = cnt5 = 0\n        for x in range(left, right + 1):\n            while x % 2 == 0:\n                cnt2 += 1\n                x //= 2\n            while x % 5 == 0:\n                cnt5 += 1\n                x //= 5\n        c = cnt2 = cnt5 = min(cnt2, cnt5)\n        pre = suf = 1\n        gt = False\n        for x in range(left, right + 1):\n            suf *= x\n            while cnt2 and suf % 2 == 0:\n                suf //= 2\n                cnt2 -= 1\n            while cnt5 and suf % 5 == 0:\n                suf //= 5\n                cnt5 -= 1\n            if suf >= 1e10:\n                gt = True\n                suf %= int(1e10)\n            pre *= x\n            while pre > 1e5:\n                pre /= 10\n        if gt:\n            return str(int(pre)) + \"...\" + str(suf % int(1e5)).zfill(5) + \"e\" + str(c)\n        return str(suf) + \"e\" + str(c)\n", "class Solution:\n  def abbreviateProduct(self, left: int, right: int) -> str:\n    prod = 1.0\n    suf = 1\n    countDigits = 0\n    countZeros = 0\n\n    for num in range(left, right + 1):\n      prod *= num\n      while prod >= 1.0:\n        prod /= 10\n        countDigits += 1\n      suf *= num\n      while suf % 10 == 0:\n        suf //= 10\n        countZeros += 1\n      if suf > 10**8:\n        suf %= 10**8\n\n    if countDigits - countZeros <= 10:\n      tens = 10**(countDigits - countZeros)\n      return str(int(prod * tens + 0.5)) + 'e' + str(countZeros)\n\n    pre = str(int(prod * 10 ** 5))\n    suf = str(suf)[-5:]\n    return pre + '...' + suf + 'e' + str(countZeros)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2131, "slug": "longest-palindrome-by-concatenating-two-letter-words", "solutions": ["class Solution:\n    def longestPalindrome(self, words: List[str]) -> int:\n        cnt = Counter(words)\n        ans = x = 0\n        for k, v in cnt.items():\n            if k[0] == k[1]:\n                x += v & 1\n                ans += v // 2 * 2 * 2\n            else:\n                ans += min(v, cnt[k[::-1]]) * 2\n        ans += 2 if x else 0\n        return ans\n", "class Solution:\n  def longestPalindrome(self, words: list[str]) -> int:\n    ans = 0\n    count = [[0] * 26 for _ in range(26)]\n\n    for a, b in words:\n      i = ord(a) - ord('a')\n      j = ord(b) - ord('a')\n      if count[j][i]:\n        ans += 4\n        count[j][i] -= 1\n      else:\n        count[i][j] += 1\n\n    for i in range(26):\n      if count[i][i]:\n        return ans + 2\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2173, "slug": "longest-winning-streak", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2178, "slug": "maximum-split-of-positive-even-integers", "solutions": ["class Solution:\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\n        if finalSum & 1:\n            return []\n        ans = []\n        i = 2\n        while i <= finalSum:\n            finalSum -= i\n            ans.append(i)\n            i += 2\n        ans[-1] += finalSum\n        return ans\n", "class Solution:\n  def maximumEvenSplit(self, finalSum: int) -> list[int]:\n    if finalSum % 2 == 1:\n      return []\n\n    ans = []\n    needSum = finalSum\n    even = 2\n\n    while needSum - even >= even + 2:\n      ans.append(even)\n      needSum -= even\n      even += 2\n\n    return ans + [needSum]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2167, "slug": "minimum-time-to-remove-all-cars-containing-illegal-goods", "solutions": ["class Solution:\n    def minimumTime(self, s: str) -> int:\n        n = len(s)\n        pre = [0] * (n + 1)\n        suf = [0] * (n + 1)\n        for i, c in enumerate(s):\n            pre[i + 1] = pre[i] if c == '0' else min(pre[i] + 2, i + 1)\n        for i in range(n - 1, -1, -1):\n            suf[i] = suf[i + 1] if s[i] == '0' else min(suf[i + 1] + 2, n - i)\n        return min(a + b for a, b in zip(pre[1:], suf[1:]))\n", "class Solution:\n  def minimumTime(self, s: str) -> int:\n    n = len(s)\n    # left[i] := the minimum time to remove the illegal cars of s[0..i]\n    left = [0] * n\n    left[0] = int(s[0])\n    # dp[i] := the minimum time to remove the illegal cars of s[0..i] optimally\n    # + the time to remove the illegal cars of s[i + 1..n) consecutively\n    # Note that the way to remove the illegal cars in the right part\n    # doesn't need to be optimal since:\n    #   `left | illegal cars | n - 1 - k` will be covered in\n    #   `left' | n - 1 - i` later.\n    dp = [n] * n\n    dp[0] = left[0] + n - 1\n\n    for i in range(1, n):\n      left[i] = min(left[i - 1] + int(s[i]) * 2, i + 1)\n      dp[i] = min(dp[i], left[i] + n - 1 - i)\n\n    return min(dp)\n", "class Solution:\n  def minimumTime(self, s: str) -> int:\n    n = len(s)\n    ans = n\n    left = 0  # the minimum time to remove the illegal cars so far\n\n    for i, c in enumerate(s):\n      left = min(left + int(c) * 2, i + 1)\n      ans = min(ans, left + n - 1 - i)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2141, "slug": "maximum-running-time-of-n-computers", "solutions": ["class Solution:\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\n        l, r = 0, sum(batteries)\n        while l < r:\n            mid = (l + r + 1) >> 1\n            if sum(min(x, mid) for x in batteries) >= n * mid:\n                l = mid\n            else:\n                r = mid - 1\n        return l\n", "class Solution:\n  def maxRunTime(self, n: int, batteries: list[int]) -> int:\n    summ = sum(batteries)\n\n    batteries.sort()\n\n    # The maximum battery is greater than the average, so it can last forever.\n    # Reduce the problem from size n to size n - 1.\n    while batteries[-1] > summ // n:\n      summ -= batteries.pop()\n      n -= 1\n\n    # If the maximum battery <= average running time, it won't be waste, and so\n    # do smaller batteries.\n    return summ // n\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2197, "slug": "replace-non-coprime-numbers-in-array", "solutions": ["class Solution:\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\n        stk = []\n        for x in nums:\n            stk.append(x)\n            while len(stk) > 1:\n                x, y = stk[-2:]\n                g = gcd(x, y)\n                if g == 1:\n                    break\n                stk.pop()\n                stk[-1] = x * y // g\n        return stk\n", "class Solution:\n  def replaceNonCoprimes(self, nums: list[int]) -> list[int]:\n    ans = []\n\n    for num in nums:\n      while ans and math.gcd(ans[-1], num) > 1:\n        num = math.lcm(ans.pop(), num)\n      ans.append(num)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2190, "slug": "most-frequent-number-following-key-in-an-array", "solutions": ["class Solution:\n    def mostFrequent(self, nums: List[int], key: int) -> int:\n        cnt = Counter()\n        ans = mx = 0\n        for a, b in pairwise(nums):\n            if a == key:\n                cnt[b] += 1\n                if mx < cnt[b]:\n                    mx = cnt[b]\n                    ans = b\n        return ans\n", "class Solution:\n  def mostFrequent(self, nums: list[int], key: int) -> int:\n    count = collections.Counter()\n\n    for a, b in itertools.pairwise(nums):\n      if a == key:\n        count[b] += 1\n\n    return max(count, key=lambda num: count[num])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2145, "slug": "count-the-hidden-sequences", "solutions": ["class Solution:\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\n        x = mi = mx = 0\n        for d in differences:\n            x += d\n            mi = min(mi, x)\n            mx = max(mx, x)\n        return max(upper - lower - (mx - mi) + 1, 0)\n", "class Solution:\n  def numberOfArrays(\n      self,\n      differences: list[int],\n      lower: int,\n      upper: int,\n  ) -> int:\n    prefix = 0\n    mn = 0  # Starts from 0.\n    mx = 0  # Starts from 0.\n\n    for d in differences:\n      prefix += d\n      mn = min(mn, prefix)\n      mx = max(mx, prefix)\n\n    return max(0, (upper - lower) - (mx - mn) + 1)\n", "class Solution:\n  def numberOfArrays(\n      self,\n      differences: list[int],\n      lower: int,\n      upper: int,\n  ) -> int:\n    prefix = list(itertools.accumulate(differences, initial=0))\n    return max(0, (upper - lower) - (max(prefix) - min(prefix)) + 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2126, "slug": "destroying-asteroids", "solutions": ["class Solution:\n    def asteroidsDestroyed(self, mass: int, asteroids: List[int]) -> bool:\n        asteroids.sort()\n        for x in asteroids:\n            if mass < x:\n                return False\n            mass += x\n        return True\n", "class Solution:\n  def asteroidsDestroyed(self, mass: int, asteroids: list[int]) -> bool:\n    for asteroid in sorted(asteroids):\n      if mass >= asteroid:\n        mass += asteroid\n      else:\n        return False\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2148, "slug": "count-elements-with-strictly-smaller-and-greater-elements", "solutions": ["class Solution:\n    def countElements(self, nums: List[int]) -> int:\n        mi, mx = min(nums), max(nums)\n        return sum(mi < x < mx for x in nums)\n", "class Solution:\n  def countElements(self, nums: list[int]) -> int:\n    mn = min(nums)\n    mx = max(nums)\n    return sum(mn < num < mx for num in nums)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2123, "slug": "minimum-operations-to-remove-adjacent-ones-in-matrix", "solutions": ["class Solution:\n    def minimumOperations(self, grid: List[List[int]]) -> int:\n        def find(i: int) -> int:\n            for j in g[i]:\n                if j not in vis:\n                    vis.add(j)\n                    if match[j] == -1 or find(match[j]):\n                        match[j] = i\n                        return 1\n            return 0\n\n        g = defaultdict(list)\n        m, n = len(grid), len(grid[0])\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                if (i + j) % 2 and v:\n                    x = i * n + j\n                    if i < m - 1 and grid[i + 1][j]:\n                        g[x].append(x + n)\n                    if i and grid[i - 1][j]:\n                        g[x].append(x - n)\n                    if j < n - 1 and grid[i][j + 1]:\n                        g[x].append(x + 1)\n                    if j and grid[i][j - 1]:\n                        g[x].append(x - 1)\n\n        match = [-1] * (m * n)\n        ans = 0\n        for i in g.keys():\n            vis = set()\n            ans += find(i)\n        return ans\n", "class Solution:\n  def minimumOperations(self, grid: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    seen = [[0] * n for _ in range(m)]\n    match = [[-1] * n for _ in range(m)]\n\n    def dfs(i: int, j: int, sessionId: int) -> int:\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if grid[x][y] == 0 or seen[x][y] == sessionId:\n          continue\n        seen[x][y] = sessionId\n        if match[x][y] == -1 or dfs(*divmod(match[x][y], n), sessionId):\n          match[x][y] = i * n + j\n          match[i][j] = x * n + y\n          return 1\n      return 0\n\n    ans = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1 and match[i][j] == -1:\n          sessionId = i * n + j\n          seen[i][j] = sessionId\n          ans += dfs(i, j, sessionId)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2168, "slug": "unique-substrings-with-equal-digit-frequency", "solutions": ["class Solution:\n    def equalDigitFrequency(self, s: str) -> int:\n        def check(i, j):\n            v = set()\n            for k in range(10):\n                cnt = presum[j + 1][k] - presum[i][k]\n                if cnt > 0:\n                    v.add(cnt)\n                if len(v) > 1:\n                    return False\n            return True\n\n        n = len(s)\n        presum = [[0] * 10 for _ in range(n + 1)]\n        for i, c in enumerate(s):\n            presum[i + 1][int(c)] += 1\n            for j in range(10):\n                presum[i + 1][j] += presum[i][j]\n        vis = set(s[i : j + 1] for i in range(n) for j in range(i, n) if check(i, j))\n        return len(vis)\n", "class Solution:\n  def equalDigitFrequency(self, s: str) -> int:\n    BASE = 11\n    HASH = 1_000_000_007\n    counts: list[dict] = []  # counts[i] := the counter map of s[0..i]\n    count = collections.Counter()\n    pows = [1]  # pows[i] := BASE^i % HASH\n    # hash[i] = the hash of the first i letters of s, where hash[i] =\n    # (26^(i - 1) * s[0] + 26^(i - 2) * s[1] + ... + s[i - 1]) % HASH\n    hash = [0]\n\n    def val(c: str) -> int:\n      return int(c) + 1\n\n    for c in s:\n      count[c] += 1\n      counts.append(count.copy())\n      pows.append(pows[-1] * BASE % HASH)\n      hash.append((hash[-1] * BASE + val(c)) % HASH)\n\n    def getRollingHash(l: int, r: int) -> int:\n      \"\"\"Returns the rolling hash of s[l..r).\"\"\"\n      h = (hash[r] - hash[l] * pows[r - l]) % HASH\n      return h + HASH if h < 0 else h\n\n    return len({getRollingHash(i, j + 1)\n                for i in range(len(s))\n                for j in range(i, len(s))\n                if self._isSameFreq(counts, i, j)})\n\n  def _isSameFreq(self, counts: list[dict], i: int, j: int) -> bool:\n    count = counts[j].copy()\n    if i > 0:\n      for c, freq in counts[i - 1].items():\n        count[c] -= freq\n        if count[c] == 0:\n          del count[c]\n    return min(count.values()) == max(count.values())\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2188, "slug": "minimum-time-to-finish-the-race", "solutions": ["class Solution:\n    def minimumFinishTime(\n        self, tires: List[List[int]], changeTime: int, numLaps: int\n    ) -> int:\n        cost = [inf] * 18\n        for f, r in tires:\n            i, s, t = 1, 0, f\n            while t <= changeTime + f:\n                s += t\n                cost[i] = min(cost[i], s)\n                t *= r\n                i += 1\n        f = [inf] * (numLaps + 1)\n        f[0] = -changeTime\n        for i in range(1, numLaps + 1):\n            for j in range(1, min(18, i + 1)):\n                f[i] = min(f[i], f[i - j] + cost[j])\n            f[i] += changeTime\n        return f[numLaps]\n", "class Solution:\n  def minimumFinishTime(\n      self,\n      tires: list[list[int]],\n      changeTime: int,\n      numLaps: int,\n  ) -> int:\n    # singleTire[i] := the minimum time to finish i laps without changing tire\n    singleTire = [math.inf] * (numLaps + 1)\n    # dp[i] := the minimum time to finish i laps\n    dp = [math.inf] * (numLaps + 1)\n\n    for i, (f, r) in enumerate(tires):\n      sumSecs = 0\n      rPower = 1\n      for j in range(1, numLaps + 1):\n        # the time to use the same tire for the next lap >=\n        # the time to change a new tire + f\n        if f * rPower >= changeTime + f:\n          break\n        sumSecs += f * rPower\n        rPower *= r\n        singleTire[j] = min(singleTire[j], sumSecs)\n\n    dp[0] = 0\n    for i in range(1, numLaps + 1):\n      for j in range(1, i + 1):\n        dp[i] = min(dp[i], dp[i - j] + changeTime + singleTire[j])\n\n    return dp[numLaps] - changeTime\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2192, "slug": "all-ancestors-of-a-node-in-a-directed-acyclic-graph", "solutions": ["class Solution:\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n        def bfs(s: int):\n            q = deque([s])\n            vis = {s}\n            while q:\n                i = q.popleft()\n                for j in g[i]:\n                    if j not in vis:\n                        vis.add(j)\n                        q.append(j)\n                        ans[j].append(s)\n\n        g = defaultdict(list)\n        for u, v in edges:\n            g[u].append(v)\n        ans = [[] for _ in range(n)]\n        for i in range(n):\n            bfs(i)\n        return ans\n", "class Solution:\n  def getAncestors(self, n: int, edges: list[list[int]]) -> list[list[int]]:\n    ans = [set() for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n\n    # Build the graph.\n    for u, v in edges:\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    # Perform topological sorting.\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    while q:\n      for _ in range(len(q)):\n        u = q.popleft()\n        for v in graph[u]:\n          ans[v].add(u)\n          ans[v].update(ans[u])\n          inDegrees[v] -= 1\n          if inDegrees[v] == 0:\n            q.append(v)\n\n    return [sorted(nodes) for nodes in ans]\n", "class Solution:\n  def getAncestors(self, n: int, edges: list[list[int]]) -> list[list[int]]:\n    ans = [[] for _ in range(n)]\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n\n    def dfs(u: int, ancestor: int, seen: set[int]) -> None:\n      seen.add(u)\n      for v in graph[u]:\n        if v in seen:\n          continue\n        ans[v].append(ancestor)\n        dfs(v, ancestor, seen)\n\n    for i in range(n):\n      dfs(i, i, set())\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2157, "slug": "groups-of-strings", "solutions": ["class Solution:\n    def groupStrings(self, words: List[str]) -> List[int]:\n        def find(x):\n            if p[x] != x:\n                p[x] = find(p[x])\n            return p[x]\n\n        def union(a, b):\n            nonlocal mx, n\n            if b not in p:\n                return\n            pa, pb = find(a), find(b)\n            if pa == pb:\n                return\n            p[pa] = pb\n            size[pb] += size[pa]\n            mx = max(mx, size[pb])\n            n -= 1\n\n        p = {}\n        size = Counter()\n        n = len(words)\n        mx = 0\n        for word in words:\n            x = 0\n            for c in word:\n                x |= 1 << (ord(c) - ord('a'))\n            p[x] = x\n            size[x] += 1\n            mx = max(mx, size[x])\n            if size[x] > 1:\n                n -= 1\n        for x in p.keys():\n            for i in range(26):\n                union(x, x ^ (1 << i))\n                if (x >> i) & 1:\n                    for j in range(26):\n                        if ((x >> j) & 1) == 0:\n                            union(x, x ^ (1 << i) | (1 << j))\n        return [n, mx]\n", "class UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.sz = [1] * n\n\n  def unionBySize(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.sz[i] < self.sz[j]:\n      self.sz[j] += self.sz[i]\n      self.id[i] = j\n    else:\n      self.sz[i] += self.sz[j]\n      self.id[j] = i\n    self.count -= 1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def groupStrings(self, words: list[str]) -> list[int]:\n    uf = UnionFind(len(words))\n\n    def getMask(s: str) -> int:\n      mask = 0\n      for c in s:\n        mask |= 1 << ord(c) - ord('a')\n      return mask\n\n    def getAddedMasks(mask: int):\n      for i in range(26):\n        if not (mask >> i & 1):\n          yield mask | 1 << i\n\n    def getDeletedMasks(mask: int):\n      for i in range(26):\n        if mask >> i & 1:\n          yield mask ^ 1 << i\n\n    maskToIndex = {getMask(word): i for i, word in enumerate(words)}\n    deletedMaskToIndex = {}\n\n    for i, word in enumerate(words):\n      mask = getMask(word)\n      for m in getAddedMasks(mask):\n        if m in maskToIndex:\n          uf.unionBySize(i, maskToIndex[m])\n      for m in getDeletedMasks(mask):\n        if m in maskToIndex:\n          uf.unionBySize(i, maskToIndex[m])\n        if m in deletedMaskToIndex:\n          uf.unionBySize(i, deletedMaskToIndex[m])\n        else:\n          deletedMaskToIndex[m] = i\n\n    return [uf.count, max(uf.sz)]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2194, "slug": "cells-in-a-range-on-an-excel-sheet", "solutions": ["class Solution:\n    def cellsInRange(self, s: str) -> List[str]:\n        return [\n            chr(i) + str(j)\n            for i in range(ord(s[0]), ord(s[-2]) + 1)\n            for j in range(int(s[1]), int(s[-1]) + 1)\n        ]\n", "class Solution:\n  def cellsInRange(self, s: str) -> list[str]:\n    ans = []\n    startCol, startRow, _, endCol, endRow = s\n\n    for j in range(ord(startCol), ord(endCol) + 1):\n      for i in range(int(startRow), int(endRow) + 1):\n        ans.append(chr(j) + str(i))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2132, "slug": "stamping-the-grid", "solutions": ["class Solution:\n    def possibleToStamp(\n        self, grid: List[List[int]], stampHeight: int, stampWidth: int\n    ) -> bool:\n        m, n = len(grid), len(grid[0])\n        s = [[0] * (n + 1) for _ in range(m + 1)]\n        for i, row in enumerate(grid, 1):\n            for j, v in enumerate(row, 1):\n                s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + v\n        d = [[0] * (n + 2) for _ in range(m + 2)]\n        for i in range(1, m - stampHeight + 2):\n            for j in range(1, n - stampWidth + 2):\n                x, y = i + stampHeight - 1, j + stampWidth - 1\n                if s[x][y] - s[x][j - 1] - s[i - 1][y] + s[i - 1][j - 1] == 0:\n                    d[i][j] += 1\n                    d[i][y + 1] -= 1\n                    d[x + 1][j] -= 1\n                    d[x + 1][y + 1] += 1\n        for i, row in enumerate(grid, 1):\n            for j, v in enumerate(row, 1):\n                d[i][j] += d[i - 1][j] + d[i][j - 1] - d[i - 1][j - 1]\n                if v == 0 and d[i][j] == 0:\n                    return False\n        return True\n", "class Solution:\n  def possibleToStamp(\n      self,\n      grid: list[list[int]],\n      stampHeight: int,\n      stampWidth: int,\n  ) -> bool:\n    m = len(grid)\n    n = len(grid[0])\n    # A[i][j] := the number of 1s in grid[0..i)[0..j)\n    A = [[0] * (n + 1) for _ in range(m + 1)]\n    # B[i][j] := the number of ways to stamp the submatrix in [0..i)[0..j)\n    B = [[0] * (n + 1) for _ in range(m + 1)]\n    # fit[i][j] := true if the stamps can fit with the right-bottom at (i, j)\n    fit = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        A[i + 1][j + 1] = A[i + 1][j] + A[i][j + 1] - A[i][j] + grid[i][j]\n        if i + 1 >= stampHeight and j + 1 >= stampWidth:\n          x = i - stampHeight + 1\n          y = j - stampWidth + 1\n          if A[i + 1][j + 1] - A[x][j + 1] - A[i + 1][y] + A[x][y] == 0:\n            fit[i][j] = True\n\n    for i in range(m):\n      for j in range(n):\n        B[i + 1][j + 1] = B[i + 1][j] + B[i][j + 1] - B[i][j] + fit[i][j]\n\n    for i in range(m):\n      for j in range(n):\n        if not grid[i][j]:\n          x = min(i + stampHeight, m)\n          y = min(j + stampWidth, n)\n          if B[x][y] - B[i][y] - B[x][j] + B[i][j] == 0:\n            return False\n\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2182, "slug": "construct-string-with-repeat-limit", "solutions": ["class Solution:\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\n        cnt = [0] * 26\n        for c in s:\n            cnt[ord(c) - ord(\"a\")] += 1\n        ans = []\n        j = 24\n        for i in range(25, -1, -1):\n            j = min(i - 1, j)\n            while 1:\n                x = min(repeatLimit, cnt[i])\n                cnt[i] -= x\n                ans.append(ascii_lowercase[i] * x)\n                if cnt[i] == 0:\n                    break\n                while j >= 0 and cnt[j] == 0:\n                    j -= 1\n                if j < 0:\n                    break\n                cnt[j] -= 1\n                ans.append(ascii_lowercase[j])\n        return \"\".join(ans)\n", "class Solution:\n  def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\n    ans = ''\n    count = collections.Counter(s)\n\n    while True:\n      addOne = ans and self._shouldAddOne(ans, count)\n      c = self._getLargestChar(ans, count)\n      if c == ' ':\n        break\n      repeats = 1 if addOne else min(count[c], repeatLimit)\n      ans += c * repeats\n      count[c] -= repeats\n\n    return ans\n\n  def _shouldAddOne(self, ans: str, count: collections.Counter) -> bool:\n    for c in reversed(string.ascii_lowercase):\n      if count[c]:\n        return ans[-1] == c\n    return False\n\n  def _getLargestChar(self, ans: str, count: collections.Counter) -> int:\n    for c in reversed(string.ascii_lowercase):\n      if count[c] and (not ans or ans[-1] != c):\n        return c\n    return ' '\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2175, "slug": "the-change-in-global-rankings", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2186, "slug": "minimum-number-of-steps-to-make-two-strings-anagram-ii", "solutions": ["class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        cnt = Counter(s)\n        for c in t:\n            cnt[c] -= 1\n        return sum(abs(v) for v in cnt.values())\n", "class Solution:\n  def minSteps(self, s: str, t: str) -> int:\n    count = collections.Counter(s)\n    count.subtract(collections.Counter(t))\n    return sum([abs(c) for c in count.values()])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2196, "slug": "create-binary-tree-from-descriptions", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\n        nodes = defaultdict(TreeNode)\n        children = set()\n        for parent, child, isLeft in descriptions:\n            if parent not in nodes:\n                nodes[parent] = TreeNode(parent)\n            if child not in nodes:\n                nodes[child] = TreeNode(child)\n            children.add(child)\n            if isLeft:\n                nodes[parent].left = nodes[child]\n            else:\n                nodes[parent].right = nodes[child]\n        root = (set(nodes.keys()) - children).pop()\n        return nodes[root]\n", "class Solution:\n  def createBinaryTree(self, descriptions: list[list[int]]) -> TreeNode | None:\n    children = set()\n    valToNode = {}\n\n    for p, c, isLeft in descriptions:\n      parent = valToNode.setdefault(p, TreeNode(p))\n      child = valToNode.setdefault(c, TreeNode(c))\n      if isLeft:\n        parent.left = child\n      else:\n        parent.right = child\n      children.add(c)\n\n    root = (set(valToNode) - set(children)).pop()\n    return valToNode[root]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2109, "slug": "adding-spaces-to-a-string", "solutions": ["class Solution:\n    def addSpaces(self, s: str, spaces: List[int]) -> str:\n        ans = []\n        j = 0\n        for i, c in enumerate(s):\n            if j < len(spaces) and i == spaces[j]:\n                ans.append(' ')\n                j += 1\n            ans.append(c)\n        return ''.join(ans)\n", "class Solution:\n  def addSpaces(self, s: str, spaces: list[int]) -> str:\n    ans = []\n    j = 0  # spaces' index\n\n    for i, c in enumerate(s):\n      if j < len(spaces) and i == spaces[j]:\n        ans.append(' ')\n        j += 1\n      ans.append(c)\n\n    return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2156, "slug": "find-substring-with-given-hash-value", "solutions": ["class Solution:\n    def subStrHash(\n        self, s: str, power: int, modulo: int, k: int, hashValue: int\n    ) -> str:\n        h, n = 0, len(s)\n        p = 1\n        for i in range(n - 1, n - 1 - k, -1):\n            val = ord(s[i]) - ord(\"a\") + 1\n            h = ((h * power) + val) % modulo\n            if i != n - k:\n                p = p * power % modulo\n        j = n - k\n        for i in range(n - 1 - k, -1, -1):\n            pre = ord(s[i + k]) - ord(\"a\") + 1\n            cur = ord(s[i]) - ord(\"a\") + 1\n            h = ((h - pre * p) * power + cur) % modulo\n            if h == hashValue:\n                j = i\n        return s[j : j + k]\n", "class Solution:\n  def subStrHash(\n      self,\n      s: str,\n      power: int,\n      modulo: int,\n      k: int,\n      hashValue: int,\n  ) -> str:\n    maxPower = pow(power, k, modulo)\n    hash = 0\n\n    def val(c: str) -> int:\n      return ord(c) - ord('a') + 1\n\n    for i, c in reversed(list(enumerate(s))):\n      hash = (hash * power + val(c)) % modulo\n      if i + k < len(s):\n        hash = (hash - val(s[i + k]) * maxPower) % modulo\n      if hash == hashValue:\n        bestLeft = i\n\n    return s[bestLeft:bestLeft + k]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2179, "slug": "count-good-triplets-in-an-array", "solutions": ["class BinaryIndexedTree:\n    def __init__(self, n):\n        self.n = n\n        self.c = [0] * (n + 1)\n\n    @staticmethod\n    def lowbit(x):\n        return x & -x\n\n    def update(self, x, delta):\n        while x <= self.n:\n            self.c[x] += delta\n            x += BinaryIndexedTree.lowbit(x)\n\n    def query(self, x):\n        s = 0\n        while x > 0:\n            s += self.c[x]\n            x -= BinaryIndexedTree.lowbit(x)\n        return s\n\n\nclass Solution:\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\n        pos = {v: i for i, v in enumerate(nums2, 1)}\n        ans = 0\n        n = len(nums1)\n        tree = BinaryIndexedTree(n)\n        for num in nums1:\n            p = pos[num]\n            left = tree.query(p)\n            right = n - p - (tree.query(n) - tree.query(p))\n            ans += left * right\n            tree.update(p, 1)\n        return ans\n", "class FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def add(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def goodTriplets(self, nums1: list[int], nums2: list[int]) -> int:\n    n = len(nums1)\n    numToIndex = {num: i for i, num in enumerate(nums1)}\n    # Remap each number in `nums2` to the according index in `nums1` as `arr`.\n    # So the problem is to find the number of increasing tripets in `arr`.\n    arr = [numToIndex[num] for num in nums2]\n    # leftSmaller[i] := the number of arr[j] < arr[i], where 0 <= j < i\n    leftSmaller = [0] * n\n    # rightLarger[i] := the number of arr[j] > arr[i], where i < j < n\n    rightLarger = [0] * n\n    tree1 = FenwickTree(n)  # Calculates `leftSmaller`.\n    tree2 = FenwickTree(n)  # Calculates `rightLarger`.\n\n    for i, a in enumerate(arr):\n      leftSmaller[i] = tree1.get(a)\n      tree1.add(a + 1, 1)\n\n    for i, a in reversed(list(enumerate(arr))):\n      rightLarger[i] = tree2.get(n) - tree2.get(a)\n      tree2.add(a + 1, 1)\n\n    return sum(a * b for a, b in zip(leftSmaller, rightLarger))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2103, "slug": "rings-and-rods", "solutions": ["class Solution:\n    def countPoints(self, rings: str) -> int:\n        mask = [0] * 10\n        d = {\"R\": 1, \"G\": 2, \"B\": 4}\n        for i in range(0, len(rings), 2):\n            c = rings[i]\n            j = int(rings[i + 1])\n            mask[j] |= d[c]\n        return mask.count(7)\n", "class Solution:\n  def countPoints(self, rings: str) -> int:\n    colors = [0] * 10\n\n    for c, num in zip(rings[::2], rings[1::2]):\n      color = 1 if c == 'R' else 2 if c == 'G' else 4\n      colors[int(num)] |= color\n\n    return sum(color == 7 for color in colors)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2137, "slug": "pour-water-between-buckets-to-make-water-levels-equal", "solutions": ["class Solution:\n    def equalizeWater(self, buckets: List[int], loss: int) -> float:\n        def check(v):\n            a = b = 0\n            for x in buckets:\n                if x >= v:\n                    a += x - v\n                else:\n                    b += (v - x) * 100 / (100 - loss)\n            return a >= b\n\n        l, r = 0, max(buckets)\n        while r - l > 1e-5:\n            mid = (l + r) / 2\n            if check(mid):\n                l = mid\n            else:\n                r = mid\n        return l\n", "class Solution:\n  def equalizeWater(self, buckets: list[int], loss: int) -> float:\n    ERR = 1e-5\n    PERCENTAGE = (100 - loss) / 100\n    l = 0.0\n    r = max(buckets)\n\n    def canFill(target: float) -> bool:\n      extra = 0\n      need = 0\n      for bucket in buckets:\n        if bucket > target:\n          extra += bucket - target\n        else:\n          need += target - bucket\n      return extra * PERCENTAGE >= need\n\n    while r - l > ERR:\n      m = (l + r) / 2\n      if canFill(m):\n        l = m\n      else:\n        r = m\n\n    return l\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2110, "slug": "number-of-smooth-descent-periods-of-a-stock", "solutions": ["class Solution:\n    def getDescentPeriods(self, prices: List[int]) -> int:\n        ans = 0\n        i, n = 0, len(prices)\n        while i < n:\n            j = i + 1\n            while j < n and prices[j - 1] - prices[j] == 1:\n                j += 1\n            cnt = j - i\n            ans += (1 + cnt) * cnt // 2\n            i = j\n        return ans\n", "class Solution:\n  def getDescentPeriods(self, prices: list[int]) -> int:\n    ans = 1  # prices[0]\n    dp = 1\n\n    for i in range(1, len(prices)):\n      if prices[i] == prices[i - 1] - 1:\n        dp += 1\n      else:\n        dp = 1\n      ans += dp\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2111, "slug": "minimum-operations-to-make-the-array-k-increasing", "solutions": ["class Solution:\n    def kIncreasing(self, arr: List[int], k: int) -> int:\n        def lis(arr):\n            t = []\n            for x in arr:\n                idx = bisect_right(t, x)\n                if idx == len(t):\n                    t.append(x)\n                else:\n                    t[idx] = x\n            return len(arr) - len(t)\n\n        return sum(lis(arr[i::k]) for i in range(k))\n", "class Solution:\n  def kIncreasing(self, arr: list[int], k: int) -> int:\n    def numReplaced(arr: list[int]) -> int:\n      tails = []\n      for a in arr:\n        if not tails or tails[-1] <= a:\n          tails.append(a)\n        else:\n          tails[bisect_right(tails, a)] = a\n      return len(arr) - len(tails)\n\n    return sum(numReplaced(arr[i::k]) for i in range(k))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2128, "slug": "remove-all-ones-with-row-and-column-flips", "solutions": ["class Solution:\n    def removeOnes(self, grid: List[List[int]]) -> bool:\n        s = set()\n        for row in grid:\n            t = tuple(row) if row[0] == grid[0][0] else tuple(x ^ 1 for x in row)\n            s.add(t)\n        return len(s) == 1\n", "class Solution:\n  def removeOnes(self, grid: list[list[int]]) -> bool:\n    revRow = [a ^ 1 for a in grid[0]]\n    return all(row == grid[0] or row == revRow for row in grid)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2101, "slug": "detonate-the-maximum-bombs", "solutions": ["class Solution:\n    def maximumDetonation(self, bombs: List[List[int]]) -> int:\n        n = len(bombs)\n        g = [[] for _ in range(n)]\n        for i in range(n - 1):\n            x1, y1, r1 = bombs[i]\n            for j in range(i + 1, n):\n                x2, y2, r2 = bombs[j]\n                dist = hypot(x1 - x2, y1 - y2)\n                if dist <= r1:\n                    g[i].append(j)\n                if dist <= r2:\n                    g[j].append(i)\n        ans = 0\n        for k in range(n):\n            vis = {k}\n            q = [k]\n            for i in q:\n                for j in g[i]:\n                    if j not in vis:\n                        vis.add(j)\n                        q.append(j)\n            if len(vis) == n:\n                return n\n            ans = max(ans, len(vis))\n        return ans\n", "class Solution:\n  def maximumDetonation(self, bombs: list[list[int]]) -> int:\n    n = len(bombs)\n    ans = 0\n    graph = [[] for _ in range(n)]\n\n    for i, (xi, yi, ri) in enumerate(bombs):\n      for j, (xj, yj, rj) in enumerate(bombs):\n        if i == j:\n          continue\n        if ri**2 >= (xi - xj)**2 + (yi - yj)**2:\n          graph[i].append(j)\n\n    def dfs(u: int, seen: set[int]) -> None:\n      for v in graph[u]:\n        if v in seen:\n          continue\n        seen.add(v)\n        dfs(v, seen)\n\n    for i in range(n):\n      seen = set([i])\n      dfs(i, seen)\n      ans = max(ans, len(seen))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2193, "slug": "minimum-number-of-moves-to-make-palindrome", "solutions": ["class Solution:\n    def minMovesToMakePalindrome(self, s: str) -> int:\n        cs = list(s)\n        ans, n = 0, len(s)\n        i, j = 0, n - 1\n        while i < j:\n            even = False\n            for k in range(j, i, -1):\n                if cs[i] == cs[k]:\n                    even = True\n                    while k < j:\n                        cs[k], cs[k + 1] = cs[k + 1], cs[k]\n                        k += 1\n                        ans += 1\n                    j -= 1\n                    break\n            if not even:\n                ans += n // 2 - i\n            i += 1\n        return ans\n", "class Solution:\n  def minMovesToMakePalindrome(self, s: str) -> int:\n    ans = 0\n    chars = list(s)\n\n    while len(chars) > 1:\n      # Greedily match the last digit.\n      i = chars.index(chars[-1])\n      if i == len(chars) - 1:\n        # s[i] is the middle letter.\n        ans += i // 2\n      else:\n        chars.pop(i)\n        ans += i  # Swap the matched letter to the left.\n      chars.pop()\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2153, "slug": "the-number-of-passengers-in-each-bus-ii", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3151, "slug": "special-array-i", "solutions": ["class Solution:\n    def isArraySpecial(self, nums: List[int]) -> bool:\n        return all(a % 2 != b % 2 for a, b in pairwise(nums))\n", "class Solution:\n  def isArraySpecial(self, nums: list[int]) -> bool:\n    return all(a % 2 != b % 2 for a, b in itertools.pairwise(nums))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3106, "slug": "lexicographically-smallest-string-after-operations-with-constraint", "solutions": ["class Solution:\n    def getSmallestString(self, s: str, k: int) -> str:\n        cs = list(s)\n        for i, c1 in enumerate(s):\n            for c2 in ascii_lowercase:\n                if c2 >= c1:\n                    break\n                d = min(ord(c1) - ord(c2), 26 - ord(c1) + ord(c2))\n                if d <= k:\n                    cs[i] = c2\n                    k -= d\n                    break\n        return \"\".join(cs)\n", "class Solution:\n  def getSmallestString(self, s: str, k: int) -> str:\n    ans = list(s)\n\n    for i, c in enumerate(s):\n      if k == 0:\n        break\n      distToA = min(ord(c) - ord('a'), ord('z') - ord(c) + 1)\n      if k >= distToA:\n        k -= distToA\n        ans[i] = 'a'\n      else:\n        # k is not enough to change the current letter to 'a', so move as closer\n        # to 'a' as possible.\n        ans[i] = chr(ord(c) - k)\n        k = 0\n\n    return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3128, "slug": "right-triangles", "solutions": ["class Solution:\n    def numberOfRightTriangles(self, grid: List[List[int]]) -> int:\n        rows = [0] * len(grid)\n        cols = [0] * len(grid[0])\n        for i, row in enumerate(grid):\n            for j, x in enumerate(row):\n                rows[i] += x\n                cols[j] += x\n        ans = 0\n        for i, row in enumerate(grid):\n            for j, x in enumerate(row):\n                if x:\n                    ans += (rows[i] - 1) * (cols[j] - 1)\n        return ans\n", "class Solution:\n  def numberOfRightTriangles(self, grid: list[list[int]]) -> int:\n    rows = [0] * len(grid)\n    cols = [0] * len(grid[0])\n\n    for i, row in enumerate(grid):\n      for j, num in enumerate(row):\n        if num == 1:\n          rows[i] += 1\n          cols[j] += 1\n\n    return sum((rows[i] - 1) * (cols[j] - 1)\n               for i, row in enumerate(grid)\n               for j, num in enumerate(row)\n               if num == 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3171, "slug": "find-subarray-with-bitwise-or-closest-to-k", "solutions": ["class Solution:\n    def minimumDifference(self, nums: List[int], k: int) -> int:\n        m = max(nums).bit_length()\n        cnt = [0] * m\n        s = i = 0\n        ans = inf\n        for j, x in enumerate(nums):\n            s |= x\n            ans = min(ans, abs(s - k))\n            for h in range(m):\n                if x >> h & 1:\n                    cnt[h] += 1\n            while i < j and s > k:\n                y = nums[i]\n                for h in range(m):\n                    if y >> h & 1:\n                        cnt[h] -= 1\n                        if cnt[h] == 0:\n                            s ^= 1 << h\n                i += 1\n                ans = min(ans, abs(s - k))\n        return ans\n", "class Solution:\n  # Similar to 1521. Find a Value of a Mysterious Function Closest to Target\n  def minimumDifference(self, nums: list[int], k: int) -> int:\n    ans = math.inf\n    dp = set()  # all the values of subarrays that end in the current number\n\n    for num in nums:\n      # Extend each subarray that ends in the dpious number. Due to\n      # monotonicity of the OR operation, the size of `next_set` will be at most\n      # bin(num).count('1') + 1.\n      dp = {num} | {val | num for val in dp}\n      ans = min(ans, min(abs(k - val) for val in dp))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3157, "slug": "find-the-level-of-tree-with-minimum-sum", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minimumLevel(self, root: Optional[TreeNode]) -> int:\n        q = deque([root])\n        ans = 0\n        level, s = 1, inf\n        while q:\n            t = 0\n            for _ in range(len(q)):\n                node = q.popleft()\n                t += node.val\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            if s > t:\n                s = t\n                ans = level\n            level += 1\n        return ans\n", "class Solution:\n  # Similar to 1161. Maximum Level Sum of a Binary Tree\n  def minimumLevel(self, root: TreeNode | None) -> int:\n    ans = 0\n    minLevelSum = math.inf\n    q = collections.deque([root])\n\n    level = 1\n    while q:\n      levelSum = 0\n      for _ in range(len(q)):\n        node = q.popleft()\n        levelSum += node.val\n        if node.left:\n          q.append(node.left)\n        if node.right:\n          q.append(node.right)\n      if levelSum < minLevelSum:\n        minLevelSum = levelSum\n        ans = level\n      level += 1\n\n    return ans\n", "class Solution:\n  # Similar to 1161. Maximum Level Sum of a Binary Tree\n  def minimumLevel(self, root: TreeNode | None) -> int:\n    # levelSums[i] := the sum of level (i + 1) (1-indexed)\n    levelSums = []\n\n    def dfs(root: TreeNode | None, level: int) -> None:\n      if not root:\n        return\n      if len(levelSums) == level:\n        levelSums.append(0)\n      levelSums[level] += root.val\n      dfs(root.left, level + 1)\n      dfs(root.right, level + 1)\n\n    dfs(root, 0)\n    return 1 + levelSums.index(min(levelSums))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3184, "slug": "count-pairs-that-form-a-complete-day-i", "solutions": ["class Solution:\n    def countCompleteDayPairs(self, hours: List[int]) -> int:\n        cnt = Counter()\n        ans = 0\n        for x in hours:\n            ans += cnt[(24 - (x % 24)) % 24]\n            cnt[x % 24] += 1\n        return ans\n", "class Solution:\n  def countCompleteDayPairs(self, hours: list[int]) -> int:\n    ans = 0\n    count = [0] * 24\n\n    for hour in hours:\n      ans += count[(24 - hour % 24) % 24]\n      count[hour % 24] += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3186, "slug": "maximum-total-damage-with-spell-casting", "solutions": ["class Solution:\n    def maximumTotalDamage(self, power: List[int]) -> int:\n        @cache\n        def dfs(i: int) -> int:\n            if i >= n:\n                return 0\n            a = dfs(i + cnt[power[i]])\n            b = power[i] * cnt[power[i]] + dfs(nxt[i])\n            return max(a, b)\n\n        n = len(power)\n        cnt = Counter(power)\n        power.sort()\n        nxt = [bisect_right(power, x + 2, lo=i + 1) for i, x in enumerate(power)]\n        return dfs(0)\n", "class Solution:\n  def maximumTotalDamage(self, power: list[int]) -> int:\n    count = collections.Counter(power)\n    uniqueDamages = sorted(count.keys())\n    # dp[i][k] := the maximum damage using uniqueDamages[0..i], where k\n    # indicates if the i-th damage is used\n    dp = [[0] * 2 for _ in range(len(uniqueDamages))]\n\n    for i, damage in enumerate(uniqueDamages):\n      if i == 0:\n        dp[0] = [0, damage * count[damage]]\n        continue\n      dp[i][0] = max(dp[i - 1])\n      dp[i][1] = damage * count[damage]\n      if i >= 1 and uniqueDamages[i - 1] not in (damage - 1, damage - 2):\n        dp[i][1] += max(dp[i - 1])\n      elif i >= 2 and uniqueDamages[i - 2] != damage - 2:\n        dp[i][1] += max(dp[i - 2])\n      elif i >= 3:\n        dp[i][1] += max(dp[i - 3])\n\n    return max(dp[-1])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3103, "slug": "find-trending-hashtags-ii", "solutions": ["import pandas as pd\n\n\ndef find_trending_hashtags(tweets: pd.DataFrame) -> pd.DataFrame:\n    # Filter tweets for February 2024\n    tweets_feb_2024 = tweets[tweets[\"tweet_date\"].between(\"2024-02-01\", \"2024-02-29\")]\n\n    # Extract hashtags from tweets\n    hashtags = tweets_feb_2024[\"tweet\"].str.findall(r\"#\\w+\")\n\n    # Flatten list of hashtags\n    all_hashtags = [tag for sublist in hashtags for tag in sublist]\n\n    # Count occurrences of each hashtag\n    hashtag_counts = pd.Series(all_hashtags).value_counts().reset_index()\n    hashtag_counts.columns = [\"hashtag\", \"count\"]\n\n    # Sort by count of hashtag in descending order\n    hashtag_counts = hashtag_counts.sort_values(\n        by=[\"count\", \"hashtag\"], ascending=[False, False]\n    )\n\n    # Get top 3 trending hashtags\n    top_3_hashtags = hashtag_counts.head(3)\n\n    return top_3_hashtags\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3111, "slug": "minimum-rectangles-to-cover-points", "solutions": ["class Solution:\n    def minRectanglesToCoverPoints(self, points: List[List[int]], w: int) -> int:\n        points.sort()\n        ans, x1 = 0, -1\n        for x, _ in points:\n            if x > x1:\n                ans += 1\n                x1 = x + w\n        return ans\n", "class Solution:\n  def minRectanglesToCoverPoints(self, points: list[list[int]], w: int) -> int:\n    ans = 0\n    prevX = -w - 1\n    xs = sorted([x for x, _ in points])\n\n    for x in xs:\n      if x > prevX + w:\n        ans += 1\n        prevX = x\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3155, "slug": "maximum-number-of-upgradable-servers", "solutions": ["class Solution:\n    def maxUpgrades(\n        self, count: List[int], upgrade: List[int], sell: List[int], money: List[int]\n    ) -> List[int]:\n        ans = []\n        for cnt, cost, income, cash in zip(count, upgrade, sell, money):\n            ans.append(min(cnt, (cnt * income + cash) // (cost + income)))\n        return ans\n", "class Solution:\n  def maxUpgrades(\n      self,\n      count: list[int],\n      upgrade: list[int],\n      sell: list[int],\n      money: list[int],\n  ) -> list[int]:\n    # If there's enough money, upgrade all servers; otherwise, optimize by\n    # upgrading x servers. We have x * upgrade <= money + (count - x) * sell.\n    # Therefore, x = (money + count * sell) / (sell + upgrade).\n    return [min(c, (m + c * s) // (s + u))\n            for c, u, s, m in zip(count, upgrade, sell, money)]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3113, "slug": "find-the-number-of-subarrays-where-boundary-elements-are-maximum", "solutions": ["class Solution:\n    def numberOfSubarrays(self, nums: List[int]) -> int:\n        stk = []\n        ans = 0\n        for x in nums:\n            while stk and stk[-1][0] < x:\n                stk.pop()\n            if not stk or stk[-1][0] > x:\n                stk.append([x, 1])\n            else:\n                stk[-1][1] += 1\n            ans += stk[-1][1]\n        return ans\n", "class Solution:\n  def numberOfSubarrays(self, nums: list[int]) -> int:\n    ans = 0\n    stack = []\n\n    for num in nums:\n      while stack and stack[-1][0] < num:\n        stack.pop()\n      if not stack or stack[-1][0] != num:\n        stack.append([num, 0])\n      stack[-1][1] += 1\n      ans += stack[-1][1]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3198, "slug": "find-cities-in-each-state", "solutions": ["import pandas as pd\n\n\ndef find_cities(cities: pd.DataFrame) -> pd.DataFrame:\n    result = (\n        cities.groupby(\"state\")[\"city\"]\n        .apply(lambda x: \", \".join(sorted(x)))\n        .reset_index()\n    )\n    result.columns = [\"state\", \"cities\"]\n    return result\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3196, "slug": "maximize-total-cost-of-alternating-subarrays", "solutions": ["class Solution:\n    def maximumTotalCost(self, nums: List[int]) -> int:\n        @cache\n        def dfs(i: int, j: int) -> int:\n            if i >= len(nums):\n                return 0\n            ans = nums[i] + dfs(i + 1, 1)\n            if j == 1:\n                ans = max(ans, -nums[i] + dfs(i + 1, 0))\n            return ans\n\n        return dfs(0, 0)\n", "class Solution:\n  def maximumTotalCost(self, nums: list[int]) -> int:\n    # A small trick so that we don't need to handle the edge case and can use\n    # ranged-based for loop.\n    keep = -math.inf  # the maximum cost if the last number is kept\n    flip = 0  # the maximum cost if the last number is flipped\n\n    for num in nums:\n      keep, flip = max(keep, flip) + num, keep - num\n\n    return max(keep, flip)\n", "class Solution:\n  def maximumTotalCost(self, nums: list[int]) -> int:\n    keep = nums[0]  # the maximum cost if the last number is kept\n    flip = nums[0]  # the maximum cost if the last number is flipped\n\n    for i in range(1, len(nums)):\n      keepCurr = max(keep, flip) + nums[i]\n      flipCurr = keep - nums[i]\n      keep = keepCurr\n      flip = flipCurr\n\n    return max(keep, flip)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3136, "slug": "valid-word", "solutions": ["class Solution:\n    def isValid(self, word: str) -> bool:\n        if len(word) < 3:\n            return False\n        has_vowel = has_consonant = False\n        vs = set(\"aeiouAEIOU\")\n        for c in word:\n            if not c.isalnum():\n                return False\n            if c.isalpha():\n                if c in vs:\n                    has_vowel = True\n                else:\n                    has_consonant = True\n        return has_vowel and has_consonant\n", "class Solution:\n  def isValid(self, word: str) -> bool:\n    VOWELS = 'aeiouAEIOU'\n\n    def isConsonant(c: str) -> bool:\n      return c.isalpha() and c not in VOWELS\n\n    return (len(word) >= 3 and\n            all(c.isalnum() for c in word) and\n            any(c in VOWELS for c in word) and\n            any(isConsonant(c) for c in word))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3119, "slug": "maximum-number-of-potholes-that-can-be-fixed", "solutions": ["class Solution:\n    def maxPotholes(self, road: str, budget: int) -> int:\n        road += \".\"\n        n = len(road)\n        cnt = [0] * n\n        k = 0\n        for c in road:\n            if c == \"x\":\n                k += 1\n            elif k:\n                cnt[k] += 1\n                k = 0\n        ans = 0\n        for k in range(n - 1, 0, -1):\n            if cnt[k] == 0:\n                continue\n            t = min(budget // (k + 1), cnt[k])\n            ans += t * k\n            budget -= t * (k + 1)\n            if budget == 0:\n                break\n            cnt[k - 1] += cnt[k] - t\n        return ans\n", "class Solution:\n  def maxPotholes(self, road: str, budget: int) -> int:\n    ans = 0\n\n    for length in sorted(map(len, road.split('.')), reverse=True):\n      canRepair = max(0, budget - 1)\n      if length > canRepair:\n        return ans + canRepair\n      ans += length\n      budget -= length + 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3133, "slug": "minimum-array-end", "solutions": ["class Solution:\n    def minEnd(self, n: int, x: int) -> int:\n        n -= 1\n        ans = x\n        for i in range(31):\n            if x >> i & 1 ^ 1:\n                ans |= (n & 1) << i\n                n >>= 1\n        ans |= n << 31\n        return ans\n", "class Solution:\n  def minEnd(self, n: int, x: int) -> int:\n    # Set x's 0s with (n - 1)'s LSb-to-MSb bits, preserving x's 1s. This\n    # operation increase x for (n - 1) iterations while preserving x's 1s.\n    MAX_BIT = n.bit_length() + x.bit_length()\n    k = n - 1\n    BINARY_INDEX = 0\n\n    for i in range(MAX_BIT):\n      if x >> i & 1 == 0:\n        # Set x's 0 with k's bit if the running bit of k is 1.\n        if k >> BINARY_INDEX & 1:\n          x |= 1 << i\n        BINARY_INDEX += 1\n\n    return x\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3116, "slug": "kth-smallest-amount-with-single-denomination-combination", "solutions": ["class Solution:\n    def findKthSmallest(self, coins: List[int], k: int) -> int:\n        def check(mx: int) -> bool:\n            cnt = 0\n            for i in range(1, 1 << len(coins)):\n                v = 1\n                for j, x in enumerate(coins):\n                    if i >> j & 1:\n                        v = lcm(v, x)\n                        if v > mx:\n                            break\n                m = i.bit_count()\n                if m & 1:\n                    cnt += mx // v\n                else:\n                    cnt -= mx // v\n            return cnt >= k\n\n        return bisect_left(range(10**11), True, key=check)\n", "class Solution:\n  def findKthSmallest(self, coins: list[int], k: int) -> int:\n    sizeToLcms = self._getSizeToLcms(coins)\n\n    def count(m: int) -> int:\n      \"\"\"Returns the number of denominations <= m.\"\"\"\n      res = 0\n      for sz, lcms in enumerate(sizeToLcms):\n        for lcm in lcms:\n          # Principle of Inclusion-Exclusion (PIE)\n          res += m // lcm * pow(-1, sz + 1)\n      return res\n\n    return bisect.bisect_left(range(k * min(coins)), k, key=count)\n\n  def _getSizeToLcms(self, coins: list[int]) -> list[list[int]]:\n    # Returns the LCMs for each number of combination of coins.\n    sizeToLcms = [[] for _ in range(len(coins) + 1)]\n    for sz in range(1, len(coins) + 1):\n      for combination in itertools.combinations(coins, sz):\n        sizeToLcms[sz].append(math.lcm(*combination))\n    return sizeToLcms\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3124, "slug": "find-longest-calls", "solutions": ["import pandas as pd\n\n\ndef find_longest_calls(contacts: pd.DataFrame, calls: pd.DataFrame) -> pd.DataFrame:\n    merged_data = calls.merge(contacts, left_on=\"contact_id\", right_on=\"id\")\n    merged_data[\"duration_formatted\"] = (\n        merged_data[\"duration\"] // 3600 * 10000\n        + merged_data[\"duration\"] % 3600 // 60 * 100\n        + merged_data[\"duration\"] % 60\n    ).apply(lambda x: \"{:02}:{:02}:{:02}\".format(x // 10000, x // 100 % 100, x % 100))\n\n    merged_data[\"rk\"] = merged_data.groupby(\"type\")[\"duration\"].rank(\n        method=\"dense\", ascending=False\n    )\n\n    result = merged_data[merged_data[\"rk\"] <= 3][\n        [\"first_name\", \"type\", \"duration_formatted\"]\n    ]\n    result = result.sort_values(\n        by=[\"type\", \"duration_formatted\", \"first_name\"], ascending=[True, False, False]\n    )\n    return result\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3162, "slug": "find-the-number-of-good-pairs-i", "solutions": ["class Solution:\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], k: int) -> int:\n        return sum(x % (y * k) == 0 for x in nums1 for y in nums2)\n", "class Solution:\n  def numberOfPairs(self, nums1: list[int], nums2: list[int], k: int) -> int:\n    return sum(num1 % (num2 * k) == 0\n               for num1 in nums1\n               for num2 in nums2)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3172, "slug": "second-day-verification", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3147, "slug": "taking-maximum-energy-from-the-mystic-dungeon", "solutions": ["class Solution:\n    def maximumEnergy(self, energy: List[int], k: int) -> int:\n        ans = -inf\n        n = len(energy)\n        for i in range(n - k, n):\n            j, s = i, 0\n            while j >= 0:\n                s += energy[j]\n                ans = max(ans, s)\n                j -= k\n        return ans\n", "class Solution:\n  def maximumEnergy(self, energy: list[int], k: int) -> int:\n    # dp[i] := the sum of energy starting at i\n    dp = energy.copy()\n    for i in range(len(energy) - 1 - k, -1, -1):\n      dp[i] += dp[i + k]\n    return max(dp)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3160, "slug": "find-the-number-of-distinct-colors-among-the-balls", "solutions": ["class Solution:\n    def queryResults(self, limit: int, queries: List[List[int]]) -> List[int]:\n        g = {}\n        cnt = Counter()\n        ans = []\n        for x, y in queries:\n            cnt[y] += 1\n            if x in g:\n                cnt[g[x]] -= 1\n                if cnt[g[x]] == 0:\n                    cnt.pop(g[x])\n            g[x] = y\n            ans.append(len(cnt))\n        return ans\n", "class Solution:\n  def queryResults(self, limit: int, queries: list[list[int]]) -> list[int]:\n    ans = []\n    ballToColor = {}\n    colorCount = collections.Counter()\n\n    for ball, color in queries:\n      if ball in ballToColor:\n        prevColor = ballToColor[ball]\n        colorCount[prevColor] -= 1\n        if colorCount[prevColor] == 0:\n          del colorCount[prevColor]\n      ballToColor[ball] = color\n      colorCount[color] += 1\n      ans.append(len(colorCount))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3153, "slug": "sum-of-digit-differences-of-all-pairs", "solutions": ["class Solution:\n    def sumDigitDifferences(self, nums: List[int]) -> int:\n        n = len(nums)\n        m = int(log10(nums[0])) + 1\n        ans = 0\n        for _ in range(m):\n            cnt = Counter()\n            for i, x in enumerate(nums):\n                nums[i], y = divmod(x, 10)\n                cnt[y] += 1\n            ans += sum(v * (n - v) for v in cnt.values()) // 2\n        return ans\n", "class Solution:\n  def sumDigitDifferences(self, nums: list[int]) -> int:\n    n = len(nums)\n    digitSize = len(str(nums[0]))\n    ans = 0\n\n    denominator = 1\n    for _ in range(digitSize):\n      count = [0] * 10\n      for num in nums:\n        count[num // denominator % 10] += 1\n      ans += sum(freq * (n - freq) for freq in count)\n      denominator *= 10\n\n    return ans // 2\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3174, "slug": "clear-digits", "solutions": ["class Solution:\n    def clearDigits(self, s: str) -> str:\n        stk = []\n        for c in s:\n            if c.isdigit():\n                stk.pop()\n            else:\n                stk.append(c)\n        return \"\".join(stk)\n", "class Solution:\n  def clearDigits(self, s: str) -> str:\n    ans = []\n\n    for c in s:\n      if c.isdigit():\n        # Since `ans` only contains non-digit characters, removing the last\n        # character is equivalent to deleting the closest non-digit character.\n        ans.pop()\n      else:\n        ans.append(c)\n\n    return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3134, "slug": "find-the-median-of-the-uniqueness-array", "solutions": ["class Solution:\n    def medianOfUniquenessArray(self, nums: List[int]) -> int:\n        def check(mx: int) -> bool:\n            cnt = defaultdict(int)\n            k = l = 0\n            for r, x in enumerate(nums):\n                cnt[x] += 1\n                while len(cnt) > mx:\n                    y = nums[l]\n                    cnt[y] -= 1\n                    if cnt[y] == 0:\n                        cnt.pop(y)\n                    l += 1\n                k += r - l + 1\n                if k >= (m + 1) // 2:\n                    return True\n            return False\n\n        n = len(nums)\n        m = (1 + n) * n // 2\n        return bisect_left(range(n), True, key=check)\n", "class Solution:\n  def medianOfUniquenessArray(self, nums: list[int]):\n    n = len(nums)\n    subarrayCount = n * (n + 1) // 2\n    medianCount = (subarrayCount + 1) // 2\n\n    # Similar to 992. Subarrays with K Different Integers\n    def subarraysWithAtMostKDistinct(k: int) -> int:\n      res = 0\n      count = collections.Counter()\n\n      l = 0\n      for r, num in enumerate(nums):\n        count[num] += 1\n        if count[num] == 1:\n          k -= 1\n        while k < 0:\n          count[nums[l]] -= 1\n          if count[nums[l]] == 0:\n            k += 1\n          l += 1\n        res += r - l + 1  # nums[l..r], nums[l + 1..r], ..., nums[r]\n\n      return res\n\n    l = 1\n    r = n\n    return bisect.bisect_left(range(l, r), medianCount,\n                              key=subarraysWithAtMostKDistinct) + l\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3146, "slug": "permutation-difference-between-two-strings", "solutions": ["class Solution:\n    def findPermutationDifference(self, s: str, t: str) -> int:\n        d = {c: i for i, c in enumerate(s)}\n        return sum(abs(d[c] - i) for i, c in enumerate(t))\n", "class Solution:\n  def findPermutationDifference(self, s: str, t: str) -> int:\n    indices = {c: i for i, c in enumerate(s)}\n    return sum([abs(indices[c] - i) for i, c in enumerate(t)])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3177, "slug": "find-the-maximum-length-of-a-good-subsequence-ii", "solutions": ["class Solution:\n    def maximumLength(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        f = [[0] * (k + 1) for _ in range(n)]\n        mp = [defaultdict(int) for _ in range(k + 1)]\n        g = [[0] * 3 for _ in range(k + 1)]\n        ans = 0\n        for i, x in enumerate(nums):\n            for h in range(k + 1):\n                f[i][h] = mp[h][x]\n                if h:\n                    if g[h - 1][0] != nums[i]:\n                        f[i][h] = max(f[i][h], g[h - 1][1])\n                    else:\n                        f[i][h] = max(f[i][h], g[h - 1][2])\n                f[i][h] += 1\n                mp[h][nums[i]] = max(mp[h][nums[i]], f[i][h])\n                if g[h][0] != x:\n                    if f[i][h] >= g[h][1]:\n                        g[h][2] = g[h][1]\n                        g[h][1] = f[i][h]\n                        g[h][0] = x\n                    else:\n                        g[h][2] = max(g[h][2], f[i][h])\n                else:\n                    g[h][1] = max(g[h][1], f[i][h])\n                ans = max(ans, f[i][h])\n        return ans\n", "class Solution:\n  # Same as 3176. Find the Maximum Length of a Good Subsequence I\n  def maximumLength(self, nums: list[int], k: int) -> int:\n    # dp[count][num] := the maximum length of a good subsequence with at most\n    # `count` indices where seq[i] != seq[i + 1] and it ends in `num`.\n    dp = [collections.Counter() for _ in range(k + 1)]\n    # maxLen[count] := the maximum length of a good subsequence with `count`\n    # indices where seq[i] != seq[i + 1]\n    maxLen = [0] * (k + 1)\n\n    for num in nums:\n      for count in range(k, -1, -1):\n        # Append `num` to the subsequence.\n        dp[count][num] += 1\n        if count > 0:\n          dp[count][num] = max(dp[count][num], maxLen[count - 1] + 1)\n        maxLen[count] = max(maxLen[count], dp[count][num])\n\n    return maxLen[k]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3158, "slug": "find-the-xor-of-numbers-which-appear-twice", "solutions": ["class Solution:\n    def duplicateNumbersXOR(self, nums: List[int]) -> int:\n        cnt = Counter(nums)\n        return reduce(xor, [x for x, v in cnt.items() if v == 2], 0)\n", "class Solution:\n  def duplicateNumbersXOR(self, nums):\n    count = collections.Counter(nums)\n    return functools.reduce(\n        operator.xor, [num for num, freq in count.items() if freq == 2],\n        0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3129, "slug": "find-all-possible-stable-binary-arrays-i", "solutions": ["class Solution:\n    def numberOfStableArrays(self, zero: int, one: int, limit: int) -> int:\n        @cache\n        def dfs(i: int, j: int, k: int) -> int:\n            if i == 0:\n                return int(k == 1 and j <= limit)\n            if j == 0:\n                return int(k == 0 and i <= limit)\n            if k == 0:\n                return (\n                    dfs(i - 1, j, 0)\n                    + dfs(i - 1, j, 1)\n                    - (0 if i - limit - 1 < 0 else dfs(i - limit - 1, j, 1))\n                )\n            return (\n                dfs(i, j - 1, 0)\n                + dfs(i, j - 1, 1)\n                - (0 if j - limit - 1 < 0 else dfs(i, j - limit - 1, 0))\n            )\n\n        mod = 10**9 + 7\n        ans = (dfs(zero, one, 0) + dfs(zero, one, 1)) % mod\n        dfs.cache_clear()\n        return ans\n", "class Solution:\n  # Same as 3129. Find All Possible Stable Binary Arrays I\n  def numberOfStableArrays(self, zero: int, one: int, limit: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i][j][k] := the number of stable arrays, where the number of\n    # occurrences of 0 is i and the number of occurrences of 1 is j and the last\n    # number is k (0/1)\n    dp = [[[0] * 2\n           for _ in range(one + 1)]\n          for _ in range(zero + 1)]\n\n    for i in range(min(zero, limit) + 1):\n      dp[i][0][0] = 1\n\n    for j in range(min(one, limit) + 1):\n      dp[0][j][1] = 1\n\n    for i in range(1, zero + 1):\n      for j in range(1, one + 1):\n        dp[i][j][0] = (\n            dp[i - 1][j][0] + dp[i - 1][j][1] -\n            (dp[i - limit - 1][j][1] if i - limit >= 1 else 0) + MOD) % MOD\n        dp[i][j][1] = (\n            dp[i][j - 1][0] + dp[i][j - 1][1] -\n            (dp[i][j - limit - 1][0] if j - limit >= 1 else 0) + MOD) % MOD\n\n    return (dp[zero][one][0] + dp[zero][one][1]) % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3179, "slug": "find-the-n-th-value-after-k-seconds", "solutions": ["class Solution:\n    def valueAfterKSeconds(self, n: int, k: int) -> int:\n        a = [1] * n\n        mod = 10**9 + 7\n        for _ in range(k):\n            for i in range(1, n):\n                a[i] = (a[i] + a[i - 1]) % mod\n        return a[n - 1]\n", "class Solution:\n  def valueAfterKSeconds(self, n: int, k: int) -> int:\n    return math.comb(n + k - 1, n - 1) % 1_000_000_007\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3193, "slug": "count-the-number-of-inversions", "solutions": ["class Solution:\n    def numberOfPermutations(self, n: int, requirements: List[List[int]]) -> int:\n        req = [-1] * n\n        for end, cnt in requirements:\n            req[end] = cnt\n        if req[0] > 0:\n            return 0\n        req[0] = 0\n        mod = 10**9 + 7\n        m = max(req)\n        f = [[0] * (m + 1) for _ in range(n)]\n        f[0][0] = 1\n        for i in range(1, n):\n            l, r = 0, m\n            if req[i] >= 0:\n                l = r = req[i]\n            for j in range(l, r + 1):\n                for k in range(min(i, j) + 1):\n                    f[i][j] = (f[i][j] + f[i - 1][j - k]) % mod\n        return f[n - 1][req[n - 1]]\n", "class Solution:\n  def numberOfPermutations(self, n: int, requirements: list[list[int]]) -> int:\n    MOD = 1_000_000_007\n    MAX_INVERSIONS = 400\n    # dp[i][j] := the number of ways to arrange the first i numbers of the\n    # permutation s.t. there are j inversions\n    dp = [[0] * (MAX_INVERSIONS + 1) for _ in range(n + 1)]\n    endToCnt = {end + 1: cnt for end, cnt in requirements}\n\n    # There's only one way to arrange a single number with zero inversions.\n    dp[1][0] = 1\n\n    for i in range(2, n + 1):\n      for newInversions in range(i):\n        for j in range(MAX_INVERSIONS - newInversions + 1):\n          inversionsAfterInsertion = j + newInversions\n          if i in endToCnt and inversionsAfterInsertion != endToCnt[i]:\n            continue\n          dp[i][inversionsAfterInsertion] += dp[i - 1][j]\n          dp[i][inversionsAfterInsertion] %= MOD\n\n    return dp[n][endToCnt[n]]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3135, "slug": "equalize-strings-by-adding-or-removing-characters-at-ends", "solutions": ["class Solution:\n    def minOperations(self, initial: str, target: str) -> int:\n        m, n = len(initial), len(target)\n        f = [[0] * (n + 1) for _ in range(m + 1)]\n        mx = 0\n        for i, a in enumerate(initial, 1):\n            for j, b in enumerate(target, 1):\n                if a == b:\n                    f[i][j] = f[i - 1][j - 1] + 1\n                    mx = max(mx, f[i][j])\n        return m + n - mx * 2\n", "class Solution:\n  def minOperations(self, initial: str, target: str) -> int:\n    m = len(initial)\n    n = len(target)\n    # dp[i][j] := the length of LCS(initial[0..i), target[0..j))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        if initial[i - 1] == target[j - 1]:\n          dp[i][j] = 1 + dp[i - 1][j - 1]\n\n    return m + n - 2 * max(map(max, dp))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3137, "slug": "minimum-number-of-operations-to-make-word-k-periodic", "solutions": ["class Solution:\n    def minimumOperationsToMakeKPeriodic(self, word: str, k: int) -> int:\n        n = len(word)\n        return n // k - max(Counter(word[i : i + k] for i in range(0, n, k)).values())\n", "class Solution:\n  def minimumOperationsToMakeKPeriodic(self, word: str, k: int) -> int:\n    count = collections.Counter(word[i:i + k] for i in range(0, len(word), k))\n    return len(word) // k - max(count.values())\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3169, "slug": "count-days-without-meetings", "solutions": ["class Solution:\n    def countDays(self, days: int, meetings: List[List[int]]) -> int:\n        meetings.sort()\n        ans = last = 0\n        for st, ed in meetings:\n            if last < st:\n                ans += st - last - 1\n            last = max(last, ed)\n        ans += days - last\n        return ans\n", "class Solution:\n  def countDays(self, days: int, meetings: list[list[int]]) -> int:\n    freeDays = 0\n    prevEnd = 0\n\n    for start, end in sorted(meetings):\n      if start > prevEnd:\n        freeDays += start - prevEnd - 1\n      prevEnd = max(prevEnd, end)\n\n    return freeDays + max(0, days - prevEnd)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3121, "slug": "count-the-number-of-special-characters-ii", "solutions": ["class Solution:\n    def numberOfSpecialChars(self, word: str) -> int:\n        first, last = {}, {}\n        for i, c in enumerate(word):\n            if c not in first:\n                first[c] = i\n            last[c] = i\n        return sum(\n            a in last and b in first and last[a] < first[b]\n            for a, b in zip(ascii_lowercase, ascii_uppercase)\n        )\n", "class Solution:\n  def numberOfSpecialChars(self, word: str) -> int:\n    lower = collections.defaultdict(bool)\n    upper = collections.defaultdict(bool)\n\n    for c in word:\n      if c.islower():\n        lower[c] = not upper[c.upper()]\n      else:\n        upper[c] = True\n\n    return sum(lower[a] and upper[b]\n               for a, b in zip(string.ascii_lowercase,\n                               string.ascii_uppercase))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3105, "slug": "longest-strictly-increasing-or-strictly-decreasing-subarray", "solutions": ["class Solution:\n    def longestMonotonicSubarray(self, nums: List[int]) -> int:\n        ans = t = 1\n        for i, x in enumerate(nums[1:]):\n            if nums[i] < x:\n                t += 1\n                ans = max(ans, t)\n            else:\n                t = 1\n        t = 1\n        for i, x in enumerate(nums[1:]):\n            if nums[i] > x:\n                t += 1\n                ans = max(ans, t)\n            else:\n                t = 1\n        return ans\n", "class Solution:\n  # Similar to 978. Longest Turbulent Subarray\n  def longestMonotonicSubarray(self, nums: list[int]) -> int:\n    ans = 1\n    increasing = 1\n    decreasing = 1\n\n    for i in range(1, len(nums)):\n      if nums[i] > nums[i - 1]:\n        increasing += 1\n        decreasing = 1\n      elif nums[i] < nums[i - 1]:\n        decreasing += 1\n        increasing = 1\n      else:\n        increasing = 1\n        decreasing = 1\n      ans = max(ans, increasing, decreasing)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3127, "slug": "make-a-square-with-the-same-color", "solutions": ["class Solution:\n    def canMakeSquare(self, grid: List[List[str]]) -> bool:\n        for i in range(0, 2):\n            for j in range(0, 2):\n                cnt1 = cnt2 = 0\n                for a, b in pairwise((0, 0, 1, 1, 0)):\n                    x, y = i + a, j + b\n                    cnt1 += grid[x][y] == \"W\"\n                    cnt2 += grid[x][y] == \"B\"\n                if cnt1 != cnt2:\n                    return True\n        return False\n", "class Solution:\n  def canMakeSquare(self, grid: list[list[str]]) -> bool:\n    for i in range(2):\n      for j in range(2):\n        black = 0\n        white = 0\n        for x in range(2):\n          for y in range(2):\n            if grid[i + x][j + y] == 'B':\n              black += 1\n            else:\n              white += 1\n        if black >= 3 or white >= 3:\n          return True\n    return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3181, "slug": "maximum-total-reward-using-operations-ii", "solutions": ["class Solution:\n    def maxTotalReward(self, rewardValues: List[int]) -> int:\n        nums = sorted(set(rewardValues))\n        f = 1\n        for v in nums:\n            f |= (f & ((1 << v) - 1)) << v\n        return f.bit_length() - 1\n", "class Solution:\n  # Same as 3180. Maximum Total Reward Using Operations I\n  def maxTotalReward(self, rewardValues: list[int]) -> int:\n    dp = 1  # the possible rewards (initially, 0 is achievable)\n\n    for num in sorted(rewardValues):\n      # Remove the numbers >= the current number.\n      smallerNums = dp & ((1 << num) - 1)\n      dp |= smallerNums << num\n\n    return dp.bit_length() - 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3167, "slug": "better-compression-of-string", "solutions": ["class Solution:\n    def betterCompression(self, compressed: str) -> str:\n        cnt = Counter()\n        i, n = 0, len(compressed)\n        while i < n:\n            j = i + 1\n            x = 0\n            while j < n and compressed[j].isdigit():\n                x = x * 10 + int(compressed[j])\n                j += 1\n            cnt[compressed[i]] += x\n            i = j\n        return \"\".join(sorted(f\"{k}{v}\" for k, v in cnt.items()))\n", "class Solution:\n  def betterCompression(self, compressed: str) -> str:\n    count = collections.Counter()\n    i = 0\n\n    while i < len(compressed):\n      c = compressed[i]\n      i += 1\n      freq = 0\n      while i < len(compressed) and compressed[i].isdigit():\n        freq = freq * 10 + int(compressed[i])\n        i += 1\n      count[c] += freq\n\n    return ''.join([c + str(count[c])\n                    for c in sorted(count.keys())])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3159, "slug": "find-occurrences-of-an-element-in-an-array", "solutions": ["class Solution:\n    def occurrencesOfElement(\n        self, nums: List[int], queries: List[int], x: int\n    ) -> List[int]:\n        ids = [i for i, v in enumerate(nums) if v == x]\n        return [ids[i - 1] if i - 1 < len(ids) else -1 for i in queries]\n", "class Solution:\n  def occurrencesOfElement(\n      self,\n      nums: list[int],\n      queries: list[int],\n      x: int,\n  ) -> list[int]:\n    indices = [i for i, num in enumerate(nums) if num == x]\n    return [indices[query - 1] if query <= len(indices) else -1\n            for query in queries]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3142, "slug": "check-if-grid-satisfies-conditions", "solutions": ["class Solution:\n    def satisfiesConditions(self, grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        for i, row in enumerate(grid):\n            for j, x in enumerate(row):\n                if i + 1 < m and x != grid[i + 1][j]:\n                    return False\n                if j + 1 < n and x == grid[i][j + 1]:\n                    return False\n        return True\n", "class Solution:\n  def satisfiesConditions(self, grid: list[list[int]]) -> bool:\n    m = len(grid)\n    n = len(grid[0])\n    return (all(grid[i][j] == grid[i + 1][j]\n                for i in range(m - 1)\n                for j in range(n)) and\n            all(grid[i][j] != grid[i][j + 1]\n                for i in range(m)\n                for j in range(n - 1)))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3195, "slug": "find-the-minimum-area-to-cover-all-ones-i", "solutions": ["class Solution:\n    def minimumArea(self, grid: List[List[int]]) -> int:\n        x1 = y1 = inf\n        x2 = y2 = -inf\n        for i, row in enumerate(grid):\n            for j, x in enumerate(row):\n                if x == 1:\n                    x1 = min(x1, i)\n                    y1 = min(y1, j)\n                    x2 = max(x2, i)\n                    y2 = max(y2, j)\n        return (x2 - x1 + 1) * (y2 - y1 + 1)\n", "class Solution:\n  def minimumArea(self, grid: list[list[int]]) -> int:\n    x1 = math.inf\n    y1 = math.inf\n    x2 = 0\n    y2 = 0\n\n    for i, row in enumerate(grid):\n      for j, num in enumerate(row):\n        if num == 1:\n          x1 = min(x1, i)\n          y1 = min(y1, j)\n          x2 = max(x2, i)\n          y2 = max(y2, j)\n\n    return (x2 - x1 + 1) * (y2 - y1 + 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3188, "slug": "find-top-scoring-students-ii", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3191, "slug": "minimum-operations-to-make-binary-array-elements-equal-to-one-i", "solutions": ["class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        for i, x in enumerate(nums):\n            if x == 0:\n                if i + 2 >= len(nums):\n                    return -1\n                nums[i + 1] ^= 1\n                nums[i + 2] ^= 1\n                ans += 1\n        return ans\n", "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    ans = 0\n\n    for i in range(len(nums) - 2):\n      if nums[i] == 0:\n        nums[i + 1] ^= 1\n        nums[i + 2] ^= 1\n        ans += 1\n\n    return -1 if nums[-1] == 0 or nums[-2] == 0 else ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3107, "slug": "minimum-operations-to-make-median-of-array-equal-to-k", "solutions": ["class Solution:\n    def minOperationsToMakeMedianK(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        n = len(nums)\n        m = n >> 1\n        ans = abs(nums[m] - k)\n        if nums[m] > k:\n            for i in range(m - 1, -1, -1):\n                if nums[i] <= k:\n                    break\n                ans += nums[i] - k\n        else:\n            for i in range(m + 1, n):\n                if nums[i] >= k:\n                    break\n                ans += k - nums[i]\n        return ans\n", "class Solution:\n  def minOperationsToMakeMedianK(self, nums: list[int], k: int) -> int:\n    n = len(nums)\n    ans = 0\n\n    nums.sort()\n\n    for i in range(n // 2 + 1):\n      ans += max(0, nums[i] - k)\n\n    for i in range(n // 2, n):\n      ans += max(0, k - nums[i])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3140, "slug": "consecutive-available-seats-ii", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3100, "slug": "water-bottles-ii", "solutions": ["class Solution:\n    def maxBottlesDrunk(self, numBottles: int, numExchange: int) -> int:\n        ans = numBottles\n        while numBottles >= numExchange:\n            numBottles -= numExchange\n            numExchange += 1\n            ans += 1\n            numBottles += 1\n        return ans\n", "class Solution:\n  def maxBottlesDrunk(self, numBottles: int, numExchange: int) -> int:\n    ans = numBottles\n\n    while numBottles >= numExchange:\n      numBottles = numBottles - numExchange + 1\n      numExchange += 1\n      ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3125, "slug": "maximum-number-that-makes-result-of-bitwise-and-zero", "solutions": ["class Solution:\n    def maxNumber(self, n: int) -> int:\n        return (1 << (n.bit_length() - 1)) - 1\n", "class Solution:\n  def maxNumber(self, n: int) -> int:\n    # assume n = 0b00...11???\n    #        x = 0b00...01111\n    #  since y = 0b00...10000 is in [x, n]\n    #    and x & y = 0\n    return (1 << n.bit_length() - 1) - 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3114, "slug": "latest-time-you-can-obtain-after-replacing-characters", "solutions": ["class Solution:\n    def findLatestTime(self, s: str) -> str:\n        for h in range(11, -1, -1):\n            for m in range(59, -1, -1):\n                t = f\"{h:02d}:{m:02d}\"\n                if all(a == b for a, b in zip(s, t) if a != \"?\"):\n                    return t\n", "class Solution:\n  # Similar to 1736. Latest Time by Replacing Hidden Digits\n  def findLatestTime(self, s: str) -> str:\n    ans = list(s)\n    if s[0] == '?':\n      ans[0] = '1' if s[1] == '?' or s[1] < '2' else '0'\n    if s[1] == '?':\n      ans[1] = '1' if ans[0] == '1' else '9'\n    if s[3] == '?':\n      ans[3] = '5'\n    if s[4] == '?':\n      ans[4] = '9'\n    return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3170, "slug": "lexicographically-minimum-string-after-removing-stars", "solutions": ["class Solution:\n    def clearStars(self, s: str) -> str:\n        g = defaultdict(list)\n        n = len(s)\n        rem = [False] * n\n        for i, c in enumerate(s):\n            if c == \"*\":\n                rem[i] = True\n                for a in ascii_lowercase:\n                    if g[a]:\n                        rem[g[a].pop()] = True\n                        break\n            else:\n                g[c].append(i)\n        return \"\".join(c for i, c in enumerate(s) if not rem[i])\n", "class Solution:\n  def clearStars(self, s: str) -> str:\n    ans = list(s)\n    buckets = [[] for _ in range(26)]\n\n    for i, c in enumerate(s):\n      if c == '*':\n        ans[i] = ''\n        j = next(j for j, bucket in enumerate(buckets) if bucket)\n        ans[buckets[j].pop()] = ''\n      else:\n        buckets[ord(c) - ord('a')].append(i)\n\n    return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3166, "slug": "calculate-parking-fees-and-duration", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3132, "slug": "find-the-integer-added-to-array-ii", "solutions": ["class Solution:\n    def minimumAddedInteger(self, nums1: List[int], nums2: List[int]) -> int:\n        def f(x: int) -> bool:\n            i = j = cnt = 0\n            while i < len(nums1) and j < len(nums2):\n                if nums2[j] - nums1[i] != x:\n                    cnt += 1\n                else:\n                    j += 1\n                i += 1\n            return cnt <= 2\n\n        nums1.sort()\n        nums2.sort()\n        ans = inf\n        for i in range(3):\n            x = nums2[0] - nums1[i]\n            if f(x):\n                ans = min(ans, x)\n        return ans\n", "class Solution:\n  def minimumAddedInteger(self, nums1: list[int], nums2: list[int]) -> int:\n    # After removing two elements from nums1, either nums1[0], nums1[1], or\n    # nums1[2] will persist. Therefore, the difference between nums1 (with two\n    # elements removed) and nums2 is represented by nums2[0] - nums1[i], where\n    # 0 <= i <= 2.\n    ans = math.inf\n\n    nums1.sort()\n    nums2.sort()\n\n    for i in range(3):\n      inc = nums2[0] - nums1[i]\n      if self._isValidDiff(nums1, nums2, inc):\n        ans = min(ans, inc)\n\n    return ans\n\n  def _isValidDiff(self, nums1: list[int], nums2: list[int], inc: int) -> bool:\n    \"\"\"\n    Returns True if it's possible to increase nums1 (with two elements removed)\n    by `inc` to nums2.\n    \"\"\"\n    removed = 0\n    i = 0  # nums2's index\n\n    for num in nums1:\n      if num + inc == nums2[i]:\n        i += 1\n        if i == len(nums2):\n          break\n      else:\n        removed += 1\n\n    return removed <= 2\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3185, "slug": "count-pairs-that-form-a-complete-day-ii", "solutions": ["class Solution:\n    def countCompleteDayPairs(self, hours: List[int]) -> int:\n        cnt = Counter()\n        ans = 0\n        for x in hours:\n            ans += cnt[(24 - (x % 24)) % 24]\n            cnt[x % 24] += 1\n        return ans\n", "class Solution:\n  # Same as 3184. Count Pairs That Form a Complete Day I\n  def countCompleteDayPairs(self, hours: list[int]) -> int:\n    ans = 0\n    count = [0] * 24\n\n    for hour in hours:\n      ans += count[(24 - hour % 24) % 24]\n      count[hour % 24] += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3101, "slug": "count-alternating-subarrays", "solutions": ["class Solution:\n    def countAlternatingSubarrays(self, nums: List[int]) -> int:\n        ans = s = 1\n        for a, b in pairwise(nums):\n            s = s + 1 if a != b else 1\n            ans += s\n        return ans\n", "class Solution:\n  def countAlternatingSubarrays(self, nums: list[int]) -> int:\n    # dp[i] := the number of alternating subarrays ending in index i\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n      if nums[i] != nums[i - 1]:\n        dp[i] += dp[i - 1]\n\n    return sum(dp)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3156, "slug": "employee-task-duration-and-concurrent-tasks", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3117, "slug": "minimum-sum-of-values-by-dividing-array", "solutions": ["class Solution:\n    def minimumValueSum(self, nums: List[int], andValues: List[int]) -> int:\n        @cache\n        def dfs(i: int, j: int, a: int) -> int:\n            if n - i < m - j:\n                return inf\n            if j == m:\n                return 0 if i == n else inf\n            a &= nums[i]\n            if a < andValues[j]:\n                return inf\n            ans = dfs(i + 1, j, a)\n            if a == andValues[j]:\n                ans = min(ans, dfs(i + 1, j + 1, -1) + nums[i])\n            return ans\n\n        n, m = len(nums), len(andValues)\n        ans = dfs(0, 0, -1)\n        return ans if ans < inf else -1\n", "class Solution:\n  def minimumValueSum(self, nums: list[int], andValues: list[int]) -> int:\n    n = len(nums)\n    m = len(andValues)\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, mask: int) -> int:\n      \"\"\"\n      Returns the minimum value sum of nums[i..n) and andValues[j..m), where\n      `mask` is the running value of the current subarray.\n      \"\"\"\n      if i == n and j == m:\n        return 0\n      if i == n or j == m:\n        return math.inf\n      mask &= nums[i]\n      if mask < andValues[j]:\n        return math.inf\n      if mask == andValues[j]:\n        # 1. Keep going.\n        # 2. End the subarray here and pick nums[i], then fresh start.\n        return min(dp(i + 1, j, mask),\n                   nums[i] + dp(i + 1, j + 1, -1))\n      return dp(i + 1, j, mask)  # Keep going.\n\n    ans = dp(0, 0, -1)\n    return ans if ans < math.inf else -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3149, "slug": "find-the-minimum-cost-array-permutation", "solutions": ["class Solution:\n    def findPermutation(self, nums: List[int]) -> List[int]:\n        @cache\n        def dfs(mask: int, pre: int) -> int:\n            if mask == (1 << n) - 1:\n                return abs(pre - nums[0])\n            res = inf\n            for cur in range(1, n):\n                if mask >> cur & 1 ^ 1:\n                    res = min(res, abs(pre - nums[cur]) + dfs(mask | 1 << cur, cur))\n            return res\n\n        def g(mask: int, pre: int):\n            ans.append(pre)\n            if mask == (1 << n) - 1:\n                return\n            res = dfs(mask, pre)\n            for cur in range(1, n):\n                if mask >> cur & 1 ^ 1:\n                    if abs(pre - nums[cur]) + dfs(mask | 1 << cur, cur) == res:\n                        g(mask | 1 << cur, cur)\n                        break\n\n        n = len(nums)\n        ans = []\n        g(1, 0)\n        return ans\n", "class Solution:\n  def findPermutation(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n    bestPick = [[0] * (1 << n) for _ in range(n)]\n\n    @functools.lru_cache(None)\n    def getScore(last: int, mask: int) -> int:\n      if mask.bit_count() == len(nums):\n        return abs(last - nums[0])\n\n      minScore = math.inf\n      for i in range(1, len(nums)):\n        if mask >> i & 1:\n          continue\n        nextMinScore = abs(last - nums[i]) + getScore(i, mask | (1 << i))\n        if nextMinScore < minScore:\n          minScore = nextMinScore\n          bestPick[last][mask] = i\n\n      return minScore\n\n    getScore(0, 1)\n    return self._construct(bestPick)\n\n  def _construct(self, bestPick: list[list[int]]) -> list[int]:\n    ans = []\n    last = 0\n    mask = 1\n    for _ in range(len(bestPick)):\n      ans.append(last)\n      last = bestPick[last][mask]\n      mask |= 1 << last\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3139, "slug": "minimum-cost-to-equalize-array", "solutions": ["class Solution:\n  def minCostToEqualizeArray(\n      self,\n      nums: list[int],\n      cost1: int,\n      cost2: int,\n  ) -> int:\n    MOD = 1_000_000_007\n    n = len(nums)\n    minNum = min(nums)\n    maxNum = max(nums)\n    summ = sum(nums)\n\n    if cost1 * 2 <= cost2 or n < 3:\n      totalGap = maxNum * n - summ\n      return (cost1 * totalGap) % MOD\n\n    def getMinCost(target: int) -> int:\n      \"\"\"Returns the minimum cost to make all numbers equal to `target`.\"\"\"\n      maxGap = target - minNum\n      totalGap = target * n - summ\n      # Pair one shallowest number with one non-shallowest number, so the worst\n      # case is that we have `totalGap - maxGap` non-shallowest numbers to pair.\n      pairs = min(totalGap // 2, totalGap - maxGap)\n      return cost1 * (totalGap - 2 * pairs) + cost2 * pairs\n\n    return min(getMinCost(target)\n               for target in range(maxNum, 2 * maxNum)) % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3118, "slug": "friday-purchase-iii", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3130, "slug": "find-all-possible-stable-binary-arrays-ii", "solutions": ["class Solution:\n    def numberOfStableArrays(self, zero: int, one: int, limit: int) -> int:\n        @cache\n        def dfs(i: int, j: int, k: int) -> int:\n            if i == 0:\n                return int(k == 1 and j <= limit)\n            if j == 0:\n                return int(k == 0 and i <= limit)\n            if k == 0:\n                return (\n                    dfs(i - 1, j, 0)\n                    + dfs(i - 1, j, 1)\n                    - (0 if i - limit - 1 < 0 else dfs(i - limit - 1, j, 1))\n                )\n            return (\n                dfs(i, j - 1, 0)\n                + dfs(i, j - 1, 1)\n                - (0 if j - limit - 1 < 0 else dfs(i, j - limit - 1, 0))\n            )\n\n        mod = 10**9 + 7\n        ans = (dfs(zero, one, 0) + dfs(zero, one, 1)) % mod\n        dfs.cache_clear()\n        return ans\n", "class Solution:\n  # Same as 3129. Find All Possible Stable Binary Arrays I\n  def numberOfStableArrays(self, zero: int, one: int, limit: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i][j][k] := the number of stable arrays, where the number of\n    # occurrences of 0 is i and the number of occurrences of 1 is j and the last\n    # number is k (0/1)\n    dp = [[[0] * 2\n          for _ in range(one + 1)]\n          for _ in range(zero + 1)]\n\n    for i in range(min(zero, limit) + 1):\n      dp[i][0][0] = 1\n\n    for j in range(min(one, limit) + 1):\n      dp[0][j][1] = 1\n\n    for i in range(1, zero + 1):\n      for j in range(1, one + 1):\n        dp[i][j][0] = (\n            dp[i - 1][j][0] + dp[i - 1][j][1] -\n            (dp[i - limit - 1][j][1] if i - limit >= 1 else 0) + MOD) % MOD\n        dp[i][j][1] = (\n            dp[i][j - 1][0] + dp[i][j - 1][1] -\n            (dp[i][j - limit - 1][0] if j - limit >= 1 else 0) + MOD) % MOD\n\n    return (dp[zero][one][0] + dp[zero][one][1]) % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3109, "slug": "find-the-index-of-permutation", "solutions": ["class BinaryIndexedTree:\n    __slots__ = \"n\", \"c\"\n\n    def __init__(self, n: int):\n        self.n = n\n        self.c = [0] * (n + 1)\n\n    def update(self, x: int, delta: int) -> None:\n        while x <= self.n:\n            self.c[x] += delta\n            x += x & -x\n\n    def query(self, x: int) -> int:\n        s = 0\n        while x:\n            s += self.c[x]\n            x -= x & -x\n        return s\n\n\nclass Solution:\n    def getPermutationIndex(self, perm: List[int]) -> int:\n        mod = 10**9 + 7\n        ans, n = 0, len(perm)\n        tree = BinaryIndexedTree(n + 1)\n        f = [1] * n\n        for i in range(1, n):\n            f[i] = f[i - 1] * i % mod\n        for i, x in enumerate(perm):\n            cnt = x - 1 - tree.query(x)\n            ans += cnt * f[n - i - 1] % mod\n            tree.update(x, 1)\n        return ans % mod\n", "class FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def add(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def getPermutationIndex(self, perm: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(perm)\n    ans = 0\n    tree = FenwickTree(n)\n    fact = [1] * (n + 1)  # fact[i] := i!\n\n    for i in range(2, n + 1):\n      fact[i] = (fact[i - 1] * i) % MOD\n\n    for i, num in enumerate(perm):\n      # the number of unused numbers less than `num`\n      unusedNums = num - 1 - tree.get(num - 1)\n      suffixLength = fact[n - 1 - i]\n      ans += unusedNums * suffixLength\n      ans %= MOD\n      tree.add(num, 1)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3138, "slug": "minimum-length-of-anagram-concatenation", "solutions": ["class Solution:\n    def minAnagramLength(self, s: str) -> int:\n        def check(k: int) -> bool:\n            for i in range(0, n, k):\n                cnt1 = Counter(s[i : i + k])\n                for c, v in cnt.items():\n                    if cnt1[c] * (n // k) != v:\n                        return False\n            return True\n\n        cnt = Counter(s)\n        n = len(s)\n        for i in range(1, n + 1):\n            if n % i == 0 and check(i):\n                return i\n", "class Solution:\n  def minAnagramLength(self, s: str) -> int:\n    n = len(s)\n    for k in range(1, n + 1):\n      if n % k == 0 and self._canFormAnagram(s, k):\n        return k\n    return n\n\n  def _canFormAnagram(self, s: str, k: int) -> bool:\n    \"\"\"Returns True if we can concatenate an anagram of length k to s.\"\"\"\n    anagramCount = collections.Counter(s[:k])\n    return all(collections.Counter(s[i:i + k]) == anagramCount\n               for i in range(k, len(s), k))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3168, "slug": "minimum-number-of-chairs-in-a-waiting-room", "solutions": ["class Solution:\n    def minimumChairs(self, s: str) -> int:\n        cnt = left = 0\n        for c in s:\n            if c == \"E\":\n                if left:\n                    left -= 1\n                else:\n                    cnt += 1\n            else:\n                left += 1\n        return cnt\n", "class Solution:\n  def minimumChairs(self, s: str) -> int:\n    ans = 0\n    chairs = 0\n\n    for c in s:\n      chairs += 1 if c == 'E' else -1\n      ans = max(ans, chairs)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3131, "slug": "find-the-integer-added-to-array-i", "solutions": ["class Solution:\n    def addedInteger(self, nums1: List[int], nums2: List[int]) -> int:\n        return min(nums2) - min(nums1)\n", "class Solution:\n  def addedInteger(self, nums1: list[int], nums2: list[int]) -> int:\n    return min(nums2) - min(nums1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3152, "slug": "special-array-ii", "solutions": ["class Solution:\n    def isArraySpecial(self, nums: List[int], queries: List[List[int]]) -> List[bool]:\n        n = len(nums)\n        d = list(range(n))\n        for i in range(1, n):\n            if nums[i] % 2 != nums[i - 1] % 2:\n                d[i] = d[i - 1]\n        return [d[t] <= f for f, t in queries]\n", "class Solution:\n  def isArraySpecial(\n      self,\n      nums: list[int],\n      queries: list[list[int]],\n  ) -> list[bool]:\n    ans = []\n    id = 0\n    # parityIds[i] := the id of the parity group that nums[i] belongs to\n    parityIds = [id]\n\n    for a, b in itertools.pairwise(nums):\n      if a % 2 == b % 2:\n        id += 1\n      parityIds.append(id)\n\n    for _from, to in queries:\n      ans.append(parityIds[_from] == parityIds[to])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3190, "slug": "find-minimum-operations-to-make-all-elements-divisible-by-three", "solutions": ["class Solution:\n    def minimumOperations(self, nums: List[int]) -> int:\n        ans = 0\n        for x in nums:\n            if mod := x % 3:\n                ans += min(mod, 3 - mod)\n        return ans\n", "class Solution:\n  def minimumOperations(self, nums: list[int]) -> int:\n    return sum(num % 3 != 0 for num in nums)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3154, "slug": "find-number-of-ways-to-reach-the-k-th-stair", "solutions": ["class Solution:\n    def waysToReachStair(self, k: int) -> int:\n        @cache\n        def dfs(i: int, j: int, jump: int) -> int:\n            if i > k + 1:\n                return 0\n            ans = int(i == k)\n            if i > 0 and j == 0:\n                ans += dfs(i - 1, 1, jump)\n            ans += dfs(i + (1 << jump), 0, jump + 1)\n            return ans\n\n        return dfs(1, 0, 0)\n", "class Solution:\n  def waysToReachStair(self, k: int) -> int:\n    # Let's say we have `down` operation 1 and `jump` operation 2.\n    # The final stair is 1 + (2^0 + 2^1 + ... + 2^(jump - 1)) - down = k.\n    # => 1 + (2^jump - 1) - down = k.\n    # => down = 2^jump - k.\n    # Since `down` operations cannot be used consecutively, there're jump + 1\n    # positions (before and after each `jump`) for  `down`. The maximum jump is\n    # 29, as it satisfies the condition down = 2^jump - k <= jump + 1, with k\n    # being the maximum value of 10^9.\n    MAX_JUMP = 29\n    ans = 0\n\n    for jump in range(MAX_JUMP + 1):\n      down = (1 << jump) - k\n      if down < 0 or down > jump + 1:\n        continue\n      ans += math.comb(jump + 1, down)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3194, "slug": "minimum-average-of-smallest-and-largest-elements", "solutions": ["class Solution:\n    def minimumAverage(self, nums: List[int]) -> float:\n        nums.sort()\n        n = len(nums)\n        return min(nums[i] + nums[-i - 1] for i in range(n // 2)) / 2\n", "class Solution:\n  def minimumAverage(self, nums: list[int]) -> float:\n    nums.sort()\n    return min((nums[i] + nums[~i]) / 2\n               for i in range(len(nums) // 2 + 1))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3102, "slug": "minimize-manhattan-distances", "solutions": ["class Solution:\n    def minimumDistance(self, points: List[List[int]]) -> int:\n        sl1 = SortedList()\n        sl2 = SortedList()\n        for x, y in points:\n            sl1.add(x + y)\n            sl2.add(x - y)\n        ans = inf\n        for x, y in points:\n            sl1.remove(x + y)\n            sl2.remove(x - y)\n            ans = min(ans, max(sl1[-1] - sl1[0], sl2[-1] - sl2[0]))\n            sl1.add(x + y)\n            sl2.add(x - y)\n        return ans\n", "class Solution:\n  def minimumDistance(self, points: list[list[int]]) -> int:\n    i, j = self._maxManhattanDistance(points, -1)\n    xi, yi = self._maxManhattanDistance(points, i)\n    xj, yj = self._maxManhattanDistance(points, j)\n    return min(self._manhattan(points, xi, yi),\n               self._manhattan(points, xj, yj))\n\n  def _maxManhattanDistance(\n      self,\n      points: list[list[int]],\n      excludedIndex: int,\n  ) -> int:\n    minSum = math.inf\n    maxSum = -math.inf\n    minDiff = math.inf\n    maxDiff = -math.inf\n    minSumIndex = -1\n    maxSumIndex = -1\n    minDiffIndex = -1\n    maxDiffIndex = -1\n\n    for i, (x, y) in enumerate(points):\n      if i == excludedIndex:\n        continue\n      summ = x + y\n      diff = x - y\n      if summ < minSum:\n        minSum = summ\n        minSumIndex = i\n      if summ > maxSum:\n        maxSum = summ\n        maxSumIndex = i\n      if diff < minDiff:\n        minDiff = diff\n        minDiffIndex = i\n      if diff > maxDiff:\n        maxDiff = diff\n        maxDiffIndex = i\n\n    return ([minSumIndex, maxSumIndex] if maxSum - minSum >= maxDiff - minDiff\n            else [minDiffIndex, maxDiffIndex])\n\n  def _manhattan(self, points: list[list[int]], i: int, j: int) -> int:\n    return abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3173, "slug": "bitwise-or-of-adjacent-elements", "solutions": ["class Solution:\n    def orArray(self, nums: List[int]) -> List[int]:\n        return [a | b for a, b in pairwise(nums)]\n", "class Solution:\n  def orArray(self, nums: list[int]) -> list[int]:\n    return [a | b for a, b in itertools.pairwise(nums)]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3175, "slug": "find-the-first-player-to-win-k-games-in-a-row", "solutions": ["class Solution:\n    def findWinningPlayer(self, skills: List[int], k: int) -> int:\n        n = len(skills)\n        k = min(k, n - 1)\n        i = cnt = 0\n        for j in range(1, n):\n            if skills[i] < skills[j]:\n                i = j\n                cnt = 1\n            else:\n                cnt += 1\n            if cnt == k:\n                break\n        return i\n", "class Solution:\n  # Similar to 1535. Find the Winner of an Array Game\n  def findWinningPlayer(self, skills: list[int], k: int) -> int:\n    ans = 0\n    wins = 0\n\n    i = 1\n    while i < len(skills) and wins < k:\n      if skills[i] > skills[ans]:\n        ans = i\n        wins = 1\n      else:\n        wins += 1\n      i += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3163, "slug": "string-compression-iii", "solutions": ["class Solution:\n    def compressedString(self, word: str) -> str:\n        g = groupby(word)\n        ans = []\n        for c, v in g:\n            k = len(list(v))\n            while k:\n                x = min(9, k)\n                ans.append(str(x) + c)\n                k -= x\n        return \"\".join(ans)\n", "class Solution:\n  def compressedString(self, word: str) -> str:\n    n = len(word)\n    ans = []\n    i = 0\n    j = 0\n\n    while i < n:\n      count = 0\n      while j < n and word[j] == word[i] and count < 9:\n        j += 1\n        count += 1\n      ans.append(str(count) + word[i])\n      i = j\n\n    return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3115, "slug": "maximum-prime-difference", "solutions": ["class Solution:\n    def maximumPrimeDifference(self, nums: List[int]) -> int:\n        def is_prime(x: int) -> bool:\n            if x < 2:\n                return False\n            return all(x % i for i in range(2, int(sqrt(x)) + 1))\n\n        for i, x in enumerate(nums):\n            if is_prime(x):\n                for j in range(len(nums) - 1, i - 1, -1):\n                    if is_prime(nums[j]):\n                        return j - i\n", "class Solution:\n  def maximumPrimeDifference(self, nums: list[int]) -> int:\n    MAX = 100\n    isPrime = self._sieveEratosthenes(MAX + 1)\n    minPrimeIndex = -1\n    maxPrimeIndex = -1\n\n    for i, num in enumerate(nums):\n      if isPrime[num]:\n        if minPrimeIndex == -1:\n          minPrimeIndex = i\n        maxPrimeIndex = i\n\n    return maxPrimeIndex - minPrimeIndex\n\n  def _sieveEratosthenes(self, n: int) -> list[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3187, "slug": "peaks-in-array", "solutions": ["class BinaryIndexedTree:\n    __slots__ = \"n\", \"c\"\n\n    def __init__(self, n: int):\n        self.n = n\n        self.c = [0] * (n + 1)\n\n    def update(self, x: int, delta: int) -> None:\n        while x <= self.n:\n            self.c[x] += delta\n            x += x & -x\n\n    def query(self, x: int) -> int:\n        s = 0\n        while x:\n            s += self.c[x]\n            x -= x & -x\n        return s\n\n\nclass Solution:\n    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        def update(i: int, val: int):\n            if i <= 0 or i >= n - 1:\n                return\n            if nums[i - 1] < nums[i] and nums[i] > nums[i + 1]:\n                tree.update(i, val)\n\n        n = len(nums)\n        tree = BinaryIndexedTree(n - 1)\n        for i in range(1, n - 1):\n            update(i, 1)\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                l, r = q[1] + 1, q[2] - 1\n                ans.append(0 if l > r else tree.query(r) - tree.query(l - 1))\n            else:\n                idx, val = q[1:]\n                for i in range(idx - 1, idx + 2):\n                    update(i, -1)\n                nums[idx] = val\n                for i in range(idx - 1, idx + 2):\n                    update(i, 1)\n        return ans\n", "class FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def add(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def countOfPeaks(\n      self,\n      nums: list[int],\n      queries:\n      list[list[int]],\n  ) -> list[int]:\n    ans = []\n    peak = [0] + [int(a < b > c)\n                  for a, b, c in zip(nums[:-2], nums[1:-1], nums[2:])] + [0]\n    tree = FenwickTree(len(peak))\n\n    for i, p in enumerate(peak):\n      tree.add(i + 1, p)\n\n    def update(i: int) -> None:\n      \"\"\"\n      Update the peak array and Fenwick tree if the peak status of nums[i]\n      changes.\n      \"\"\"\n      newPeak = self._isPeak(nums, i)\n      if newPeak != peak[i]:\n        tree.add(i + 1, newPeak - peak[i])\n        peak[i] = newPeak\n\n    for query in queries:\n      if query[0] == 1:\n        l = query[1]\n        r = query[2]\n        ans.append(0 if r - l < 2 else tree.get(r) - tree.get(l + 1))\n      elif query[0] == 2:\n        index = query[1]\n        val = query[2]\n        nums[index] = val\n        update(index)\n        if index > 0:\n          update(index - 1)\n        if index + 1 < len(nums):\n          update(index + 1)\n\n    return ans\n\n  def _isPeak(self, nums: list[int], i: int) -> bool:\n    return i > 0 and i + 1 < len(nums) and nums[i - 1] < nums[i] > nums[i + 1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3165, "slug": "maximum-sum-of-subsequence-with-non-adjacent-elements", "solutions": ["def max(a: int, b: int) -> int:\n    return a if a > b else b\n\n\nclass Node:\n    __slots__ = \"l\", \"r\", \"s00\", \"s01\", \"s10\", \"s11\"\n\n    def __init__(self, l: int, r: int):\n        self.l = l\n        self.r = r\n        self.s00 = self.s01 = self.s10 = self.s11 = 0\n\n\nclass SegmentTree:\n    __slots__ = \"tr\"\n\n    def __init__(self, n: int):\n        self.tr: List[Node | None] = [None] * (n << 2)\n        self.build(1, 1, n)\n\n    def build(self, u: int, l: int, r: int):\n        self.tr[u] = Node(l, r)\n        if l == r:\n            return\n        mid = (l + r) >> 1\n        self.build(u << 1, l, mid)\n        self.build(u << 1 | 1, mid + 1, r)\n\n    def query(self, u: int, l: int, r: int) -> int:\n        if self.tr[u].l >= l and self.tr[u].r <= r:\n            return self.tr[u].s11\n        mid = (self.tr[u].l + self.tr[u].r) >> 1\n        ans = 0\n        if r <= mid:\n            ans = self.query(u << 1, l, r)\n        if l > mid:\n            ans = max(ans, self.query(u << 1 | 1, l, r))\n        return ans\n\n    def pushup(self, u: int):\n        left, right = self.tr[u << 1], self.tr[u << 1 | 1]\n        self.tr[u].s00 = max(left.s00 + right.s10, left.s01 + right.s00)\n        self.tr[u].s01 = max(left.s00 + right.s11, left.s01 + right.s01)\n        self.tr[u].s10 = max(left.s10 + right.s10, left.s11 + right.s00)\n        self.tr[u].s11 = max(left.s10 + right.s11, left.s11 + right.s01)\n\n    def modify(self, u: int, x: int, v: int):\n        if self.tr[u].l == self.tr[u].r:\n            self.tr[u].s11 = max(0, v)\n            return\n        mid = (self.tr[u].l + self.tr[u].r) >> 1\n        if x <= mid:\n            self.modify(u << 1, x, v)\n        else:\n            self.modify(u << 1 | 1, x, v)\n        self.pushup(u)\n\n\nclass Solution:\n    def maximumSumSubsequence(self, nums: List[int], queries: List[List[int]]) -> int:\n        n = len(nums)\n        tree = SegmentTree(n)\n        for i, x in enumerate(nums, 1):\n            tree.modify(1, i, x)\n        ans = 0\n        mod = 10**9 + 7\n        for i, x in queries:\n            tree.modify(1, i + 1, x)\n            ans = (ans + tree.query(1, 1, n)) % mod\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3108, "slug": "minimum-cost-walk-in-weighted-graph", "solutions": ["class UnionFind:\n    def __init__(self, n):\n        self.p = list(range(n))\n        self.size = [1] * n\n\n    def find(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n\n    def union(self, a, b):\n        pa, pb = self.find(a), self.find(b)\n        if pa == pb:\n            return False\n        if self.size[pa] > self.size[pb]:\n            self.p[pb] = pa\n            self.size[pa] += self.size[pb]\n        else:\n            self.p[pa] = pb\n            self.size[pb] += self.size[pa]\n        return True\n\n\nclass Solution:\n    def minimumCost(\n        self, n: int, edges: List[List[int]], query: List[List[int]]\n    ) -> List[int]:\n        g = [-1] * n\n        uf = UnionFind(n)\n        for u, v, _ in edges:\n            uf.union(u, v)\n        for u, _, w in edges:\n            root = uf.find(u)\n            g[root] &= w\n\n        def f(u: int, v: int) -> int:\n            if u == v:\n                return 0\n            a, b = uf.find(u), uf.find(v)\n            return g[a] if a == b else -1\n\n        return [f(s, t) for s, t in query]\n", "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n    # 2^17 - 1 is the minimum number in the form 2^x - 1 > 10^5.\n    self.weight = [(1 << 17) - 1] * n\n\n  def unionByRank(self, u: int, v: int, w: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    newWeight = self.weight[i] & self.weight[j] & w\n    self.weight[i] = newWeight\n    self.weight[j] = newWeight\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def getMinCost(self, u: int, v: int) -> int:\n    if u == v:\n      return 0\n    i = self._find(u)\n    j = self._find(v)\n    return self.weight[i] if i == j else -1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def minimumCost(\n      self,\n      n: int,\n      edges: list[list[int]],\n      query: list[list[int]],\n  ) -> list[int]:\n    uf = UnionFind(n)\n\n    for u, v, w in edges:\n      uf.unionByRank(u, v, w)\n\n    return [uf.getMinCost(u, v) for u, v in query]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3122, "slug": "minimum-number-of-operations-to-satisfy-conditions", "solutions": ["class Solution:\n    def minimumOperations(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        f = [[inf] * 10 for _ in range(n)]\n        for i in range(n):\n            cnt = [0] * 10\n            for j in range(m):\n                cnt[grid[j][i]] += 1\n            if i == 0:\n                for j in range(10):\n                    f[i][j] = m - cnt[j]\n            else:\n                for j in range(10):\n                    for k in range(10):\n                        if k != j:\n                            f[i][j] = min(f[i][j], f[i - 1][k] + m - cnt[j])\n        return min(f[-1])\n", "class Solution:\n  def minimumOperations(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    count = [[0] * 10 for _ in range(n)]\n\n    for row in grid:\n      for j, num in enumerate(row):\n        count[j][num] += 1\n\n    @functools.lru_cache(None)\n    def dp(i: int, prev: int) -> int:\n      \"\"\"\n      Returns the number of minimum operations needed to make grid[:][j..n)\n      satisfy the conditions, where the (j - 1)-th column is filled with `prev`.\n      \"\"\"\n      if i == n:\n        return 0\n\n      res = math.inf\n\n      for num in range(10):\n        if i == 0 or num != prev:\n          res = min(res, m - count[i][num] + dp(i + 1, num))\n\n      return res\n\n    return dp(0, 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3197, "slug": "find-the-minimum-area-to-cover-all-ones-ii", "solutions": ["class Solution:\n    def minimumSum(self, grid: List[List[int]]) -> int:\n        def f(i1: int, j1: int, i2: int, j2: int) -> int:\n            x1 = y1 = inf\n            x2 = y2 = -inf\n            for i in range(i1, i2 + 1):\n                for j in range(j1, j2 + 1):\n                    if grid[i][j] == 1:\n                        x1 = min(x1, i)\n                        y1 = min(y1, j)\n                        x2 = max(x2, i)\n                        y2 = max(y2, j)\n            return (x2 - x1 + 1) * (y2 - y1 + 1)\n\n        m, n = len(grid), len(grid[0])\n        ans = m * n\n        for i1 in range(m - 1):\n            for i2 in range(i1 + 1, m - 1):\n                ans = min(\n                    ans,\n                    f(0, 0, i1, n - 1)\n                    + f(i1 + 1, 0, i2, n - 1)\n                    + f(i2 + 1, 0, m - 1, n - 1),\n                )\n        for j1 in range(n - 1):\n            for j2 in range(j1 + 1, n - 1):\n                ans = min(\n                    ans,\n                    f(0, 0, m - 1, j1)\n                    + f(0, j1 + 1, m - 1, j2)\n                    + f(0, j2 + 1, m - 1, n - 1),\n                )\n        for i in range(m - 1):\n            for j in range(n - 1):\n                ans = min(\n                    ans,\n                    f(0, 0, i, j) + f(0, j + 1, i, n - 1) + f(i + 1, 0, m - 1, n - 1),\n                )\n                ans = min(\n                    ans,\n                    f(0, 0, i, n - 1)\n                    + f(i + 1, 0, m - 1, j)\n                    + f(i + 1, j + 1, m - 1, n - 1),\n                )\n\n                ans = min(\n                    ans,\n                    f(0, 0, i, j) + f(i + 1, 0, m - 1, j) + f(0, j + 1, m - 1, n - 1),\n                )\n                ans = min(\n                    ans,\n                    f(0, 0, m - 1, j)\n                    + f(0, j + 1, i, n - 1)\n                    + f(i + 1, j + 1, m - 1, n - 1),\n                )\n        return ans\n", "\nclass Solution:\n  def minimumSum(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = m * n\n\n    for i in range(m):\n      top = self._minimumArea(grid, 0, i, 0, n - 1)\n      for j in range(n):\n        ans = min(ans, top +\n                  self._minimumArea(grid, i + 1, m - 1, 0, j) +\n                  self._minimumArea(grid, i + 1, m - 1, j + 1, n - 1))\n\n    for i in range(m):\n      bottom = self._minimumArea(grid, i, m - 1, 0, n - 1)\n      for j in range(n):\n        ans = min(ans, bottom +\n                  self._minimumArea(grid, 0, i - 1, 0, j) +\n                  self._minimumArea(grid, 0, i - 1, j + 1, n - 1))\n\n    for j in range(n):\n      left = self._minimumArea(grid, 0, m - 1, 0, j)\n      for i in range(m):\n        ans = min(ans, left +\n                  self._minimumArea(grid, 0, i, j + 1, n - 1) +\n                  self._minimumArea(grid, i + 1, m - 1, j + 1, n - 1))\n\n    for j in range(n):\n      right = self._minimumArea(grid, 0, m - 1, j, n - 1)\n      for i in range(m):\n        ans = min(ans, right +\n                  self._minimumArea(grid, 0, i, 0, j - 1) +\n                  self._minimumArea(grid, i + 1, m - 1, 0, j - 1))\n\n    for i1 in range(m):\n      for i2 in range(i1 + 1, m):\n        ans = min(ans, self._minimumArea(grid, 0, i1, 0, n - 1) +\n                  self._minimumArea(grid, i1 + 1, i2, 0, n - 1) +\n                  self._minimumArea(grid, i2 + 1, m - 1, 0, n - 1))\n\n    for j1 in range(n):\n      for j2 in range(j1 + 1, n):\n        ans = min(ans, self._minimumArea(grid, 0, m - 1, 0, j1) +\n                  self._minimumArea(grid, 0, m - 1, j1 + 1, j2) +\n                  self._minimumArea(grid, 0, m - 1, j2 + 1, n - 1))\n\n    return ans\n\n  def _minimumArea(\n      self,\n      grid: list[list[int]],\n      si: int,\n      ei: int,\n      sj: int,\n      ej: int,\n  ) -> int:\n    x1 = math.inf\n    y1 = math.inf\n    x2 = 0\n    y2 = 0\n    for i in range(si, ei + 1):\n      for j in range(sj, ej + 1):\n        if grid[i][j] == 1:\n          x1 = min(x1, i)\n          y1 = min(y1, j)\n          x2 = max(x2, i)\n          y2 = max(y2, j)\n    return 0 if x1 == math.inf else (x2 - x1 + 1) * (y2 - y1 + 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3104, "slug": "find-longest-self-contained-substring", "solutions": ["class Solution:\n    def maxSubstringLength(self, s: str) -> int:\n        first, last = {}, {}\n        for i, c in enumerate(s):\n            if c not in first:\n                first[c] = i\n            last[c] = i\n        ans, n = -1, len(s)\n        for c, i in first.items():\n            mx = last[c]\n            for j in range(i, n):\n                a, b = first[s[j]], last[s[j]]\n                if a < i:\n                    break\n                mx = max(mx, b)\n                if mx == j and j - i + 1 < n:\n                    ans = max(ans, j - i + 1)\n        return ans\n", "class Solution:\n  def maxSubstringLength(self, s: str) -> int:\n    allCount = collections.Counter(s)\n\n    # Similar to 395. Longest Substring with At Least K Repeating Characters\n    def maxSubstringLengthWithNUniqueLetters(n: int) -> int:\n      res = -1\n      # the number of unique letters\n      uniqueLetters = 0\n      # the number of letters that have all their frequency in the substring\n      lettersHavingAllFreq = 0\n      count = collections.Counter()\n\n      l = 0\n      for r, c in enumerate(s):\n        count[c] += 1\n        if count[c] == 1:\n          uniqueLetters += 1\n        if count[c] == allCount[c]:\n          lettersHavingAllFreq += 1\n        while uniqueLetters > n:\n          if count[s[l]] == allCount[s[l]]:\n            lettersHavingAllFreq -= 1\n          count[s[l]] -= 1\n          if count[s[l]] == 0:\n            uniqueLetters -= 1\n          l += 1\n        # Since both the number of unique letters and the number of letters\n        # having all their frequency are equal to n, this is a valid window.\n        # Implcit: uniqueLetters == n\n        if lettersHavingAllFreq == n and r - l + 1 < len(s):\n          res = max(res, r - l + 1)\n\n      return res\n\n    return max(maxSubstringLengthWithNUniqueLetters(n)\n               for n in range(1, 27))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3183, "slug": "the-number-of-ways-to-make-the-sum", "solutions": ["class Solution:\n    def numberOfWays(self, n: int) -> int:\n        mod = 10**9 + 7\n        coins = [1, 2, 6]\n        f = [0] * (n + 1)\n        f[0] = 1\n        for x in coins:\n            for j in range(x, n + 1):\n                f[j] = (f[j] + f[j - x]) % mod\n        ans = f[n]\n        if n >= 4:\n            ans = (ans + f[n - 4]) % mod\n        if n >= 8:\n            ans = (ans + f[n - 8]) % mod\n        return ans\n", "class Solution:\n  def numberOfWays(self, n: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i] := the number of ways to make the sum of i using coins 1, 2, and 6\n    dp = [1] + [0] * n\n\n    for coin in (1, 2, 6):\n      for i in range(coin, n + 1):\n        dp[i] = (dp[i] + dp[i - coin]) % MOD\n\n    ans = dp[n]\n    if n - 4 >= 0:\n      ans = (ans + dp[n - 4]) % MOD\n    if n - 8 >= 0:\n      ans = (ans + dp[n - 8]) % MOD\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3161, "slug": "block-placement-queries", "solutions": ["from sortedcontainers import SortedList\n\n\nclass FenwickTree:\n  def __init__(self, n: int):\n    self.vals = [0] * (n + 1)\n\n  def maximize(self, i: int, val: int) -> None:\n    while i < len(self.vals):\n      self.vals[i] = max(self.vals[i], val)\n      i += FenwickTree.lowtree(i)\n\n  def get(self, i: int) -> int:\n    res = 0\n    while i > 0:\n      res = max(res, self.vals[i])\n      i -= FenwickTree.lowtree(i)\n    return res\n\n  @staticmethod\n  def lowtree(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def getResults(self, queries: list[list[int]]) -> list[bool]:\n    n = min(50000, len(queries) * 3)\n    ans = []\n    tree = FenwickTree(n + 1)\n    obstacles = SortedList([0, n])  # sentinel values\n\n    for query in queries:\n      type = query[0]\n      if type == 1:\n        x = query[1]\n        obstacles.add(x)\n\n    for x1, x2 in itertools.pairwise(obstacles):\n      tree.maximize(x2, x2 - x1)\n\n    for query in reversed(queries):\n      type = query[0]\n      x = query[1]\n      if type == 1:\n        i = obstacles.index(x)\n        next = obstacles[i + 1]\n        prev = obstacles[i - 1]\n        obstacles.remove(x)\n        tree.maximize(next, next - prev)\n      else:\n        sz = query[2]\n        i = obstacles.bisect_right(x)\n        prev = obstacles[i - 1]\n        ans.append(tree.get(prev) >= sz or x - prev >= sz)\n\n    return ans[::-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3120, "slug": "count-the-number-of-special-characters-i", "solutions": ["class Solution:\n    def numberOfSpecialChars(self, word: str) -> int:\n        s = set(word)\n        return sum(a in s and b in s for a, b in zip(ascii_lowercase, ascii_uppercase))\n", "class Solution:\n  def numberOfSpecialChars(self, word: str) -> int:\n    lower = collections.defaultdict(bool)\n    upper = collections.defaultdict(bool)\n\n    for c in word:\n      if c.islower():\n        lower[c] = True\n      else:\n        upper[c] = True\n\n    return sum(lower[a] and upper[b]\n               for a, b in zip(string.ascii_lowercase,\n                               string.ascii_uppercase))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3164, "slug": "find-the-number-of-good-pairs-ii", "solutions": ["class Solution:\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], k: int) -> int:\n        cnt1 = Counter(x // k for x in nums1 if x % k == 0)\n        if not cnt1:\n            return 0\n        cnt2 = Counter(nums2)\n        ans = 0\n        mx = max(cnt1)\n        for x, v in cnt2.items():\n            s = sum(cnt1[y] for y in range(x, mx + 1, x))\n            ans += s * v\n        return ans\n", "class Solution:\n  def numberOfPairs(self, nums1: list[int], nums2: list[int], k: int) -> int:\n    count = collections.Counter(num * k for num in nums2)\n    ans = 0\n\n    for num in nums1:\n      for divisor in range(1, int(num ** 0.5) + 1):\n        if num % divisor == 0:\n          ans += count[divisor]\n          if num // divisor != divisor:\n            ans += count[num // divisor]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3176, "slug": "find-the-maximum-length-of-a-good-subsequence-i", "solutions": ["class Solution:\n    def maximumLength(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        f = [[1] * (k + 1) for _ in range(n)]\n        ans = 0\n        for i, x in enumerate(nums):\n            for h in range(k + 1):\n                for j, y in enumerate(nums[:i]):\n                    if x == y:\n                        f[i][h] = max(f[i][h], f[j][h] + 1)\n                    elif h:\n                        f[i][h] = max(f[i][h], f[j][h - 1] + 1)\n            ans = max(ans, f[i][k])\n        return ans\n", "class Solution:\n  def maximumLength(self, nums: list[int], k: int) -> int:\n    # dp[count][num] := the maximum length of a good subsequence with at most\n    # `count` indices where seq[i] != seq[i + 1] and it ends in `num`.\n    dp = [collections.Counter() for _ in range(k + 1)]\n    # maxLen[count] := the maximum length of a good subsequence with `count`\n    # indices where seq[i] != seq[i + 1]\n    maxLen = [0] * (k + 1)\n\n    for num in nums:\n      for count in range(k, -1, -1):\n        # Append `num` to the subsequence.\n        dp[count][num] += 1\n        if count > 0:\n          dp[count][num] = max(dp[count][num], maxLen[count - 1] + 1)\n        maxLen[count] = max(maxLen[count], dp[count][num])\n\n    return maxLen[k]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3199, "slug": "count-triplets-with-even-xor-set-bits-i", "solutions": ["class Solution:\n    def tripletCount(self, a: List[int], b: List[int], c: List[int]) -> int:\n        cnt1 = Counter(x.bit_count() & 1 for x in a)\n        cnt2 = Counter(x.bit_count() & 1 for x in b)\n        cnt3 = Counter(x.bit_count() & 1 for x in c)\n        ans = 0\n        for i in range(2):\n            for j in range(2):\n                for k in range(2):\n                    if (i + j + k) & 1 ^ 1:\n                        ans += cnt1[i] * cnt2[j] * cnt3[k]\n        return ans\n", "class Solution:\n  def tripletCount(self, a: list[int], b: list[int], c: list[int]) -> int:\n    evenA, oddA = self._getEvenOddBitCount(a)\n    evenB, oddB = self._getEvenOddBitCount(b)\n    evenC, oddC = self._getEvenOddBitCount(c)\n    return evenA * oddB * oddC + oddA * evenB * oddC + oddA * oddB * evenC + evenA * evenB * evenC\n\n  def _getEvenOddBitCount(self, nums: list[int]) -> tuple[int, int]:\n    \"\"\"\n    Returns the count of numbers in the `nums` arrays that have even number of\n    ones and odd number of ones in their binary representation.\n    \"\"\"\n    even = sum(num.bit_count() % 2 == 0 for num in nums)\n    return (even, len(nums) - even)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3189, "slug": "minimum-moves-to-get-a-peaceful-board", "solutions": ["class Solution:\n    def minMoves(self, rooks: List[List[int]]) -> int:\n        rooks.sort()\n        ans = sum(abs(x - i) for i, (x, _) in enumerate(rooks))\n        rooks.sort(key=lambda x: x[1])\n        ans += sum(abs(y - j) for j, (_, y) in enumerate(rooks))\n        return ans\n", "class Solution:\n  def minMoves(self, rooks: list[list[int]]) -> int:\n    n = len(rooks)\n    sortedByRow = sorted(rooks, key=lambda x: x[0])\n    sortedByCol = sorted(rooks, key=lambda x: x[1])\n    return (sum(abs(i - row) for (i, _), row in zip(sortedByRow, range(n))) +\n            sum(abs(j - col) for (_, j), col in zip(sortedByCol, range(n))))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3126, "slug": "server-utilization-time", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3192, "slug": "minimum-operations-to-make-binary-array-elements-equal-to-one-ii", "solutions": ["class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = v = 0\n        for x in nums:\n            x ^= v\n            if x == 0:\n                ans += 1\n                v ^= 1\n        return ans\n", "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    ans = 0\n    target = 1\n\n    for num in nums:\n      if num != target:\n        ans += 1\n        target ^= 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3145, "slug": "find-products-of-elements-of-big-array", "solutions": ["m = 50\ncnt = [0] * (m + 1)\ns = [0] * (m + 1)\np = 1\nfor i in range(1, m + 1):\n    cnt[i] = cnt[i - 1] * 2 + p\n    s[i] = s[i - 1] * 2 + p * (i - 1)\n    p *= 2\n\n\ndef num_idx_and_sum(x: int) -> tuple:\n    idx = 0\n    total_sum = 0\n    while x:\n        i = x.bit_length() - 1\n        idx += cnt[i]\n        total_sum += s[i]\n        x -= 1 << i\n        total_sum += (x + 1) * i\n        idx += x + 1\n    return (idx, total_sum)\n\n\ndef f(i: int) -> int:\n    l, r = 0, 1 << m\n    while l < r:\n        mid = (l + r + 1) >> 1\n        idx, _ = num_idx_and_sum(mid)\n        if idx < i:\n            l = mid\n        else:\n            r = mid - 1\n\n    total_sum = 0\n    idx, total_sum = num_idx_and_sum(l)\n    i -= idx\n    x = l + 1\n    for _ in range(i):\n        y = x & -x\n        total_sum += y.bit_length() - 1\n        x -= y\n    return total_sum\n\n\nclass Solution:\n    def findProductsOfElements(self, queries: List[List[int]]) -> List[int]:\n        return [pow(2, f(right + 1) - f(left), mod) for left, right, mod in queries]\n", "class Solution:\n  def findProductsOfElements(self, queries: list[list[int]]) -> list[int]:\n    def sumBitsTill(x: int) -> int:\n      \"\"\"Returns sum(i.bit_count()), where 1 <= i <= x.\"\"\"\n      sumBits = 0\n      powerOfTwo = 1\n      while powerOfTwo <= x:\n        sumBits += (x // (2 * powerOfTwo)) * powerOfTwo\n        sumBits += max(0, x % (2 * powerOfTwo) + 1 - powerOfTwo)\n        powerOfTwo *= 2\n      return sumBits\n\n    def sumPowersTill(x: int) -> int:\n      \"\"\"Returns sum(all powers of i), where 1 <= i <= x.\"\"\"\n      sumPowers = 0\n      powerOfTwo = 1\n      for power in range(x.bit_length()):\n        sumPowers += (x // (2 * powerOfTwo)) * powerOfTwo * power\n        sumPowers += max(0, x % (2 * powerOfTwo) + 1 - powerOfTwo) * power\n        powerOfTwo *= 2\n      return sumPowers\n\n    def sumPowersFirstKBigNums(k: int) -> int:\n      \"\"\"Returns the sum of powers of the first k numbers in `big_nums`.\"\"\"\n      # Find the first number in [1, k] that has sumBitsTill(num) >= k.\n      num = bisect.bisect_left(range(k), k, key=sumBitsTill)\n      sumPowers = sumPowersTill(num - 1)\n      remainingCount = k - sumBitsTill(num - 1)\n      for power in range(num.bit_length()):\n        if num >> power & 1:\n          sumPowers += power\n          remainingCount -= 1\n          if remainingCount == 0:\n            break\n      return sumPowers\n\n    return [pow(2,\n                sumPowersFirstKBigNums(b + 1) -\n                sumPowersFirstKBigNums(a), mod)\n            for a, b, mod in queries]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3141, "slug": "maximum-hamming-distances", "solutions": ["class Solution:\n    def maxHammingDistances(self, nums: List[int], m: int) -> List[int]:\n        dist = [-1] * (1 << m)\n        for x in nums:\n            dist[x] = 0\n        q = nums\n        k = 1\n        while q:\n            t = []\n            for x in q:\n                for i in range(m):\n                    y = x ^ (1 << i)\n                    if dist[y] == -1:\n                        t.append(y)\n                        dist[y] = k\n            q = t\n            k += 1\n        return [m - dist[x ^ ((1 << m) - 1)] for x in nums]\n", "class Solution:\n  def maxHammingDistances(self, nums: list[int], m: int) -> list[int]:\n    MAX_MASK = 1 << m\n    # dp[i] := the maximum hamming distance from i to any number in `nums`\n    dp = [-math.inf] * MAX_MASK\n\n    for num in nums:\n      dp[num] = 0\n\n    for bit in range(m):\n      newDp = [0] * MAX_MASK\n      for mask in range(MAX_MASK):\n        newDp[mask] = max(dp[mask], dp[mask ^ (1 << bit)] + 1)\n      dp = newDp\n\n    return [dp[num] for num in nums]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3123, "slug": "find-edges-in-shortest-paths", "solutions": ["class Solution:\n    def findAnswer(self, n: int, edges: List[List[int]]) -> List[bool]:\n        g = defaultdict(list)\n        for i, (a, b, w) in enumerate(edges):\n            g[a].append((b, w, i))\n            g[b].append((a, w, i))\n        dist = [inf] * n\n        dist[0] = 0\n        q = [(0, 0)]\n        while q:\n            da, a = heappop(q)\n            if da > dist[a]:\n                continue\n            for b, w, _ in g[a]:\n                if dist[b] > dist[a] + w:\n                    dist[b] = dist[a] + w\n                    heappush(q, (dist[b], b))\n        m = len(edges)\n        ans = [False] * m\n        if dist[n - 1] == inf:\n            return ans\n        q = deque([n - 1])\n        while q:\n            a = q.popleft()\n            for b, w, i in g[a]:\n                if dist[a] == dist[b] + w:\n                    ans[i] = True\n                    q.append(b)\n        return ans\n", "class Solution:\n  # Similar to 2203. Minimum Weighted Subgraph With the Required Paths\n  def findAnswer(self, n: int, edges: list[list[int]]) -> list[bool]:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    from0 = self._dijkstra(graph, 0)\n    from1 = self._dijkstra(graph, n - 1)\n    return [from0[u] + w + from1[v] == from0[-1] or\n            from0[v] + w + from1[u] == from0[-1]\n            for u, v, w in edges]\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n  ) -> list[int]:\n    dist = [10**9] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3110, "slug": "score-of-a-string", "solutions": ["class Solution:\n    def scoreOfString(self, s: str) -> int:\n        return sum(abs(a - b) for a, b in pairwise(map(ord, s)))\n", "class Solution:\n  def scoreOfString(self, s: str) -> int:\n    return sum(abs(ord(a) - ord(b))\n               for a, b in itertools.pairwise(s))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3180, "slug": "maximum-total-reward-using-operations-i", "solutions": ["class Solution:\n    def maxTotalReward(self, rewardValues: List[int]) -> int:\n        @cache\n        def dfs(x: int) -> int:\n            i = bisect_right(rewardValues, x)\n            ans = 0\n            for v in rewardValues[i:]:\n                ans = max(ans, v + dfs(x + v))\n            return ans\n\n        rewardValues.sort()\n        return dfs(0)\n", "# According to the constraint rewardValues[i] <= 5 * 10^4, the maximum total\n# reward < 2 * (5 * 10^4) = 10^5. We can use bitset to record whether each\n# `rewardValue` is achievable in O(1).\n#\n# Let's use `rewardValues = [1, 3, 4]` as an example.\n#\n# The maximum reward is 4, so the maximum possible total < 2 * 4 = 8.\n# Therefore, we can set the size of the bitset to 8 to represent possible\n# total rewards from 0 to 7.\n#\n# Let's define a bitset `dp` to record whether each total reward is\n# achievable. dp[num] = true if reward `num` is achievable.\n#\n# Initially, dp = 0b00000001 := reward 0 is achievable.\n#\n# * rewardValues[0] = 1, for each dp[i] = 1, where i + 1 < 10, dp[i + 1] = 1.\n#   => dp = 0b00000011 := rewards 0 and 1 are achievable.\n#\n# * rewardValues[1] = 3, for each dp[i] = 1, where i + 3 < 10, dp[i + 3] = 1.\n#   => dp = 0b00011011 := rewards 0, 1, 3, and 4 are achievable.\n#\n# * rewardValues[2] = 4, for each dp[i] = 1, where i + 4 < 10, dp[i + 4] = 1.\n#   => dp = 0b10011011 := rewards 0, 1, 3, 4, 5, and 7 are achievable.\n#\n# Therefore, the maximum total reward is 7.\n\nclass Solution:\n  def maxTotalReward(self, rewardValues: list[int]) -> int:\n    dp = 1  # the possible rewards (initially, 0 is achievable)\n\n    for num in sorted(rewardValues):\n      # Remove the numbers >= the current number.\n      smallerNums = dp & ((1 << num) - 1)\n      dp |= smallerNums << num\n\n    return dp.bit_length() - 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3112, "slug": "minimum-time-to-visit-disappearing-nodes", "solutions": ["class Solution:\n    def minimumTime(\n        self, n: int, edges: List[List[int]], disappear: List[int]\n    ) -> List[int]:\n        g = defaultdict(list)\n        for u, v, w in edges:\n            g[u].append((v, w))\n            g[v].append((u, w))\n        dist = [inf] * n\n        dist[0] = 0\n        pq = [(0, 0)]\n        while pq:\n            du, u = heappop(pq)\n            if du > dist[u]:\n                continue\n            for v, w in g[u]:\n                if dist[v] > dist[u] + w and dist[u] + w < disappear[v]:\n                    dist[v] = dist[u] + w\n                    heappush(pq, (dist[v], v))\n        return [a if a < b else -1 for a, b in zip(dist, disappear)]\n", "class Solution:\n  def minimumTime(\n      self,\n      n: int,\n      edges: list[list[int]],\n      disappear: list[int],\n  ) -> list[int]:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, disappear)\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n      disappear: list[int],\n  ) -> list[int]:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < disappear[v] and d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return [d if d != math.inf else -1\n            for d in dist]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3143, "slug": "maximum-points-inside-the-square", "solutions": ["class Solution:\n    def maxPointsInsideSquare(self, points: List[List[int]], s: str) -> int:\n        g = defaultdict(list)\n        for i, (x, y) in enumerate(points):\n            g[max(abs(x), abs(y))].append(i)\n        vis = set()\n        ans = 0\n        for d in sorted(g):\n            idx = g[d]\n            for i in idx:\n                if s[i] in vis:\n                    return ans\n                vis.add(s[i])\n            ans += len(idx)\n        return ans\n", "class Solution:\n  def maxPointsInsideSquare(self, points: list[list[int]], s: str) -> int:\n    secondMinSize = math.inf\n    minSizes = {}\n\n    for (x, y), c in zip(points, s):\n      sz = max(abs(x), abs(y))\n      if c not in minSizes:\n        minSizes[c] = sz\n      elif sz < minSizes[c]:\n        # This is because minSizes[j] is about to be replaced by a smaller\n        # value, so it becomes a candidate for the second minimum size.\n        secondMinSize = min(secondMinSize, minSizes[c])\n        minSizes[c] = sz\n      else:\n        # `sz` is not smaller than the current minimum size, but it could be\n        # smaller than the current second minimum size.\n        secondMinSize = min(secondMinSize, sz)\n\n    return sum(sz < secondMinSize for sz in minSizes.values())\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3144, "slug": "minimum-substring-partition-of-equal-character-frequency", "solutions": ["class Solution:\n    def minimumSubstringsInPartition(self, s: str) -> int:\n        @cache\n        def dfs(i: int) -> int:\n            if i >= n:\n                return 0\n            cnt = defaultdict(int)\n            freq = defaultdict(int)\n            ans = n - i\n            for j in range(i, n):\n                if cnt[s[j]]:\n                    freq[cnt[s[j]]] -= 1\n                    if not freq[cnt[s[j]]]:\n                        freq.pop(cnt[s[j]])\n                cnt[s[j]] += 1\n                freq[cnt[s[j]]] += 1\n                if len(freq) == 1 and (t := 1 + dfs(j + 1)) < ans:\n                    ans = t\n            return ans\n\n        n = len(s)\n        return dfs(0)\n", "class Solution:\n  def minimumSubstringsInPartition(self, s: str) -> int:\n    n = len(s)\n    # dp[i] := the minimum number of substrings in s[0..i]\n    dp = [n] * n\n\n    for i in range(n):\n      count = collections.Counter()\n      for j in range(i, -1, -1):\n        count[s[j]] += 1\n        # word[j..i] is balanced.\n        if min(count.values()) == max(count.values()):\n          dp[i] = min(dp[i], 1 + dp[j - 1] if j > 0 else 1)\n\n    return dp[-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3178, "slug": "find-the-child-who-has-the-ball-after-k-seconds", "solutions": ["class Solution:\n    def numberOfChild(self, n: int, k: int) -> int:\n        k, mod = divmod(k, n - 1)\n        return n - mod - 1 if k & 1 else mod\n", "class Solution:\n  def numberOfChild(self, n: int, k: int) -> int:\n    # the time for the ball to return to 0\n    roundTime = 2 * (n - 1)\n    pos = k % roundTime\n    return pos if pos < n else roundTime - pos\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3150, "slug": "invalid-tweets-ii", "solutions": ["import pandas as pd\n\n\ndef find_invalid_tweets(tweets: pd.DataFrame) -> pd.DataFrame:\n    invalid_tweets = tweets[\n        (tweets[\"content\"].str.len() > 140)\n        | (tweets[\"content\"].str.count(\"@\") > 3)\n        | (tweets[\"content\"].str.count(\"#\") > 3)\n    ].sort_values(by=\"tweet_id\")\n    return invalid_tweets[[\"tweet_id\"]]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3148, "slug": "maximum-difference-score-in-a-grid", "solutions": ["class Solution:\n    def maxScore(self, grid: List[List[int]]) -> int:\n        f = [[0] * len(grid[0]) for _ in range(len(grid))]\n        ans = -inf\n        for i, row in enumerate(grid):\n            for j, x in enumerate(row):\n                mi = inf\n                if i:\n                    mi = min(mi, f[i - 1][j])\n                if j:\n                    mi = min(mi, f[i][j - 1])\n                ans = max(ans, x - mi)\n                f[i][j] = min(x, mi)\n        return ans\n", "class Solution:\n  def maxScore(self, grid: list[list[int]]) -> int:\n    MAX = 200000\n    ans = -MAX\n\n    for i, row in enumerate(grid):\n      for j, num in enumerate(row):\n        prevMin = min(grid[i - 1][j] if i > 0 else MAX,\n                      grid[i][j - 1] if j > 0 else MAX)\n        ans = max(ans, num - prevMin)\n        grid[i][j] = min(num, prevMin)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3182, "slug": "find-top-scoring-students", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 898, "slug": "bitwise-ors-of-subarrays", "solutions": ["class Solution:\n    def subarrayBitwiseORs(self, arr: List[int]) -> int:\n        ans = set()\n        s = set()\n        for x in arr:\n            s = {x | y for y in s} | {x}\n            ans |= s\n        return len(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 830, "slug": "positions-of-large-groups", "solutions": ["class Solution:\n    def largeGroupPositions(self, s: str) -> List[List[int]]:\n        i, n = 0, len(s)\n        ans = []\n        while i < n:\n            j = i\n            while j < n and s[j] == s[i]:\n                j += 1\n            if j - i >= 3:\n                ans.append([i, j - 1])\n            i = j\n        return ans\n", "class Solution:\n  def largeGroupPositions(self, s: str) -> list[list[int]]:\n    n = len(s)\n    ans = []\n    i = 0\n    j = 0\n\n    while i < n:\n      while j < n and s[j] == s[i]:\n        j += 1\n      if j - i >= 3:\n        ans.append([i, j - 1])\n      i = j\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 862, "slug": "shortest-subarray-with-sum-at-least-k", "solutions": ["class Solution:\n    def shortestSubarray(self, nums: List[int], k: int) -> int:\n        s = list(accumulate(nums, initial=0))\n        q = deque()\n        ans = inf\n        for i, v in enumerate(s):\n            while q and v - s[q[0]] >= k:\n                ans = min(ans, i - q.popleft())\n            while q and s[q[-1]] >= v:\n                q.pop()\n            q.append(i)\n        return -1 if ans == inf else ans\n", "class Solution:\n  def shortestSubarray(self, nums: list[int], k: int) -> int:\n    n = len(nums)\n    ans = n + 1\n    dq = collections.deque()\n    prefix = list(itertools.accumulate(nums, initial=0))\n\n    for i in range(n + 1):\n      while dq and prefix[i] - prefix[dq[0]] >= k:\n        ans = min(ans, i - dq.popleft())\n      while dq and prefix[i] <= prefix[dq[-1]]:\n        dq.pop()\n      dq.append(i)\n\n    return ans if ans <= n else -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 852, "slug": "peak-index-in-a-mountain-array", "solutions": ["class Solution:\n    def peakIndexInMountainArray(self, arr: List[int]) -> int:\n        left, right = 1, len(arr) - 2\n        while left < right:\n            mid = (left + right) >> 1\n            if arr[mid] > arr[mid + 1]:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n", "class Solution:\n  def peakIndexInMountainArray(self, arr: list[int]) -> int:\n    l = 0\n    r = len(arr) - 1\n\n    while l < r:\n      m = (l + r) // 2\n      if arr[m] >= arr[m + 1]:\n        r = m\n      else:\n        l = m + 1\n\n    return l\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 893, "slug": "groups-of-special-equivalent-strings", "solutions": ["class Solution:\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\n        s = {''.join(sorted(word[::2]) + sorted(word[1::2])) for word in words}\n        return len(s)\n", "class Solution:\n  def numSpecialEquivGroups(self, words: list[str]) -> int:\n    return len({''.join(sorted(word[::2])) + ''.join(sorted(word[1::2]))\n                for word in words})\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 894, "slug": "all-possible-full-binary-trees", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def allPossibleFBT(self, n: int) -> List[Optional[TreeNode]]:\n        @cache\n        def dfs(n: int) -> List[Optional[TreeNode]]:\n            if n == 1:\n                return [TreeNode()]\n            ans = []\n            for i in range(n - 1):\n                j = n - 1 - i\n                for left in dfs(i):\n                    for right in dfs(j):\n                        ans.append(TreeNode(0, left, right))\n            return ans\n\n        return dfs(n)\n", "class Solution:\n  @functools.lru_cache(None)\n  def allPossibleFBT(self, n: int) -> list[TreeNode | None]:\n    if n % 2 == 0:\n      return []\n    if n == 1:\n      return [TreeNode(0)]\n\n    ans = []\n\n    for leftCount in range(n):\n      rightCount = n - 1 - leftCount\n      for left in self.allPossibleFBT(leftCount):\n        for right in self.allPossibleFBT(rightCount):\n          ans.append(TreeNode(0))\n          ans[-1].left = left\n          ans[-1].right = right\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 812, "slug": "largest-triangle-area", "solutions": ["class Solution:\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\n        ans = 0\n        for x1, y1 in points:\n            for x2, y2 in points:\n                for x3, y3 in points:\n                    u1, v1 = x2 - x1, y2 - y1\n                    u2, v2 = x3 - x1, y3 - y1\n                    t = abs(u1 * v2 - u2 * v1) / 2\n                    ans = max(ans, t)\n        return ans\n", "class Solution:\n  def largestTriangleArea(self, points: list[list[int]]) -> float:\n    ans = 0\n\n    for Ax, Ay in points:\n      for Bx, By in points:\n        for Cx, Cy in points:\n          ans = max(ans, 0.5 * abs((Bx - Ax) * (Cy - Ay) -\n                                   (Cx - Ax) * (By - Ay)))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 821, "slug": "shortest-distance-to-a-character", "solutions": ["class Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        ans = [n] * n\n        pre = -inf\n        for i, ch in enumerate(s):\n            if ch == c:\n                pre = i\n            ans[i] = min(ans[i], i - pre)\n        suf = inf\n        for i in range(n - 1, -1, -1):\n            if s[i] == c:\n                suf = i\n            ans[i] = min(ans[i], suf - i)\n        return ans\n", "class Solution:\n  def shortestToChar(self, s: str, c: str) -> list[int]:\n    n = len(s)\n    ans = [0] * n\n    prev = -n\n\n    for i in range(n):\n      if s[i] == c:\n        prev = i\n      ans[i] = i - prev\n\n    for i in range(prev - 1, -1, -1):\n      if s[i] == c:\n        prev = i\n      ans[i] = min(ans[i], prev - i)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 829, "slug": "consecutive-numbers-sum", "solutions": ["class Solution:\n    def consecutiveNumbersSum(self, n: int) -> int:\n        n <<= 1\n        ans, k = 0, 1\n        while k * (k + 1) <= n:\n            if n % k == 0 and (n // k - k + 1) % 2 == 0:\n                ans += 1\n            k += 1\n        return ans\n", "class Solution:\n  def consecutiveNumbersSum(self, n: int) -> int:\n    ans = 0\n    i = 1\n    triangleNum = 1\n    while triangleNum <= n:\n      if (n - triangleNum) % i == 0:\n        ans += 1\n      i += 1\n      triangleNum += i\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 895, "slug": "maximum-frequency-stack", "solutions": ["class FreqStack:\n    def __init__(self):\n        self.cnt = defaultdict(int)\n        self.q = []\n        self.ts = 0\n\n    def push(self, val: int) -> None:\n        self.ts += 1\n        self.cnt[val] += 1\n        heappush(self.q, (-self.cnt[val], -self.ts, val))\n\n    def pop(self) -> int:\n        val = heappop(self.q)[2]\n        self.cnt[val] -= 1\n        return val\n\n\n# Your FreqStack object will be instantiated and called as such:\n# obj = FreqStack()\n# obj.push(val)\n# param_2 = obj.pop()\n", "class FreqStack:\n  def __init__(self):\n    self.maxFreq = 0\n    self.count = collections.Counter()\n    self.countToStack = collections.defaultdict(list)\n\n  def push(self, val: int) -> None:\n    self.count[val] += 1\n    self.countToStack[self.count[val]].append(val)\n    self.maxFreq = max(self.maxFreq, self.count[val])\n\n  def pop(self) -> int:\n    val = self.countToStack[self.maxFreq].pop()\n    self.count[val] -= 1\n    if not self.countToStack[self.maxFreq]:\n      self.maxFreq -= 1\n    return val\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 875, "slug": "koko-eating-bananas", "solutions": ["class Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        def check(k: int) -> bool:\n            return sum((x + k - 1) // k for x in piles) <= h\n\n        return 1 + bisect_left(range(1, max(piles) + 1), True, key=check)\n", "class Solution:\n  def minEatingSpeed(self, piles: list[int], h: int) -> int:\n    def eatHours(m: int) -> bool:\n      \"\"\"Returns the hours to eat all the piles with speed m.\"\"\"\n      return sum((pile - 1) // m + 1 for pile in piles)\n    l = 1\n    r = max(piles)\n    return bisect.bisect_left(range(l, r), True,\n                              key=lambda m: eatHours(m) <= h) + l\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 891, "slug": "sum-of-subsequence-widths", "solutions": ["class Solution:\n    def sumSubseqWidths(self, nums: List[int]) -> int:\n        mod = 10**9 + 7\n        nums.sort()\n        ans, p = 0, 1\n        for i, v in enumerate(nums):\n            ans = (ans + (v - nums[-i - 1]) * p) % mod\n            p = (p << 1) % mod\n        return ans\n", "class Solution:\n  def sumSubseqWidths(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(nums)\n    ans = 0\n    exp = 1\n\n    nums.sort()\n\n    for i in range(n):\n      ans += (nums[i] - nums[n - 1 - i]) * exp\n      ans %= MOD\n      exp = exp * 2 % MOD\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 832, "slug": "flipping-an-image", "solutions": ["class Solution:\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\n        n = len(image)\n        for row in image:\n            i, j = 0, n - 1\n            while i < j:\n                if row[i] == row[j]:\n                    row[i] ^= 1\n                    row[j] ^= 1\n                i, j = i + 1, j - 1\n            if i == j:\n                row[i] ^= 1\n        return image\n", "class Solution:\n  def flipAndInvertImage(self, A: list[list[int]]) -> list[list[int]]:\n    n = len(A)\n\n    for i in range(n):\n      for j in range((n + 2) // 2):\n        A[i][j], A[i][n - j - 2] = A[i][n - j - 1] ^ 2, A[i][j] ^ 1\n\n    return A\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 838, "slug": "push-dominoes", "solutions": ["class Solution:\n    def pushDominoes(self, dominoes: str) -> str:\n        n = len(dominoes)\n        q = deque()\n        time = [-1] * n\n        force = defaultdict(list)\n        for i, f in enumerate(dominoes):\n            if f != '.':\n                q.append(i)\n                time[i] = 0\n                force[i].append(f)\n        ans = ['.'] * n\n        while q:\n            i = q.popleft()\n            if len(force[i]) == 1:\n                ans[i] = f = force[i][0]\n                j = i - 1 if f == 'L' else i + 1\n                if 0 <= j < n:\n                    t = time[i]\n                    if time[j] == -1:\n                        q.append(j)\n                        time[j] = t + 1\n                        force[j].append(f)\n                    elif time[j] == t + 1:\n                        force[j].append(f)\n        return ''.join(ans)\n", "class Solution:\n  def pushDominoes(self, dominoes: str) -> str:\n    ans = list(dominoes)\n    L = -1\n    R = -1\n\n    for i in range(len(dominoes) + 1):\n      if i == len(dominoes) or dominoes[i] == 'R':\n        if L < R:\n          while R < i:\n            ans[R] = 'R'\n            R += 1\n        R = i\n      elif dominoes[i] == 'L':\n        if R < L or (L, R) == (-1, -1):\n          if (L, R) == (-1, -1):\n            L += 1\n          while L < i:\n            ans[L] = 'L'\n            L += 1\n        else:\n          l = R + 1\n          r = i - 1\n          while l < r:\n            ans[l] = 'R'\n            ans[r] = 'L'\n            l += 1\n            r -= 1\n        L = i\n\n    return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 865, "slug": "smallest-subtree-with-all-the-deepest-nodes", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def subtreeWithAllDeepest(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        def dfs(root: Optional[TreeNode]) -> Tuple[Optional[TreeNode], int]:\n            if root is None:\n                return None, 0\n            l, ld = dfs(root.left)\n            r, rd = dfs(root.right)\n            if ld > rd:\n                return l, ld + 1\n            if ld < rd:\n                return r, rd + 1\n            return root, ld + 1\n\n        return dfs(root)[0]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 833, "slug": "find-and-replace-in-string", "solutions": ["class Solution:\n    def findReplaceString(\n        self, s: str, indices: List[int], sources: List[str], targets: List[str]\n    ) -> str:\n        n = len(s)\n        d = [-1] * n\n        for k, (i, src) in enumerate(zip(indices, sources)):\n            if s.startswith(src, i):\n                d[i] = k\n        ans = []\n        i = 0\n        while i < n:\n            if ~d[i]:\n                ans.append(targets[d[i]])\n                i += len(sources[d[i]])\n            else:\n                ans.append(s[i])\n                i += 1\n        return \"\".join(ans)\n", "class Solution:\n  def findReplaceString(\n      self,\n      s: str,\n      indices: list[int],\n      sources: list[str],\n      targets: list[str]\n  ) -> str:\n    for index, source, target in sorted(\n            zip(indices, sources, targets),\n            reverse=True):\n      if s[index:index + len(source)] == source:\n        s = s[:index] + target + s[index + len(source):]\n    return s\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 801, "slug": "minimum-swaps-to-make-sequences-increasing", "solutions": ["class Solution:\n    def minSwap(self, nums1: List[int], nums2: List[int]) -> int:\n        a, b = 0, 1\n        for i in range(1, len(nums1)):\n            x, y = a, b\n            if nums1[i - 1] >= nums1[i] or nums2[i - 1] >= nums2[i]:\n                a, b = y, x + 1\n            else:\n                b = y + 1\n                if nums1[i - 1] < nums2[i] and nums2[i - 1] < nums1[i]:\n                    a, b = min(a, y), min(b, x + 1)\n        return min(a, b)\n", "class Solution:\n  def minSwap(self, nums1: list[int], nums2: list[int]) -> int:\n    keepAt = [math.inf] * len(nums1)\n    swapAt = [math.inf] * len(nums1)\n    keepAt[0] = 0\n    swapAt[0] = 1\n\n    for i in range(1, len(nums1)):\n      if nums1[i] > nums1[i - 1] and nums2[i] > nums2[i - 1]:\n        keepAt[i] = keepAt[i - 1]\n        swapAt[i] = swapAt[i - 1] + 1\n      if nums1[i] > nums2[i - 1] and nums2[i] > nums1[i - 1]:\n        keepAt[i] = min(keepAt[i], swapAt[i - 1])\n        swapAt[i] = min(swapAt[i], keepAt[i - 1] + 1)\n\n    return min(keepAt[-1], swapAt[-1])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 851, "slug": "loud-and-rich", "solutions": ["class Solution:\n    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\n        def dfs(i: int):\n            if ans[i] != -1:\n                return\n            ans[i] = i\n            for j in g[i]:\n                dfs(j)\n                if quiet[ans[j]] < quiet[ans[i]]:\n                    ans[i] = ans[j]\n\n        g = defaultdict(list)\n        for a, b in richer:\n            g[b].append(a)\n        n = len(quiet)\n        ans = [-1] * n\n        for i in range(n):\n            dfs(i)\n        return ans\n", "class Solution:\n  def loudAndRich(self, richer: list[list[int]], quiet: list[int]) -> list[int]:\n    graph = [[] for _ in range(len(quiet))]\n\n    for v, u in richer:\n      graph[u].append(v)\n\n    @functools.lru_cache(None)\n    def dfs(u: int) -> int:\n      ans = u\n\n      for v in graph[u]:\n        res = dfs(v)\n        if quiet[res] < quiet[ans]:\n          ans = res\n\n      return ans\n\n    return map(dfs, range(len(graph)))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 837, "slug": "new-21-game", "solutions": ["class Solution:\n    def new21Game(self, n: int, k: int, maxPts: int) -> float:\n        @cache\n        def dfs(i: int) -> float:\n            if i >= k:\n                return int(i <= n)\n            if i == k - 1:\n                return min(n - k + 1, maxPts) / maxPts\n            return dfs(i + 1) + (dfs(i + 1) - dfs(i + maxPts + 1)) / maxPts\n\n        return dfs(0)\n", "class Solution:\n  def new21Game(self, n: int, k: int, maxPts: int) -> float:\n    # When the game ends, the point is in [k..k - 1 maxPts].\n    #   P = 1, if n >= k - 1 + maxPts\n    #   P = 0, if n < k (note that the constraints already have k <= n)\n    if k == 0 or n >= k - 1 + maxPts:\n      return 1.0\n\n    ans = 0.0\n    dp = [1.0] + [0] * n  # dp[i] := the probability to have i points\n    windowSum = dp[0]  # P(i - 1) + P(i - 2) + ... + P(i - maxPts)\n\n    for i in range(1, n + 1):\n      # The probability to get i points is\n      # P(i) = [P(i - 1) + P(i - 2) + ... + P(i - maxPts)] / maxPts\n      dp[i] = windowSum / maxPts\n      if i < k:\n        windowSum += dp[i]\n      else:  # The game ends.\n        ans += dp[i]\n      if i - maxPts >= 0:\n        windowSum -= dp[i - maxPts]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 856, "slug": "score-of-parentheses", "solutions": ["class Solution:\n    def scoreOfParentheses(self, s: str) -> int:\n        ans = d = 0\n        for i, c in enumerate(s):\n            if c == '(':\n                d += 1\n            else:\n                d -= 1\n                if s[i - 1] == '(':\n                    ans += 1 << d\n        return ans\n", "class Solution:\n  def scoreOfParentheses(self, s: str) -> int:\n    ans = 0\n    layer = 0\n\n    for a, b in itertools.pairwise(s):\n      if a + b == '()':\n        ans += 1 << layer\n      layer += 1 if a == '(' else -1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 882, "slug": "reachable-nodes-in-subdivided-graph", "solutions": ["class Solution:\n    def reachableNodes(self, edges: List[List[int]], maxMoves: int, n: int) -> int:\n        g = defaultdict(list)\n        for u, v, cnt in edges:\n            g[u].append((v, cnt + 1))\n            g[v].append((u, cnt + 1))\n        q = [(0, 0)]\n        dist = [0] + [inf] * n\n        while q:\n            d, u = heappop(q)\n            for v, cnt in g[u]:\n                if (t := d + cnt) < dist[v]:\n                    dist[v] = t\n                    q.append((t, v))\n        ans = sum(d <= maxMoves for d in dist)\n        for u, v, cnt in edges:\n            a = min(cnt, max(0, maxMoves - dist[u]))\n            b = min(cnt, max(0, maxMoves - dist[v]))\n            ans += min(cnt, a + b)\n        return ans\n", "class Solution:\n  def reachableNodes(\n      self,\n      edges: list[list[int]],\n      maxMoves: int,\n      n: int,\n  ) -> int:\n    graph = [[] for _ in range(n)]\n    dist = [maxMoves + 1] * n\n\n    for u, v, cnt in edges:\n      graph[u].append((v, cnt))\n      graph[v].append((u, cnt))\n\n    reachableNodes = self._dijkstra(graph, 0, maxMoves, dist)\n    reachableSubnodes = 0\n\n    for u, v, cnt in edges:\n      # the number of reachable nodes of (u, v) from `u`\n      a = 0 if dist[u] > maxMoves else min(maxMoves - dist[u], cnt)\n      # the number of reachable nodes of (u, v) from `v`\n      b = 0 if dist[v] > maxMoves else min(maxMoves - dist[v], cnt)\n      reachableSubnodes += min(a + b, cnt)\n\n    return reachableNodes + reachableSubnodes\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n      maxMoves: int,\n      dist: list[int],\n  ) -> int:\n    dist[src] = 0\n    minHeap = [(dist[src], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      # Already took `maxMoves` to reach `u`, so can't explore anymore.\n      if dist[u] >= maxMoves:\n        break\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        newDist = d + w + 1\n        if newDist < dist[v]:\n          dist[v] = newDist\n          heapq.heappush(minHeap, (newDist, v))\n\n    return sum(d <= maxMoves for d in dist)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 846, "slug": "hand-of-straights", "solutions": ["class Solution:\n    def isNStraightHand(self, hand: List[int], groupSize: int) -> bool:\n        if len(hand) % groupSize:\n            return False\n        cnt = Counter(hand)\n        for x in sorted(hand):\n            if cnt[x]:\n                for y in range(x, x + groupSize):\n                    if cnt[y] == 0:\n                        return False\n                    cnt[y] -= 1\n        return True\n", "class Solution:\n  def isNStraightHand(self, hand: list[int], groupSize: int) -> bool:\n    count = collections.Counter(hand)\n\n    for start in sorted(count):\n      value = count[start]\n      if value > 0:\n        for i in range(start, start + groupSize):\n          count[i] -= value\n          if count[i] < 0:\n            return False\n\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 880, "slug": "decoded-string-at-index", "solutions": ["class Solution:\n    def decodeAtIndex(self, s: str, k: int) -> str:\n        m = 0\n        for c in s:\n            if c.isdigit():\n                m *= int(c)\n            else:\n                m += 1\n        for c in s[::-1]:\n            k %= m\n            if k == 0 and c.isalpha():\n                return c\n            if c.isdigit():\n                m //= int(c)\n            else:\n                m -= 1\n", "class Solution:\n  def decodeAtIndex(self, s: str, k: int) -> str:\n    size = 0\n\n    for c in s:\n      if c.isdigit():\n        size *= int(c)\n      else:\n        size += 1\n\n    for c in reversed(s):\n      k %= size\n      if k == 0 and c.isalpha():\n        return c\n      if c.isdigit():\n        size //= int(c)\n      else:\n        size -= 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 848, "slug": "shifting-letters", "solutions": ["class Solution:\n    def shiftingLetters(self, s: str, shifts: List[int]) -> str:\n        n, t = len(s), 0\n        s = list(s)\n        for i in range(n - 1, -1, -1):\n            t += shifts[i]\n            j = (ord(s[i]) - ord(\"a\") + t) % 26\n            s[i] = ascii_lowercase[j]\n        return \"\".join(s)\n", "class Solution:\n  def shiftingLetters(self, s: str, shifts: list[int]) -> str:\n    ans = []\n\n    for i in reversed(range(len(shifts) - 1)):\n      shifts[i] += shifts[i + 1]\n\n    for c, shift in zip(s, shifts):\n      ans.append(chr((ord(c) - ord('a') + shift) % 26 + ord('a')))\n\n    return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 811, "slug": "subdomain-visit-count", "solutions": ["class Solution:\n    def subdomainVisits(self, cpdomains: List[str]) -> List[str]:\n        cnt = Counter()\n        for s in cpdomains:\n            v = int(s[: s.index(' ')])\n            for i, c in enumerate(s):\n                if c in ' .':\n                    cnt[s[i + 1 :]] += v\n        return [f'{v} {s}' for s, v in cnt.items()]\n", "class Solution:\n  def subdomainVisits(self, cpdomains: list[str]) -> list[str]:\n    ans = []\n    count = collections.Counter()\n\n    for cpdomain in cpdomains:\n      num, domains = cpdomain.split()\n      num, domains = int(num), domains.split('.')\n      for i in reversed(range(len(domains))):\n        count['.'.join(domains[i:])] += num\n\n    return [str(freq) + ' ' + domain for domain, freq in count.items()]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 899, "slug": "orderly-queue", "solutions": ["class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n        if k == 1:\n            ans = s\n            for _ in range(len(s) - 1):\n                s = s[1:] + s[0]\n                ans = min(ans, s)\n            return ans\n        return \"\".join(sorted(s))\n", "class Solution:\n  def orderlyQueue(self, s: str, k: int) -> str:\n    return (''.join(sorted(s)) if k > 1\n            else min(s[i:] + s[:i] for i in range(len(s))))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 843, "slug": "guess-the-word", "solutions": ["# \"\"\"\n# This is Master's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# Class Master:\n#   def guess(self, word: str) -> int:\n\nclass Solution:\n  def findSecretWord(self, words: list[str], master: 'Master') -> None:\n    for _ in range(10):\n      guessedWord = words[random.randint(0, len(words) - 1)]\n      matches = master.guess(guessedWord)\n      if matches == 6:\n        break\n      words = [\n          word for word in words\n          if sum(c1 == c2 for c1, c2 in zip(guessedWord, word)) == matches]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 800, "slug": "similar-rgb-color", "solutions": ["class Solution:\n    def similarRGB(self, color: str) -> str:\n        def f(x):\n            y, z = divmod(int(x, 16), 17)\n            if z > 8:\n                y += 1\n            return '{:02x}'.format(17 * y)\n\n        a, b, c = color[1:3], color[3:5], color[5:7]\n        return f'#{f(a)}{f(b)}{f(c)}'\n", "class Solution:\n  def similarRGB(self, color: str) -> str:\n    SHORTHANDS = ['00', '11', '22', '33', '44', '55', '66', '77', '88', '99',\n                  'aa', 'bb', 'cc', 'dd', 'ee', 'ff']\n    ans = ['#']\n\n    for i in range(1, len(color), 2):\n      currValue = int(color[i:i + 2], 16)\n      closestShorthand = min(SHORTHANDS,\n                             key=lambda x: (currValue - int(x, 16))**2)\n      ans.append(closestShorthand)\n\n    return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 867, "slug": "transpose-matrix", "solutions": ["class Solution:\n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\n        return list(zip(*matrix))\n", "class Solution:\n  def transpose(self, A: list[list[int]]) -> list[list[int]]:\n    ans = [[0] * len(A) for _ in range(len(A[0]))]\n\n    for i in range(len(A)):\n      for j in range(len(A[0])):\n        ans[j][i] = A[i][j]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 886, "slug": "possible-bipartition", "solutions": ["class Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        def dfs(i, c):\n            color[i] = c\n            for j in g[i]:\n                if color[j] == c:\n                    return False\n                if color[j] == 0 and not dfs(j, 3 - c):\n                    return False\n            return True\n\n        g = defaultdict(list)\n        color = [0] * n\n        for a, b in dislikes:\n            a, b = a - 1, b - 1\n            g[a].append(b)\n            g[b].append(a)\n        return all(c or dfs(i, 1) for i, c in enumerate(color))\n", "from enum import Enum\n\n\nclass Color(Enum):\n  WHITE = 0\n  RED = 1\n  GREEN = 2\n\n\nclass Solution:\n  def possibleBipartition(self, n: int, dislikes: list[list[int]]) -> bool:\n    graph = [[] for _ in range(n + 1)]\n    colors = [Color.WHITE] * (n + 1)\n\n    for u, v in dislikes:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    # Reduce to 785. Is Graph Bipartite?\n    def isValidColor(u: int, color: Color) -> bool:\n      # Always paint red for a white node.\n      if colors[u] != Color.WHITE:\n        return colors[u] == color\n\n      colors[u] = color  # Always paint the node with `color`.\n\n      # All the children should have valid colors.\n      childrenColor = Color.RED if colors[u] == Color.GREEN else Color.GREEN\n      return all(isValidColor(v, childrenColor) for v in graph[u])\n\n    return all(colors[i] != Color.WHITE or isValidColor(i, Color.RED)\n               for i in range(1, n + 1))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 887, "slug": "super-egg-drop", "solutions": ["class Solution:\n    def superEggDrop(self, k: int, n: int) -> int:\n        @cache\n        def dfs(i: int, j: int) -> int:\n            if i < 1:\n                return 0\n            if j == 1:\n                return i\n            l, r = 1, i\n            while l < r:\n                mid = (l + r + 1) >> 1\n                a = dfs(mid - 1, j - 1)\n                b = dfs(i - mid, j)\n                if a <= b:\n                    l = mid\n                else:\n                    r = mid - 1\n            return max(dfs(l - 1, j - 1), dfs(i - l, j)) + 1\n\n        return dfs(n, k)\n", "class Solution:\n  def superEggDrop(self, k: int, n: int) -> int:\n    moves = 0\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n\n    while dp[moves][k] < n:\n      moves += 1\n      for eggs in range(1, k + 1):\n        dp[moves][eggs] = (dp[moves - 1][eggs - 1] +\n                           dp[moves - 1][eggs] + 1)\n\n    return moves\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 817, "slug": "linked-list-components", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\n        ans = 0\n        s = set(nums)\n        while head:\n            while head and head.val not in s:\n                head = head.next\n            ans += head is not None\n            while head and head.val in s:\n                head = head.next\n        return ans\n", "class Solution:\n  def numComponents(self, head: ListNode | None, nums: list[int]) -> int:\n    ans = 0\n    numsSet = set(nums)\n\n    while head:\n      if head.val in numsSet and (\n              head.next == None or head.next.val not in numsSet):\n        ans += 1\n      head = head.next\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 870, "slug": "advantage-shuffle", "solutions": ["class Solution:\n    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        nums1.sort()\n        t = sorted((v, i) for i, v in enumerate(nums2))\n        n = len(nums2)\n        ans = [0] * n\n        i, j = 0, n - 1\n        for v in nums1:\n            if v <= t[i][0]:\n                ans[t[j][1]] = v\n                j -= 1\n            else:\n                ans[t[i][1]] = v\n                i += 1\n        return ans\n", "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def advantageCount(self, nums1: list[int], nums2: list[int]) -> list[int]:\n    sl = SortedList(nums1)\n\n    for i, num in enumerate(nums2):\n      index = 0 if sl[-1] <= num else sl.bisect_right(num)\n      nums1[i] = sl[index]\n      del sl[index]\n\n    return nums1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 810, "slug": "chalkboard-xor-game", "solutions": ["class Solution:\n    def xorGame(self, nums: List[int]) -> bool:\n        return len(nums) % 2 == 0 or reduce(xor, nums) == 0\n", "class Solution:\n  def xorGame(self, nums: list[int]) -> bool:\n    return functools.reduce(operator.xor, nums) == 0 or len(nums) % 2 == 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 896, "slug": "monotonic-array", "solutions": ["class Solution:\n    def isMonotonic(self, nums: List[int]) -> bool:\n        asc = all(a <= b for a, b in pairwise(nums))\n        desc = all(a >= b for a, b in pairwise(nums))\n        return asc or desc\n", "class Solution:\n  def isMonotonic(self, nums: list[int]) -> bool:\n    increasing = True\n    decreasing = True\n\n    for i in range(1, len(nums)):\n      increasing &= nums[i - 1] <= nums[i]\n      decreasing &= nums[i - 1] >= nums[i]\n\n    return increasing or decreasing\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 845, "slug": "longest-mountain-in-array", "solutions": ["class Solution:\n    def longestMountain(self, arr: List[int]) -> int:\n        n = len(arr)\n        f = [1] * n\n        g = [1] * n\n        for i in range(1, n):\n            if arr[i] > arr[i - 1]:\n                f[i] = f[i - 1] + 1\n        ans = 0\n        for i in range(n - 2, -1, -1):\n            if arr[i] > arr[i + 1]:\n                g[i] = g[i + 1] + 1\n                if f[i] > 1:\n                    ans = max(ans, f[i] + g[i] - 1)\n        return ans\n", "class Solution:\n  def longestMountain(self, arr: list[int]) -> int:\n    ans = 0\n    i = 0\n\n    while i + 1 < len(arr):\n      while i + 1 < len(arr) and arr[i] == arr[i + 1]:\n        i += 1\n\n      increasing = 0\n      decreasing = 0\n\n      while i + 1 < len(arr) and arr[i] < arr[i + 1]:\n        increasing += 1\n        i += 1\n\n      while i + 1 < len(arr) and arr[i] > arr[i + 1]:\n        decreasing += 1\n        i += 1\n\n      if increasing > 0 and decreasing > 0:\n        ans = max(ans, increasing + decreasing + 1)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 807, "slug": "max-increase-to-keep-city-skyline", "solutions": ["class Solution:\n    def maxIncreaseKeepingSkyline(self, grid: List[List[int]]) -> int:\n        row_max = [max(row) for row in grid]\n        col_max = [max(col) for col in zip(*grid)]\n        return sum(\n            min(row_max[i], col_max[j]) - x\n            for i, row in enumerate(grid)\n            for j, x in enumerate(row)\n        )\n", "class Solution:\n  def maxIncreaseKeepingSkyline(self, grid: list[list[int]]) -> int:\n    rowMax = list(map(max, grid))\n    colMax = list(map(max, zip(*grid)))\n    return sum(min(i, j) for i in rowMax for j in colMax) - sum(map(sum, grid))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 885, "slug": "spiral-matrix-iii", "solutions": ["class Solution:\n    def spiralMatrixIII(\n        self, rows: int, cols: int, rStart: int, cStart: int\n    ) -> List[List[int]]:\n        ans = [[rStart, cStart]]\n        if rows * cols == 1:\n            return ans\n        k = 1\n        while True:\n            for dr, dc, dk in [[0, 1, k], [1, 0, k], [0, -1, k + 1], [-1, 0, k + 1]]:\n                for _ in range(dk):\n                    rStart += dr\n                    cStart += dc\n                    if 0 <= rStart < rows and 0 <= cStart < cols:\n                        ans.append([rStart, cStart])\n                        if len(ans) == rows * cols:\n                            return ans\n            k += 2\n", "class Solution:\n  def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> list[list[int]]:\n    dx = [1, 0, -1, 0]\n    dy = [0, 1, 0, -1]\n    ans = [[rStart, cStart]]\n    i = 0\n\n    while len(ans) < rows * cols:\n      for _ in range(i // 2 + 1):\n        rStart += dy[i % 4]\n        cStart += dx[i % 4]\n        if 0 <= rStart < rows and 0 <= cStart < cols:\n          ans.append([rStart, cStart])\n      i += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 823, "slug": "binary-trees-with-factors", "solutions": ["class Solution:\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\n        mod = 10**9 + 7\n        n = len(arr)\n        arr.sort()\n        idx = {v: i for i, v in enumerate(arr)}\n        f = [1] * n\n        for i, a in enumerate(arr):\n            for j in range(i):\n                b = arr[j]\n                if a % b == 0 and (c := (a // b)) in idx:\n                    f[i] = (f[i] + f[j] * f[idx[c]]) % mod\n        return sum(f) % mod\n", "class Solution:\n  def numFactoredBinaryTrees(self, arr: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(arr)\n    # dp[i] := the number of binary trees with arr[i] as the root\n    dp = [1] * n\n    arr.sort()\n    numToIndex = {a: i for i, a in enumerate(arr)}\n\n    for i, root in enumerate(arr):  # arr[i] is the root\n      for j in range(i):\n        if root % arr[j] == 0:  # arr[j] is the left subtree\n          right = root // arr[j]\n          if right in numToIndex:\n            dp[i] += dp[j] * dp[numToIndex[right]]\n            dp[i] %= MOD\n\n    return sum(dp) % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 858, "slug": "mirror-reflection", "solutions": ["class Solution:\n    def mirrorReflection(self, p: int, q: int) -> int:\n        g = gcd(p, q)\n        p = (p // g) % 2\n        q = (q // g) % 2\n        if p == 1 and q == 1:\n            return 1\n        return 0 if p == 1 else 2\n", "class Solution:\n  def mirrorReflection(self, p: int, q: int) -> int:\n    while p % 2 == 0 and q % 2 == 0:\n      p //= 2\n      q //= 2\n\n    if p % 2 == 0:\n      return 2\n    if q % 2 == 0:\n      return 0\n    return 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 819, "slug": "most-common-word", "solutions": ["class Solution:\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\n        s = set(banned)\n        p = Counter(re.findall('[a-z]+', paragraph.lower()))\n        return next(word for word, _ in p.most_common() if word not in s)\n", "class Solution:\n  def mostCommonWord(self, paragraph: str, banned: list[str]) -> str:\n    banned = set(banned)\n    words = re.findall(r'\\w+', paragraph.lower())\n    return collections.Counter(\n        word for word in words if word not in banned).most_common(1)[0][0]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 815, "slug": "bus-routes", "solutions": ["class Solution:\n    def numBusesToDestination(\n        self, routes: List[List[int]], source: int, target: int\n    ) -> int:\n        if source == target:\n            return 0\n        g = defaultdict(list)\n        for i, route in enumerate(routes):\n            for stop in route:\n                g[stop].append(i)\n        if source not in g or target not in g:\n            return -1\n        q = [(source, 0)]\n        vis_bus = set()\n        vis_stop = {source}\n        for stop, bus_count in q:\n            if stop == target:\n                return bus_count\n            for bus in g[stop]:\n                if bus not in vis_bus:\n                    vis_bus.add(bus)\n                    for next_stop in routes[bus]:\n                        if next_stop not in vis_stop:\n                            vis_stop.add(next_stop)\n                            q.append((next_stop, bus_count + 1))\n        return -1\n", "class Solution:\n  def numBusesToDestination(\n      self,\n      routes: list[list[int]],\n      source: int,\n      target: int,\n  ) -> int:\n    if source == target:\n      return 0\n\n    graph = collections.defaultdict(list)\n    usedBuses = set()\n\n    for i in range(len(routes)):\n      for route in routes[i]:\n        graph[route].append(i)\n\n    q = collections.deque([source])\n\n    step = 1\n    while q:\n      for _ in range(len(q)):\n        for bus in graph[q.popleft()]:\n          if bus in usedBuses:\n            continue\n          usedBuses.add(bus)\n          for nextRoute in routes[bus]:\n            if nextRoute == target:\n              return step\n            q.append(nextRoute)\n      step += 1\n\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 877, "slug": "stone-game", "solutions": ["class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        @cache\n        def dfs(i: int, j: int) -> int:\n            if i > j:\n                return 0\n            return max(piles[i] - dfs(i + 1, j), piles[j] - dfs(i, j - 1))\n\n        return dfs(0, len(piles) - 1) > 0\n", "class Solution:\n  def stoneGame(self, piles: list[int]) -> bool:\n    n = len(piles)\n    # dp[i][j] := the maximum stones you can get more than your opponent in piles[i..j]\n    dp = [[0] * n for _ in range(n)]\n\n    for i, pile in enumerate(piles):\n      dp[i][i] = pile\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        dp[i][j] = max(piles[i] - dp[i + 1][j],\n                       piles[j] - dp[i][j - 1])\n\n    return dp[0][n - 1] > 0\n", "class Solution:\n  def stoneGame(self, piles: list[int]) -> bool:\n    n = len(piles)\n    dp = piles.copy()\n\n    for d in range(1, n):\n      for j in range(n - 1, d - 1, -1):\n        i = j - d\n        dp[j] = max(piles[i] - dp[j], piles[j] - dp[j - 1])\n\n    return dp[n - 1] > 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 869, "slug": "reordered-power-of-2", "solutions": ["class Solution:\n    def reorderedPowerOf2(self, n: int) -> bool:\n        def convert(n):\n            cnt = [0] * 10\n            while n:\n                n, v = divmod(n, 10)\n                cnt[v] += 1\n            return cnt\n\n        i, s = 1, convert(n)\n        while i <= 10**9:\n            if convert(i) == s:\n                return True\n            i <<= 1\n        return False\n", "class Solution:\n  def reorderedPowerOf2(self, n: int) -> bool:\n    count = collections.Counter(str(n))\n    return any(Counter(str(1 << i)) == count for i in range(30))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 873, "slug": "length-of-longest-fibonacci-subsequence", "solutions": ["class Solution:\n    def lenLongestFibSubseq(self, arr: List[int]) -> int:\n        n = len(arr)\n        f = [[0] * n for _ in range(n)]\n        d = {x: i for i, x in enumerate(arr)}\n        for i in range(n):\n            for j in range(i):\n                f[i][j] = 2\n        ans = 0\n        for i in range(2, n):\n            for j in range(1, i):\n                t = arr[i] - arr[j]\n                if t in d and (k := d[t]) < j:\n                    f[i][j] = max(f[i][j], f[j][k] + 1)\n                    ans = max(ans, f[i][j])\n        return ans\n", "class Solution:\n  def lenLongestFibSubseq(self, arr: list[int]) -> int:\n    n = len(arr)\n    ans = 0\n    numToIndex = {a: i for i, a in enumerate(arr)}\n    dp = [[2] * n for _ in range(n)]\n\n    for j in range(n):\n      for k in range(j + 1, n):\n        ai = arr[k] - arr[j]\n        if ai < arr[j] and ai in numToIndex:\n          i = numToIndex[ai]\n          dp[j][k] = dp[i][j] + 1\n          ans = max(ans, dp[j][k])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 805, "slug": "split-array-with-same-average", "solutions": ["class Solution:\n    def splitArraySameAverage(self, nums: List[int]) -> bool:\n        n = len(nums)\n        if n == 1:\n            return False\n        s = sum(nums)\n        for i, v in enumerate(nums):\n            nums[i] = v * n - s\n        m = n >> 1\n        vis = set()\n        for i in range(1, 1 << m):\n            t = sum(v for j, v in enumerate(nums[:m]) if i >> j & 1)\n            if t == 0:\n                return True\n            vis.add(t)\n        for i in range(1, 1 << (n - m)):\n            t = sum(v for j, v in enumerate(nums[m:]) if i >> j & 1)\n            if t == 0 or (i != (1 << (n - m)) - 1 and -t in vis):\n                return True\n        return False\n", "class Solution:\n  def splitArraySameAverage(self, nums: list[int]) -> bool:\n    n = len(nums)\n    summ = sum(nums)\n    if not any(i * summ % n == 0 for i in range(1, n // 2 + 1)):\n      return False\n\n    sums = [set() for _ in range(n // 2 + 1)]\n    sums[0].add(0)\n\n    for num in nums:\n      for i in range(n // 2, 0, -1):\n        for val in sums[i - 1]:\n          sums[i].add(num + val)\n\n    for i in range(1, n // 2 + 1):\n      if i * summ % n == 0 and i * summ // n in sums[i]:\n        return True\n\n    return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 889, "slug": "construct-binary-tree-from-preorder-and-postorder-traversal", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def constructFromPrePost(\n        self, preorder: List[int], postorder: List[int]\n    ) -> Optional[TreeNode]:\n        def dfs(a: int, b: int, c: int, d: int) -> Optional[TreeNode]:\n            if a > b:\n                return None\n            root = TreeNode(preorder[a])\n            if a == b:\n                return root\n            i = pos[preorder[a + 1]]\n            m = i - c + 1\n            root.left = dfs(a + 1, a + m, c, i)\n            root.right = dfs(a + m + 1, b, i + 1, d - 1)\n            return root\n\n        pos = {x: i for i, x in enumerate(postorder)}\n        return dfs(0, len(preorder) - 1, 0, len(postorder) - 1)\n", "class Solution:\n  def constructFromPrePost(\n      self,\n      pre: list[int],\n      post: list[int],\n  ) -> TreeNode | None:\n    postToIndex = {num: i for i, num in enumerate(post)}\n\n    def build(preStart: int, preEnd: int, postStart: int, postEnd: int) -> TreeNode | None:\n      if preStart > preEnd:\n        return None\n      if preStart == preEnd:\n        return TreeNode(pre[preStart])\n\n      rootVal = pre[preStart]\n      leftRootVal = pre[preStart + 1]\n      leftRootPostIndex = postToIndex[leftRootVal]\n      leftSize = leftRootPostIndex - postStart + 1\n\n      root = TreeNode(rootVal)\n      root.left = build(preStart + 1, preStart + leftSize,\n                        postStart, leftRootPostIndex)\n      root.right = build(preStart + leftSize + 1, preEnd,\n                         leftRootPostIndex + 1, postEnd - 1)\n      return root\n\n    return build(0, len(pre) - 1, 0, len(post) - 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 857, "slug": "minimum-cost-to-hire-k-workers", "solutions": ["class Solution:\n    def mincostToHireWorkers(\n        self, quality: List[int], wage: List[int], k: int\n    ) -> float:\n        t = sorted(zip(quality, wage), key=lambda x: x[1] / x[0])\n        ans, tot = inf, 0\n        h = []\n        for q, w in t:\n            tot += q\n            heappush(h, -q)\n            if len(h) == k:\n                ans = min(ans, w / q * tot)\n                tot += heappop(h)\n        return ans\n", "class Solution:\n  def mincostToHireWorkers(\n      self,\n      quality: list[int],\n      wage: list[int],\n      k: int,\n  ) -> float:\n    ans = math.inf\n    qualitySum = 0\n    # (wagePerQuality, quality) sorted by wagePerQuality\n    workers = sorted((w / q, q) for q, w in zip(quality, wage))\n    maxHeap = []\n\n    for wagePerQuality, q in workers:\n      heapq.heappush(maxHeap, -q)\n      qualitySum += q\n      if len(maxHeap) > k:\n        qualitySum += heapq.heappop(maxHeap)\n      if len(maxHeap) == k:\n        ans = min(ans, qualitySum * wagePerQuality)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 881, "slug": "boats-to-save-people", "solutions": ["class Solution:\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\n        people.sort()\n        ans = 0\n        i, j = 0, len(people) - 1\n        while i <= j:\n            if people[i] + people[j] <= limit:\n                i += 1\n            j -= 1\n            ans += 1\n        return ans\n", "class Solution:\n  def numRescueBoats(self, people: list[int], limit: int) -> int:\n    ans = 0\n    i = 0\n    j = len(people) - 1\n\n    people.sort()\n\n    while i <= j:\n      remain = limit - people[j]\n      j -= 1\n      if people[i] <= remain:\n        i += 1\n      ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 897, "slug": "increasing-order-search-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def increasingBST(self, root: TreeNode) -> TreeNode:\n        def dfs(root):\n            if root is None:\n                return\n            nonlocal prev\n            dfs(root.left)\n            prev.right = root\n            root.left = None\n            prev = root\n            dfs(root.right)\n\n        dummy = prev = TreeNode(right=root)\n        dfs(root)\n        return dummy.right\n", "class Solution:\n  def increasingBST(self, root: TreeNode, tail: TreeNode = None) -> TreeNode:\n    if not root:\n      return tail\n\n    res = self.increasingBST(root.left, root)\n    root.left = None\n    root.right = self.increasingBST(root.right, tail)\n    return res\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 825, "slug": "friends-of-appropriate-ages", "solutions": ["class Solution:\n    def numFriendRequests(self, ages: List[int]) -> int:\n        cnt = [0] * 121\n        for x in ages:\n            cnt[x] += 1\n        ans = 0\n        for ax, x in enumerate(cnt):\n            for ay, y in enumerate(cnt):\n                if not (ay <= 0.5 * ax + 7 or ay > ax or (ay > 100 and ax < 100)):\n                    ans += x * (y - int(ax == ay))\n        return ans\n", "class Solution:\n  def numFriendRequests(self, ages: list[int]) -> int:\n    ans = 0\n    count = [0] * 121\n\n    for age in ages:\n      count[age] += 1\n\n    for i in range(15, 121):\n      ans += count[i] * (count[i] - 1)\n\n    for i in range(15, 121):\n      for j in range(i // 2 + 8, i):\n        ans += count[i] * count[j]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 879, "slug": "profitable-schemes", "solutions": ["class Solution:\n    def profitableSchemes(\n        self, n: int, minProfit: int, group: List[int], profit: List[int]\n    ) -> int:\n        @cache\n        def dfs(i: int, j: int, k: int) -> int:\n            if i >= len(group):\n                return 1 if k == minProfit else 0\n            ans = dfs(i + 1, j, k)\n            if j + group[i] <= n:\n                ans += dfs(i + 1, j + group[i], min(k + profit[i], minProfit))\n            return ans % (10**9 + 7)\n\n        return dfs(0, 0, 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 802, "slug": "find-eventual-safe-states", "solutions": ["class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        rg = defaultdict(list)\n        indeg = [0] * len(graph)\n        for i, vs in enumerate(graph):\n            for j in vs:\n                rg[j].append(i)\n            indeg[i] = len(vs)\n        q = deque([i for i, v in enumerate(indeg) if v == 0])\n        while q:\n            i = q.popleft()\n            for j in rg[i]:\n                indeg[j] -= 1\n                if indeg[j] == 0:\n                    q.append(j)\n        return [i for i, v in enumerate(indeg) if v == 0]\n", "from enum import Enum\n\n\nclass State(Enum):\n  INIT = 0\n  VISITING = 1\n  VISITED = 2\n\n\nclass Solution:\n  def eventualSafeNodes(self, graph: list[list[int]]) -> list[int]:\n    states = [State.INIT] * len(graph)\n\n    def hasCycle(u: int) -> bool:\n      if states[u] == State.VISITING:\n        return True\n      if states[u] == State.VISITED:\n        return False\n      states[u] = State.VISITING\n      if any(hasCycle(v) for v in graph[u]):\n        return True\n      states[u] = State.VISITED\n      return False\n\n    return [i for i in range(len(graph)) if not hasCycle(i)]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 842, "slug": "split-array-into-fibonacci-sequence", "solutions": ["class Solution:\n    def splitIntoFibonacci(self, num: str) -> List[int]:\n        def dfs(i):\n            if i == n:\n                return len(ans) > 2\n            x = 0\n            for j in range(i, n):\n                if j > i and num[i] == '0':\n                    break\n                x = x * 10 + int(num[j])\n                if x > 2**31 - 1 or (len(ans) > 2 and x > ans[-2] + ans[-1]):\n                    break\n                if len(ans) < 2 or ans[-2] + ans[-1] == x:\n                    ans.append(x)\n                    if dfs(j + 1):\n                        return True\n                    ans.pop()\n            return False\n\n        n = len(num)\n        ans = []\n        dfs(0)\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 854, "slug": "k-similar-strings", "solutions": ["class Solution:\n    def kSimilarity(self, s1: str, s2: str) -> int:\n        def next(s):\n            i = 0\n            while s[i] == s2[i]:\n                i += 1\n            res = []\n            for j in range(i + 1, n):\n                if s[j] == s2[i] and s[j] != s2[j]:\n                    res.append(s2[: i + 1] + s[i + 1 : j] + s[i] + s[j + 1 :])\n            return res\n\n        q = deque([s1])\n        vis = {s1}\n        ans, n = 0, len(s1)\n        while 1:\n            for _ in range(len(q)):\n                s = q.popleft()\n                if s == s2:\n                    return ans\n                for nxt in next(s):\n                    if nxt not in vis:\n                        vis.add(nxt)\n                        q.append(nxt)\n            ans += 1\n", "class Solution:\n  def kSimilarity(self, s1: str, s2: str) -> int:\n    q = collections.deque([s1])\n    seen = {s1}\n\n    step = 0\n    while q:\n      for _ in range(len(q)):\n        curr = q.popleft()\n        if curr == s2:\n          return step\n        for child in self._getChildren(curr, s2):\n          if child in seen:\n            continue\n          q.append(child)\n          seen.add(child)\n      step += 1\n\n    return -1\n\n  def _getChildren(self, curr: str, target: str) -> list[str]:\n    children = []\n    s = list(curr)\n    i = 0  # the first index s.t. curr[i] != target[i]\n    while curr[i] == target[i]:\n      i += 1\n\n    for j in range(i + 1, len(s)):\n      if s[j] == target[i]:\n        s[i], s[j] = s[j], s[i]\n        children.append(''.join(s))\n        s[i], s[j] = s[j], s[i]\n\n    return children\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 863, "slug": "all-nodes-distance-k-in-binary-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\n\nclass Solution:\n    def distanceK(self, root: TreeNode, target: TreeNode, k: int) -> List[int]:\n        def dfs(root, fa):\n            if root is None:\n                return\n            g[root] = fa\n            dfs(root.left, root)\n            dfs(root.right, root)\n\n        def dfs2(root, fa, k):\n            if root is None:\n                return\n            if k == 0:\n                ans.append(root.val)\n                return\n            for nxt in (root.left, root.right, g[root]):\n                if nxt != fa:\n                    dfs2(nxt, root, k - 1)\n\n        g = {}\n        dfs(root, None)\n        ans = []\n        dfs2(target, None, k)\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 847, "slug": "shortest-path-visiting-all-nodes", "solutions": ["class Solution:\n    def shortestPathLength(self, graph: List[List[int]]) -> int:\n        n = len(graph)\n        q = deque()\n        vis = set()\n        for i in range(n):\n            q.append((i, 1 << i))\n            vis.add((i, 1 << i))\n        ans = 0\n        while 1:\n            for _ in range(len(q)):\n                i, st = q.popleft()\n                if st == (1 << n) - 1:\n                    return ans\n                for j in graph[i]:\n                    nst = st | 1 << j\n                    if (j, nst) not in vis:\n                        vis.add((j, nst))\n                        q.append((j, nst))\n            ans += 1\n", "class Solution:\n  def shortestPathLength(self, graph: list[list[int]]) -> int:\n    n = len(graph)\n    goal = (1 << n) - 1\n    q = collections.deque()  # (u, state)\n    seen = set()\n\n    for i in range(n):\n      q.append((i, 1 << i))\n\n    step = 0\n    while q:\n      for _ in range(len(q)):\n        u, state = q.popleft()\n        if state == goal:\n          return step\n        if (u, state) in seen:\n          continue\n        seen.add((u, state))\n        for v in graph[u]:\n          q.append((v, state | 1 << v))\n      step += 1\n\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 860, "slug": "lemonade-change", "solutions": ["class Solution:\n    def lemonadeChange(self, bills: List[int]) -> bool:\n        five = ten = 0\n        for v in bills:\n            if v == 5:\n                five += 1\n            elif v == 10:\n                ten += 1\n                five -= 1\n            else:\n                if ten:\n                    ten -= 1\n                    five -= 1\n                else:\n                    five -= 3\n            if five < 0:\n                return False\n        return True\n", "class Solution:\n  def lemonadeChange(self, bills: list[int]) -> bool:\n    fives = 0\n    tens = 0\n\n    for bill in bills:\n      if bill == 5:\n        fives += 1\n      elif bill == 10:\n        fives -= 1\n        tens += 1\n      else:  # bill == 20\n        if tens > 0:\n          tens -= 1\n          fives -= 1\n        else:\n          fives -= 3\n      if fives < 0:\n        return False\n\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 841, "slug": "keys-and-rooms", "solutions": ["class Solution:\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\n        def dfs(i: int):\n            if i in vis:\n                return\n            vis.add(i)\n            for j in rooms[i]:\n                dfs(j)\n\n        vis = set()\n        dfs(0)\n        return len(vis) == len(rooms)\n", "class Solution:\n  def canVisitAllRooms(self, rooms: list[list[int]]) -> bool:\n    seen = [False] * len(rooms)\n\n    def dfs(node: int) -> None:\n      seen[node] = True\n      for child in rooms[node]:\n        if not seen[child]:\n          dfs(child)\n\n    dfs(0)\n    return all(seen)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 892, "slug": "surface-area-of-3d-shapes", "solutions": ["class Solution:\n    def surfaceArea(self, grid: List[List[int]]) -> int:\n        ans = 0\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                if v:\n                    ans += 2 + v * 4\n                    if i:\n                        ans -= min(v, grid[i - 1][j]) * 2\n                    if j:\n                        ans -= min(v, grid[i][j - 1]) * 2\n        return ans\n", "class Solution:\n  def surfaceArea(self, grid: list[list[int]]) -> int:\n    ans = 0\n\n    for i in range(len(grid)):\n      for j in range(len(grid)):\n        if grid[i][j]:\n          ans += grid[i][j] * 4 + 2\n        if i > 0:\n          ans -= min(grid[i][j], grid[i - 1][j]) * 2\n        if j > 0:\n          ans -= min(grid[i][j], grid[i][j - 1]) * 2\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 866, "slug": "prime-palindrome", "solutions": ["class Solution:\n    def primePalindrome(self, n: int) -> int:\n        def is_prime(x):\n            if x < 2:\n                return False\n            v = 2\n            while v * v <= x:\n                if x % v == 0:\n                    return False\n                v += 1\n            return True\n\n        def reverse(x):\n            res = 0\n            while x:\n                res = res * 10 + x % 10\n                x //= 10\n            return res\n\n        while 1:\n            if reverse(n) == n and is_prime(n):\n                return n\n            if 10**7 < n < 10**8:\n                n = 10**8\n            n += 1\n", "class Solution:\n  def primePalindrome(self, n: int) -> int:\n    def getPalindromes(n: int) -> int:\n      length = n // 2\n      for i in range(10**(length - 1), 10**length):\n        s = str(i)\n        for j in range(10):\n          yield int(s + str(j) + s[::-1])\n\n    def isPrime(num: int) -> bool:\n      return not any(num % i == 0 for i in range(2, int(num**0.5 + 1)))\n\n    if n <= 2:\n      return 2\n    if n == 3:\n      return 3\n    if n <= 5:\n      return 5\n    if n <= 7:\n      return 7\n    if n <= 11:\n      return 11\n\n    nLength = len(str(n))\n\n    while True:\n      for num in getPalindromes(nLength):\n        if num >= n and isPrime(num):\n          return num\n      nLength += 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 836, "slug": "rectangle-overlap", "solutions": ["class Solution:\n    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:\n        x1, y1, x2, y2 = rec1\n        x3, y3, x4, y4 = rec2\n        return not (y3 >= y2 or y4 <= y1 or x3 >= x2 or x4 <= x1)\n", "class Solution:\n  def isRectangleOverlap(self, rec1: list[int], rec2: list[int]) -> bool:\n    return rec1[0] < rec2[2] and rec2[0] < rec1[2] and rec1[1] < rec2[3] and rec2[1] < rec1[3]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 814, "slug": "binary-tree-pruning", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def pruneTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        if root is None:\n            return root\n        root.left = self.pruneTree(root.left)\n        root.right = self.pruneTree(root.right)\n        if root.val == 0 and root.left == root.right:\n            return None\n        return root\n", "class Solution:\n  def pruneTree(self, root: TreeNode | None) -> TreeNode | None:\n    if not root:\n      return None\n    root.left = self.pruneTree(root.left)\n    root.right = self.pruneTree(root.right)\n    if not root.left and not root.right and not root.val:\n      return None\n    return root\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 861, "slug": "score-after-flipping-matrix", "solutions": ["class Solution:\n    def matrixScore(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        for i in range(m):\n            if grid[i][0] == 0:\n                for j in range(n):\n                    grid[i][j] ^= 1\n        ans = 0\n        for j in range(n):\n            cnt = sum(grid[i][j] for i in range(m))\n            ans += max(cnt, m - cnt) * (1 << (n - j - 1))\n        return ans\n", "class Solution:\n  def matrixScore(self, grid: list[list[int]]) -> int:\n    # Flip the rows with a leading 0.\n    for row in grid:\n      if row[0] == 0:\n        self._flip(row)\n\n    # Flip the columns with 1s < 0s.\n    for j, col in enumerate(list(zip(*grid))):\n      if sum(col) * 2 < len(grid):\n        self._flipCol(grid, j)\n\n    # Add a binary number for each row.\n    return sum(self._binary(row) for row in grid)\n\n  def _flip(self, row: list[int]) -> None:\n    for i in range(len(row)):\n      row[i] ^= 1\n\n  def _flipCol(self, grid: list[list[int]], j: int) -> None:\n    for i in range(len(grid)):\n      grid[i][j] ^= 1\n\n  def _binary(self, row: list[int]) -> int:\n    res = row[0]\n    for j in range(1, len(row)):\n      res = res * 2 + row[j]\n    return res\n", "class Solution:\n  def matrixScore(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = m  # All the cells in the first column are 1.\n\n    for j in range(1, n):\n      # The best strategy is flipping the rows with a leading 0..\n      onesCount = sum(grid[i][j] == grid[i][0] for i in range(m))\n      ans = ans * 2 + max(onesCount, m - onesCount)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 840, "slug": "magic-squares-in-grid", "solutions": ["class Solution:\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\n        def check(i: int, j: int) -> int:\n            if i + 3 > m or j + 3 > n:\n                return 0\n            s = set()\n            row = [0] * 3\n            col = [0] * 3\n            a = b = 0\n            for x in range(i, i + 3):\n                for y in range(j, j + 3):\n                    v = grid[x][y]\n                    if v < 1 or v > 9:\n                        return 0\n                    s.add(v)\n                    row[x - i] += v\n                    col[y - j] += v\n                    if x - i == y - j:\n                        a += v\n                    if x - i == 2 - (y - j):\n                        b += v\n            if len(s) != 9 or a != b:\n                return 0\n            if any(x != a for x in row) or any(x != a for x in col):\n                return 0\n            return 1\n\n        m, n = len(grid), len(grid[0])\n        return sum(check(i, j) for i in range(m) for j in range(n))\n", "class Solution:\n  def numMagicSquaresInside(self, grid: list[list[int]]) -> int:\n    def isMagic(i: int, j: int) -> int:\n      s = \"\".join(str(grid[i + num // 3][j + num % 3])\n                  for num in [0, 1, 2, 5, 8, 7, 6, 3])\n      return s in \"43816729\" * 2 or s in \"43816729\"[::-1] * 2\n\n    ans = 0\n\n    for i in range(len(grid) - 2):\n      for j in range(len(grid[0]) - 2):\n        if grid[i][j] % 2 == 0 and grid[i + 1][j + 1] == 5:\n          ans += isMagic(i, j)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 874, "slug": "walking-robot-simulation", "solutions": ["class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        dirs = (0, 1, 0, -1, 0)\n        s = {(x, y) for x, y in obstacles}\n        ans = k = 0\n        x = y = 0\n        for c in commands:\n            if c == -2:\n                k = (k + 3) % 4\n            elif c == -1:\n                k = (k + 1) % 4\n            else:\n                for _ in range(c):\n                    nx, ny = x + dirs[k], y + dirs[k + 1]\n                    if (nx, ny) in s:\n                        break\n                    x, y = nx, ny\n                    ans = max(ans, x * x + y * y)\n        return ans\n", "class Solution:\n  def robotSim(self, commands: list[int], obstacles: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    ans = 0\n    d = 0  # 0 := north, 1 := east, 2 := south, 3 := west\n    x = 0  # the start x\n    y = 0  # the start y\n    obstaclesSet = {(x, y) for x, y in obstacles}\n\n    for command in commands:\n      if command == -1:\n        d = (d + 1) % 4\n      elif command == -2:\n        d = (d + 3) % 4\n      else:\n        for _ in range(command):\n          if (x + DIRS[d][0], y + DIRS[d][1]) in obstaclesSet:\n            break\n          x += DIRS[d][0]\n          y += DIRS[d][1]\n      ans = max(ans, x * x + y * y)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 878, "slug": "nth-magical-number", "solutions": ["class Solution:\n    def nthMagicalNumber(self, n: int, a: int, b: int) -> int:\n        mod = 10**9 + 7\n        c = lcm(a, b)\n        r = (a + b) * n\n        return bisect_left(range(r), x=n, key=lambda x: x // a + x // b - x // c) % mod\n", "class Solution:\n  def nthMagicalNumber(self, n: int, a: int, b: int) -> int:\n    lcm = a * b // math.gcd(a, b)\n    l = min(a, b)\n    r = min(a, b) * n\n    ans = bisect.bisect_left(range(l, r), n,\n                             key=lambda m: m // a + m // b - m // lcm) + l\n    return ans % (10**9 + 7)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 844, "slug": "backspace-string-compare", "solutions": ["class Solution:\n    def backspaceCompare(self, s: str, t: str) -> bool:\n        i, j, skip1, skip2 = len(s) - 1, len(t) - 1, 0, 0\n        while i >= 0 or j >= 0:\n            while i >= 0:\n                if s[i] == '#':\n                    skip1 += 1\n                    i -= 1\n                elif skip1:\n                    skip1 -= 1\n                    i -= 1\n                else:\n                    break\n            while j >= 0:\n                if t[j] == '#':\n                    skip2 += 1\n                    j -= 1\n                elif skip2:\n                    skip2 -= 1\n                    j -= 1\n                else:\n                    break\n            if i >= 0 and j >= 0:\n                if s[i] != t[j]:\n                    return False\n            elif i >= 0 or j >= 0:\n                return False\n            i, j = i - 1, j - 1\n        return True\n", "class Solution:\n  def backspaceCompare(self, s: str, t: str) -> bool:\n    def backspace(s: str) -> str:\n      stack = []\n      for c in s:\n        if c != '#':\n          stack.append(c)\n        elif stack:\n          stack.pop()\n      return stack\n\n    return backspace(s) == backspace(t)\n", "class Solution:\n  def backspaceCompare(self, s: str, t: str) -> bool:\n    i = len(s) - 1  # s' index\n    j = len(t) - 1  # t's index\n\n    while True:\n      # Delete characters of s if needed.\n      backspace = 0\n      while i >= 0 and (s[i] == '#' or backspace > 0):\n        backspace += 1 if s[i] == '#' else -1\n        i -= 1\n      # Delete characters of t if needed.\n      backspace = 0\n      while j >= 0 and (t[j] == '#' or backspace > 0):\n        backspace += 1 if t[j] == '#' else -1\n        j -= 1\n      if i >= 0 and j >= 0 and s[i] == t[j]:\n        i -= 1\n        j -= 1\n      else:\n        break\n\n    return i == -1 and j == -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 831, "slug": "masking-personal-information", "solutions": ["class Solution:\n    def maskPII(self, s: str) -> str:\n        if s[0].isalpha():\n            s = s.lower()\n            return s[0] + '*****' + s[s.find('@') - 1 :]\n        s = ''.join(c for c in s if c.isdigit())\n        cnt = len(s) - 10\n        suf = '***-***-' + s[-4:]\n        return suf if cnt == 0 else f'+{\"*\" * cnt}-{suf}'\n", "class Solution:\n  def maskPII(self, s: str) -> str:\n    atIndex = s.find('@')\n    if atIndex != -1:\n      s = s.lower()\n      return s[0] + '*' * 5 + s[atIndex - 1:]\n\n    ans = ''.join(c for c in s if c.isdigit())\n\n    if len(ans) == 10:\n      return '***-***-' + ans[-4:]\n    return '+' + '*' * (len(ans) - 10) + '-***-***-' + ans[-4:]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 828, "slug": "count-unique-characters-of-all-substrings-of-a-given-string", "solutions": ["class Solution:\n    def uniqueLetterString(self, s: str) -> int:\n        d = defaultdict(list)\n        for i, c in enumerate(s):\n            d[c].append(i)\n        ans = 0\n        for v in d.values():\n            v = [-1] + v + [len(s)]\n            for i in range(1, len(v) - 1):\n                ans += (v[i] - v[i - 1]) * (v[i + 1] - v[i])\n        return ans\n", "class Solution:\n  def uniqueLetterString(self, s: str) -> int:\n    ans = 0\n    # lastSeen[c] := the index of the last time ('a' + i) appeared\n    lastSeen = collections.defaultdict(lambda: -1)\n    # prevSeen[c] := the previous index of the last time ('a' + i) appeared\n    prevLastSeen = collections.defaultdict(lambda: -1)\n\n    for i, c in enumerate(s):\n      if c in lastSeen:\n        ans += (i - lastSeen[c]) * (lastSeen[c] - prevLastSeen[c])\n      prevLastSeen[c] = lastSeen[c]\n      lastSeen[c] = i\n\n    for c in string.ascii_uppercase:\n      ans += (len(s) - lastSeen[c]) * (lastSeen[c] - prevLastSeen[c])\n\n    return ans\n", "class Solution:\n  def uniqueLetterString(self, s: str) -> int:\n    ans = 0\n    # the number of unique letters in all the substrings ending in the index so\n    # far\n    dp = 0\n    lastCount = {}\n    lastSeen = {}\n\n    for i, c in enumerate(s):\n      newCount = i - lastSeen.get(c, -1)\n      # Substract the duplicates.\n      dp -= lastCount.get(c, 0)\n      # Add count of s[lastSeen[c] + 1..i], s[lastSeen[c] + 2..i], ..., s[i].\n      dp += newCount\n      lastCount[c] = newCount\n      lastSeen[c] = i\n      ans += dp\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 876, "slug": "middle-of-the-linked-list", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        slow = fast = head\n        while fast and fast.next:\n            slow, fast = slow.next, fast.next.next\n        return slow\n", "class Solution:\n  def middleNode(self, head: ListNode) -> ListNode:\n    slow = head\n    fast = head\n\n    while fast and fast.next:\n      slow = slow.next\n      fast = fast.next.next\n\n    return slow\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 824, "slug": "goat-latin", "solutions": ["class Solution:\n    def toGoatLatin(self, sentence: str) -> str:\n        ans = []\n        for i, word in enumerate(sentence.split()):\n            if word.lower()[0] not in ['a', 'e', 'i', 'o', 'u']:\n                word = word[1:] + word[0]\n            word += 'ma'\n            word += 'a' * (i + 1)\n            ans.append(word)\n        return ' '.join(ans)\n", "class Solution:\n  def toGoatLatin(self, sentence: str) -> str:\n    ans = []\n    VOWELS = 'aeiouAEIOU'\n\n    i = 1\n    for word in sentence.split():\n      if i > 1:\n        ans.append(' ')\n      if word[0] in VOWELS:\n        ans.append(word)\n      else:\n        ans.append(word[1:] + word[0])\n      ans.append('ma' + 'a' * i)\n      i += 1\n\n    return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 855, "slug": "exam-room", "solutions": ["class ExamRoom:\n    def __init__(self, n: int):\n        def dist(x):\n            l, r = x\n            return r - l - 1 if l == -1 or r == n else (r - l) >> 1\n\n        self.n = n\n        self.ts = SortedList(key=lambda x: (-dist(x), x[0]))\n        self.left = {}\n        self.right = {}\n        self.add((-1, n))\n\n    def seat(self) -> int:\n        s = self.ts[0]\n        p = (s[0] + s[1]) >> 1\n        if s[0] == -1:\n            p = 0\n        elif s[1] == self.n:\n            p = self.n - 1\n        self.delete(s)\n        self.add((s[0], p))\n        self.add((p, s[1]))\n        return p\n\n    def leave(self, p: int) -> None:\n        l, r = self.left[p], self.right[p]\n        self.delete((l, p))\n        self.delete((p, r))\n        self.add((l, r))\n\n    def add(self, s):\n        self.ts.add(s)\n        self.left[s[1]] = s[0]\n        self.right[s[0]] = s[1]\n\n    def delete(self, s):\n        self.ts.remove(s)\n        self.left.pop(s[1])\n        self.right.pop(s[0])\n\n\n# Your ExamRoom object will be instantiated and called as such:\n# obj = ExamRoom(n)\n# param_1 = obj.seat()\n# obj.leave(p)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 890, "slug": "find-and-replace-pattern", "solutions": ["class Solution:\n    def findAndReplacePattern(self, words: List[str], pattern: str) -> List[str]:\n        def match(s, t):\n            m1, m2 = [0] * 128, [0] * 128\n            for i, (a, b) in enumerate(zip(s, t), 1):\n                if m1[ord(a)] != m2[ord(b)]:\n                    return False\n                m1[ord(a)] = m2[ord(b)] = i\n            return True\n\n        return [word for word in words if match(word, pattern)]\n", "class Solution:\n  def findAndReplacePattern(self, words: list[str], pattern: str) -> list[str]:\n    def isIsomorphic(w: str, p: str) -> bool:\n      return [*map(w.index, w)] == [*map(p.index, p)]\n    return [word for word in words if isIsomorphic(word, pattern)]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 813, "slug": "largest-sum-of-averages", "solutions": ["class Solution:\n    def largestSumOfAverages(self, nums: List[int], k: int) -> float:\n        @cache\n        def dfs(i: int, k: int) -> float:\n            if i == n:\n                return 0\n            if k == 1:\n                return (s[n] - s[i]) / (n - i)\n            ans = 0\n            for j in range(i + 1, n):\n                ans = max(ans, (s[j] - s[i]) / (j - i) + dfs(j, k - 1))\n            return ans\n\n        n = len(nums)\n        s = list(accumulate(nums, initial=0))\n        return dfs(0, k)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 827, "slug": "making-a-large-island", "solutions": ["class Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        def dfs(i: int, j: int):\n            p[i][j] = root\n            cnt[root] += 1\n            for a, b in pairwise(dirs):\n                x, y = i + a, j + b\n                if 0 <= x < n and 0 <= y < n and grid[x][y] and p[x][y] == 0:\n                    dfs(x, y)\n\n        n = len(grid)\n        cnt = Counter()\n        p = [[0] * n for _ in range(n)]\n        dirs = (-1, 0, 1, 0, -1)\n        root = 0\n        for i, row in enumerate(grid):\n            for j, x in enumerate(row):\n                if x and p[i][j] == 0:\n                    root += 1\n                    dfs(i, j)\n        ans = max(cnt.values() or [0])\n        for i, row in enumerate(grid):\n            for j, x in enumerate(row):\n                if x == 0:\n                    s = set()\n                    for a, b in pairwise(dirs):\n                        x, y = i + a, j + b\n                        if 0 <= x < n and 0 <= y < n:\n                            s.add(p[x][y])\n                    ans = max(ans, sum(cnt[root] for root in s) + 1)\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 826, "slug": "most-profit-assigning-work", "solutions": ["class Solution:\n    def maxProfitAssignment(\n        self, difficulty: List[int], profit: List[int], worker: List[int]\n    ) -> int:\n        worker.sort()\n        jobs = sorted(zip(difficulty, profit))\n        ans = mx = i = 0\n        for w in worker:\n            while i < len(jobs) and jobs[i][0] <= w:\n                mx = max(mx, jobs[i][1])\n                i += 1\n            ans += mx\n        return ans\n", "class Solution:\n  def maxProfitAssignment(\n      self,\n      difficulty: list[int],\n      profit: list[int],\n      worker: list[int],\n  ) -> int:\n    ans = 0\n    jobs = sorted(zip(difficulty, profit))\n    worker.sort(reverse=1)\n\n    i = 0\n    maxProfit = 0\n\n    for w in sorted(worker):\n      while i < len(jobs) and w >= jobs[i][0]:\n        maxProfit = max(maxProfit, jobs[i][1])\n        i += 1\n      ans += maxProfit\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 864, "slug": "shortest-path-to-get-all-keys", "solutions": ["class Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        m, n = len(grid), len(grid[0])\n        #  (si, sj)\n        si, sj = next((i, j) for i in range(m) for j in range(n) if grid[i][j] == '@')\n        # \n        k = sum(v.islower() for row in grid for v in row)\n        dirs = (-1, 0, 1, 0, -1)\n        q = deque([(si, sj, 0)])\n        vis = {(si, sj, 0)}\n        ans = 0\n        while q:\n            for _ in range(len(q)):\n                i, j, state = q.popleft()\n                # \n                if state == (1 << k) - 1:\n                    return ans\n\n                # \n                for a, b in pairwise(dirs):\n                    x, y = i + a, j + b\n                    nxt = state\n                    # \n                    if 0 <= x < m and 0 <= y < n:\n                        c = grid[x][y]\n                        # \n                        if (\n                            c == '#'\n                            or c.isupper()\n                            and (state & (1 << (ord(c) - ord('A')))) == 0\n                        ):\n                            continue\n                        # \n                        if c.islower():\n                            # \n                            nxt |= 1 << (ord(c) - ord('a'))\n                        # \n                        if (x, y, nxt) not in vis:\n                            vis.add((x, y, nxt))\n                            q.append((x, y, nxt))\n            # \n            ans += 1\n        return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 809, "slug": "expressive-words", "solutions": ["class Solution:\n    def expressiveWords(self, s: str, words: List[str]) -> int:\n        def check(s, t):\n            m, n = len(s), len(t)\n            if n > m:\n                return False\n            i = j = 0\n            while i < m and j < n:\n                if s[i] != t[j]:\n                    return False\n                k = i\n                while k < m and s[k] == s[i]:\n                    k += 1\n                c1 = k - i\n                i, k = k, j\n                while k < n and t[k] == t[j]:\n                    k += 1\n                c2 = k - j\n                j = k\n                if c1 < c2 or (c1 < 3 and c1 != c2):\n                    return False\n            return i == m and j == n\n\n        return sum(check(s, t) for t in words)\n", "class Solution:\n  def expressiveWords(self, s: str, words: list[str]) -> int:\n    def isStretchy(word: str) -> bool:\n      n = len(s)\n      m = len(word)\n\n      j = 0\n      for i in range(n):\n        if j < m and s[i] == word[j]:\n          j += 1\n        elif i > 1 and s[i] == s[i - 1] == s[i - 2]:\n          continue\n        elif 0 < i < n - 1 and s[i - 1] == s[i] == s[i + 1]:\n          continue\n        else:\n          return False\n\n      return j == m\n\n    return sum(isStretchy(word) for word in words)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 834, "slug": "sum-of-distances-in-tree", "solutions": ["class Solution:\n    def sumOfDistancesInTree(self, n: int, edges: List[List[int]]) -> List[int]:\n        def dfs1(i: int, fa: int, d: int):\n            ans[0] += d\n            size[i] = 1\n            for j in g[i]:\n                if j != fa:\n                    dfs1(j, i, d + 1)\n                    size[i] += size[j]\n\n        def dfs2(i: int, fa: int, t: int):\n            ans[i] = t\n            for j in g[i]:\n                if j != fa:\n                    dfs2(j, i, t - size[j] + n - size[j])\n\n        g = defaultdict(list)\n        for a, b in edges:\n            g[a].append(b)\n            g[b].append(a)\n\n        ans = [0] * n\n        size = [0] * n\n        dfs1(0, -1, 0)\n        dfs2(0, -1, ans[0])\n        return ans\n", "class Solution:\n  def sumOfDistancesInTree(self, n: int, edges: list[list[int]]) -> list[int]:\n    ans = [0] * n\n    count = [1] * n\n    tree = [set() for _ in range(n)]\n\n    for u, v in edges:\n      tree[u].add(v)\n      tree[v].add(u)\n\n    def postorder(u: int, prev: int) -> None:\n      for v in tree[u]:\n        if v == prev:\n          continue\n        postorder(v, u)\n        count[u] += count[v]\n        ans[u] += ans[v] + count[v]\n\n    def preorder(u: int, prev: int) -> None:\n      for v in tree[u]:\n        if v == prev:\n          continue\n        # count[v] us are 1 step closer from v than prev.\n        # (n - count[v]) us are 1 step farther from v than prev.\n        ans[v] = ans[u] - count[v] + (n - count[v])\n        preorder(v, u)\n\n    postorder(0, -1)\n    preorder(0, -1)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 850, "slug": "rectangle-area-ii", "solutions": ["class Node:\n    def __init__(self):\n        self.l = self.r = 0\n        self.cnt = self.length = 0\n\n\nclass SegmentTree:\n    def __init__(self, nums):\n        n = len(nums) - 1\n        self.nums = nums\n        self.tr = [Node() for _ in range(n << 2)]\n        self.build(1, 0, n - 1)\n\n    def build(self, u, l, r):\n        self.tr[u].l, self.tr[u].r = l, r\n        if l != r:\n            mid = (l + r) >> 1\n            self.build(u << 1, l, mid)\n            self.build(u << 1 | 1, mid + 1, r)\n\n    def modify(self, u, l, r, k):\n        if self.tr[u].l >= l and self.tr[u].r <= r:\n            self.tr[u].cnt += k\n        else:\n            mid = (self.tr[u].l + self.tr[u].r) >> 1\n            if l <= mid:\n                self.modify(u << 1, l, r, k)\n            if r > mid:\n                self.modify(u << 1 | 1, l, r, k)\n        self.pushup(u)\n\n    def pushup(self, u):\n        if self.tr[u].cnt:\n            self.tr[u].length = self.nums[self.tr[u].r + 1] - self.nums[self.tr[u].l]\n        elif self.tr[u].l == self.tr[u].r:\n            self.tr[u].length = 0\n        else:\n            self.tr[u].length = self.tr[u << 1].length + self.tr[u << 1 | 1].length\n\n    @property\n    def length(self):\n        return self.tr[1].length\n\n\nclass Solution:\n    def rectangleArea(self, rectangles: List[List[int]]) -> int:\n        segs = []\n        alls = set()\n        for x1, y1, x2, y2 in rectangles:\n            segs.append((x1, y1, y2, 1))\n            segs.append((x2, y1, y2, -1))\n            alls.update([y1, y2])\n\n        segs.sort()\n        alls = sorted(alls)\n        tree = SegmentTree(alls)\n        m = {v: i for i, v in enumerate(alls)}\n        ans = 0\n        for i, (x, y1, y2, k) in enumerate(segs):\n            if i:\n                ans += tree.length * (x - segs[i - 1][0])\n            tree.modify(1, m[y1], m[y2] - 1, k)\n        ans %= int(1e9 + 7)\n        return ans\n", "class Solution:\n  def rectangleArea(self, rectangles: list[list[int]]) -> int:\n    events = []\n\n    for x1, y1, x2, y2 in rectangles:\n      events.append((x1, y1, y2, 's'))\n      events.append((x2, y1, y2, 'e'))\n\n    events.sort(key=lambda x: x[0])\n\n    ans = 0\n    prevX = 0\n    yPairs = []\n\n    def getHeight(yPairs: list[tuple[int, int]]) -> int:\n      height = 0\n      prevY = 0\n\n      for y1, y2 in yPairs:\n        prevY = max(prevY, y1)\n        if y2 > prevY:\n          height += y2 - prevY\n          prevY = y2\n\n      return height\n\n    for currX, y1, y2, type in events:\n      if currX > prevX:\n        width = currX - prevX\n        ans += width * getHeight(yPairs)\n        prevX = currX\n      if type == 's':\n        yPairs.append((y1, y2))\n        yPairs.sort()\n      else:  # type == 'e'\n        yPairs.remove((y1, y2))\n\n    return ans % (10**9 + 7)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 868, "slug": "binary-gap", "solutions": ["class Solution:\n    def binaryGap(self, n: int) -> int:\n        ans = 0\n        pre, cur = inf, 0\n        while n:\n            if n & 1:\n                ans = max(ans, cur - pre)\n                pre = cur\n            cur += 1\n            n >>= 1\n        return ans\n", "class Solution:\n  def binaryGap(self, n: int) -> int:\n    ans = 0\n    d = -32  # the distance between any two 1s\n\n    while n:\n      if n % 2 == 1:\n        ans = max(ans, d)\n        d = 0\n      n //= 2\n      d += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 884, "slug": "uncommon-words-from-two-sentences", "solutions": ["class Solution:\n    def uncommonFromSentences(self, s1: str, s2: str) -> List[str]:\n        cnt = Counter(s1.split()) + Counter(s2.split())\n        return [s for s, v in cnt.items() if v == 1]\n", "class Solution:\n  def uncommonFromSentences(self, A: str, B: str) -> list[str]:\n    count = collections.Counter((A + ' ' + B).split())\n    return [word for word, freq in count.items() if freq == 1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 806, "slug": "number-of-lines-to-write-string", "solutions": ["class Solution:\n    def numberOfLines(self, widths: List[int], s: str) -> List[int]:\n        lines, last = 1, 0\n        for w in map(lambda c: widths[ord(c) - ord(\"a\")], s):\n            if last + w <= 100:\n                last += w\n            else:\n                lines += 1\n                last = w\n        return [lines, last]\n", "class Solution:\n  def numberOfLines(self, widths: list[int], s: str) -> list[int]:\n    numLines = 1\n    runningWidth = 0\n\n    for c in s:\n      width = widths[ord(c) - ord('a')]\n      if runningWidth + width <= 100:\n        runningWidth += width\n      else:\n        numLines += 1\n        runningWidth = width\n\n    return [numLines, runningWidth]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 808, "slug": "soup-servings", "solutions": ["class Solution:\n    def soupServings(self, n: int) -> float:\n        @cache\n        def dfs(i: int, j: int) -> float:\n            if i <= 0 and j <= 0:\n                return 0.5\n            if i <= 0:\n                return 1\n            if j <= 0:\n                return 0\n            return 0.25 * (\n                dfs(i - 4, j)\n                + dfs(i - 3, j - 1)\n                + dfs(i - 2, j - 2)\n                + dfs(i - 1, j - 3)\n            )\n\n        return 1 if n > 4800 else dfs((n + 24) // 25, (n + 24) // 25)\n", "class Solution:\n  def soupServings(self, n: int) -> float:\n    @functools.lru_cache(None)\n    def dfs(a: int, b: int) -> float:\n      if a <= 0 and b <= 0:\n        return 0.5\n      if a <= 0:\n        return 1.0\n      if b <= 0:\n        return 0.0\n      return 0.25 * (dfs(a - 4, b) +\n                     dfs(a - 3, b - 1) +\n                     dfs(a - 2, b - 2) +\n                     dfs(a - 1, b - 3))\n\n    return 1 if n >= 4800 else dfs((n + 24) // 25, (n + 24) // 25)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 816, "slug": "ambiguous-coordinates", "solutions": ["class Solution:\n    def ambiguousCoordinates(self, s: str) -> List[str]:\n        def f(i, j):\n            res = []\n            for k in range(1, j - i + 1):\n                l, r = s[i : i + k], s[i + k : j]\n                ok = (l == '0' or not l.startswith('0')) and not r.endswith('0')\n                if ok:\n                    res.append(l + ('.' if k < j - i else '') + r)\n            return res\n\n        n = len(s)\n        return [\n            f'({x}, {y})' for i in range(2, n - 1) for x in f(1, i) for y in f(i, n - 1)\n        ]\n", "class Solution:\n  def ambiguousCoordinates(self, s: str) -> list[str]:\n    def splits(s: str) -> list[str]:\n      if not s or len(s) > 1 and s[0] == s[-1] == '0':\n        return []\n      if s[-1] == '0':\n        return [s]\n      if s[0] == '0':\n        return [s[0] + '.' + s[1:]]\n      return [s] + [s[:i] + '.' + s[i:] for i in range(1, len(s))]\n\n    ans = []\n    s = s[1:-1]\n\n    for i in range(1, len(s)):\n      for x in splits(s[:i]):\n        for y in splits(s[i:]):\n          ans.append('(%s, %s)' % (x, y))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 822, "slug": "card-flipping-game", "solutions": ["class Solution:\n    def flipgame(self, fronts: List[int], backs: List[int]) -> int:\n        s = {a for a, b in zip(fronts, backs) if a == b}\n        return min((x for x in chain(fronts, backs) if x not in s), default=0)\n", "class Solution:\n  def flipgame(self, fronts: list[int], backs: list[int]) -> int:\n    same = {front\n            for front, back in zip(fronts, backs)\n            if front == back}\n    return min([num for num in fronts + backs\n                if num not in same] or [0])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 820, "slug": "short-encoding-of-words", "solutions": ["class Trie:\n    def __init__(self) -> None:\n        self.children = [None] * 26\n\n\nclass Solution:\n    def minimumLengthEncoding(self, words: List[str]) -> int:\n        root = Trie()\n        for w in words:\n            cur = root\n            for c in w[::-1]:\n                idx = ord(c) - ord(\"a\")\n                if cur.children[idx] == None:\n                    cur.children[idx] = Trie()\n                cur = cur.children[idx]\n        return self.dfs(root, 1)\n\n    def dfs(self, cur: Trie, l: int) -> int:\n        isLeaf, ans = True, 0\n        for i in range(26):\n            if cur.children[i] != None:\n                isLeaf = False\n                ans += self.dfs(cur.children[i], l + 1)\n        if isLeaf:\n            ans += l\n        return ans\n", "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.depth = 0\n\n\nclass Solution:\n  def minimumLengthEncoding(self, words: list[str]) -> int:\n    root = TrieNode()\n    leaves = []\n\n    def insert(word: str) -> TrieNode:\n      node = root\n      for c in reversed(word):\n        node = node.children.setdefault(c, TrieNode())\n      node.depth = len(word)\n      return node\n\n    for word in set(words):\n      leaves.append(insert(word))\n\n    return sum(leaf.depth + 1 for leaf in leaves\n               if not len(leaf.children))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 871, "slug": "minimum-number-of-refueling-stops", "solutions": ["class Solution:\n    def minRefuelStops(\n        self, target: int, startFuel: int, stations: List[List[int]]\n    ) -> int:\n        pq = []\n        ans = pre = 0\n        stations.append([target, 0])\n        for pos, fuel in stations:\n            dist = pos - pre\n            startFuel -= dist\n            while startFuel < 0 and pq:\n                startFuel -= heappop(pq)\n                ans += 1\n            if startFuel < 0:\n                return -1\n            heappush(pq, -fuel)\n            pre = pos\n        return ans\n", "class Solution:\n  def minRefuelStops(\n      self,\n      target: int,\n      startFuel: int,\n      stations: list[list[int]],\n  ) -> int:\n    # dp[i] := the farthest position we can reach w / i refuels\n    dp = [startFuel] + [0] * len(stations)\n\n    for i, station in enumerate(stations):\n      for j in range(i + 1, 0, -1):\n        if dp[j - 1] >= station[0]:\n          dp[j] = max(dp[j], dp[j - 1] + station[1])\n\n    for i, d in enumerate(dp):\n      if d >= target:\n        return i\n\n    return -1\n", "class Solution:\n  def minRefuelStops(\n      self,\n      target: int,\n      startFuel: int,\n      stations: list[list[int]],\n  ) -> int:\n    ans = 0\n    i = 0  # station's index\n    curr = startFuel\n    maxHeap = []\n\n    while curr < target:\n      # Add all the reachable stops to maxHeap\n      while i < len(stations) and stations[i][0] <= curr:\n        heapq.heappush(maxHeap, -stations[i][1])\n        i += 1\n      if not maxHeap:  # Can't be refueled.\n        return -1\n      curr -= heapq.heappop(maxHeap)  # Pop out the largest gas.\n      ans += 1  # Then, refuel once.\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 849, "slug": "maximize-distance-to-closest-person", "solutions": ["class Solution:\n    def maxDistToClosest(self, seats: List[int]) -> int:\n        first = last = None\n        d = 0\n        for i, c in enumerate(seats):\n            if c:\n                if last is not None:\n                    d = max(d, i - last)\n                if first is None:\n                    first = i\n                last = i\n        return max(first, len(seats) - last - 1, d // 2)\n", "class Solution:\n  def maxDistToClosest(self, seats: list[int]) -> int:\n    n = len(seats)\n    ans = 0\n    j = -1\n\n    for i in range(n):\n      if seats[i] == 1:\n        ans = i if j == -1 else max(ans, (i - j) // 2)\n        j = i\n\n    return max(ans, n - j - 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 818, "slug": "race-car", "solutions": ["class Solution:\n    def racecar(self, target: int) -> int:\n        dp = [0] * (target + 1)\n        for i in range(1, target + 1):\n            k = i.bit_length()\n            if i == 2**k - 1:\n                dp[i] = k\n                continue\n            dp[i] = dp[2**k - 1 - i] + k + 1\n            for j in range(k - 1):\n                dp[i] = min(dp[i], dp[i - (2 ** (k - 1) - 2**j)] + k - 1 + j + 2)\n        return dp[target]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 853, "slug": "car-fleet", "solutions": ["class Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        idx = sorted(range(len(position)), key=lambda i: position[i])\n        ans = pre = 0\n        for i in idx[::-1]:\n            t = (target - position[i]) / speed[i]\n            if t > pre:\n                ans += 1\n                pre = t\n        return ans\n", "class Solution:\n  def carFleet(self, target: int, position: list[int], speed: list[int]) -> int:\n    ans = 0\n    times = [\n        float(target - p) / s for p, s in sorted(zip(position, speed),\n                                                 reverse=True)]\n    maxTime = 0  # the time of the slowest car to reach the target\n\n    for time in times:\n      # A car needs more time to reach the target, so it becomes the slowest.\n      if time > maxTime:\n        maxTime = time\n        ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 804, "slug": "unique-morse-code-words", "solutions": ["class Solution:\n    def uniqueMorseRepresentations(self, words: List[str]) -> int:\n        codes = [\n            \".-\",\n            \"-...\",\n            \"-.-.\",\n            \"-..\",\n            \".\",\n            \"..-.\",\n            \"--.\",\n            \"....\",\n            \"..\",\n            \".---\",\n            \"-.-\",\n            \".-..\",\n            \"--\",\n            \"-.\",\n            \"---\",\n            \".--.\",\n            \"--.-\",\n            \".-.\",\n            \"...\",\n            \"-\",\n            \"..-\",\n            \"...-\",\n            \".--\",\n            \"-..-\",\n            \"-.--\",\n            \"--..\",\n        ]\n        s = {''.join([codes[ord(c) - ord('a')] for c in word]) for word in words}\n        return len(s)\n", "class Solution:\n  def uniqueMorseRepresentations(self, words: list[str]) -> int:\n    morse = [\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\",\n             \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\",\n             \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"]\n    transformations = set()\n\n    for word in words:\n      transformation = ''.join(\n          morse[ord(c) - ord('a')] for c in word)\n      transformations.add(transformation)\n\n    return len(transformations)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 872, "slug": "leaf-similar-trees", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def leafSimilar(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:\n        def dfs(root: Optional[TreeNode], nums: List[int]) -> None:\n            if root.left == root.right:\n                nums.append(root.val)\n                return\n            if root.left:\n                dfs(root.left, nums)\n            if root.right:\n                dfs(root.right, nums)\n\n        l1, l2 = [], []\n        dfs(root1, l1)\n        dfs(root2, l2)\n        return l1 == l2\n", "class Solution:\n  def leafSimilar(self, root1: TreeNode | None, root2: TreeNode | None) -> bool:\n    def dfs(root: TreeNode | None) -> None:\n      if not root:\n        return\n      if not root.left and not root.right:\n        yield root.val\n        return\n\n      yield from dfs(root.left)\n      yield from dfs(root.right)\n\n    return list(dfs(root1)) == list(dfs(root2))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 839, "slug": "similar-string-groups", "solutions": ["class UnionFind:\n    def __init__(self, n):\n        self.p = list(range(n))\n        self.size = [1] * n\n\n    def find(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n\n    def union(self, a, b):\n        pa, pb = self.find(a), self.find(b)\n        if pa == pb:\n            return False\n        if self.size[pa] > self.size[pb]:\n            self.p[pb] = pa\n            self.size[pa] += self.size[pb]\n        else:\n            self.p[pa] = pb\n            self.size[pb] += self.size[pa]\n        return True\n\n\nclass Solution:\n    def numSimilarGroups(self, strs: List[str]) -> int:\n        n, m = len(strs), len(strs[0])\n        uf = UnionFind(n)\n        for i, s in enumerate(strs):\n            for j, t in enumerate(strs[:i]):\n                if sum(s[k] != t[k] for k in range(m)) <= 2 and uf.union(i, j):\n                    n -= 1\n        return n\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 835, "slug": "image-overlap", "solutions": ["class Solution:\n    def largestOverlap(self, img1: List[List[int]], img2: List[List[int]]) -> int:\n        n = len(img1)\n        cnt = Counter()\n        for i in range(n):\n            for j in range(n):\n                if img1[i][j]:\n                    for h in range(n):\n                        for k in range(n):\n                            if img2[h][k]:\n                                cnt[(i - h, j - k)] += 1\n        return max(cnt.values()) if cnt else 0\n", "class Solution:\n  def largestOverlap(self, img1: list[list[int]], img2: list[list[int]]) -> int:\n    MAGIC = 100\n    ones1 = [(i, j)\n             for i, row in enumerate(img1)\n             for j, num in enumerate(row)\n             if num == 1]\n    ones2 = [(i, j)\n             for i, row in enumerate(img2)\n             for j, num in enumerate(row)\n             if num == 1]\n    offsetCount = collections.Counter()\n\n    for ax, ay in ones1:\n      for bx, by in ones2:\n        offsetCount[(ax - bx) * MAGIC + (ay - by)] += 1\n\n    return max(offsetCount.values()) if offsetCount else 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 859, "slug": "buddy-strings", "solutions": ["class Solution:\n    def buddyStrings(self, s: str, goal: str) -> bool:\n        m, n = len(s), len(goal)\n        if m != n:\n            return False\n        cnt1, cnt2 = Counter(s), Counter(goal)\n        if cnt1 != cnt2:\n            return False\n        diff = sum(s[i] != goal[i] for i in range(n))\n        return diff == 2 or (diff == 0 and any(v > 1 for v in cnt1.values()))\n", "class Solution:\n  def buddyStrings(self, s: str, goal: str) -> bool:\n    if len(s) != len(goal):\n      return False\n    if s == goal and len(set(s)) < len(s):\n      return True\n    diffIndices = [i for i, (a, b) in enumerate(zip(s, goal))\n                   if a != b]\n    return (len(diffIndices) == 2 and\n            s[diffIndices[0]] == goal[diffIndices[1]] and\n            s[diffIndices[1]] == goal[diffIndices[0]])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 883, "slug": "projection-area-of-3d-shapes", "solutions": ["class Solution:\n    def projectionArea(self, grid: List[List[int]]) -> int:\n        xy = sum(v > 0 for row in grid for v in row)\n        yz = sum(max(row) for row in grid)\n        zx = sum(max(col) for col in zip(*grid))\n        return xy + yz + zx\n", "class Solution:\n  def projectionArea(self, grid: list[list[int]]) -> int:\n    return sum(\n        a > 0 for row in grid for a in row) + sum(\n        max(row) for row in grid) + sum(\n        max(col) for col in zip(*grid))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 803, "slug": "bricks-falling-when-hit", "solutions": ["class Solution:\n    def hitBricks(self, grid: List[List[int]], hits: List[List[int]]) -> List[int]:\n        def find(x):\n            if p[x] != x:\n                p[x] = find(p[x])\n            return p[x]\n\n        def union(a, b):\n            pa, pb = find(a), find(b)\n            if pa != pb:\n                size[pb] += size[pa]\n                p[pa] = pb\n\n        m, n = len(grid), len(grid[0])\n        p = list(range(m * n + 1))\n        size = [1] * len(p)\n        g = deepcopy(grid)\n        for i, j in hits:\n            g[i][j] = 0\n        for j in range(n):\n            if g[0][j] == 1:\n                union(j, m * n)\n        for i in range(1, m):\n            for j in range(n):\n                if g[i][j] == 0:\n                    continue\n                if g[i - 1][j] == 1:\n                    union(i * n + j, (i - 1) * n + j)\n                if j > 0 and g[i][j - 1] == 1:\n                    union(i * n + j, i * n + j - 1)\n        ans = []\n        for i, j in hits[::-1]:\n            if grid[i][j] == 0:\n                ans.append(0)\n                continue\n            g[i][j] = 1\n            prev = size[find(m * n)]\n            if i == 0:\n                union(j, m * n)\n            for a, b in [(-1, 0), (1, 0), (0, 1), (0, -1)]:\n                x, y = i + a, j + b\n                if 0 <= x < m and 0 <= y < n and g[x][y] == 1:\n                    union(i * n + j, x * n + y)\n            curr = size[find(m * n)]\n            ans.append(max(0, curr - prev - 1))\n        return ans[::-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 888, "slug": "fair-candy-swap", "solutions": ["class Solution:\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\n        diff = (sum(aliceSizes) - sum(bobSizes)) >> 1\n        s = set(bobSizes)\n        for a in aliceSizes:\n            if (b := (a - diff)) in s:\n                return [a, b]\n", "class Solution:\n  def fairCandySwap(\n      self,\n      aliceSizes: list[int],\n      bobSizes: list[int],\n  ) -> list[int]:\n    diff = (sum(aliceSizes) - sum(bobSizes)) // 2\n    bobSizesSet = set(bobSizes)\n\n    for aliceSize in aliceSizes:\n      target = aliceSize - diff\n      if target in bobSizesSet:\n        return [aliceSize, target]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1873, "slug": "calculate-special-bonus", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1839, "slug": "longest-substring-of-all-vowels-in-order", "solutions": ["class Solution:\n    def longestBeautifulSubstring(self, word: str) -> int:\n        arr = []\n        n = len(word)\n        i = 0\n        while i < n:\n            j = i\n            while j < n and word[j] == word[i]:\n                j += 1\n            arr.append((word[i], j - i))\n            i = j\n        ans = 0\n        for i in range(len(arr) - 4):\n            a, b, c, d, e = arr[i : i + 5]\n            if a[0] + b[0] + c[0] + d[0] + e[0] == \"aeiou\":\n                ans = max(ans, a[1] + b[1] + c[1] + d[1] + e[1])\n        return ans\n", "class Solution:\n  def longestBeautifulSubstring(self, word: str) -> int:\n    ans = 0\n    count = 1\n\n    l = 0\n    for r in range(1, len(word)):\n      curr = word[r]\n      prev = word[r - 1]\n      if curr >= prev:\n        if curr > prev:\n          count += 1\n        if count == 5:\n          ans = max(ans, r - l + 1)\n      else:\n        count = 1\n        l = r\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1834, "slug": "single-threaded-cpu", "solutions": ["class Solution:\n    def getOrder(self, tasks: List[List[int]]) -> List[int]:\n        for i, task in enumerate(tasks):\n            task.append(i)\n        tasks.sort()\n        ans = []\n        q = []\n        n = len(tasks)\n        i = t = 0\n        while q or i < n:\n            if not q:\n                t = max(t, tasks[i][0])\n            while i < n and tasks[i][0] <= t:\n                heappush(q, (tasks[i][1], tasks[i][2]))\n                i += 1\n            pt, j = heappop(q)\n            ans.append(j)\n            t += pt\n        return ans\n", "class Solution:\n  def getOrder(self, tasks: list[list[int]]) -> list[int]:\n    n = len(tasks)\n    A = [[*task, i] for i, task in enumerate(tasks)]\n    ans = []\n    minHeap = []\n    i = 0  # tasks' index\n    time = 0  # the current time\n\n    A.sort()\n\n    while i < n or minHeap:\n      if not minHeap:\n        time = max(time, A[i][0])\n      while i < n and time >= A[i][0]:\n        heapq.heappush(minHeap, (A[i][1], A[i][2]))\n        i += 1\n      procTime, index = heapq.heappop(minHeap)\n      time += procTime\n      ans.append(index)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1888, "slug": "minimum-number-of-flips-to-make-the-binary-string-alternating", "solutions": ["class Solution:\n    def minFlips(self, s: str) -> int:\n        n = len(s)\n        target = \"01\"\n        cnt = sum(c != target[i & 1] for i, c in enumerate(s))\n        ans = min(cnt, n - cnt)\n        for i in range(n):\n            cnt -= s[i] != target[i & 1]\n            cnt += s[i] != target[(i + n) & 1]\n            ans = min(ans, cnt, n - cnt)\n        return ans\n", "class Solution:\n  def minFlips(self, s: str) -> int:\n    n = len(s)\n    # count[0][0] :=  the number of '0' in the even indices\n    # count[0][1] :=  the number of '0' in the odd indices\n    # count[1][0] :=  the number of '1' in the even indices\n    # count[1][1] :=  the number of '1' in the odd indices\n    count = [[0] * 2 for _ in range(2)]\n\n    for i, c in enumerate(s):\n      count[int(c)][i % 2] += 1\n\n    # min(make all 0s in the even indices + make all 1s in the odd indices,\n    #     make all 1s in the even indices + make all 0s in the odd indices)\n    ans = min(count[1][0] + count[0][1], count[0][0] + count[1][1])\n\n    for i, c in enumerate(s):\n      count[int(c)][i % 2] -= 1\n      count[int(c)][(n + i) % 2] += 1\n      ans = min(ans, count[1][0] + count[0][1], count[0][0] + count[1][1])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1885, "slug": "count-pairs-in-two-arrays", "solutions": ["class Solution:\n    def countPairs(self, nums1: List[int], nums2: List[int]) -> int:\n        nums = [a - b for a, b in zip(nums1, nums2)]\n        nums.sort()\n        l, r = 0, len(nums) - 1\n        ans = 0\n        while l < r:\n            while l < r and nums[l] + nums[r] <= 0:\n                l += 1\n            ans += r - l\n            r -= 1\n        return ans\n", "class Solution:\n  def countPairs(self, nums1: list[int], nums2: list[int]) -> int:\n    ans = 0\n    arr = sorted([x - y for x, y in zip(nums1, nums2)])\n\n    for i, a in enumerate(arr):\n      index = bisect_left(arr, -a + 1)\n      ans += len(arr) - max(i + 1, index)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1806, "slug": "minimum-number-of-operations-to-reinitialize-a-permutation", "solutions": ["class Solution:\n    def reinitializePermutation(self, n: int) -> int:\n        ans, i = 0, 1\n        while 1:\n            ans += 1\n            if i < n >> 1:\n                i <<= 1\n            else:\n                i = (i - (n >> 1)) << 1 | 1\n            if i == 1:\n                return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1880, "slug": "check-if-word-equals-summation-of-two-words", "solutions": ["class Solution:\n    def isSumEqual(self, firstWord: str, secondWord: str, targetWord: str) -> bool:\n        def f(s: str) -> int:\n            ans, a = 0, ord(\"a\")\n            for c in map(ord, s):\n                x = c - a\n                ans = ans * 10 + x\n            return ans\n\n        return f(firstWord) + f(secondWord) == f(targetWord)\n", "class Solution:\n  def isSumEqual(\n      self,\n      firstWord: str,\n      secondWord: str,\n      targetWord: str,\n  ) -> bool:\n    first = self._getNumber(firstWord)\n    second = self._getNumber(secondWord)\n    target = self._getNumber(targetWord)\n    return first + second == target\n\n  def _getNumber(self, word: str) -> int:\n    num = 0\n    for c in word:\n      num = num * 10 + ord(c) - ord('a')\n    return num\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1867, "slug": "orders-with-maximum-quantity-above-average", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1874, "slug": "minimize-product-sum-of-two-arrays", "solutions": ["class Solution:\n    def minProductSum(self, nums1: List[int], nums2: List[int]) -> int:\n        nums1.sort()\n        nums2.sort(reverse=True)\n        return sum(x * y for x, y in zip(nums1, nums2))\n", "class Solution:\n  def minProductSum(self, nums1: list[int], nums2: list[int]) -> int:\n    return sum([a * b for a, b in zip(sorted(nums1), sorted(nums2, reverse=True))])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1804, "slug": "implement-trie-ii-prefix-tree", "solutions": ["class Trie:\n    def __init__(self):\n        self.children = [None] * 26\n        self.v = self.pv = 0\n\n    def insert(self, word: str) -> None:\n        node = self\n        for c in word:\n            idx = ord(c) - ord('a')\n            if node.children[idx] is None:\n                node.children[idx] = Trie()\n            node = node.children[idx]\n            node.pv += 1\n        node.v += 1\n\n    def countWordsEqualTo(self, word: str) -> int:\n        node = self.search(word)\n        return 0 if node is None else node.v\n\n    def countWordsStartingWith(self, prefix: str) -> int:\n        node = self.search(prefix)\n        return 0 if node is None else node.pv\n\n    def erase(self, word: str) -> None:\n        node = self\n        for c in word:\n            idx = ord(c) - ord('a')\n            node = node.children[idx]\n            node.pv -= 1\n        node.v -= 1\n\n    def search(self, word):\n        node = self\n        for c in word:\n            idx = ord(c) - ord('a')\n            if node.children[idx] is None:\n                return None\n            node = node.children[idx]\n        return node\n\n\n# Your Trie object will be instantiated and called as such:\n# obj = Trie()\n# obj.insert(word)\n# param_2 = obj.countWordsEqualTo(word)\n# param_3 = obj.countWordsStartingWith(prefix)\n# obj.erase(word)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1832, "slug": "check-if-the-sentence-is-pangram", "solutions": ["class Solution:\n    def checkIfPangram(self, sentence: str) -> bool:\n        return len(set(sentence)) == 26\n", "class Solution:\n  def checkIfPangram(self, sentence: str) -> bool:\n    seen = 0\n\n    for c in sentence:\n      seen |= 1 << ord(c) - ord('a')\n\n    return seen == (1 << 26) - 1\n", "class Solution:\n  def checkIfPangram(self, sentence: str) -> bool:\n    return len(set(sentence)) == 26\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1878, "slug": "get-biggest-three-rhombus-sums-in-a-grid", "solutions": ["class Solution:\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\n        m, n = len(grid), len(grid[0])\n        s1 = [[0] * (n + 2) for _ in range(m + 1)]\n        s2 = [[0] * (n + 2) for _ in range(m + 1)]\n        for i, row in enumerate(grid, 1):\n            for j, x in enumerate(row, 1):\n                s1[i][j] = s1[i - 1][j - 1] + x\n                s2[i][j] = s2[i - 1][j + 1] + x\n        ss = SortedSet()\n        for i, row in enumerate(grid, 1):\n            for j, x in enumerate(row, 1):\n                l = min(i - 1, m - i, j - 1, n - j)\n                ss.add(x)\n                for k in range(1, l + 1):\n                    a = s1[i + k][j] - s1[i][j - k]\n                    b = s1[i][j + k] - s1[i - k][j]\n                    c = s2[i][j - k] - s2[i - k][j]\n                    d = s2[i + k][j] - s2[i][j + k]\n                    ss.add(\n                        a + b + c + d - grid[i + k - 1][j - 1] + grid[i - k - 1][j - 1]\n                    )\n                while len(ss) > 3:\n                    ss.remove(ss[0])\n        return list(ss)[::-1]\n", "from sortedcontainers import SortedSet\n\n\nclass Solution:\n  def getBiggestThree(self, grid: list[list[int]]) -> list[int]:\n    m = len(grid)\n    n = len(grid[0])\n    sums = SortedSet()\n\n    for i in range(m):\n      for j in range(n):\n        sz = 0\n        while i + sz < m and i - sz >= 0 and j + 2 * sz < n:\n          summ = grid[i][j] if sz == 0 else self._getSum(grid, i, j, sz)\n          sums.add(summ)\n          if len(sums) > 3:\n            sums.pop(0)\n          sz += 1\n\n    return sums\n\n  def _getSum(self, grid: list[list[int]], i: int, j: int, sz: int) -> int:\n    \"\"\"\n    Returns the sum of the rhombus, where the top grid is (i, j) and the edge\n    size is `sz`.\n    \"\"\"\n    x = i\n    y = j\n    summ = 0\n\n    # Go left down.\n    for _ in range(sz):\n      x -= 1\n      y += 1\n      summ += grid[x][y]\n\n    # Go right down.\n    for _ in range(sz):\n      x += 1\n      y += 1\n      summ += grid[x][y]\n\n    # Go right up.\n    for _ in range(sz):\n      x += 1\n      y -= 1\n      summ += grid[x][y]\n\n    # Go left up.\n    for _ in range(sz):\n      x -= 1\n      y -= 1\n      summ += grid[x][y]\n\n    return summ\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1842, "slug": "next-palindrome-using-same-digits", "solutions": ["class Solution:\n    def nextPalindrome(self, num: str) -> str:\n        def next_permutation(nums: List[str]) -> bool:\n            n = len(nums) // 2\n            i = n - 2\n            while i >= 0 and nums[i] >= nums[i + 1]:\n                i -= 1\n            if i < 0:\n                return False\n            j = n - 1\n            while j >= 0 and nums[j] <= nums[i]:\n                j -= 1\n            nums[i], nums[j] = nums[j], nums[i]\n            nums[i + 1 : n] = nums[i + 1 : n][::-1]\n            return True\n\n        nums = list(num)\n        if not next_permutation(nums):\n            return \"\"\n        n = len(nums)\n        for i in range(n // 2):\n            nums[n - i - 1] = nums[i]\n        return \"\".join(nums)\n", "class Solution:\n  def nextPalindrome(self, num: str) -> str:\n    def nextPermutation(nums: list[int]) -> bool:\n      n = len(nums)\n\n      # From the back to the front, find the first num < nums[i + 1].\n      i = n - 2\n      while i >= 0:\n        if nums[i] < nums[i + 1]:\n          break\n        i -= 1\n\n      if i < 0:\n        return False\n\n      # From the back to the front, find the first num > nums[i] and swap it\n      # with nums[i].\n      for j in range(n - 1, i, -1):\n        if nums[j] > nums[i]:\n          nums[i], nums[j] = nums[j], nums[i]\n          break\n\n      def reverse(nums, l, r):\n        while l < r:\n          nums[l], nums[r] = nums[r], nums[l]\n          l += 1\n          r -= 1\n\n      # Reverse nums[i + 1..n - 1].\n      reverse(nums, i + 1, len(nums) - 1)\n      return True\n\n    n = len(num)\n    arr = [int(num[i]) for i in range(len(num) // 2)]\n    if not nextPermutation(arr):\n      return ''\n\n    s = ''.join([chr(ord('0') + a) for a in arr])\n    if n % 2 == 1:\n      return s + num[n // 2] + s[::-1]\n    return s + s[::-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1861, "slug": "rotating-the-box", "solutions": ["class Solution:\n    def rotateTheBox(self, box: List[List[str]]) -> List[List[str]]:\n        m, n = len(box), len(box[0])\n        ans = [[None] * m for _ in range(n)]\n        for i in range(m):\n            for j in range(n):\n                ans[j][m - i - 1] = box[i][j]\n        for j in range(m):\n            q = deque()\n            for i in range(n - 1, -1, -1):\n                if ans[i][j] == '*':\n                    q.clear()\n                elif ans[i][j] == '.':\n                    q.append(i)\n                elif q:\n                    ans[q.popleft()][j] = '#'\n                    ans[i][j] = '.'\n                    q.append(i)\n        return ans\n", "class Solution:\n  def rotateTheBox(self, box: list[list[str]]) -> list[list[str]]:\n    m = len(box)\n    n = len(box[0])\n    rotated = [['.'] * m for _ in range(n)]\n\n    for i in range(m):\n      k = n - 1\n      for j in reversed(range(n)):\n        if box[i][j] != '.':\n          if box[i][j] == '*':\n            k = j\n          rotated[k][m - i - 1] = box[i][j]\n          k -= 1\n\n    return [''.join(row) for row in rotated]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1899, "slug": "merge-triplets-to-form-target-triplet", "solutions": ["class Solution:\n    def mergeTriplets(self, triplets: List[List[int]], target: List[int]) -> bool:\n        x, y, z = target\n        d = e = f = 0\n        for a, b, c in triplets:\n            if a <= x and b <= y and c <= z:\n                d = max(d, a)\n                e = max(e, b)\n                f = max(f, c)\n        return [d, e, f] == target\n", "class Solution:\n  def mergeTriplets(self, triplets: list[list[int]], target: list[int]) -> bool:\n    merged = [0] * len(target)\n\n    for triplet in triplets:\n      if all(a <= b for a, b in zip(triplet, target)):\n        for i in range(3):\n          merged[i] = max(merged[i], triplet[i])\n\n    return merged == target\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1818, "slug": "minimum-absolute-sum-difference", "solutions": ["class Solution:\n    def minAbsoluteSumDiff(self, nums1: List[int], nums2: List[int]) -> int:\n        mod = 10**9 + 7\n        nums = sorted(nums1)\n        s = sum(abs(a - b) for a, b in zip(nums1, nums2)) % mod\n        mx = 0\n        for a, b in zip(nums1, nums2):\n            d1, d2 = abs(a - b), inf\n            i = bisect_left(nums, b)\n            if i < len(nums):\n                d2 = min(d2, abs(nums[i] - b))\n            if i:\n                d2 = min(d2, abs(nums[i - 1] - b))\n            mx = max(mx, d1 - d2)\n        return (s - mx + mod) % mod\n", "class Solution:\n  def minAbsoluteSumDiff(self, nums1: list[int], nums2: list[int]) -> int:\n    ans = math.inf\n    diffs = [abs(a - b) for a, b in zip(nums1, nums2)]\n    sumDiff = sum(diffs)\n\n    nums1.sort()\n\n    for num, diff in zip(nums2, diffs):\n      i = bisect.bisect_left(nums1, num)\n      if i > 0:\n        ans = min(ans, sumDiff - diff + abs(num - nums1[i - 1]))\n      if i < len(nums1):\n        ans = min(ans, sumDiff - diff + abs(num - nums1[i]))\n\n    return ans % 1_000_000_007\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1833, "slug": "maximum-ice-cream-bars", "solutions": ["class Solution:\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\n        costs.sort()\n        for i, c in enumerate(costs):\n            if coins < c:\n                return i\n            coins -= c\n        return len(costs)\n", "class Solution:\n  def maxIceCream(self, costs: list[int], coins: int) -> int:\n    for i, cost in enumerate(sorted(costs)):\n      if coins >= cost:\n        coins -= cost\n      else:\n        return i\n\n    return len(costs)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1815, "slug": "maximum-number-of-groups-getting-fresh-donuts", "solutions": ["class Solution:\n    def maxHappyGroups(self, batchSize: int, groups: List[int]) -> int:\n        @cache\n        def dfs(state, mod):\n            res = 0\n            x = int(mod == 0)\n            for i in range(1, batchSize):\n                if state >> (i * 5) & 31:\n                    t = dfs(state - (1 << (i * 5)), (mod + i) % batchSize)\n                    res = max(res, t + x)\n            return res\n\n        state = ans = 0\n        for v in groups:\n            i = v % batchSize\n            ans += i == 0\n            if i:\n                state += 1 << (i * 5)\n        ans += dfs(state, 0)\n        return ans\n", "class Solution:\n  def maxHappyGroups(self, batchSize: int, groups: list[int]) -> int:\n    happy = 0\n    freq = [0] * batchSize\n\n    for g in groups:\n      g %= batchSize\n      if g == 0:\n        happy += 1\n      elif freq[batchSize - g]:\n        freq[batchSize - g] -= 1\n        happy += 1\n      else:\n        freq[g] += 1\n\n    @functools.lru_cache(None)\n    def dp(freq: int, remainder: int) -> int:\n      \"\"\"Returns the maximum number of partitions can be formed.\"\"\"\n      ans = 0\n      if any(freq):\n        for i, f in enumerate(freq):\n          if f:\n            ans = max(ans, dp(freq[:i] + (f - 1,) +\n                              freq[i + 1:], (remainder + i) % batchSize))\n        if remainder == 0:\n          ans += 1\n      return ans\n\n    return happy + dp(tuple(freq), 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1883, "slug": "minimum-skips-to-arrive-at-meeting-on-time", "solutions": ["class Solution:\n    def minSkips(self, dist: List[int], speed: int, hoursBefore: int) -> int:\n        n = len(dist)\n        f = [[inf] * (n + 1) for _ in range(n + 1)]\n        f[0][0] = 0\n        eps = 1e-8\n        for i, x in enumerate(dist, 1):\n            for j in range(i + 1):\n                if j < i:\n                    f[i][j] = min(f[i][j], ceil(f[i - 1][j] + x / speed - eps))\n                if j:\n                    f[i][j] = min(f[i][j], f[i - 1][j - 1] + x / speed)\n        for j in range(n + 1):\n            if f[n][j] <= hoursBefore + eps:\n                return j\n        return -1\n", "class Solution:\n  def minSkips(self, dist: list[int], speed: int, hoursBefore: int) -> int:\n    INF = 10**7\n    EPS = 1e-9\n    n = len(dist)\n    # dp[i][j] := the minimum time, where i is the number of roads we traversed\n    # so far and j is the number of skips we did\n    dp = [[INF] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i, d in enumerate(dist, 1):\n      dp[i][0] = math.ceil(dp[i - 1][0] + d / speed - EPS)\n      for j in range(1, i + 1):\n        dp[i][j] = min(dp[i - 1][j - 1] + d / speed,\n                       math.ceil(dp[i - 1][j] + d / speed - EPS))\n\n    for j, time in enumerate(dp[-1]):\n      if time <= hoursBefore:\n        return j\n\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1866, "slug": "number-of-ways-to-rearrange-sticks-with-k-sticks-visible", "solutions": ["class Solution:\n    def rearrangeSticks(self, n: int, k: int) -> int:\n        mod = 10**9 + 7\n        f = [[0] * (k + 1) for _ in range(n + 1)]\n        f[0][0] = 1\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                f[i][j] = (f[i - 1][j - 1] + f[i - 1][j] * (i - 1)) % mod\n        return f[n][k]\n", "class Solution:\n  @functools.lru_cache(None)\n  def rearrangeSticks(self, n: int, k: int) -> int:\n    if n == k:\n      return 1\n    if k == 0:\n      return 0\n    return (self.rearrangeSticks(n - 1, k - 1) +\n            self.rearrangeSticks(n - 1, k) * (n - 1)) % self.MOD\n\n  MOD = 1_000_000_007\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1808, "slug": "maximize-number-of-nice-divisors", "solutions": ["class Solution:\n    def maxNiceDivisors(self, primeFactors: int) -> int:\n        mod = 10**9 + 7\n        if primeFactors < 4:\n            return primeFactors\n        if primeFactors % 3 == 0:\n            return pow(3, primeFactors // 3, mod) % mod\n        if primeFactors % 3 == 1:\n            return 4 * pow(3, primeFactors // 3 - 1, mod) % mod\n        return 2 * pow(3, primeFactors // 3, mod) % mod\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1859, "slug": "sorting-the-sentence", "solutions": ["class Solution:\n    def sortSentence(self, s: str) -> str:\n        ws = s.split()\n        ans = [None] * len(ws)\n        for w in ws:\n            ans[int(w[-1]) - 1] = w[:-1]\n        return \" \".join(ans)\n", "class Solution:\n  def sortSentence(self, s: str) -> str:\n    return ' '.join([word[:-1]\n                     for word in sorted(s.split(), key=lambda x: x[-1])])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1898, "slug": "maximum-number-of-removable-characters", "solutions": ["class Solution:\n    def maximumRemovals(self, s: str, p: str, removable: List[int]) -> int:\n        def check(k: int) -> bool:\n            rem = [False] * len(s)\n            for i in removable[:k]:\n                rem[i] = True\n            i = j = 0\n            while i < len(s) and j < len(p):\n                if not rem[i] and p[j] == s[i]:\n                    j += 1\n                i += 1\n            return j == len(p)\n\n        l, r = 0, len(removable)\n        while l < r:\n            mid = (l + r + 1) >> 1\n            if check(mid):\n                l = mid\n            else:\n                r = mid - 1\n        return l\n", "class Solution:\n  def maximumRemovals(self, s: str, p: str, removable: list[int]) -> int:\n    l = 0\n    r = len(removable) + 1\n\n    def remove(k: int) -> str:\n      removed = [c for c in s]\n      for i in range(k):\n        removed[removable[i]] = '*'\n      return ''.join(removed)\n\n    def isSubsequence(p: str, s: str) -> bool:\n      i = 0\n      for j, c in enumerate(s):\n        if p[i] == s[j]:\n          i += 1\n          if i == len(p):\n            return True\n      return False\n\n    while l < r:\n      m = (l + r) // 2\n      removed = remove(m)\n      if isSubsequence(p, removed):\n        l = m + 1\n      else:\n        r = m\n\n    return l - 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1829, "slug": "maximum-xor-for-each-query", "solutions": ["class Solution:\n    def getMaximumXor(self, nums: List[int], maximumBit: int) -> List[int]:\n        ans = []\n        xs = reduce(xor, nums)\n        for x in nums[::-1]:\n            k = 0\n            for i in range(maximumBit - 1, -1, -1):\n                if (xs >> i & 1) == 0:\n                    k |= 1 << i\n            ans.append(k)\n            xs ^= x\n        return ans\n", "class Solution:\n  def getMaximumXor(self, nums: list[int], maximumBit: int) -> list[int]:\n    mx = (1 << maximumBit) - 1\n    ans = []\n    xors = 0\n\n    for num in nums:\n      xors ^= num\n      ans.append(xors ^ mx)\n\n    return ans[::-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1893, "slug": "check-if-all-the-integers-in-a-range-are-covered", "solutions": ["class Solution:\n    def isCovered(self, ranges: List[List[int]], left: int, right: int) -> bool:\n        diff = [0] * 52\n        for l, r in ranges:\n            diff[l] += 1\n            diff[r + 1] -= 1\n        s = 0\n        for i, x in enumerate(diff):\n            s += x\n            if s <= 0 and left <= i <= right:\n                return False\n        return True\n", "class Solution:\n  def isCovered(self, ranges: list[list[int]], left: int, right: int) -> bool:\n    return all(any(l <= i <= r for l, r in ranges) for i in range(\n        left, right + 1))\n", "class Solution:\n  def isCovered(self, ranges: list[list[int]], left: int, right: int) -> bool:\n    seen = [0] * 52\n\n    for l, r in ranges:\n      seen[l] += 1\n      seen[r + 1] -= 1\n\n    for i in range(1, 52):\n      seen[i] += seen[i - 1]\n\n    return all(seen[i] for i in range(left, right + 1))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1840, "slug": "maximum-building-height", "solutions": ["class Solution:\n    def maxBuilding(self, n: int, restrictions: List[List[int]]) -> int:\n        r = restrictions\n        r.append([1, 0])\n        r.sort()\n        if r[-1][0] != n:\n            r.append([n, n - 1])\n        m = len(r)\n        for i in range(1, m):\n            r[i][1] = min(r[i][1], r[i - 1][1] + r[i][0] - r[i - 1][0])\n        for i in range(m - 2, 0, -1):\n            r[i][1] = min(r[i][1], r[i + 1][1] + r[i + 1][0] - r[i][0])\n        ans = 0\n        for i in range(m - 1):\n            t = (r[i][1] + r[i + 1][1] + r[i + 1][0] - r[i][0]) // 2\n            ans = max(ans, t)\n        return ans\n", "class Solution:\n  def maxBuilding(self, n: int, restrictions: list[list[int]]) -> int:\n    A = sorted(restrictions + [[1, 0]] + [[n, n - 1]])\n\n    for i in range(len(A)):\n      dist = A[i][0] - A[i - 1][0]\n      A[i][1] = min(A[i][1], A[i - 1][1] + dist)\n\n    for i in reversed(range(len(A) - 1)):\n      dist = A[i + 1][0] - A[i][0]\n      A[i][1] = min(A[i][1], A[i + 1][1] + dist)\n\n    ans = 0\n\n    for (l, hL), (r, hR) in zip(A, A[1:]):\n      ans = max(ans, max(hL, hR) + (r - l - abs(hL - hR)) // 2)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1816, "slug": "truncate-sentence", "solutions": ["class Solution:\n    def truncateSentence(self, s: str, k: int) -> str:\n        return ' '.join(s.split()[:k])\n", "class Solution:\n  def truncateSentence(self, s: str, k: int) -> str:\n    return ' '.join(s.split()[:k])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1875, "slug": "group-employees-of-the-same-salary", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1809, "slug": "ad-free-sessions", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1820, "slug": "maximum-number-of-accepted-invitations", "solutions": ["class Solution:\n    def maximumInvitations(self, grid: List[List[int]]) -> int:\n        def find(i):\n            for j, v in enumerate(grid[i]):\n                if v and j not in vis:\n                    vis.add(j)\n                    if match[j] == -1 or find(match[j]):\n                        match[j] = i\n                        return True\n            return False\n\n        m, n = len(grid), len(grid[0])\n        match = [-1] * n\n        ans = 0\n        for i in range(m):\n            vis = set()\n            ans += find(i)\n        return ans\n", "class Solution:\n  def maximumInvitations(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    mates = [-1] * n  # mates[i] := the i-th girl's mate\n\n    def canInvite(i: int, seen: list[bool]) -> bool:\n      \"\"\"Returns True if the i-th boy can make an invitation.\"\"\"\n      # The i-th boy asks each girl.\n      for j in range(n):\n        if not grid[i][j] or seen[j]:\n          continue\n        seen[j] = True\n        if mates[j] == -1 or canInvite(mates[j], seen):\n          mates[j] = i  # Match the j-th girl with i-th boy.\n          return True\n      return False\n\n    for i in range(m):\n      seen = [False] * n\n      if canInvite(i, seen):\n        ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1805, "slug": "number-of-different-integers-in-a-string", "solutions": ["class Solution:\n    def numDifferentIntegers(self, word: str) -> int:\n        s = set()\n        i, n = 0, len(word)\n        while i < n:\n            if word[i].isdigit():\n                while i < n and word[i] == '0':\n                    i += 1\n                j = i\n                while j < n and word[j].isdigit():\n                    j += 1\n                s.add(word[i:j])\n                i = j\n            i += 1\n        return len(s)\n", "class Solution:\n  def numDifferentIntegers(self, word: str) -> int:\n    nums = set()\n    curr = []\n\n    for c in word:\n      if c.isdigit():\n        curr.append(c)\n      elif curr:\n        nums.add(''.join(self._removeLeadingZeros(curr)))\n        curr = []\n\n    if curr:\n      nums.add(''.join(self._removeLeadingZeros(curr)))\n\n    return len(nums)\n\n  def _removeLeadingZeros(self, s: str) -> str:\n    index = next((i for i, c in enumerate(s) if c != '0'), -1)\n    return ['0'] if index == -1 else s[index:]\n", "class Solution:\n  def numDifferentIntegers(self, word: str) -> int:\n    return len(set(map(int, re.findall(r'\\d+', word))))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1869, "slug": "longer-contiguous-segments-of-ones-than-zeros", "solutions": ["class Solution:\n    def checkZeroOnes(self, s: str) -> bool:\n        def f(x: str) -> int:\n            cnt = mx = 0\n            for c in s:\n                if c == x:\n                    cnt += 1\n                    mx = max(mx, cnt)\n                else:\n                    cnt = 0\n            return mx\n\n        return f(\"1\") > f(\"0\")\n", "class Solution:\n  def checkZeroOnes(self, s: str) -> bool:\n    longestOnes = 0\n    longestZeros = 0\n    currentOnes = 0\n    currentZeros = 0\n\n    for c in s:\n      if c == '0':\n        currentOnes = 0\n        currentZeros += 1\n        longestZeros = max(longestZeros, currentZeros)\n      else:\n        currentZeros = 0\n        currentOnes += 1\n        longestOnes = max(longestOnes, currentOnes)\n\n    return longestOnes > longestZeros\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1802, "slug": "maximum-value-at-a-given-index-in-a-bounded-array", "solutions": ["class Solution:\n    def maxValue(self, n: int, index: int, maxSum: int) -> int:\n        def sum(x, cnt):\n            return (\n                (x + x - cnt + 1) * cnt // 2 if x >= cnt else (x + 1) * x // 2 + cnt - x\n            )\n\n        left, right = 1, maxSum\n        while left < right:\n            mid = (left + right + 1) >> 1\n            if sum(mid - 1, index) + sum(mid, n - index) <= maxSum:\n                left = mid\n            else:\n                right = mid - 1\n        return left\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1827, "slug": "minimum-operations-to-make-the-array-increasing", "solutions": ["class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = mx = 0\n        for v in nums:\n            ans += max(0, mx + 1 - v)\n            mx = max(mx + 1, v)\n        return ans\n", "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    ans = 0\n    last = 0\n\n    for num in nums:\n      ans += max(0, last - num + 1)\n      last = max(num, last + 1)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1860, "slug": "incremental-memory-leak", "solutions": ["class Solution:\n    def memLeak(self, memory1: int, memory2: int) -> List[int]:\n        i = 1\n        while i <= max(memory1, memory2):\n            if memory1 >= memory2:\n                memory1 -= i\n            else:\n                memory2 -= i\n            i += 1\n        return [i, memory1, memory2]\n", "class Solution:\n  def memLeak(self, memory1: int, memory2: int) -> list[int]:\n    i = 1\n\n    while memory1 >= i or memory2 >= i:\n      if memory1 >= memory2:\n        memory1 -= i\n      else:\n        memory2 -= i\n      i += 1\n\n    return [i, memory1, memory2]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1847, "slug": "closest-room", "solutions": ["class Solution:\n    def closestRoom(\n        self, rooms: List[List[int]], queries: List[List[int]]\n    ) -> List[int]:\n        rooms.sort(key=lambda x: x[1])\n        k = len(queries)\n        idx = sorted(range(k), key=lambda i: queries[i][1])\n        ans = [-1] * k\n        i, n = 0, len(rooms)\n        sl = SortedList(x[0] for x in rooms)\n        for j in idx:\n            prefer, minSize = queries[j]\n            while i < n and rooms[i][1] < minSize:\n                sl.remove(rooms[i][0])\n                i += 1\n            if i == n:\n                break\n            p = sl.bisect_left(prefer)\n            if p < len(sl):\n                ans[j] = sl[p]\n            if p and (ans[j] == -1 or ans[j] - prefer >= prefer - sl[p - 1]):\n                ans[j] = sl[p - 1]\n        return ans\n", "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def closestRoom(\n      self,\n      rooms: list[list[int]],\n      queries: list[list[int]],\n  ) -> list[int]:\n    ans = [0] * len(queries)\n    qs = [[*q, i] for i, q in enumerate(queries)]\n    roomIds = SortedList()\n\n    rooms.sort(key=lambda x: -x[1])\n    qs.sort(key=lambda x: -x[1])\n\n    def searchClosestRoomId(roomIds: SortedList, preferred: int):\n      if not roomIds:\n        return -1\n\n      candIds = []\n      i = roomIds.bisect_right(preferred)\n      if i > 0:\n        candIds.append(roomIds[i - 1])\n      if i < len(roomIds):\n        candIds.append(roomIds[i])\n      return min(candIds, key=lambda x: abs(x - preferred))\n\n    i = 0  # rooms' index\n    for preferred, minSize, index in qs:\n      while i < len(rooms) and rooms[i][1] >= minSize:\n        roomIds.add(rooms[i][0])\n        i += 1\n      ans[index] = searchClosestRoomId(roomIds, preferred)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1881, "slug": "maximum-value-after-insertion", "solutions": ["class Solution:\n    def maxValue(self, n: str, x: int) -> str:\n        i = 0\n        if n[0] == \"-\":\n            i += 1\n            while i < len(n) and int(n[i]) <= x:\n                i += 1\n        else:\n            while i < len(n) and int(n[i]) >= x:\n                i += 1\n        return n[:i] + str(x) + n[i:]\n", "class Solution:\n  def maxValue(self, n: str, x: int) -> str:\n    isNegative = n[0] == '-'\n\n    for i, c in enumerate(n):\n      if not isNegative and int(c) < x or isNegative and int(c) > x:\n        return n[:i] + str(x) + n[i:]\n\n    return n + str(x)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1855, "slug": "maximum-distance-between-a-pair-of-values", "solutions": ["class Solution:\n    def maxDistance(self, nums1: List[int], nums2: List[int]) -> int:\n        ans = 0\n        nums2 = nums2[::-1]\n        for i, v in enumerate(nums1):\n            j = len(nums2) - bisect_left(nums2, v) - 1\n            ans = max(ans, j - i)\n        return ans\n", "class Solution:\n  def maxDistance(self, nums1: list[int], nums2: list[int]) -> int:\n    ans = 0\n    i = 0\n    j = 0\n\n    while i < len(nums1) and j < len(nums2):\n      if nums1[i] > nums2[j]:\n        i += 1\n      else:\n        ans = max(ans, j - i)\n        j += 1\n\n    return ans\n", "class Solution:\n  def maxDistance(self, nums1: list[int], nums2: list[int]) -> int:\n    i = 0\n    j = 0\n\n    while i < len(nums1) and j < len(nums2):\n      if nums1[i] > nums2[j]:\n        i += 1\n      j += 1\n\n    return 0 if i == j else j - i - 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1886, "slug": "determine-whether-matrix-can-be-obtained-by-rotation", "solutions": ["class Solution:\n    def findRotation(self, mat: List[List[int]], target: List[List[int]]) -> bool:\n        def rotate(matrix):\n            n = len(matrix)\n            for i in range(n // 2):\n                for j in range(i, n - 1 - i):\n                    t = matrix[i][j]\n                    matrix[i][j] = matrix[n - j - 1][i]\n                    matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n                    matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n                    matrix[j][n - i - 1] = t\n\n        for _ in range(4):\n            if mat == target:\n                return True\n            rotate(mat)\n        return False\n", "class Solution:\n  def findRotation(self, mat: list[list[int]], target: list[list[int]]) -> bool:\n    for _ in range(4):\n      if mat == target:\n        return True\n      mat = [list(x) for x in zip(*mat[::-1])]\n    return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1852, "slug": "distinct-numbers-in-each-subarray", "solutions": ["class Solution:\n    def distinctNumbers(self, nums: List[int], k: int) -> List[int]:\n        cnt = Counter(nums[:k])\n        ans = [len(cnt)]\n        for i in range(k, len(nums)):\n            cnt[nums[i]] += 1\n            cnt[nums[i - k]] -= 1\n            if cnt[nums[i - k]] == 0:\n                cnt.pop(nums[i - k])\n            ans.append(len(cnt))\n        return ans\n", "class Solution:\n  def distinctNumbers(self, nums: list[int], k: int) -> list[int]:\n    ans = []\n    count = collections.Counter()\n    distinct = 0\n\n    for i, num in enumerate(nums):\n      count[num] += 1\n      if count[num] == 1:\n        distinct += 1\n      if i >= k:\n        count[nums[i - k]] -= 1\n        if count[nums[i - k]] == 0:\n          distinct -= 1\n      if i >= k - 1:\n        ans.append(distinct)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1887, "slug": "reduction-operations-to-make-the-array-elements-equal", "solutions": ["class Solution:\n    def reductionOperations(self, nums: List[int]) -> int:\n        nums.sort()\n        ans = cnt = 0\n        for a, b in pairwise(nums):\n            if a != b:\n                cnt += 1\n            ans += cnt\n        return ans\n", "class Solution:\n  def reductionOperations(self, nums: list[int]) -> int:\n    ans = 0\n\n    nums.sort()\n\n    for i in range(len(nums) - 1, 0, -1):\n      if nums[i] != nums[i - 1]:\n        ans += len(nums) - i\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1862, "slug": "sum-of-floored-pairs", "solutions": ["class Solution:\n    def sumOfFlooredPairs(self, nums: List[int]) -> int:\n        mod = 10**9 + 7\n        cnt = Counter(nums)\n        mx = max(nums)\n        s = [0] * (mx + 1)\n        for i in range(1, mx + 1):\n            s[i] = s[i - 1] + cnt[i]\n        ans = 0\n        for y in range(1, mx + 1):\n            if cnt[y]:\n                d = 1\n                while d * y <= mx:\n                    ans += cnt[y] * d * (s[min(mx, d * y + y - 1)] - s[d * y - 1])\n                    ans %= mod\n                    d += 1\n        return ans\n", "class Solution:\n  def sumOfFlooredPairs(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    MAX = max(nums)\n    ans = 0\n    count = [0] * (MAX + 1)\n\n    for num in nums:\n      count[num] += 1\n\n    for i in range(1, MAX + 1):\n      count[i] += count[i - 1]\n\n    for i in range(1, MAX + 1):\n      if count[i] > count[i - 1]:\n        summ = 0\n        j = 1\n        while i * j <= MAX:\n          lo = i * j - 1\n          hi = i * (j + 1) - 1\n          summ += (count[min(hi, MAX)] - count[lo]) * j\n          j += 1\n        ans += summ * (count[i] - count[i - 1])\n        ans %= MOD\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1825, "slug": "finding-mk-average", "solutions": ["class MKAverage:\n    def __init__(self, m: int, k: int):\n        self.m = m\n        self.k = k\n        self.s = 0\n        self.q = deque()\n        self.lo = SortedList()\n        self.mid = SortedList()\n        self.hi = SortedList()\n\n    def addElement(self, num: int) -> None:\n        if not self.lo or num <= self.lo[-1]:\n            self.lo.add(num)\n        elif not self.hi or num >= self.hi[0]:\n            self.hi.add(num)\n        else:\n            self.mid.add(num)\n            self.s += num\n        self.q.append(num)\n        if len(self.q) > self.m:\n            x = self.q.popleft()\n            if x in self.lo:\n                self.lo.remove(x)\n            elif x in self.hi:\n                self.hi.remove(x)\n            else:\n                self.mid.remove(x)\n                self.s -= x\n        while len(self.lo) > self.k:\n            x = self.lo.pop()\n            self.mid.add(x)\n            self.s += x\n        while len(self.hi) > self.k:\n            x = self.hi.pop(0)\n            self.mid.add(x)\n            self.s += x\n        while len(self.lo) < self.k and self.mid:\n            x = self.mid.pop(0)\n            self.lo.add(x)\n            self.s -= x\n        while len(self.hi) < self.k and self.mid:\n            x = self.mid.pop()\n            self.hi.add(x)\n            self.s -= x\n\n    def calculateMKAverage(self) -> int:\n        return -1 if len(self.q) < self.m else self.s // (self.m - 2 * self.k)\n\n\n# Your MKAverage object will be instantiated and called as such:\n# obj = MKAverage(m, k)\n# obj.addElement(num)\n# param_2 = obj.calculateMKAverage()\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1844, "slug": "replace-all-digits-with-characters", "solutions": ["class Solution:\n    def replaceDigits(self, s: str) -> str:\n        s = list(s)\n        for i in range(1, len(s), 2):\n            s[i] = chr(ord(s[i - 1]) + int(s[i]))\n        return ''.join(s)\n", "class Solution:\n  def replaceDigits(self, s: str) -> str:\n    return ''.join(\n        c if i % 2 == 0 else chr(ord(s[i - 1]) + int(c))\n        for i, c in enumerate(s)\n    )\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1864, "slug": "minimum-number-of-swaps-to-make-the-binary-string-alternating", "solutions": ["class Solution:\n    def minSwaps(self, s: str) -> int:\n        def calc(c: int) -> int:\n            return sum((c ^ i & 1) != x for i, x in enumerate(map(int, s))) // 2\n\n        n0 = s.count(\"0\")\n        n1 = len(s) - n0\n        if abs(n0 - n1) > 1:\n            return -1\n        if n0 == n1:\n            return min(calc(0), calc(1))\n        return calc(0 if n0 > n1 else 1)\n", "class Solution:\n  def minSwaps(self, s: str) -> int:\n    ones = s.count('1')\n    zeros = len(s) - ones\n    if abs(ones - zeros) > 1:\n      return -1\n\n    def countSwaps(curr: str) -> int:\n      swaps = 0\n      for c in s:\n        if c != curr:\n          swaps += 1\n        curr = chr(ord(curr) ^ 1)\n      return swaps // 2\n\n    if ones > zeros:\n      return countSwaps('1')\n    if zeros > ones:\n      return countSwaps('0')\n    return min(countSwaps('1'), countSwaps('0'))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1811, "slug": "find-interview-candidates", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1895, "slug": "largest-magic-square", "solutions": ["class Solution:\n    def largestMagicSquare(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        rowsum = [[0] * (n + 1) for _ in range(m + 1)]\n        colsum = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                rowsum[i][j] = rowsum[i][j - 1] + grid[i - 1][j - 1]\n                colsum[i][j] = colsum[i - 1][j] + grid[i - 1][j - 1]\n\n        def check(x1, y1, x2, y2):\n            val = rowsum[x1 + 1][y2 + 1] - rowsum[x1 + 1][y1]\n            for i in range(x1 + 1, x2 + 1):\n                if rowsum[i + 1][y2 + 1] - rowsum[i + 1][y1] != val:\n                    return False\n            for j in range(y1, y2 + 1):\n                if colsum[x2 + 1][j + 1] - colsum[x1][j + 1] != val:\n                    return False\n            s, i, j = 0, x1, y1\n            while i <= x2:\n                s += grid[i][j]\n                i += 1\n                j += 1\n            if s != val:\n                return False\n            s, i, j = 0, x1, y2\n            while i <= x2:\n                s += grid[i][j]\n                i += 1\n                j -= 1\n            if s != val:\n                return False\n            return True\n\n        for k in range(min(m, n), 1, -1):\n            i = 0\n            while i + k - 1 < m:\n                j = 0\n                while j + k - 1 < n:\n                    i2, j2 = i + k - 1, j + k - 1\n                    if check(i, j, i2, j2):\n                        return k\n                    j += 1\n                i += 1\n        return 1\n", "class Solution:\n  def largestMagicSquare(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    # prefixRow[i][j] := the sum of the first j numbers in the i-th row\n    prefixRow = [[0] * (n + 1) for _ in range(m)]\n    # prefixCol[i][j] := the sum of the first j numbers in the i-th column\n    prefixCol = [[0] * (m + 1) for _ in range(n)]\n\n    for i in range(m):\n      for j in range(n):\n        prefixRow[i][j + 1] = prefixRow[i][j] + grid[i][j]\n        prefixCol[j][i + 1] = prefixCol[j][i] + grid[i][j]\n\n    def isMagicSquare(i: int, j: int, k: int) -> bool:\n      \"\"\"Returns True if grid[i..i + k)[j..j + k) is a magic square.\"\"\"\n      diag, antiDiag = 0, 0\n      for d in range(k):\n        diag += grid[i + d][j + d]\n        antiDiag += grid[i + d][j + k - 1 - d]\n      if diag != antiDiag:\n        return False\n      for d in range(k):\n        if self._getSum(prefixRow, i + d, j, j + k - 1) != diag:\n          return False\n        if self._getSum(prefixCol, j + d, i, i + k - 1) != diag:\n          return False\n      return True\n\n    def containsMagicSquare(k: int) -> bool:\n      \"\"\"Returns True if the grid contains any magic square of size k x k.\"\"\"\n      for i in range(m - k + 1):\n        for j in range(n - k + 1):\n          if isMagicSquare(i, j, k):\n            return True\n      return False\n\n    for k in range(min(m, n), 1, -1):\n      if containsMagicSquare(k):\n        return k\n\n    return 1\n\n  def _getSum(self, prefix: list[list[int]], i: int, l: int, r: int) -> int:\n    \"\"\"Returns sum(grid[i][l..r]) or sum(grid[l..r][i]).\"\"\"\n    return prefix[i][r + 1] - prefix[i][l]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1849, "slug": "splitting-a-string-into-descending-consecutive-values", "solutions": ["class Solution:\n    def splitString(self, s: str) -> bool:\n        def dfs(i: int, x: int) -> bool:\n            if i >= len(s):\n                return True\n            y = 0\n            r = len(s) - 1 if x < 0 else len(s)\n            for j in range(i, r):\n                y = y * 10 + int(s[j])\n                if (x < 0 or x - y == 1) and dfs(j + 1, y):\n                    return True\n            return False\n\n        return dfs(0, -1)\n", "class Solution:\n  def splitString(self, s: str) -> bool:\n    def isValid(s: str, start: int, prev: int, segment: int) -> bool:\n      if start == len(s) and segment > 1:\n        return True\n\n      curr = 0\n      for i in range(start, len(s)):\n        curr = curr * 10 + int(s[i])\n        if curr > 9999999999:\n          return False\n        if (prev == -1 or curr == prev - 1) and isValid(s, i + 1, curr, segment + 1):\n          return True\n\n      return False\n\n    return isValid(s, 0, -1, 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1843, "slug": "suspicious-bank-accounts", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1836, "slug": "remove-duplicates-from-an-unsorted-linked-list", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def deleteDuplicatesUnsorted(self, head: ListNode) -> ListNode:\n        cnt = Counter()\n        cur = head\n        while cur:\n            cnt[cur.val] += 1\n            cur = cur.next\n        dummy = ListNode(0, head)\n        pre, cur = dummy, head\n        while cur:\n            if cnt[cur.val] > 1:\n                pre.next = cur.next\n            else:\n                pre = cur\n            cur = cur.next\n        return dummy.next\n", "class Solution:\n  def deleteDuplicatesUnsorted(self, head: ListNode) -> ListNode:\n    dummy = ListNode(0, head)\n    count = collections.Counter()\n\n    curr = head\n    while curr:\n      count[curr.val] += 1\n      curr = curr.next\n\n    curr = dummy\n\n    while curr:\n      while curr.next and curr.next.val in count and count[curr.next.val] > 1:\n        curr.next = curr.next.next\n      curr = curr.next\n\n    return dummy.next\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1897, "slug": "redistribute-characters-to-make-all-strings-equal", "solutions": ["class Solution:\n    def makeEqual(self, words: List[str]) -> bool:\n        cnt = Counter()\n        for w in words:\n            for c in w:\n                cnt[c] += 1\n        n = len(words)\n        return all(v % n == 0 for v in cnt.values())\n", "class Solution:\n  def makeEqual(self, words: list[str]) -> bool:\n    return all(c % len(words) == 0\n               for c in collections.Counter(''.join(words)).values())\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1889, "slug": "minimum-space-wasted-from-packaging", "solutions": ["class Solution:\n    def minWastedSpace(self, packages: List[int], boxes: List[List[int]]) -> int:\n        mod = 10**9 + 7\n        ans = inf\n        packages.sort()\n        for box in boxes:\n            box.sort()\n            if packages[-1] > box[-1]:\n                continue\n            s = i = 0\n            for b in box:\n                j = bisect_right(packages, b, lo=i)\n                s += (j - i) * b\n                i = j\n            ans = min(ans, s)\n        if ans == inf:\n            return -1\n        return (ans - sum(packages)) % mod\n", "class Solution:\n  def minWastedSpace(self, packages: list[int], boxes: list[list[int]]) -> int:\n    ans = math.inf\n\n    packages.sort()\n\n    for box in boxes:\n      box.sort()\n      if box[-1] < packages[-1]:\n        continue\n      accu = 0\n      i = 0\n      for b in box:\n        j = bisect.bisect(packages, b, i)\n        accu += b * (j - i)\n        i = j\n      ans = min(ans, accu)\n\n    return -1 if ans == math.inf else (ans - sum(packages)) % 1_000_000_007\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1822, "slug": "sign-of-the-product-of-an-array", "solutions": ["class Solution:\n    def arraySign(self, nums: List[int]) -> int:\n        ans = 1\n        for v in nums:\n            if v == 0:\n                return 0\n            if v < 0:\n                ans *= -1\n        return ans\n", "class Solution:\n  def arraySign(self, nums: list[int]) -> int:\n    sign = 1\n\n    for num in nums:\n      if num == 0:\n        return 0\n      if num < 0:\n        sign = -sign\n\n    return sign\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1823, "slug": "find-the-winner-of-the-circular-game", "solutions": ["class Solution:\n    def findTheWinner(self, n: int, k: int) -> int:\n        if n == 1:\n            return 1\n        ans = (k + self.findTheWinner(n - 1, k)) % n\n        return n if ans == 0 else ans\n", "class Solution:\n  def findTheWinner(self, n: int, k: int) -> int:\n    # e.g. n = 4, k = 2.\n    # By using 0-indexed notation, we have the following circle:\n    #\n    # 0 -> 1 -> 2 -> 3 -> 0\n    #      x\n    #           0 -> 1 -> 2 -> 0\n    #\n    # After the first round, 1 is removed.\n    # So, 2 becomes 0, 3 becomes 1, and 0 becomes 2.\n    # Let's denote that oldIndex = f(n, k) and newIndex = f(n - 1, k).\n    # By observation, we know f(n, k) = (f(n - 1, k) + k) % n.\n    def f(n: int, k: int) -> int:\n      if n == 1:\n        return 0\n      return (f(n - 1, k) + k) % n\n\n    # Converts back to 1-indexed.\n    return f(n, k) + 1\n", "class Solution:\n  def findTheWinner(self, n: int, k: int) -> int:\n    # e.g. n = 4, k = 2.\n    # By using 0-indexed notation, we have the following circle:\n    #\n    # 0 -> 1 -> 2 -> 3 -> 0\n    #      x\n    #           0 -> 1 -> 2 -> 0\n    #\n    # After the first round, 1 is removed.\n    # So, 2 becomes 0, 3 becomes 1, and 0 becomes 2.\n    # Let's denote that oldIndex = f(n, k) and newIndex = f(n - 1, k).\n    # By observation, we know f(n, k) = (f(n - 1, k) + k) % n.\n    def f(n: int, k: int) -> int:\n      ans = 0  # f(1, k)\n      # Computes f(i, k) based on f(i - 1, k).\n      for i in range(2, n + 1):\n        ans = (ans + k) % i\n      return ans\n\n    # Converts back to 1-indexed.\n    return f(n, k) + 1\n", "class Solution:\n  def findTheWinner(self, n: int, k: int) -> int:\n    # True if i-th friend is left\n    friends = [False] * n\n\n    friendCount = n\n    fp = 0  # friends' index\n\n    while friendCount > 1:\n      for _ in range(k):\n        while friends[fp % n]:  # The friend is not there.\n          fp += 1  # Point to the next one.\n        fp += 1\n      friends[(fp - 1) % n] = True\n      friendCount -= 1\n\n    fp = 0\n    while friends[fp]:\n      fp += 1\n\n    return fp + 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1891, "slug": "cutting-ribbons", "solutions": ["class Solution:\n    def maxLength(self, ribbons: List[int], k: int) -> int:\n        left, right = 0, max(ribbons)\n        while left < right:\n            mid = (left + right + 1) >> 1\n            cnt = sum(x // mid for x in ribbons)\n            if cnt >= k:\n                left = mid\n            else:\n                right = mid - 1\n        return left\n", "class Solution:\n  def maxLength(self, ribbons: list[int], k: int) -> int:\n    def isCutPossible(length: int) -> bool:\n      count = 0\n      for ribbon in ribbons:\n        count += ribbon // length\n      return count >= k\n\n    l = 1\n    r = sum(ribbons) // k + 1\n\n    while l < r:\n      m = (l + r) // 2\n      if not isCutPossible(m):\n        r = m\n      else:\n        l = m + 1\n\n    return l - 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1884, "slug": "egg-drop-with-2-eggs-and-n-floors", "solutions": ["class Solution:\n    def twoEggDrop(self, n: int) -> int:\n        f = [0] + [inf] * n\n        for i in range(1, n + 1):\n            for j in range(1, i + 1):\n                f[i] = min(f[i], 1 + max(j - 1, f[i - j]))\n        return f[n]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1856, "slug": "maximum-subarray-min-product", "solutions": ["class Solution:\n    def maxSumMinProduct(self, nums: List[int]) -> int:\n        n = len(nums)\n        left = [-1] * n\n        right = [n] * n\n        stk = []\n        for i, x in enumerate(nums):\n            while stk and nums[stk[-1]] >= x:\n                stk.pop()\n            if stk:\n                left[i] = stk[-1]\n            stk.append(i)\n        stk = []\n        for i in range(n - 1, -1, -1):\n            while stk and nums[stk[-1]] > nums[i]:\n                stk.pop()\n            if stk:\n                right[i] = stk[-1]\n            stk.append(i)\n        s = list(accumulate(nums, initial=0))\n        mod = 10**9 + 7\n        return max((s[right[i]] - s[left[i] + 1]) * x for i, x in enumerate(nums)) % mod\n", "class Solution:\n  def maxSumMinProduct(self, nums: list[int]) -> int:\n    ans = 0\n    stack = []\n    prefix = list(itertools.accumulate(nums, initial=0))\n\n    for i in range(len(nums) + 1):\n      while stack and (i == len(nums) or nums[stack[-1]] > nums[i]):\n        minVal = nums[stack.pop()]\n        summ = prefix[i] - prefix[stack[-1] + 1] if stack else prefix[i]\n        ans = max(ans, minVal * summ)\n      stack.append(i)\n\n    return ans % 1_000_000_007\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1812, "slug": "determine-color-of-a-chessboard-square", "solutions": ["class Solution:\n    def squareIsWhite(self, coordinates: str) -> bool:\n        return (ord(coordinates[0]) + ord(coordinates[1])) % 2 == 1\n", "class Solution:\n  def squareIsWhite(self, coordinates: str) -> bool:\n    letter, digit = coordinates\n    return ord(letter) % 2 != int(digit) % 2\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1872, "slug": "stone-game-viii", "solutions": ["class Solution:\n    def stoneGameVIII(self, stones: List[int]) -> int:\n        @cache\n        def dfs(i: int) -> int:\n            if i >= len(stones) - 1:\n                return s[-1]\n            return max(dfs(i + 1), s[i] - dfs(i + 1))\n\n        s = list(accumulate(stones))\n        return dfs(1)\n", "class Solution:\n  def stoneGameVIII(self, stones: list[int]) -> int:\n    n = len(stones)\n    prefix = list(itertools.accumulate(stones))\n    # dp[i] := the maximum score difference the current player can get when the\n    # game starts at i, i.e. stones[0..i] are merged into the value prefix[i]\n    dp = [-math.inf] * n\n\n    # Must take all when there're only two stones left.\n    dp[n - 2] = prefix[-1]\n\n    for i in reversed(range(n - 2)):\n      dp[i] = max(dp[i + 1], prefix[i + 1] - dp[i + 1])\n\n    return dp[0]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1803, "slug": "count-pairs-with-xor-in-a-range", "solutions": ["class Trie:\n    def __init__(self):\n        self.children = [None] * 2\n        self.cnt = 0\n\n    def insert(self, x):\n        node = self\n        for i in range(15, -1, -1):\n            v = x >> i & 1\n            if node.children[v] is None:\n                node.children[v] = Trie()\n            node = node.children[v]\n            node.cnt += 1\n\n    def search(self, x, limit):\n        node = self\n        ans = 0\n        for i in range(15, -1, -1):\n            if node is None:\n                return ans\n            v = x >> i & 1\n            if limit >> i & 1:\n                if node.children[v]:\n                    ans += node.children[v].cnt\n                node = node.children[v ^ 1]\n            else:\n                node = node.children[v]\n        return ans\n\n\nclass Solution:\n    def countPairs(self, nums: List[int], low: int, high: int) -> int:\n        ans = 0\n        tree = Trie()\n        for x in nums:\n            ans += tree.search(x, high + 1) - tree.search(x, low)\n            tree.insert(x)\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1824, "slug": "minimum-sideway-jumps", "solutions": ["class Solution:\n    def minSideJumps(self, obstacles: List[int]) -> int:\n        f = [1, 0, 1]\n        for v in obstacles[1:]:\n            for j in range(3):\n                if v == j + 1:\n                    f[j] = inf\n                    break\n            x = min(f) + 1\n            for j in range(3):\n                if v != j + 1:\n                    f[j] = min(f[j], x)\n        return min(f)\n", "class Solution:\n  def minSideJumps(self, obstacles: list[int]) -> int:\n    INF = 1e6\n    # dp[i] := the minimum jump to reach the i-th lane\n    dp = [INF, 1, 0, 1]\n\n    for obstacle in obstacles:\n      print(dp)\n      if obstacle > 0:\n        dp[obstacle] = INF\n      for i in range(1, 4):  # the current\n        if i != obstacle:\n          for j in range(1, 4):  # the previous\n            dp[i] = min(dp[i], dp[j] + (0 if i == j else 1))\n\n    return min(dp)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1813, "slug": "sentence-similarity-iii", "solutions": ["class Solution:\n    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\n        words1, words2 = sentence1.split(), sentence2.split()\n        m, n = len(words1), len(words2)\n        if m < n:\n            words1, words2 = words2, words1\n            m, n = n, m\n        i = j = 0\n        while i < n and words1[i] == words2[i]:\n            i += 1\n        while j < n and words1[m - 1 - j] == words2[n - 1 - j]:\n            j += 1\n        return i + j >= n\n", "class Solution:\n  def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\n    if len(sentence1) == len(sentence2):\n      return sentence1 == sentence2\n\n    words1 = sentence1.split()\n    words2 = sentence2.split()\n    m, n = map(len, (words1, words2))\n    if m > n:\n      return self.areSentencesSimilar(sentence2, sentence1)\n\n    i = 0  # words1's index\n    while i < m and words1[i] == words2[i]:\n      i += 1\n    while i < m and words1[i] == words2[i + n - m]:\n      i += 1\n\n    return i == m\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1830, "slug": "minimum-number-of-operations-to-make-string-sorted", "solutions": ["n = 3010\nmod = 10**9 + 7\nf = [1] + [0] * n\ng = [1] + [0] * n\n\nfor i in range(1, n):\n    f[i] = f[i - 1] * i % mod\n    g[i] = pow(f[i], mod - 2, mod)\n\n\nclass Solution:\n    def makeStringSorted(self, s: str) -> int:\n        cnt = Counter(s)\n        ans, n = 0, len(s)\n        for i, c in enumerate(s):\n            m = sum(v for a, v in cnt.items() if a < c)\n            t = f[n - i - 1] * m\n            for v in cnt.values():\n                t = t * g[v] % mod\n            ans = (ans + t) % mod\n            cnt[c] -= 1\n            if cnt[c] == 0:\n                cnt.pop(c)\n        return ans\n", "class Solution:\n  def makeStringSorted(self, s: str) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    count = [0] * 26\n\n    @functools.lru_cache(None)\n    def fact(i: int) -> int:\n      return 1 if i <= 1 else i * fact(i - 1) % MOD\n\n    @functools.lru_cache(None)\n    def inv(i: int) -> int:\n      return pow(i, MOD - 2, MOD)\n\n    for i, c in enumerate(reversed(s)):\n      order = ord(c) - ord('a')\n      count[order] += 1\n      # count[:order] := s[i] can be any character smaller than c\n      # fact(i) := s[i + 1..n - 1] can be any sequence of characters\n      perm = sum(count[:order]) * fact(i)\n      for j in range(26):\n        perm = perm * inv(fact(count[j])) % MOD\n      ans = (ans + perm) % MOD\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1846, "slug": "maximum-element-after-decreasing-and-rearranging", "solutions": ["class Solution:\n    def maximumElementAfterDecrementingAndRearranging(self, arr: List[int]) -> int:\n        arr.sort()\n        arr[0] = 1\n        for i in range(1, len(arr)):\n            d = max(0, arr[i] - arr[i - 1] - 1)\n            arr[i] -= d\n        return max(arr)\n", "class Solution:\n  def maximumElementAfterDecrementingAndRearranging(\n      self, arr: list[int],\n  ) -> int:\n    arr.sort()\n    arr[0] = 1\n\n    for i in range(1, len(arr)):\n      arr[i] = min(arr[i], arr[i - 1] + 1)\n\n    return arr[-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1826, "slug": "faulty-sensor", "solutions": ["class Solution:\n    def badSensor(self, sensor1: List[int], sensor2: List[int]) -> int:\n        i, n = 0, len(sensor1)\n        while i < n - 1:\n            if sensor1[i] != sensor2[i]:\n                break\n            i += 1\n        while i < n - 1:\n            if sensor1[i + 1] != sensor2[i]:\n                return 1\n            if sensor1[i] != sensor2[i + 1]:\n                return 2\n            i += 1\n        return -1\n", "class Solution:\n  def badSensor(self, sensor1: list[int], sensor2: list[int]) -> int:\n    # A -> B, so B is defect\n    def canReplace(A, B):\n      i = 0  # A's index\n      j = 0  # B's index\n      droppedValue = -1\n\n      while i < len(A):\n        if A[i] == B[j]:\n          i += 1\n          j += 1\n        else:\n          droppedValue = A[i]\n          i += 1\n\n      return j == len(B) - 1 and B[-1] != droppedValue\n\n    oneDefect = canReplace(sensor2, sensor1)\n    twoDefect = canReplace(sensor1, sensor2)\n    if oneDefect and twoDefect:\n      return -1\n    if not oneDefect and not twoDefect:\n      return -1\n    return 1 if oneDefect else 2\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1865, "slug": "finding-pairs-with-a-certain-sum", "solutions": ["class FindSumPairs:\n    def __init__(self, nums1: List[int], nums2: List[int]):\n        self.cnt = Counter(nums2)\n        self.nums1 = nums1\n        self.nums2 = nums2\n\n    def add(self, index: int, val: int) -> None:\n        self.cnt[self.nums2[index]] -= 1\n        self.nums2[index] += val\n        self.cnt[self.nums2[index]] += 1\n\n    def count(self, tot: int) -> int:\n        return sum(self.cnt[tot - x] for x in self.nums1)\n\n\n# Your FindSumPairs object will be instantiated and called as such:\n# obj = FindSumPairs(nums1, nums2)\n# obj.add(index,val)\n# param_2 = obj.count(tot)\n", "class FindSumPairs:\n  def __init__(self, nums1: list[int], nums2: list[int]):\n    self.nums1 = nums1\n    self.nums2 = nums2\n    self.count2 = collections.Counter(nums2)\n\n  def add(self, index: int, val: int) -> None:\n    self.count2[self.nums2[index]] -= 1\n    self.nums2[index] += val\n    self.count2[self.nums2[index]] += 1\n\n  def count(self, tot: int) -> int:\n    ans = 0\n    for num in self.nums1:\n      ans += self.count2[tot - num]\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1890, "slug": "the-latest-login-in-2020", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1857, "slug": "largest-color-value-in-a-directed-graph", "solutions": ["class Solution:\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\n        n = len(colors)\n        indeg = [0] * n\n        g = defaultdict(list)\n        for a, b in edges:\n            g[a].append(b)\n            indeg[b] += 1\n        q = deque()\n        dp = [[0] * 26 for _ in range(n)]\n        for i, v in enumerate(indeg):\n            if v == 0:\n                q.append(i)\n                c = ord(colors[i]) - ord('a')\n                dp[i][c] += 1\n        cnt = 0\n        ans = 1\n        while q:\n            i = q.popleft()\n            cnt += 1\n            for j in g[i]:\n                indeg[j] -= 1\n                if indeg[j] == 0:\n                    q.append(j)\n                c = ord(colors[j]) - ord('a')\n                for k in range(26):\n                    dp[j][k] = max(dp[j][k], dp[i][k] + (c == k))\n                    ans = max(ans, dp[j][k])\n        return -1 if cnt < n else ans\n", "class Solution:\n  def largestPathValue(self, colors: str, edges: list[list[int]]) -> int:\n    n = len(colors)\n    ans = 0\n    processed = 0\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n    q = collections.deque()\n    count = [[0] * 26 for _ in range(n)]\n\n    # Build the graph.\n    for u, v in edges:\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    # Vpology\n    for i, degree in enumerate(inDegrees):\n      if degree == 0:\n        q.append(i)\n\n    while q:\n      u = q.popleft()\n      processed += 1\n      count[u][ord(colors[u]) - ord('a')] += 1\n      ans = max(ans, count[u][ord(colors[u]) - ord('a')])\n      for v in graph[u]:\n        for i in range(26):\n          count[v][i] = max(count[v][i], count[u][i])\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    return ans if processed == n else -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1876, "slug": "substrings-of-size-three-with-distinct-characters", "solutions": ["class Solution:\n    def countGoodSubstrings(self, s: str) -> int:\n        ans = mask = l = 0\n        for r, x in enumerate(map(lambda c: ord(c) - 97, s)):\n            while mask >> x & 1:\n                y = ord(s[l]) - 97\n                mask ^= 1 << y\n                l += 1\n            mask |= 1 << x\n            ans += int(r - l + 1 >= 3)\n        return ans\n", "class Solution:\n  def countGoodSubstrings(self, s: str) -> int:\n    ans = 0\n\n    for a, b, c in zip(s, s[1:], s[2:]):\n      if a == b or a == c or b == c:\n        continue\n      ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1870, "slug": "minimum-speed-to-arrive-on-time", "solutions": ["class Solution:\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\n        def check(v: int) -> bool:\n            s = 0\n            for i, d in enumerate(dist):\n                t = d / v\n                s += t if i == len(dist) - 1 else ceil(t)\n            return s <= hour\n\n        if len(dist) > ceil(hour):\n            return -1\n        r = 10**7 + 1\n        ans = bisect_left(range(1, r), True, key=check) + 1\n        return -1 if ans == r else ans\n", "class Solution:\n  def minSpeedOnTime(self, dist: list[int], hour: float) -> int:\n    ans = -1\n    l = 1\n    r = int(1e7)\n\n    def time(speed: int) -> float:\n      summ = 0\n      for i in range(len(dist) - 1):\n        summ += math.ceil(dist[i] / speed)\n      return summ + dist[-1] / speed\n\n    while l <= r:\n      m = (l + r) // 2\n      if time(m) > hour:\n        l = m + 1\n      else:\n        ans = m\n        r = m - 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1845, "slug": "seat-reservation-manager", "solutions": ["class SeatManager:\n    def __init__(self, n: int):\n        self.q = list(range(1, n + 1))\n\n    def reserve(self) -> int:\n        return heappop(self.q)\n\n    def unreserve(self, seatNumber: int) -> None:\n        heappush(self.q, seatNumber)\n\n\n# Your SeatManager object will be instantiated and called as such:\n# obj = SeatManager(n)\n# param_1 = obj.reserve()\n# obj.unreserve(seatNumber)\n", "class SeatManager:\n  def __init__(self, n: int):\n    self.minHeap = [i + 1 for i in range(n)]\n\n  def reserve(self) -> int:\n    return heapq.heappop(self.minHeap)\n\n  def unreserve(self, seatNumber: int) -> None:\n    heapq.heappush(self.minHeap, seatNumber)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1871, "slug": "jump-game-vii", "solutions": ["class Solution:\n    def canReach(self, s: str, minJump: int, maxJump: int) -> bool:\n        n = len(s)\n        pre = [0] * (n + 1)\n        pre[1] = 1\n        f = [True] + [False] * (n - 1)\n        for i in range(1, n):\n            if s[i] == \"0\":\n                l, r = max(0, i - maxJump), i - minJump\n                f[i] = l <= r and pre[r + 1] - pre[l] > 0\n            pre[i + 1] = pre[i] + f[i]\n        return f[-1]\n", "class Solution:\n  def canReach(self, s: str, minJump: int, maxJump: int) -> bool:\n    count = 0\n    dp = [True] + [False] * (len(s) - 1)\n\n    for i in range(minJump, len(s)):\n      count += dp[i - minJump]\n      if i - maxJump > 0:\n        count -= dp[i - maxJump - 1]\n      dp[i] = count and s[i] == '0'\n\n    return dp[-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1810, "slug": "minimum-path-cost-in-a-hidden-grid", "solutions": ["# \"\"\"\n# This is GridMaster's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# class GridMaster(object):\n#    def canMove(self, direction: str) -> bool:\n#\n#\n#    def move(self, direction: str) -> int:\n#\n#\n#    def isTarget(self) -> None:\n#\n#\n\n\nclass Solution(object):\n    def findShortestPath(self, master: 'GridMaster') -> int:\n        def dfs(i, j):\n            nonlocal target\n            if master.isTarget():\n                target = (i, j)\n            for dir, (a, b, ndir) in dirs.items():\n                x, y = i + a, j + b\n                if 0 <= x < N and 0 <= y < N and master.canMove(dir) and g[x][y] == -1:\n                    g[x][y] = master.move(dir)\n                    dfs(x, y)\n                    master.move(ndir)\n\n        target = (-1, -1)\n        N = 200\n        INF = 0x3F3F3F3F\n        g = [[-1] * N for _ in range(N)]\n        dirs = {\n            'U': (-1, 0, 'D'),\n            'D': (1, 0, 'U'),\n            'L': (0, -1, 'R'),\n            'R': (0, 1, 'L'),\n        }\n        dfs(100, 100)\n        if target == (-1, -1):\n            return -1\n        q = [(0, 100, 100)]\n        dist = [[INF] * N for _ in range(N)]\n        dist[100][100] = 0\n        while q:\n            w, i, j = heappop(q)\n            if (i, j) == target:\n                return w\n            for a, b, _ in dirs.values():\n                x, y = i + a, j + b\n                if (\n                    0 <= x < N\n                    and 0 <= y < N\n                    and g[x][y] != -1\n                    and dist[x][y] > w + g[x][y]\n                ):\n                    dist[x][y] = w + g[x][y]\n                    heappush(q, (dist[x][y], x, y))\n        return 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1896, "slug": "minimum-cost-to-change-the-final-value-of-expression", "solutions": ["class Solution:\n  def minOperationsToFlip(self, expression: str) -> int:\n    stack = []  # [(the expression, the cost to toggle the expression)]\n\n    for e in expression:\n      if e in '(&|':\n        # These aren't expressions, so the cost is meaningless.\n        stack.append((e, 0))\n        continue\n      if e == ')':\n        lastPair = stack.pop()\n        stack.pop()  # Pop '('.\n      else:  # e == '0' or e == '1'\n        # Store the '0' or '1'. The cost to change their values is just 1,\n        # whether it's changing '0' to '1' or '1' to '0'.\n        lastPair = (e, 1)\n      if stack and stack[-1][0] in '&|':\n        op = stack.pop()[0]\n        a, costA = stack.pop()\n        b, costB = lastPair\n        # Determine the cost to toggle op(a, b).\n        if op == '&':\n          if a == '0' and b == '0':\n            # Change '&' to '|' and a|b to '1'.\n            lastPair = ('0', 1 + min(costA, costB))\n          elif a == '0' and b == '1':\n            # Change '&' to '|'.\n            lastPair = ('0', 1)\n          elif a == '1' and b == '0':\n            # Change '&' to '|'.\n            lastPair = ('0', 1)\n          else:  # a == '1' and b == '1'\n            # Change a|b to '0'.\n            lastPair = ('1', min(costA, costB))\n        else:  # op == '|'\n          if a == '0' and b == '0':\n            # Change a|b to '1'.\n            lastPair = ('0', min(costA, costB))\n          elif a == '0' and b == '1':\n            # Change '|' to '&'.\n            lastPair = ('1', 1)\n          elif a == '1' and b == '0':\n            # Change '|' to '&'.\n            lastPair = ('1', 1)\n          else:  # a == '1' and b == '1'\n            # Change '|' to '&' and a|b to '0'.\n            lastPair = ('1', 1 + min(costA, costB))\n      stack.append(lastPair)\n\n    return stack[-1][1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1831, "slug": "maximum-transaction-each-day", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1879, "slug": "minimum-xor-sum-of-two-arrays", "solutions": ["class Solution:\n    def minimumXORSum(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums2)\n        f = [[inf] * (1 << n) for _ in range(n + 1)]\n        f[0][0] = 0\n        for i, x in enumerate(nums1, 1):\n            for j in range(1 << n):\n                for k in range(n):\n                    if j >> k & 1:\n                        f[i][j] = min(f[i][j], f[i - 1][j ^ (1 << k)] + (x ^ nums2[k]))\n        return f[-1][-1]\n", "class Solution:\n  def minimumXORSum(self, nums1: list[int], nums2: list[int]) -> int:\n    @functools.lru_cache(None)\n    def dp(mask: int) -> int:\n      i = mask.bit_count()\n      if i == len(nums1):\n        return 0\n      return min((nums1[i] ^ nums2[j]) + dp(mask | 1 << j)\n                 for j in range(len(nums2)) if not mask >> j & 1)\n    return dp(0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1868, "slug": "product-of-two-run-length-encoded-arrays", "solutions": ["class Solution:\n    def findRLEArray(\n        self, encoded1: List[List[int]], encoded2: List[List[int]]\n    ) -> List[List[int]]:\n        ans = []\n        j = 0\n        for vi, fi in encoded1:\n            while fi:\n                f = min(fi, encoded2[j][1])\n                v = vi * encoded2[j][0]\n                if ans and ans[-1][0] == v:\n                    ans[-1][1] += f\n                else:\n                    ans.append([v, f])\n                fi -= f\n                encoded2[j][1] -= f\n                if encoded2[j][1] == 0:\n                    j += 1\n        return ans\n", "class Solution:\n  def findRLEArray(self, encoded1: list[list[int]],\n                   encoded2: list[list[int]]) -> list[list[int]]:\n    ans = []\n    i = 0  # encoded1's index\n    j = 0  # encoded2's index\n\n    while i < len(encoded1) and j < len(encoded2):\n      mult = encoded1[i][0] * encoded2[j][0]\n      minFreq = min(encoded1[i][1], encoded2[j][1])\n      if ans and mult == ans[-1][0]:\n        ans[-1][1] += minFreq\n      else:\n        ans.append([mult, minFreq])\n      encoded1[i][1] -= minFreq\n      encoded2[j][1] -= minFreq\n      if encoded1[i][1] == 0:\n        i += 1\n      if encoded2[j][1] == 0:\n        j += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1828, "slug": "queries-on-number-of-points-inside-a-circle", "solutions": ["class Solution:\n    def countPoints(\n        self, points: List[List[int]], queries: List[List[int]]\n    ) -> List[int]:\n        ans = []\n        for x, y, r in queries:\n            cnt = 0\n            for i, j in points:\n                dx, dy = i - x, j - y\n                cnt += dx * dx + dy * dy <= r * r\n            ans.append(cnt)\n        return ans\n", "class Solution:\n  def countPoints(\n      self,\n      points: list[list[int]],\n      queries: list[list[int]],\n  ) -> list[int]:\n    ans = []\n\n    for xj, yj, rj in queries:\n      count = 0\n      for xi, yi in points:\n        if (xi - xj)**2 + (yi - yj)**2 <= rj**2:\n          count += 1\n      ans.append(count)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1801, "slug": "number-of-orders-in-the-backlog", "solutions": ["class Solution:\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\n        buy, sell = [], []\n        for p, a, t in orders:\n            if t == 0:\n                while a and sell and sell[0][0] <= p:\n                    x, y = heappop(sell)\n                    if a >= y:\n                        a -= y\n                    else:\n                        heappush(sell, (x, y - a))\n                        a = 0\n                if a:\n                    heappush(buy, (-p, a))\n            else:\n                while a and buy and -buy[0][0] >= p:\n                    x, y = heappop(buy)\n                    if a >= y:\n                        a -= y\n                    else:\n                        heappush(buy, (x, y - a))\n                        a = 0\n                if a:\n                    heappush(sell, (p, a))\n        mod = 10**9 + 7\n        return sum(v[1] for v in buy + sell) % mod\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1819, "slug": "number-of-different-subsequences-gcds", "solutions": ["class Solution:\n    def countDifferentSubsequenceGCDs(self, nums: List[int]) -> int:\n        mx = max(nums)\n        vis = set(nums)\n        ans = 0\n        for x in range(1, mx + 1):\n            g = 0\n            for y in range(x, mx + 1, x):\n                if y in vis:\n                    g = gcd(g, y)\n                    if g == x:\n                        ans += 1\n                        break\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1892, "slug": "page-recommendations-ii", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1854, "slug": "maximum-population-year", "solutions": ["class Solution:\n    def maximumPopulation(self, logs: List[List[int]]) -> int:\n        d = [0] * 101\n        offset = 1950\n        for a, b in logs:\n            a, b = a - offset, b - offset\n            d[a] += 1\n            d[b] -= 1\n        s = mx = j = 0\n        for i, x in enumerate(d):\n            s += x\n            if mx < s:\n                mx, j = s, i\n        return j + offset\n", "class Solution:\n  def maximumPopulation(self, logs: list[list[int]]) -> int:\n    MIN_YEAR = 1950\n    MAX_YEAR = 2050\n    ans = 0\n    maxPopulation = 0\n    runningPopulation = 0\n    # population[i] := the population of year i\n    population = [0] * (MAX_YEAR + 1)\n\n    for birth, death in logs:\n      population[birth] += 1\n      population[death] -= 1\n\n    for year in range(MIN_YEAR, MAX_YEAR + 1):\n      runningPopulation += population[year]\n      if runningPopulation > maxPopulation:\n        maxPopulation = runningPopulation\n        ans = year\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1882, "slug": "process-tasks-using-servers", "solutions": ["class Solution:\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\n        idle = [(x, i) for i, x in enumerate(servers)]\n        heapify(idle)\n        busy = []\n        ans = []\n        for j, t in enumerate(tasks):\n            while busy and busy[0][0] <= j:\n                _, s, i = heappop(busy)\n                heappush(idle, (s, i))\n            if idle:\n                s, i = heappop(idle)\n                heappush(busy, (j + t, s, i))\n            else:\n                w, s, i = heappop(busy)\n                heappush(busy, (w + t, s, i))\n            ans.append(i)\n        return ans\n", "class Solution:\n  def assignTasks(self, servers: list[int], tasks: list[int]) -> list[int]:\n    ans = []\n    free = []  # (weight, index, freeTime)\n    used = []  # (freeTime, weight, index)\n\n    for i, weight in enumerate(servers):\n      heapq.heappush(free, (weight, i, 0))\n\n    for i, executionTime in enumerate(tasks):  # i := the current time\n      # Poll all servers that'll be free at time i.\n      while used and used[0][0] <= i:\n        curr = heapq.heappop(used)\n        heapq.heappush(free, (curr[1], curr[2], curr[0]))\n      if free:\n        curr = heapq.heappop(free)\n        ans.append(curr[1])\n        heapq.heappush(used, (i + executionTime, curr[0], curr[1]))\n      else:\n        curr = heapq.heappop(used)\n        ans.append(curr[2])\n        heapq.heappush(used, (curr[0] + executionTime, curr[1], curr[2]))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1894, "slug": "find-the-student-that-will-replace-the-chalk", "solutions": ["class Solution:\n    def chalkReplacer(self, chalk: List[int], k: int) -> int:\n        s = sum(chalk)\n        k %= s\n        for i, x in enumerate(chalk):\n            if k < x:\n                return i\n            k -= x\n", "class Solution:\n  def chalkReplacer(self, chalk: list[int], k: int) -> int:\n    k %= sum(chalk)\n    if k == 0:\n      return 0\n\n    for i, c in enumerate(chalk):\n      k -= c\n      if k < 0:\n        return i\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1853, "slug": "convert-date-format", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1858, "slug": "longest-word-with-all-prefixes", "solutions": ["class Trie:\n    __slots__ = [\"children\", \"is_end\"]\n\n    def __init__(self):\n        self.children: List[Trie | None] = [None] * 26\n        self.is_end: bool = False\n\n    def insert(self, w: str) -> None:\n        node = self\n        for c in w:\n            idx = ord(c) - ord(\"a\")\n            if not node.children[idx]:\n                node.children[idx] = Trie()\n            node = node.children[idx]\n        node.is_end = True\n\n    def search(self, w: str) -> bool:\n        node = self\n        for c in w:\n            idx = ord(c) - ord(\"a\")\n            node = node.children[idx]\n            if not node.is_end:\n                return False\n        return True\n\n\nclass Solution:\n    def longestWord(self, words: List[str]) -> str:\n        trie = Trie()\n        for w in words:\n            trie.insert(w)\n        ans = \"\"\n        for w in words:\n            if (len(w) > len(ans) or len(w) == len(ans) and w < ans) and trie.search(w):\n                ans = w\n        return ans\n", "class Solution:\n  def __init__(self):\n    self.root = {}\n\n  def longestWord(self, words: list[str]) -> str:\n    ans = ''\n\n    for word in words:\n      self.insert(word)\n\n    for word in words:\n      if not self.allPrefixed(word):\n        continue\n      if len(ans) < len(word) or (len(ans) == len(word) and ans > word):\n        ans = word\n\n    return ans\n\n  def insert(self, word: str) -> None:\n    node = self.root\n    for c in word:\n      if c not in node:\n        node[c] = {}\n      node = node[c]\n    node['isWord'] = True\n\n  def allPrefixed(self, word: str) -> bool:\n    node = self.root\n    for c in word:\n      node = node[c]\n      if 'isWord' not in node:\n        return False\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1848, "slug": "minimum-distance-to-the-target-element", "solutions": ["class Solution:\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\n        return min(abs(i - start) for i, x in enumerate(nums) if x == target)\n", "class Solution:\n  def getMinDistance(self, nums: list[int], target: int, start: int) -> int:\n    ans = math.inf\n\n    for i, num in enumerate(nums):\n      if num == target:\n        ans = min(ans, abs(i - start))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1877, "slug": "minimize-maximum-pair-sum-in-array", "solutions": ["class Solution:\n    def minPairSum(self, nums: List[int]) -> int:\n        nums.sort()\n        return max(x + nums[-i - 1] for i, x in enumerate(nums[: len(nums) >> 1]))\n", "class Solution:\n  def minPairSum(self, nums: list[int]) -> int:\n    nums.sort()\n    return max(nums[i] + nums[len(nums) - 1 - i] for i in range(len(nums) // 2))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1863, "slug": "sum-of-all-subset-xor-totals", "solutions": ["class Solution:\n    def subsetXORSum(self, nums: List[int]) -> int:\n        ans, n = 0, len(nums)\n        for i in range(1 << n):\n            s = 0\n            for j in range(n):\n                if i >> j & 1:\n                    s ^= nums[j]\n            ans += s\n        return ans\n", "class Solution:\n  def subsetXORSum(self, nums: list[int]) -> int:\n    def dfs(i: int, xors: int) -> int:\n      if i == len(nums):\n        return xors\n\n      x = dfs(i + 1, xors)\n      y = dfs(i + 1, nums[i] ^ xors)\n      return x + y\n\n    return dfs(0, 0)\n", "class Solution:\n  def subsetXORSum(self, nums: list[int]) -> int:\n    return functools.reduce(operator.or_, nums) << len(nums) - 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1814, "slug": "count-nice-pairs-in-an-array", "solutions": ["class Solution:\n    def countNicePairs(self, nums: List[int]) -> int:\n        def rev(x):\n            y = 0\n            while x:\n                y = y * 10 + x % 10\n                x //= 10\n            return y\n\n        cnt = Counter(x - rev(x) for x in nums)\n        mod = 10**9 + 7\n        return sum(v * (v - 1) // 2 for v in cnt.values()) % mod\n", "class Solution:\n  def countNicePairs(self, nums: list[int]) -> int:\n    freqs = collections.Counter(num - int(str(num)[::-1]) for num in nums)\n    return sum(freq * (freq - 1) // 2 for freq in freqs.values()) % 1000000007\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1807, "slug": "evaluate-the-bracket-pairs-of-a-string", "solutions": ["class Solution:\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\n        d = {a: b for a, b in knowledge}\n        i, n = 0, len(s)\n        ans = []\n        while i < n:\n            if s[i] == '(':\n                j = s.find(')', i + 1)\n                ans.append(d.get(s[i + 1 : j], '?'))\n                i = j\n            else:\n                ans.append(s[i])\n            i += 1\n        return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1821, "slug": "find-customers-with-positive-revenue-this-year", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1838, "slug": "frequency-of-the-most-frequent-element", "solutions": ["class Solution:\n    def maxFrequency(self, nums: List[int], k: int) -> int:\n        def check(m: int) -> bool:\n            for i in range(m, n + 1):\n                if nums[i - 1] * m - (s[i] - s[i - m]) <= k:\n                    return True\n            return False\n\n        n = len(nums)\n        nums.sort()\n        s = list(accumulate(nums, initial=0))\n        l, r = 1, n\n        while l < r:\n            mid = (l + r + 1) >> 1\n            if check(mid):\n                l = mid\n            else:\n                r = mid - 1\n        return l\n", "class Solution:\n  def maxFrequency(self, nums: list[int], k: int) -> int:\n    ans = 0\n    summ = 0\n\n    nums.sort()\n\n    l = 0\n    for r, num in enumerate(nums):\n      summ += num\n      while summ + k < num * (r - l + 1):\n        summ -= nums[l]\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1817, "slug": "finding-the-users-active-minutes", "solutions": ["class Solution:\n    def findingUsersActiveMinutes(self, logs: List[List[int]], k: int) -> List[int]:\n        d = defaultdict(set)\n        for i, t in logs:\n            d[i].add(t)\n        ans = [0] * k\n        for ts in d.values():\n            ans[len(ts) - 1] += 1\n        return ans\n", "class Solution:\n  def findingUsersActiveMinutes(\n      self,\n      logs: list[list[int]],\n      k: int,\n  ) -> list[int]:\n    idToTimes = collections.defaultdict(set)\n\n    for id, time in logs:\n      idToTimes[id].add(time)\n\n    c = collections.Counter(len(times) for times in idToTimes.values())\n    return [c[i] for i in range(1, k + 1)]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1837, "slug": "sum-of-digits-in-base-k", "solutions": ["class Solution:\n    def sumBase(self, n: int, k: int) -> int:\n        ans = 0\n        while n:\n            ans += n % k\n            n //= k\n        return ans\n", "class Solution:\n  def sumBase(self, n: int, k: int) -> int:\n    ans = 0\n\n    while n > 0:\n      ans += n % k\n      n //= k\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1850, "slug": "minimum-adjacent-swaps-to-reach-the-kth-smallest-number", "solutions": ["class Solution:\n    def getMinSwaps(self, num: str, k: int) -> int:\n        def next_permutation(nums: List[str]) -> bool:\n            n = len(nums)\n            i = n - 2\n            while i >= 0 and nums[i] >= nums[i + 1]:\n                i -= 1\n            if i < 0:\n                return False\n            j = n - 1\n            while j >= 0 and nums[j] <= nums[i]:\n                j -= 1\n            nums[i], nums[j] = nums[j], nums[i]\n            nums[i + 1 : n] = nums[i + 1 : n][::-1]\n            return True\n\n        s = list(num)\n        for _ in range(k):\n            next_permutation(s)\n        d = [[] for _ in range(10)]\n        idx = [0] * 10\n        n = len(s)\n        for i, c in enumerate(num):\n            j = ord(c) - ord(\"0\")\n            d[j].append(i)\n        arr = [0] * n\n        for i, c in enumerate(s):\n            j = ord(c) - ord(\"0\")\n            arr[i] = d[j][idx[j]]\n            idx[j] += 1\n        return sum(arr[j] > arr[i] for i in range(n) for j in range(i))\n", "class Solution:\n  def getMinSwaps(self, num: str, k: int) -> int:\n    original = [int(c) for c in num]\n    permutated = original.copy()\n\n    for _ in range(k):\n      self._nextPermutation(permutated)\n\n    return self._countSteps(original, permutated)\n\n  def _nextPermutation(self, nums: list[int]):\n    n = len(nums)\n\n    # From the back to the front, find the first num < nums[i + 1].\n    i = n - 2\n    while i >= 0:\n      if nums[i] < nums[i + 1]:\n        break\n      i -= 1\n\n    # From the back to the front, find the first num > nums[i] and swap it with nums[i].\n    if i >= 0:\n      for j in range(n - 1, i, -1):\n        if nums[j] > nums[i]:\n          nums[i], nums[j] = nums[j], nums[i]\n          break\n\n    def reverse(nums, l, r):\n      while l < r:\n        nums[l], nums[r] = nums[r], nums[l]\n        l += 1\n        r -= 1\n\n    # Reverse nums[i + 1..n - 1].\n    reverse(nums, i + 1, len(nums) - 1)\n\n  def _countSteps(self, A: list[int], B: list[int]) -> int:\n    count = 0\n\n    j = 0\n    for i in range(len(A)):\n      j = i\n      while A[i] != B[j]:\n        j += 1\n      while i < j:\n        B[j], B[j - 1] = B[j - 1], B[j]\n        j -= 1\n        count += 1\n\n    return count\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1800, "slug": "maximum-ascending-subarray-sum", "solutions": ["class Solution:\n    def maxAscendingSum(self, nums: List[int]) -> int:\n        ans = t = 0\n        for i, v in enumerate(nums):\n            if i == 0 or v > nums[i - 1]:\n                t += v\n                ans = max(ans, t)\n            else:\n                t = v\n        return ans\n", "class Solution:\n  def maxAscendingSum(self, nums: list[int]) -> int:\n    ans = 0\n    sum = nums[0]\n\n    for i in range(1, len(nums)):\n      if nums[i] > nums[i - 1]:\n        sum += nums[i]\n      else:\n        ans = max(ans, sum)\n        sum = nums[i]\n\n    return max(ans, sum)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1835, "slug": "find-xor-sum-of-all-pairs-bitwise-and", "solutions": ["class Solution:\n    def getXORSum(self, arr1: List[int], arr2: List[int]) -> int:\n        a = reduce(xor, arr1)\n        b = reduce(xor, arr2)\n        return a & b\n", "class Solution:\n  def getXORSum(self, arr1: list[int], arr2: list[int]) -> int:\n    return functools.reduce(\n        operator.xor, arr1) & functools.reduce(\n        operator.xor, arr2)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1851, "slug": "minimum-interval-to-include-each-query", "solutions": ["class Solution:\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\n        n, m = len(intervals), len(queries)\n        intervals.sort()\n        queries = sorted((x, i) for i, x in enumerate(queries))\n        ans = [-1] * m\n        pq = []\n        i = 0\n        for x, j in queries:\n            while i < n and intervals[i][0] <= x:\n                a, b = intervals[i]\n                heappush(pq, (b - a + 1, b))\n                i += 1\n            while pq and pq[0][1] < x:\n                heappop(pq)\n            if pq:\n                ans[j] = pq[0][0]\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1841, "slug": "league-statistics", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 375, "slug": "guess-number-higher-or-lower-ii", "solutions": ["class Solution:\n    def getMoneyAmount(self, n: int) -> int:\n        f = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n - 1, 0, -1):\n            for j in range(i + 1, n + 1):\n                f[i][j] = j + f[i][j - 1]\n                for k in range(i, j):\n                    f[i][j] = min(f[i][j], max(f[i][k - 1], f[k + 1][j]) + k)\n        return f[1][n]\n", "class Solution:\n  def getMoneyAmount(self, n: int) -> int:\n    @functools.lru_cache(None)\n    def dp(i: int, j: int) -> int:\n      \"\"\"Returns the minimum money you need to guarantee a win of picking i..j.\n      \"\"\"\n      if i >= j:\n        return 0\n      return min(max(dp(i, k - 1), dp(k + 1, j)) + k\n                 for k in range(i, j + 1))\n\n    return dp(1, n)\n", "class Solution:\n  def getMoneyAmount(self, n: int) -> int:\n    # dp[i][j] := the minimum money you need to guarantee a win of picking i..j\n    dp = [[0] * (n + 2) for _ in range(n + 2)]\n\n    for d in range(1, n + 1):\n      for i in range(1, n - d + 1):\n        j = i + d\n        dp[i][j] = math.inf\n        for k in range(i, j + 1):\n          dp[i][j] = min(dp[i][j], max(dp[i][k - 1], dp[k + 1][j]) + k)\n\n    return dp[1][n]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 303, "slug": "range-sum-query-immutable", "solutions": ["class NumArray:\n    def __init__(self, nums: List[int]):\n        self.s = list(accumulate(nums, initial=0))\n\n    def sumRange(self, left: int, right: int) -> int:\n        return self.s[right + 1] - self.s[left]\n\n\n# Your NumArray object will be instantiated and called as such:\n# obj = NumArray(nums)\n# param_1 = obj.sumRange(left,right)\n", "class NumArray:\n  def __init__(self, nums: list[int]):\n    self.prefix = list(itertools.accumulate(nums, initial=0))\n\n  def sumRange(self, left: int, right: int) -> int:\n    return self.prefix[right + 1] - self.prefix[left]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 378, "slug": "kth-smallest-element-in-a-sorted-matrix", "solutions": ["class Solution:\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\n        def check(matrix, mid, k, n):\n            count = 0\n            i, j = n - 1, 0\n            while i >= 0 and j < n:\n                if matrix[i][j] <= mid:\n                    count += i + 1\n                    j += 1\n                else:\n                    i -= 1\n            return count >= k\n\n        n = len(matrix)\n        left, right = matrix[0][0], matrix[n - 1][n - 1]\n        while left < right:\n            mid = (left + right) >> 1\n            if check(matrix, mid, k, n):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n", "class Solution:\n  def kthSmallest(self, matrix: list[list[int]], k: int) -> int:\n    minHeap = []  # (matrix[i][j], i, j)\n\n    i = 0\n    while i < k and i < len(matrix):\n      heapq.heappush(minHeap, (matrix[i][0], i, 0))\n      i += 1\n\n    while k > 1:\n      k -= 1\n      _, i, j = heapq.heappop(minHeap)\n      if j + 1 < len(matrix[0]):\n        heapq.heappush(minHeap, (matrix[i][j + 1], i, j + 1))\n\n    return minHeap[0][0]\n", "class Solution:\n  def kthSmallest(self, matrix: list[list[int]], k: int) -> int:\n    def numsNoGreaterThan(m: int) -> int:\n      count = 0\n      j = len(matrix[0]) - 1\n      # For each row, find the first index j s.t. row[j] <= m s.t. the number of\n      # numbers <= m for this row will be j + 1.\n      for row in matrix:\n        while j >= 0 and row[j] > m:\n          j -= 1\n        count += j + 1\n      return count\n\n    l = matrix[0][0]\n    r = matrix[-1][-1]\n    return bisect.bisect_left(range(l, r), k, key=numsNoGreaterThan) + l\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 387, "slug": "first-unique-character-in-a-string", "solutions": ["class Solution:\n    def firstUniqChar(self, s: str) -> int:\n        cnt = Counter(s)\n        for i, c in enumerate(s):\n            if cnt[c] == 1:\n                return i\n        return -1\n", "class Solution:\n  def firstUniqChar(self, s: str) -> int:\n    count = collections.Counter(s)\n\n    for i, c in enumerate(s):\n      if count[c] == 1:\n        return i\n\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 353, "slug": "design-snake-game", "solutions": ["class SnakeGame:\n    def __init__(self, width: int, height: int, food: List[List[int]]):\n        self.m = height\n        self.n = width\n        self.food = food\n        self.score = 0\n        self.idx = 0\n        self.q = deque([(0, 0)])\n        self.vis = {(0, 0)}\n\n    def move(self, direction: str) -> int:\n        i, j = self.q[0]\n        x, y = i, j\n        match direction:\n            case \"U\":\n                x -= 1\n            case \"D\":\n                x += 1\n            case \"L\":\n                y -= 1\n            case \"R\":\n                y += 1\n        if x < 0 or x >= self.m or y < 0 or y >= self.n:\n            return -1\n        if (\n            self.idx < len(self.food)\n            and x == self.food[self.idx][0]\n            and y == self.food[self.idx][1]\n        ):\n            self.score += 1\n            self.idx += 1\n        else:\n            self.vis.remove(self.q.pop())\n        if (x, y) in self.vis:\n            return -1\n        self.q.appendleft((x, y))\n        self.vis.add((x, y))\n        return self.score\n\n\n# Your SnakeGame object will be instantiated and called as such:\n# obj = SnakeGame(width, height, food)\n# param_1 = obj.move(direction)\n", "class SnakeGame:\n  def __init__(self, width: int, height: int, food: list[list[int]]):\n    \"\"\"\n    Initialize your data structure here.\n    @param width - screen width\n    @param height - screen height\n    @param food - A list of food positions\n    E.g food = [[1,1], [1,0]] means the first food is positioned at [1,1], the second is at [1,0].\n    \"\"\"\n    self.width = width\n    self.height = height\n    self.food = food\n    self.score = 0\n    self.k = 0  # food's index\n    self.lookup = set([self.getId(0, 0)])\n    self.body = collections.deque([self.getId(0, 0)])  # snake's body\n\n  def move(self, direction: str) -> int:\n    \"\"\"\n    Moves the snake.\n    @param direction - 'U' = Up, 'L' = Left, 'R' = Right, 'D' = Down\n    @return The game's score after the move. Return -1 if game over.\n    Game over when snake crosses the screen boundary or bites its body.\n    \"\"\"\n    # the old head's position\n    i = self.body[0] // self.width\n    j = self.body[0] % self.width\n\n    # Update the head's position and check if it's out-of-bounds.\n    if direction == \"U\":\n      i -= 1\n      if i < 0:\n        return -1\n    if direction == \"L\":\n      j -= 1\n      if j < 0:\n        return -1\n    if direction == \"R\":\n      j += 1\n      if j == self.width:\n        return -1\n    if direction == \"D\":\n      i += 1\n      if i == self.height:\n        return -1\n\n    newHead = self.getId(i, j)\n\n    # 1. Eat food and increase the size by 1.\n    if self.k < len(self.food) and i == self.food[self.k][0] and j == self.food[self.k][1]:\n      self.lookup.add(newHead)\n      self.body.appendleft(newHead)\n      self.k += 1\n      self.score += 1\n      return self.score\n\n    # 2. new head != old tail and eat body!\n    if newHead != self.body[-1] and newHead in self.lookup:\n      return -1\n\n    # 3. normal case\n    # Remove the old tail first, then add new head because new head may be in\n    # old tail's position.\n    self.lookup.remove(self.body[-1])\n    self.lookup.add(newHead)\n    self.body.pop()\n    self.body.appendleft(newHead)\n\n    return self.score\n\n  def getId(self, i: int, j: int) -> int:\n    return i * self.width + j\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 351, "slug": "android-unlock-patterns", "solutions": ["class Solution:\n    def numberOfPatterns(self, m: int, n: int) -> int:\n        def dfs(i: int, cnt: int = 1) -> int:\n            if cnt > n:\n                return 0\n            vis[i] = True\n            ans = int(cnt >= m)\n            for j in range(1, 10):\n                x = cross[i][j]\n                if not vis[j] and (x == 0 or vis[x]):\n                    ans += dfs(j, cnt + 1)\n            vis[i] = False\n            return ans\n\n        cross = [[0] * 10 for _ in range(10)]\n        cross[1][3] = cross[3][1] = 2\n        cross[1][7] = cross[7][1] = 4\n        cross[1][9] = cross[9][1] = 5\n        cross[2][8] = cross[8][2] = 5\n        cross[3][7] = cross[7][3] = 5\n        cross[3][9] = cross[9][3] = 6\n        cross[4][6] = cross[6][4] = 5\n        cross[7][9] = cross[9][7] = 8\n        vis = [False] * 10\n        return dfs(1) * 4 + dfs(2) * 4 + dfs(5)\n", "class Solution:\n  def numberOfPatterns(self, m: int, n: int) -> int:\n    seen = set()\n    accross = [[0] * 10 for _ in range(10)]\n\n    accross[1][3] = accross[3][1] = 2\n    accross[1][7] = accross[7][1] = 4\n    accross[3][9] = accross[9][3] = 6\n    accross[7][9] = accross[9][7] = 8\n    accross[1][9] = accross[9][1] = accross[2][8] = accross[8][2] = \\\n        accross[3][7] = accross[7][3] = accross[4][6] = accross[6][4] = 5\n\n    def dfs(u: int, depth: int) -> int:\n      if depth > n:\n        return 0\n\n      seen.add(u)\n      ans = 1 if depth >= m else 0\n\n      for v in range(1, 10):\n        if v == u or v in seen:\n          continue\n        accrossed = accross[u][v]\n        if not accrossed or accrossed in seen:\n          ans += dfs(v, depth + 1)\n\n      seen.remove(u)\n      return ans\n\n    # 1, 3, 7, 9 are symmetric\n    # 2, 4, 6, 8 are symmetric\n    return dfs(1, 1) * 4 + dfs(2, 1) * 4 + dfs(5, 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 352, "slug": "data-stream-as-disjoint-intervals", "solutions": ["class SummaryRanges:\n    def __init__(self):\n        self.mp = SortedDict()\n\n    def addNum(self, val: int) -> None:\n        n = len(self.mp)\n        ridx = self.mp.bisect_right(val)\n        lidx = n if ridx == 0 else ridx - 1\n        keys = self.mp.keys()\n        values = self.mp.values()\n        if (\n            lidx != n\n            and ridx != n\n            and values[lidx][1] + 1 == val\n            and values[ridx][0] - 1 == val\n        ):\n            self.mp[keys[lidx]][1] = self.mp[keys[ridx]][1]\n            self.mp.pop(keys[ridx])\n        elif lidx != n and val <= values[lidx][1] + 1:\n            self.mp[keys[lidx]][1] = max(val, self.mp[keys[lidx]][1])\n        elif ridx != n and val >= values[ridx][0] - 1:\n            self.mp[keys[ridx]][0] = min(val, self.mp[keys[ridx]][0])\n        else:\n            self.mp[val] = [val, val]\n\n    def getIntervals(self) -> List[List[int]]:\n        return list(self.mp.values())\n\n\n# # Your SummaryRanges object will be instantiated and called as such:\n# # obj = SummaryRanges()\n# # obj.addNum(val)\n# # param_2 = obj.getIntervals()\n", "from sortedcontainers import SortedDict\n\n\nclass SummaryRanges:\n  def __init__(self):\n    self.intervals = SortedDict()  # {start: (start, end)}\n\n  def addNum(self, val: int) -> None:\n    if val in self.intervals:\n      return\n\n    lo = self._lowerKey(val)\n    hi = self._higherKey(val)\n\n    # {lo, map[lo][1]} + val + {hi, map[hi][1]} = {lo, map[hi][1]}\n    if lo >= 0 and hi >= 0 and self.intervals[lo][1] + 1 == val and val + 1 == hi:\n      self.intervals[lo][1] = self.intervals[hi][1]\n      del self.intervals[hi]\n      # {lo, map[lo][1]} + val = {lo, val}\n      # Prevent adding duplicate entry by using '>=' instead of '=='.\n    elif lo >= 0 and self.intervals[lo][1] + 1 >= val:\n      self.intervals[lo][1] = max(self.intervals[lo][1], val)\n    elif hi >= 0 and val + 1 == hi:\n      # val + {hi, map[hi][1]} = {val, map[hi][1]}\n      self.intervals[val] = [val, self.intervals[hi][1]]\n      del self.intervals[hi]\n    else:\n      self.intervals[val] = [val, val]\n\n  def getIntervals(self) -> list[list[int]]:\n    return list(self.intervals.values())\n\n  def _lowerKey(self, key: int):\n    \"\"\"Returns the maximum key in `self.intervals` < `key`.\"\"\"\n    i = self.intervals.bisect_left(key)\n    if i == 0:\n      return -1\n    return self.intervals.peekitem(i - 1)[0]\n\n  def _higherKey(self, key: int):\n    \"\"\"Returns the minimum key in `self.intervals` < `key`.\"\"\"\n    i = self.intervals.bisect_right(key)\n    if i == len(self.intervals):\n      return -1\n    return self.intervals.peekitem(i)[0]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 365, "slug": "water-and-jug-problem", "solutions": ["class Solution:\n    def canMeasureWater(self, x: int, y: int, z: int) -> bool:\n        def dfs(i: int, j: int) -> bool:\n            if (i, j) in vis:\n                return False\n            vis.add((i, j))\n            if i == z or j == z or i + j == z:\n                return True\n            if dfs(x, j) or dfs(i, y) or dfs(0, j) or dfs(i, 0):\n                return True\n            a = min(i, y - j)\n            b = min(j, x - i)\n            return dfs(i - a, j + a) or dfs(i + b, j - b)\n\n        vis = set()\n        return dfs(0, 0)\n", "class Solution:\n  def canMeasureWater(\n      self,\n      jug1Capacity: int,\n      jug2Capacity: int,\n      targetCapacity: int,\n  ) -> bool:\n    return (targetCapacity == 0 or\n            jug1Capacity + jug2Capacity >= targetCapacity and\n            targetCapacity % gcd(jug1Capacity, jug2Capacity) == 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 320, "slug": "generalized-abbreviation", "solutions": ["class Solution:\n    def generateAbbreviations(self, word: str) -> List[str]:\n        def dfs(i: int) -> List[str]:\n            if i >= n:\n                return [\"\"]\n            ans = [word[i] + s for s in dfs(i + 1)]\n            for j in range(i + 1, n + 1):\n                for s in dfs(j + 1):\n                    ans.append(str(j - i) + (word[j] if j < n else \"\") + s)\n            return ans\n\n        n = len(word)\n        return dfs(0)\n", "class Solution:\n  def generateAbbreviations(self, word: str) -> list[str]:\n    ans = []\n\n    def getCountString(count: int) -> str:\n      return str(count) if count > 0 else ''\n\n    def dfs(i: int, count: int, path: list[str]) -> None:\n      if i == len(word):\n        ans.append(''.join(path) + getCountString(count))\n        return\n\n      # Abbreviate the word[i].\n      dfs(i + 1, count + 1, path)\n      # Keep the word[i], so consume the count as a string.\n      path.append(getCountString(count) + word[i])\n      # Reset the count to 0.\n      dfs(i + 1, 0, path)\n      path.pop()\n\n    dfs(0, 0, [])\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 361, "slug": "bomb-enemy", "solutions": ["class Solution:\n    def maxKilledEnemies(self, grid: List[List[str]]) -> int:\n        m, n = len(grid), len(grid[0])\n        g = [[0] * n for _ in range(m)]\n        for i in range(m):\n            t = 0\n            for j in range(n):\n                if grid[i][j] == 'W':\n                    t = 0\n                elif grid[i][j] == 'E':\n                    t += 1\n                g[i][j] += t\n            t = 0\n            for j in range(n - 1, -1, -1):\n                if grid[i][j] == 'W':\n                    t = 0\n                elif grid[i][j] == 'E':\n                    t += 1\n                g[i][j] += t\n        for j in range(n):\n            t = 0\n            for i in range(m):\n                if grid[i][j] == 'W':\n                    t = 0\n                elif grid[i][j] == 'E':\n                    t += 1\n                g[i][j] += t\n            t = 0\n            for i in range(m - 1, -1, -1):\n                if grid[i][j] == 'W':\n                    t = 0\n                elif grid[i][j] == 'E':\n                    t += 1\n                g[i][j] += t\n        return max(\n            [g[i][j] for i in range(m) for j in range(n) if grid[i][j] == '0'],\n            default=0,\n        )\n", "class Solution:\n  def maxKilledEnemies(self, grid: list[list[str]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    enemyCount = 0\n    # dp[i][j] := the maximum enemies grid[i][j] can kill\n    dp = [[0] * n for _ in range(m)]\n\n    def update(i: int, j: int) -> None:\n      nonlocal enemyCount\n      if grid[i][j] == '0':\n        dp[i][j] += enemyCount\n      elif grid[i][j] == 'E':\n        enemyCount += 1\n      else:  # grid[i][j] == 'W'\n        enemyCount = 0\n\n    # Extend the four directions, if meet 'W', need to start over from 0.\n    for i in range(m):\n      enemyCount = 0\n      for j in range(n):\n        update(i, j)\n      enemyCount = 0\n      for j in reversed(range(n)):\n        update(i, j)\n\n    for j in range(n):\n      enemyCount = 0\n      for i in range(m):\n        update(i, j)\n      enemyCount = 0\n      for i in reversed(range(m)):\n        update(i, j)\n\n    # Returns sum(map(sum, dp))\n    return max(map(max, dp))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 398, "slug": "random-pick-index", "solutions": ["class Solution:\n    def __init__(self, nums: List[int]):\n        self.nums = nums\n\n    def pick(self, target: int) -> int:\n        n = ans = 0\n        for i, v in enumerate(self.nums):\n            if v == target:\n                n += 1\n                x = random.randint(1, n)\n                if x == n:\n                    ans = i\n        return ans\n\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution(nums)\n# param_1 = obj.pick(target)\n", "class Solution:\n  def __init__(self, nums: list[int]):\n    self.nums = nums\n\n  def pick(self, target: int) -> int:\n    ans = -1\n    rng = 0\n    for i, num in enumerate(self.nums):\n      if num == target:\n        rng += 1\n        if random.randint(0, rng - 1) == 0:\n          ans = i\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 332, "slug": "reconstruct-itinerary", "solutions": ["class Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        def dfs(f: str):\n            while g[f]:\n                dfs(g[f].pop())\n            ans.append(f)\n\n        g = defaultdict(list)\n        for f, t in sorted(tickets, reverse=True):\n            g[f].append(t)\n        ans = []\n        dfs(\"JFK\")\n        return ans[::-1]\n", "class Solution:\n  def findItinerary(self, tickets: list[list[str]]) -> list[str]:\n    ans = []\n    graph = collections.defaultdict(list)\n\n    for a, b in reversed(sorted(tickets)):\n      graph[a].append(b)\n\n    def dfs(u: str) -> None:\n      while u in graph and graph[u]:\n        dfs(graph[u].pop())\n      ans.append(u)\n\n    dfs('JFK')\n    return ans[::-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 367, "slug": "valid-perfect-square", "solutions": ["class Solution:\n    def isPerfectSquare(self, num: int) -> bool:\n        l = bisect_left(range(1, num + 1), num, key=lambda x: x * x) + 1\n        return l * l == num\n", "class Solution:\n  def isPerfectSquare(self, num: int) -> bool:\n    l = bisect.bisect_left(range(num), num, key=lambda m: m * m)\n    return l**2 == num\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 391, "slug": "perfect-rectangle", "solutions": ["class Solution:\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\n        area = 0\n        minX, minY = rectangles[0][0], rectangles[0][1]\n        maxX, maxY = rectangles[0][2], rectangles[0][3]\n        cnt = defaultdict(int)\n\n        for r in rectangles:\n            area += (r[2] - r[0]) * (r[3] - r[1])\n\n            minX = min(minX, r[0])\n            minY = min(minY, r[1])\n            maxX = max(maxX, r[2])\n            maxY = max(maxY, r[3])\n\n            cnt[(r[0], r[1])] += 1\n            cnt[(r[0], r[3])] += 1\n            cnt[(r[2], r[3])] += 1\n            cnt[(r[2], r[1])] += 1\n\n        if (\n            area != (maxX - minX) * (maxY - minY)\n            or cnt[(minX, minY)] != 1\n            or cnt[(minX, maxY)] != 1\n            or cnt[(maxX, maxY)] != 1\n            or cnt[(maxX, minY)] != 1\n        ):\n            return False\n\n        del cnt[(minX, minY)], cnt[(minX, maxY)], cnt[(maxX, maxY)], cnt[(maxX, minY)]\n\n        return all(c == 2 or c == 4 for c in cnt.values())\n", "class Solution:\n  def isRectangleCover(self, rectangles: list[list[int]]) -> bool:\n    area = 0\n    x1 = math.inf\n    y1 = math.inf\n    x2 = -math.inf\n    y2 = -math.inf\n    corners: set[tuple[int, int]] = set()\n\n    for x, y, a, b in rectangles:\n      area += (a - x) * (b - y)\n      x1 = min(x1, x)\n      y1 = min(y1, y)\n      x2 = max(x2, a)\n      y2 = max(y2, b)\n\n      # the four points of the current rectangle\n      for point in [(x, y), (x, b), (a, y), (a, b)]:\n        if point in corners:\n          corners.remove(point)\n        else:\n          corners.add(point)\n\n    if len(corners) != 4:\n      return False\n    if ((x1, y1) not in corners or\n        (x1, y2) not in corners or\n        (x2, y1) not in corners or\n            (x2, y2) not in corners):\n      return False\n    return area == (x2 - x1) * (y2 - y1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 325, "slug": "maximum-size-subarray-sum-equals-k", "solutions": ["class Solution:\n    def maxSubArrayLen(self, nums: List[int], k: int) -> int:\n        d = {0: -1}\n        ans = s = 0\n        for i, x in enumerate(nums):\n            s += x\n            if s - k in d:\n                ans = max(ans, i - d[s - k])\n            if s not in d:\n                d[s] = i\n        return ans\n", "class Solution:\n  def maxSubArrayLen(self, nums: list[int], k: int) -> int:\n    ans = 0\n    prefix = 0\n    prefixToIndex = {0: -1}\n\n    for i, num in enumerate(nums):\n      prefix += num\n      target = prefix - k\n      if target in prefixToIndex:\n        ans = max(ans, i - prefixToIndex[target])\n      if prefix not in prefixToIndex:\n        prefixToIndex[prefix] = i\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 333, "slug": "largest-bst-subtree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def largestBSTSubtree(self, root: Optional[TreeNode]) -> int:\n        def dfs(root):\n            if root is None:\n                return inf, -inf, 0\n            lmi, lmx, ln = dfs(root.left)\n            rmi, rmx, rn = dfs(root.right)\n            nonlocal ans\n            if lmx < root.val < rmi:\n                ans = max(ans, ln + rn + 1)\n                return min(lmi, root.val), max(rmx, root.val), ln + rn + 1\n            return -inf, inf, 0\n\n        ans = 0\n        dfs(root)\n        return ans\n", "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass T:\n  mn: int  # the minimum value in the subtree\n  mx: int  # the maximum value in the subtree\n  size: int  # the size of the subtree\n\n\nclass Solution:\n  def largestBSTSubtree(self, root: TreeNode | None) -> int:\n    def dfs(root: TreeNode | None) -> T:\n      if not root:\n        return T(math.inf, -math.inf, 0)\n\n      l = dfs(root.left)\n      r = dfs(root.right)\n\n      if l.mx < root.val < r.mn:\n        return T(min(l.mn, root.val), max(r.mx, root.val), 1 + l.size + r.size)\n\n      # Mark one as invalid, but still record the size of children.\n      # Return (-inf, inf) because no node will be > inf or < -inf.\n      return T(-math.inf, math.inf, max(l.size, r.size))\n\n    return dfs(root).size\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 300, "slug": "longest-increasing-subsequence", "solutions": ["class Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        n = len(nums)\n        f = [1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if nums[j] < nums[i]:\n                    f[i] = max(f[i], f[j] + 1)\n        return max(f)\n", "class Solution:\n  def lengthOfLIS(self, nums: list[int]) -> int:\n    # tails[i] := the minimum tails of all the increasing subsequences having\n    # length i + 1\n    tails = []\n\n    for num in nums:\n      if not tails or num > tails[-1]:\n        tails.append(num)\n      else:\n        tails[bisect.bisect_left(tails, num)] = num\n\n    return len(tails)\n", "class Solution:\n  def lengthOfLIS(self, nums: list[int]) -> int:\n    if not nums:\n      return 0\n\n    # dp[i] the length of LIS ending in nums[i]\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n      for j in range(i):\n        if nums[j] < nums[i]:\n          dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 342, "slug": "power-of-four", "solutions": ["class Solution:\n    def isPowerOfFour(self, n: int) -> bool:\n        return n > 0 and (n & (n - 1)) == 0 and (n & 0xAAAAAAAA) == 0\n", "class Solution:\n  def isPowerOfFour(self, n: int) -> bool:\n    # Why (4^n - 1) % 3 == 0?\n    # (4^n - 1) = (2^n - 1)(2^n + 1) and 2^n - 1, 2^n, 2^n + 1 are\n    # three consecutive numbers; among one of them, there must be a multiple\n    # of 3, and that can't be 2^n, so it must be either 2^n - 1 or 2^n + 1.\n    # Therefore, 4^n - 1 is a multiple of 3.\n    return n > 0 and n.bit_count() == 1 and (n - 1) % 3 == 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 369, "slug": "plus-one-linked-list", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def plusOne(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode(0, head)\n        target = dummy\n        while head:\n            if head.val != 9:\n                target = head\n            head = head.next\n        target.val += 1\n        target = target.next\n        while target:\n            target.val = 0\n            target = target.next\n        return dummy if dummy.val else dummy.next\n", "class Solution:\n  def plusOne(self, head: ListNode) -> ListNode:\n    dummy = ListNode(0)\n    curr = dummy\n    dummy.next = head\n\n    while head:\n      if head.val != 9:\n        curr = head\n      head = head.next\n    # `curr` now points to the rightmost non-9 node.\n\n    curr.val += 1\n    while curr.next:\n      curr.next.val = 0\n      curr = curr.next\n\n    return dummy.next if dummy.val == 0 else dummy\n", "class Solution:\n  def plusOne(self, head: ListNode) -> ListNode:\n    if not head:\n      return ListNode(1)\n    if self._addOne(head) == 1:\n      return ListNode(1, head)\n    return head\n\n  def _addOne(self, node: ListNode) -> int:\n    carry = self._addOne(node.next) if node.next else 1\n    summ = node.val + carry\n    node.val = summ % 10\n    return summ // 10\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 393, "slug": "utf-8-validation", "solutions": ["class Solution:\n    def validUtf8(self, data: List[int]) -> bool:\n        cnt = 0\n        for v in data:\n            if cnt > 0:\n                if v >> 6 != 0b10:\n                    return False\n                cnt -= 1\n            elif v >> 7 == 0:\n                cnt = 0\n            elif v >> 5 == 0b110:\n                cnt = 1\n            elif v >> 4 == 0b1110:\n                cnt = 2\n            elif v >> 3 == 0b11110:\n                cnt = 3\n            else:\n                return False\n        return cnt == 0\n", "class Solution:\n  def validUtf8(self, data: list[int]) -> bool:\n    followedBytes = 0\n\n    for d in data:\n      if followedBytes == 0:\n        if (d >> 3) == 0b11110:\n          followedBytes = 3\n        elif (d >> 4) == 0b1110:\n          followedBytes = 2\n        elif (d >> 5) == 0b110:\n          followedBytes = 1\n        elif (d >> 7) == 0b0:\n          followedBytes = 0\n        else:\n          return False\n      else:\n        if (d >> 6) != 0b10:\n          return False\n        followedBytes -= 1\n\n    return followedBytes == 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 326, "slug": "power-of-three", "solutions": ["class Solution:\n    def isPowerOfThree(self, n: int) -> bool:\n        while n > 2:\n            if n % 3:\n                return False\n            n //= 3\n        return n == 1\n", "class Solution:\n  def isPowerOfThree(self, n: int) -> bool:\n    return n > 0 and 3**19 % n == 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 321, "slug": "create-maximum-number", "solutions": ["class Solution:\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\n        def f(nums: List[int], k: int) -> List[int]:\n            n = len(nums)\n            stk = [0] * k\n            top = -1\n            remain = n - k\n            for x in nums:\n                while top >= 0 and stk[top] < x and remain > 0:\n                    top -= 1\n                    remain -= 1\n                if top + 1 < k:\n                    top += 1\n                    stk[top] = x\n                else:\n                    remain -= 1\n            return stk\n\n        def compare(nums1: List[int], nums2: List[int], i: int, j: int) -> bool:\n            if i >= len(nums1):\n                return False\n            if j >= len(nums2):\n                return True\n            if nums1[i] > nums2[j]:\n                return True\n            if nums1[i] < nums2[j]:\n                return False\n            return compare(nums1, nums2, i + 1, j + 1)\n\n        def merge(nums1: List[int], nums2: List[int]) -> List[int]:\n            m, n = len(nums1), len(nums2)\n            i = j = 0\n            ans = [0] * (m + n)\n            for k in range(m + n):\n                if compare(nums1, nums2, i, j):\n                    ans[k] = nums1[i]\n                    i += 1\n                else:\n                    ans[k] = nums2[j]\n                    j += 1\n            return ans\n\n        m, n = len(nums1), len(nums2)\n        l, r = max(0, k - n), min(k, m)\n        ans = [0] * k\n        for x in range(l, r + 1):\n            arr1 = f(nums1, x)\n            arr2 = f(nums2, k - x)\n            arr = merge(arr1, arr2)\n            if ans < arr:\n                ans = arr\n        return ans\n", "class Solution:\n  def maxNumber(self, nums1: list[int], nums2: list[int], k: int) -> list[int]:\n    def maxArray(nums: list[int], k: int) -> list[int]:\n      res = []\n      toTop = len(nums) - k\n      for num in nums:\n        while res and res[-1] < num and toTop > 0:\n          res.pop()\n          toTop -= 1\n        res.append(num)\n      return res[:k]\n\n    def merge(nums1: list[int], nums2: list[int]) -> list[int]:\n      return [max(nums1, nums2).pop(0) for _ in nums1 + nums2]\n\n    return max(merge(maxArray(nums1, i), maxArray(nums2, k - i))\n               for i in range(k + 1)\n               if i <= len(nums1) and k - i <= len(nums2))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 394, "slug": "decode-string", "solutions": ["class Solution:\n    def decodeString(self, s: str) -> str:\n        s1, s2 = [], []\n        num, res = 0, ''\n        for c in s:\n            if c.isdigit():\n                num = num * 10 + int(c)\n            elif c == '[':\n                s1.append(num)\n                s2.append(res)\n                num, res = 0, ''\n            elif c == ']':\n                res = s2.pop() + res * s1.pop()\n            else:\n                res += c\n        return res\n", "class Solution:\n  def decodeString(self, s: str) -> str:\n    ans = ''\n\n    while self.i < len(s) and s[self.i] != ']':\n      if s[self.i].isdigit():\n        k = 0\n        while self.i < len(s) and s[self.i].isdigit():\n          k = k * 10 + int(s[self.i])\n          self.i += 1\n        self.i += 1  # '['\n        decodedString = self.decodeString(s)\n        self.i += 1  # ']'\n        ans += k * decodedString\n      else:\n        ans += s[self.i]\n        self.i += 1\n\n    return ans\n\n  i = 0\n", "class Solution:\n  def decodeString(self, s: str) -> str:\n    stack = []  # (prevStr, repeatCount)\n    currStr = ''\n    currNum = 0\n\n    for c in s:\n      if c.isdigit():\n        currNum = currNum * 10 + int(c)\n      else:\n        if c == '[':\n          stack.append((currStr, currNum))\n          currStr = ''\n          currNum = 0\n        elif c == ']':\n          prevStr, num = stack.pop()\n          currStr = prevStr + num * currStr\n        else:\n          currStr += c\n\n    return currStr\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 341, "slug": "flatten-nested-list-iterator", "solutions": ["# \"\"\"\n# This is the interface that allows for creating nested lists.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# class NestedInteger:\n#    def isInteger(self) -> bool:\n#        \"\"\"\n#        @return True if this NestedInteger holds a single integer, rather than a nested list.\n#        \"\"\"\n#\n#    def getInteger(self) -> int:\n#        \"\"\"\n#        @return the single integer that this NestedInteger holds, if it holds a single integer\n#        Return None if this NestedInteger holds a nested list\n#        \"\"\"\n#\n#    def getList(self) -> [NestedInteger]:\n#        \"\"\"\n#        @return the nested list that this NestedInteger holds, if it holds a nested list\n#        Return None if this NestedInteger holds a single integer\n#        \"\"\"\n\n\nclass NestedIterator:\n    def __init__(self, nestedList: [NestedInteger]):\n        def dfs(ls):\n            for x in ls:\n                if x.isInteger():\n                    self.nums.append(x.getInteger())\n                else:\n                    dfs(x.getList())\n\n        self.nums = []\n        self.i = -1\n        dfs(nestedList)\n\n    def next(self) -> int:\n        self.i += 1\n        return self.nums[self.i]\n\n    def hasNext(self) -> bool:\n        return self.i + 1 < len(self.nums)\n\n\n# Your NestedIterator object will be instantiated and called as such:\n# i, v = NestedIterator(nestedList), []\n# while i.hasNext(): v.append(i.next())\n", "class NestedIterator:\n  def __init__(self, nestedList: list[NestedInteger]):\n    self.stack: list[NestedInteger] = []\n    self.addInteger(nestedList)\n\n  def next(self) -> int:\n    return self.stack.pop().getInteger()\n\n  def hasNext(self) -> bool:\n    while self.stack and not self.stack[-1].isInteger():\n      self.addInteger(self.stack.pop().getList())\n    return self.stack\n\n  # addInteger([1, [4, [6]]]) . stack = [[4, [6]], 1]\n  # addInteger([4, [6]]) . stack = [[6], 4]\n  # addInteger([6]) . stack = [6]\n  def addInteger(self, nestedList: list[NestedInteger]) -> None:\n    for n in reversed(nestedList):\n      self.stack.append(n)\n", "class NestedIterator:\n  def __init__(self, nestedList: list[NestedInteger]):\n    self.q = collections.deque()\n    self.addInteger(nestedList)\n\n  def next(self) -> int:\n    return self.q.popleft()\n\n  def hasNext(self) -> bool:\n    return self.q\n\n  def addInteger(self, nestedList: list[NestedInteger]) -> None:\n    for ni in nestedList:\n      if ni.isInteger():\n        self.q.append(ni.getInteger())\n      else:\n        self.addInteger(ni.getList())\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 380, "slug": "insert-delete-getrandom-o1", "solutions": ["class RandomizedSet:\n    def __init__(self):\n        self.d = {}\n        self.q = []\n\n    def insert(self, val: int) -> bool:\n        if val in self.d:\n            return False\n        self.d[val] = len(self.q)\n        self.q.append(val)\n        return True\n\n    def remove(self, val: int) -> bool:\n        if val not in self.d:\n            return False\n        i = self.d[val]\n        self.d[self.q[-1]] = i\n        self.q[i] = self.q[-1]\n        self.q.pop()\n        self.d.pop(val)\n        return True\n\n    def getRandom(self) -> int:\n        return choice(self.q)\n\n\n# Your RandomizedSet object will be instantiated and called as such:\n# obj = RandomizedSet()\n# param_1 = obj.insert(val)\n# param_2 = obj.remove(val)\n# param_3 = obj.getRandom()\n", "class RandomizedSet:\n  def __init__(self):\n    self.vals = []\n    self.valToIndex = collections.defaultdict(int)  # {val: index in vals}\n\n  def insert(self, val: int) -> bool:\n    if val in self.valToIndex:\n      return False\n    self.valToIndex[val] = len(self.vals)\n    self.vals.append(val)\n    return True\n\n  def remove(self, val: int) -> bool:\n    if val not in self.valToIndex:\n      return False\n    index = self.valToIndex[val]\n    # The order of the following two lines is important when vals.size() == 1.\n    self.valToIndex[self.vals[-1]] = index\n    del self.valToIndex[val]\n    self.vals[index] = self.vals[-1]\n    self.vals.pop()\n    return True\n\n  def getRandom(self) -> int:\n    index = random.randint(0, len(self.vals) - 1)\n    return self.vals[index]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 397, "slug": "integer-replacement", "solutions": ["class Solution:\n    def integerReplacement(self, n: int) -> int:\n        ans = 0\n        while n != 1:\n            if (n & 1) == 0:\n                n >>= 1\n            elif n != 3 and (n & 3) == 3:\n                n += 1\n            else:\n                n -= 1\n            ans += 1\n        return ans\n", "class Solution:\n  def integerReplacement(self, n: int) -> int:\n    ans = 0\n\n    while n > 1:\n      if n % 2 == 0:  # `n` ends in 0.\n        n >>= 1\n      elif n == 3 or (n >> 1 & 1) == 0:  # `n` = 3 or ends in 0b01.\n        n -= 1\n      else:  # `n` ends in 0b11.\n        n += 1\n      ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 317, "slug": "shortest-distance-from-all-buildings", "solutions": ["class Solution:\n    def shortestDistance(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        q = deque()\n        total = 0\n        cnt = [[0] * n for _ in range(m)]\n        dist = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    total += 1\n                    q.append((i, j))\n                    d = 0\n                    vis = set()\n                    while q:\n                        d += 1\n                        for _ in range(len(q)):\n                            r, c = q.popleft()\n                            for a, b in [[0, 1], [0, -1], [1, 0], [-1, 0]]:\n                                x, y = r + a, c + b\n                                if (\n                                    0 <= x < m\n                                    and 0 <= y < n\n                                    and grid[x][y] == 0\n                                    and (x, y) not in vis\n                                ):\n                                    cnt[x][y] += 1\n                                    dist[x][y] += d\n                                    q.append((x, y))\n                                    vis.add((x, y))\n        ans = inf\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 0 and cnt[i][j] == total:\n                    ans = min(ans, dist[i][j])\n        return -1 if ans == inf else ans\n", "class Solution:\n  def shortestDistance(self, grid: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    nBuildings = sum(a == 1 for row in grid for a in row)\n    ans = math.inf\n    # dist[i][j] := the total distance of grid[i][j] (0) to reach all the\n    # buildings (1)\n    dist = [[0] * n for _ in range(m)]\n    # reachCount[i][j] := the number of buildings (1) grid[i][j] (0) can reach\n    reachCount = [[0] * n for _ in range(m)]\n\n    def bfs(row: int, col: int) -> bool:\n      q = collections.deque([(row, col)])\n      seen = {(row, col)}\n      seenBuildings = 1\n\n      step = 1\n      while q:\n        for _ in range(len(q)):\n          i, j = q.popleft()\n          for dx, dy in DIRS:\n            x = i + dx\n            y = j + dy\n            if x < 0 or x == m or y < 0 or y == n:\n              continue\n            if (x, y) in seen:\n              continue\n            seen.add((x, y))\n            if not grid[x][y]:\n              dist[x][y] += step\n              reachCount[x][y] += 1\n              q.append((x, y))\n            elif grid[x][y] == 1:\n              seenBuildings += 1\n        step += 1\n\n      # True if all the buildings (1) are connected\n      return seenBuildings == nBuildings\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1:  # BFS from this building.\n          if not bfs(i, j):\n            return -1\n\n    for i in range(m):\n      for j in range(n):\n        if reachCount[i][j] == nBuildings:\n          ans = min(ans, dist[i][j])\n\n    return -1 if ans == math.inf else ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 350, "slug": "intersection-of-two-arrays-ii", "solutions": ["class Solution:\n    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        cnt = Counter(nums1)\n        ans = []\n        for x in nums2:\n            if cnt[x]:\n                ans.append(x)\n                cnt[x] -= 1\n        return ans\n", "class Solution:\n  def intersect(self, nums1: list[int], nums2: list[int]) -> list[int]:\n    if len(nums1) > len(nums2):\n      return self.intersect(nums2, nums1)\n\n    ans = []\n    count = collections.Counter(nums1)\n\n    for num in nums2:\n      if count[num] > 0:\n        ans.append(num)\n        count[num] -= 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 330, "slug": "patching-array", "solutions": ["class Solution:\n    def minPatches(self, nums: List[int], n: int) -> int:\n        x = 1\n        ans = i = 0\n        while x <= n:\n            if i < len(nums) and nums[i] <= x:\n                x += nums[i]\n                i += 1\n            else:\n                ans += 1\n                x <<= 1\n        return ans\n", "class Solution:\n  def minPatches(self, nums: list[int], n: int) -> int:\n    ans = 0\n    i = 0  # nums' index\n    miss = 1  # the minimum sum in [1, n] we might miss\n\n    while miss <= n:\n      if i < len(nums) and nums[i] <= miss:\n        miss += nums[i]\n        i += 1\n      else:\n        # Greedily add `miss` itself to increase the range from\n        # [1, miss) to [1, 2 * miss).\n        miss += miss\n        ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 322, "slug": "coin-change", "solutions": ["class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        m, n = len(coins), amount\n        f = [[inf] * (n + 1) for _ in range(m + 1)]\n        f[0][0] = 0\n        for i, x in enumerate(coins, 1):\n            for j in range(n + 1):\n                f[i][j] = f[i - 1][j]\n                if j >= x:\n                    f[i][j] = min(f[i][j], f[i][j - x] + 1)\n        return -1 if f[m][n] >= inf else f[m][n]\n", "class Solution:\n  def coinChange(self, coins: list[int], amount: int) -> int:\n    # dp[i] := the minimum number Of coins to make up i\n    dp = [0] + [amount + 1] * amount\n\n    for coin in coins:\n      for i in range(coin, amount + 1):\n        dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    return -1 if dp[amount] == amount + 1 else dp[amount]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 349, "slug": "intersection-of-two-arrays", "solutions": ["class Solution:\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        return list(set(nums1) & set(nums2))\n", "class Solution:\n  def intersection(self, nums1: list[int], nums2: list[int]) -> list[int]:\n    ans = []\n    nums1 = set(nums1)\n\n    for num in nums2:\n      if num in nums1:\n        ans.append(num)\n        nums1.remove(num)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 302, "slug": "smallest-rectangle-enclosing-black-pixels", "solutions": ["class Solution:\n    def minArea(self, image: List[List[str]], x: int, y: int) -> int:\n        m, n = len(image), len(image[0])\n        left, right = 0, x\n        while left < right:\n            mid = (left + right) >> 1\n            c = 0\n            while c < n and image[mid][c] == '0':\n                c += 1\n            if c < n:\n                right = mid\n            else:\n                left = mid + 1\n        u = left\n        left, right = x, m - 1\n        while left < right:\n            mid = (left + right + 1) >> 1\n            c = 0\n            while c < n and image[mid][c] == '0':\n                c += 1\n            if c < n:\n                left = mid\n            else:\n                right = mid - 1\n        d = left\n        left, right = 0, y\n        while left < right:\n            mid = (left + right) >> 1\n            r = 0\n            while r < m and image[r][mid] == '0':\n                r += 1\n            if r < m:\n                right = mid\n            else:\n                left = mid + 1\n        l = left\n        left, right = y, n - 1\n        while left < right:\n            mid = (left + right + 1) >> 1\n            r = 0\n            while r < m and image[r][mid] == '0':\n                r += 1\n            if r < m:\n                left = mid\n            else:\n                right = mid - 1\n        r = left\n        return (d - u + 1) * (r - l + 1)\n", "class Solution:\n  def minArea(self, image: list[list[str]], x: int, y: int) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(image)\n    n = len(image[0])\n    topLeft = [x, y]\n    bottomRight = [x, y]\n    q = collections.deque([(x, y)])\n    image[x][y] = '2'  # Mark as visited.\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in DIRS:\n        r = i + dx\n        c = j + dy\n        if r < 0 or r == m or c < 0 or c == n:\n          continue\n        if image[r][c] != '1':\n          continue\n        topLeft[0] = min(topLeft[0], r)\n        topLeft[1] = min(topLeft[1], c)\n        bottomRight[0] = max(bottomRight[0], r)\n        bottomRight[1] = max(bottomRight[1], c)\n        q.append((r, c))\n        image[r][c] = '2'\n\n    width = bottomRight[1] - topLeft[1] + 1\n    height = bottomRight[0] - topLeft[0] + 1\n    return width * height\n", "class Solution:\n  def minArea(self, image: list[list[str]], x: int, y: int) -> int:\n    def firstAnyOne(l: int, r: int, allZeros: Callable[[int], bool]) -> int:\n      while l < r:\n        m = (l + r) // 2\n        if allZeros(m):\n          l = m + 1\n        else:\n          r = m\n      return l\n\n    def firstAllZeros(l: int, r: int, allZeros: Callable[[int], bool]) -> int:\n      while l < r:\n        m = (l + r) // 2\n        if allZeros(m):\n          r = m\n        else:\n          l = m + 1\n      return l\n\n    def colAllZeros(colIndex: int) -> bool:\n      return all(pixel == '0' for pixel in list(zip(*image))[colIndex])\n\n    def rowAllZeros(rowIndex: int) -> bool:\n      return all(pixel == '0' for pixel in image[rowIndex])\n\n    x1 = firstAnyOne(0, x, rowAllZeros)\n    x2 = firstAllZeros(x + 1, len(image), rowAllZeros)\n    y1 = firstAnyOne(0, y, colAllZeros)\n    y2 = firstAllZeros(y + 1, len(image[0]), colAllZeros)\n    return (x2 - x1) * (y2 - y1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 329, "slug": "longest-increasing-path-in-a-matrix", "solutions": ["class Solution:\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\n        @cache\n        def dfs(i: int, j: int) -> int:\n            ans = 0\n            for a, b in pairwise((-1, 0, 1, 0, -1)):\n                x, y = i + a, j + b\n                if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                    ans = max(ans, dfs(x, y))\n            return ans + 1\n\n        m, n = len(matrix), len(matrix[0])\n        return max(dfs(i, j) for i in range(m) for j in range(n))\n", "class Solution:\n  def longestIncreasingPath(self, matrix: list[list[int]]) -> int:\n    m = len(matrix)\n    n = len(matrix[0])\n\n    @functools.lru_cache(None)\n    def dfs(i: int, j: int, prev: int) -> int:\n      if i < 0 or i == m or j < 0 or j == n:\n        return 0\n      if matrix[i][j] <= prev:\n        return 0\n\n      curr = matrix[i][j]\n      return 1 + max(dfs(i + 1, j, curr),\n                     dfs(i - 1, j, curr),\n                     dfs(i, j + 1, curr),\n                     dfs(i, j - 1, curr))\n\n    return max(dfs(i, j, -math.inf) for i in range(m) for j in range(n))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 366, "slug": "find-leaves-of-binary-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findLeaves(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def dfs(root: Optional[TreeNode]) -> int:\n            if root is None:\n                return 0\n            l, r = dfs(root.left), dfs(root.right)\n            h = max(l, r)\n            if len(ans) == h:\n                ans.append([])\n            ans[h].append(root.val)\n            return h + 1\n\n        ans = []\n        dfs(root)\n        return ans\n", "class Solution:\n  def findLeaves(self, root: TreeNode | None) -> list[list[int]]:\n    ans = []\n\n    def depth(root: TreeNode | None) -> int:\n      \"\"\"Returns the depth of the root (0-indexed).\"\"\"\n      if not root:\n        return -1\n\n      l = depth(root.left)\n      r = depth(root.right)\n      h = 1 + max(l, r)\n\n      if len(ans) == h:  # Meet a leaf\n        ans.append([])\n\n      ans[h].append(root.val)\n      return h\n\n    depth(root)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 346, "slug": "moving-average-from-data-stream", "solutions": ["class MovingAverage:\n\n    def __init__(self, size: int):\n        self.s = 0\n        self.data = [0] * size\n        self.cnt = 0\n\n    def next(self, val: int) -> float:\n        i = self.cnt % len(self.data)\n        self.s += val - self.data[i]\n        self.data[i] = val\n        self.cnt += 1\n        return self.s / min(self.cnt, len(self.data))\n\n\n# Your MovingAverage object will be instantiated and called as such:\n# obj = MovingAverage(size)\n# param_1 = obj.next(val)\n", "class MovingAverage:\n  def __init__(self, size: int):\n    self.size = size\n    self.sum = 0\n    self.q = collections.deque()\n\n  def next(self, val: int) -> float:\n    if len(self.q) == self.size:\n      self.sum -= self.q.popleft()\n    self.sum += val\n    self.q.append(val)\n    return self.sum / len(self.q)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 385, "slug": "mini-parser", "solutions": ["# \"\"\"\n# This is the interface that allows for creating nested lists.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# class NestedInteger:\n#    def __init__(self, value=None):\n#        \"\"\"\n#        If value is not specified, initializes an empty list.\n#        Otherwise initializes a single integer equal to value.\n#        \"\"\"\n#\n#    def isInteger(self):\n#        \"\"\"\n#        @return True if this NestedInteger holds a single integer, rather than a nested list.\n#        :rtype bool\n#        \"\"\"\n#\n#    def add(self, elem):\n#        \"\"\"\n#        Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\n#        :rtype void\n#        \"\"\"\n#\n#    def setInteger(self, value):\n#        \"\"\"\n#        Set this NestedInteger to hold a single integer equal to value.\n#        :rtype void\n#        \"\"\"\n#\n#    def getInteger(self):\n#        \"\"\"\n#        @return the single integer that this NestedInteger holds, if it holds a single integer\n#        Return None if this NestedInteger holds a nested list\n#        :rtype int\n#        \"\"\"\n#\n#    def getList(self):\n#        \"\"\"\n#        @return the nested list that this NestedInteger holds, if it holds a nested list\n#        Return None if this NestedInteger holds a single integer\n#        :rtype List[NestedInteger]\n#        \"\"\"\nclass Solution:\n    def deserialize(self, s: str) -> NestedInteger:\n        if not s or s == '[]':\n            return NestedInteger()\n        if s[0] != '[':\n            return NestedInteger(int(s))\n        ans = NestedInteger()\n        depth, j = 0, 1\n        for i in range(1, len(s)):\n            if depth == 0 and (s[i] == ',' or i == len(s) - 1):\n                ans.add(self.deserialize(s[j:i]))\n                j = i + 1\n            elif s[i] == '[':\n                depth += 1\n            elif s[i] == ']':\n                depth -= 1\n        return ans\n", "class Solution:\n  def deserialize(self, s: str) -> NestedInteger:\n    if s[0] != '[':\n      return NestedInteger(int(s))\n\n    stack = []\n\n    for i, c in enumerate(s):\n      if c == '[':\n        stack.append(NestedInteger())\n        start = i + 1\n      elif c == ',':\n        if i > start:\n          num = int(s[start:i])\n          stack[-1].add(NestedInteger(num))\n        start = i + 1\n      elif c == ']':\n        popped = stack.pop()\n        if i > start:\n          num = int(s[start:i])\n          popped.add(NestedInteger(num))\n        if stack:\n          stack[-1].add(popped)\n        else:\n          return popped\n        start = i + 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 355, "slug": "design-twitter", "solutions": ["class Twitter:\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.user_tweets = defaultdict(list)\n        self.user_following = defaultdict(set)\n        self.tweets = defaultdict()\n        self.time = 0\n\n    def postTweet(self, userId: int, tweetId: int) -> None:\n        \"\"\"\n        Compose a new tweet.\n        \"\"\"\n        self.time += 1\n        self.user_tweets[userId].append(tweetId)\n        self.tweets[tweetId] = self.time\n\n    def getNewsFeed(self, userId: int) -> List[int]:\n        \"\"\"\n        Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.\n        \"\"\"\n        following = self.user_following[userId]\n        users = set(following)\n        users.add(userId)\n        tweets = [self.user_tweets[u][::-1][:10] for u in users]\n        tweets = sum(tweets, [])\n        return nlargest(10, tweets, key=lambda tweet: self.tweets[tweet])\n\n    def follow(self, followerId: int, followeeId: int) -> None:\n        \"\"\"\n        Follower follows a followee. If the operation is invalid, it should be a no-op.\n        \"\"\"\n        self.user_following[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -> None:\n        \"\"\"\n        Follower unfollows a followee. If the operation is invalid, it should be a no-op.\n        \"\"\"\n        following = self.user_following[followerId]\n        if followeeId in following:\n            following.remove(followeeId)\n\n\n# Your Twitter object will be instantiated and called as such:\n# obj = Twitter()\n# obj.postTweet(userId,tweetId)\n# param_2 = obj.getNewsFeed(userId)\n# obj.follow(followerId,followeeId)\n# obj.unfollow(followerId,followeeId)\n", "class Twitter:\n  def __init__(self):\n    self.timer = itertools.count(step=-1)\n    self.tweets = collections.defaultdict(deque)\n    self.followees = collections.defaultdict(set)\n\n  def postTweet(self, userId: int, tweetId: int) -> None:\n    self.tweets[userId].appendleft((next(self.timer), tweetId))\n    if len(self.tweets[userId]) > 10:\n      self.tweets[userId].pop()\n\n  def getNewsFeed(self, userId: int) -> list[int]:\n    tweets = list(\n        heapq.merge(\n            *\n            (self.tweets[followee]\n             for followee in self.followees[userId] | {userId})))\n    return [tweetId for _, tweetId in tweets[:10]]\n\n  def follow(self, followerId: int, followeeId: int) -> None:\n    self.followees[followerId].add(followeeId)\n\n  def unfollow(self, followerId: int, followeeId: int) -> None:\n    self.followees[followerId].discard(followeeId)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 364, "slug": "nested-list-weight-sum-ii", "solutions": ["# \"\"\"\n# This is the interface that allows for creating nested lists.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# class NestedInteger:\n#    def __init__(self, value=None):\n#        \"\"\"\n#        If value is not specified, initializes an empty list.\n#        Otherwise initializes a single integer equal to value.\n#        \"\"\"\n#\n#    def isInteger(self):\n#        \"\"\"\n#        @return True if this NestedInteger holds a single integer, rather than a nested list.\n#        :rtype bool\n#        \"\"\"\n#\n#    def add(self, elem):\n#        \"\"\"\n#        Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\n#        :rtype void\n#        \"\"\"\n#\n#    def setInteger(self, value):\n#        \"\"\"\n#        Set this NestedInteger to hold a single integer equal to value.\n#        :rtype void\n#        \"\"\"\n#\n#    def getInteger(self):\n#        \"\"\"\n#        @return the single integer that this NestedInteger holds, if it holds a single integer\n#        Return None if this NestedInteger holds a nested list\n#        :rtype int\n#        \"\"\"\n#\n#    def getList(self):\n#        \"\"\"\n#        @return the nested list that this NestedInteger holds, if it holds a nested list\n#        Return None if this NestedInteger holds a single integer\n#        :rtype List[NestedInteger]\n#        \"\"\"\nclass Solution:\n    def depthSumInverse(self, nestedList: List[NestedInteger]) -> int:\n        def dfs(x, d):\n            nonlocal maxDepth, s, ws\n            maxDepth = max(maxDepth, d)\n            if x.isInteger():\n                s += x.getInteger()\n                ws += x.getInteger() * d\n            else:\n                for y in x.getList():\n                    dfs(y, d + 1)\n\n        maxDepth = s = ws = 0\n        for x in nestedList:\n            dfs(x, 1)\n        return (maxDepth + 1) * s - ws\n", "class Solution:\n  def depthSumInverse(self, nestedList: list[NestedInteger]) -> int:\n    ans = 0\n    prevSum = 0\n    q = collections.deque(nestedList)\n\n    while q:\n      for _ in range(len(q)):\n        ni = q.popleft()\n        if ni.isInteger():\n          prevSum += ni.getInteger()\n        else:\n          for nextNi in ni.getList():\n            q.append(nextNi)\n      ans += prevSum\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 306, "slug": "additive-number", "solutions": ["class Solution:\n    def isAdditiveNumber(self, num: str) -> bool:\n        def dfs(a, b, num):\n            if not num:\n                return True\n            if a + b > 0 and num[0] == '0':\n                return False\n            for i in range(1, len(num) + 1):\n                if a + b == int(num[:i]):\n                    if dfs(b, a + b, num[i:]):\n                        return True\n            return False\n\n        n = len(num)\n        for i in range(1, n - 1):\n            for j in range(i + 1, n):\n                if i > 1 and num[0] == '0':\n                    break\n                if j - i > 1 and num[i] == '0':\n                    continue\n                if dfs(int(num[:i]), int(num[i:j]), num[j:]):\n                    return True\n        return False\n", "class Solution:\n  def isAdditiveNumber(self, num: str) -> bool:\n    n = len(num)\n\n    def dfs(firstNum: int, secondNum: int, s: int) -> bool:\n      if s == len(num):\n        return True\n\n      thirdNum = firstNum + secondNum\n      thirdNumStr = str(thirdNum)\n\n      return (num.find(thirdNumStr, s) == s and\n              dfs(secondNum, thirdNum, s + len(thirdNumStr)))\n\n    # num[0..i] = firstNum\n    for i in range(n // 2):\n      if i > 0 and num[0] == '0':\n        return False\n      firstNum = int(num[:i + 1])\n      # num[i + 1..j] = secondNum\n      # |thirdNum| >= max(|firstNum|, |secondNum|)\n      j = i + 1\n      while max(i, j - i) < n - j:\n        if j > i + 1 and num[i + 1] == '0':\n          break\n        secondNum = int(num[i + 1:j + 1])\n        if dfs(firstNum, secondNum, j + 1):\n          return True\n        j += 1\n\n    return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 373, "slug": "find-k-pairs-with-smallest-sums", "solutions": ["class Solution:\n    def kSmallestPairs(\n        self, nums1: List[int], nums2: List[int], k: int\n    ) -> List[List[int]]:\n        q = [[u + nums2[0], i, 0] for i, u in enumerate(nums1[:k])]\n        heapify(q)\n        ans = []\n        while q and k > 0:\n            _, i, j = heappop(q)\n            ans.append([nums1[i], nums2[j]])\n            k -= 1\n            if j + 1 < len(nums2):\n                heappush(q, [nums1[i] + nums2[j + 1], i, j + 1])\n        return ans\n", "class Solution:\n  def kSmallestPairs(self, nums1: list[int],\n                     nums2: list[int],\n                     k: int) -> list[list[int]]:\n    minHeap = []\n\n    for i in range(min(k, len(nums1))):\n      heapq.heappush(minHeap, (nums1[i] + nums2[0], i, 0))\n\n    ans = []\n    while minHeap and len(ans) < k:\n      _, i, j = heapq.heappop(minHeap)\n      ans.append([nums1[i], nums2[j]])\n      if j + 1 < len(nums2):\n        heapq.heappush(minHeap, (nums1[i] + nums2[j + 1], i, j + 1))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 304, "slug": "range-sum-query-2d-immutable", "solutions": ["class NumMatrix:\n    def __init__(self, matrix: List[List[int]]):\n        m, n = len(matrix), len(matrix[0])\n        self.s = [[0] * (n + 1) for _ in range(m + 1)]\n        for i, row in enumerate(matrix):\n            for j, v in enumerate(row):\n                self.s[i + 1][j + 1] = (\n                    self.s[i][j + 1] + self.s[i + 1][j] - self.s[i][j] + v\n                )\n\n    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:\n        return (\n            self.s[row2 + 1][col2 + 1]\n            - self.s[row2 + 1][col1]\n            - self.s[row1][col2 + 1]\n            + self.s[row1][col1]\n        )\n\n\n# Your NumMatrix object will be instantiated and called as such:\n# obj = NumMatrix(matrix)\n# param_1 = obj.sumRegion(row1,col1,row2,col2)\n", "class NumMatrix:\n  def __init__(self, matrix: list[list[int]]):\n    if not matrix:\n      return\n\n    m = len(matrix)\n    n = len(matrix[0])\n    # prefix[i][j] := the sum of matrix[0..i)[0..j)\n    self.prefix = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m):\n      for j in range(n):\n        self.prefix[i + 1][j + 1] = (matrix[i][j] + self.prefix[i][j + 1] +\n                                     self.prefix[i + 1][j] - self.prefix[i][j])\n\n  def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:\n    return (self.prefix[row2 + 1][col2 + 1] - self.prefix[row1][col2 + 1] -\n            self.prefix[row2 + 1][col1] + self.prefix[row1][col1])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 335, "slug": "self-crossing", "solutions": ["class Solution:\n    def isSelfCrossing(self, distance: List[int]) -> bool:\n        d = distance\n        for i in range(3, len(d)):\n            if d[i] >= d[i - 2] and d[i - 1] <= d[i - 3]:\n                return True\n            if i >= 4 and d[i - 1] == d[i - 3] and d[i] + d[i - 4] >= d[i - 2]:\n                return True\n            if (\n                i >= 5\n                and d[i - 2] >= d[i - 4]\n                and d[i - 1] <= d[i - 3]\n                and d[i] >= d[i - 2] - d[i - 4]\n                and d[i - 1] + d[i - 5] >= d[i - 3]\n            ):\n                return True\n        return False\n", "class Solution:\n  def isSelfCrossing(self, x: list[int]) -> bool:\n    if len(x) <= 3:\n      return False\n\n    for i in range(3, len(x)):\n      if x[i - 2] <= x[i] and x[i - 1] <= x[i - 3]:\n        return True\n      if i >= 4 and x[i - 1] == x[i - 3] and x[i - 2] <= x[i] + x[i - 4]:\n        return True\n      if i >= 5 and x[i - 4] <= x[i - 2] and x[i - 2] <= x[i] + x[i - 4] and x[i - 1] <= x[i - 3] and x[i - 3] <= x[i - 1] + x[i - 5]:\n        return True\n\n    return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 381, "slug": "insert-delete-getrandom-o1-duplicates-allowed", "solutions": ["class RandomizedCollection:\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.m = {}\n        self.l = []\n\n    def insert(self, val: int) -> bool:\n        \"\"\"\n        Inserts a value to the collection. Returns true if the collection did not already contain the specified element.\n        \"\"\"\n        idx_set = self.m.get(val, set())\n        idx_set.add(len(self.l))\n        self.m[val] = idx_set\n        self.l.append(val)\n        return len(idx_set) == 1\n\n    def remove(self, val: int) -> bool:\n        \"\"\"\n        Removes a value from the collection. Returns true if the collection contained the specified element.\n        \"\"\"\n        if val not in self.m:\n            return False\n        idx_set = self.m[val]\n        idx = list(idx_set)[0]\n        last_idx = len(self.l) - 1\n        self.l[idx] = self.l[last_idx]\n        idx_set.remove(idx)\n\n        last_idx_set = self.m[self.l[last_idx]]\n        if last_idx in last_idx_set:\n            last_idx_set.remove(last_idx)\n        if idx < last_idx:\n            last_idx_set.add(idx)\n        if not idx_set:\n            self.m.pop(val)\n        self.l.pop()\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"\n        Get a random element from the collection.\n        \"\"\"\n        return -1 if len(self.l) == 0 else random.choice(self.l)\n\n\n# Your RandomizedCollection object will be instantiated and called as such:\n# obj = RandomizedCollection()\n# param_1 = obj.insert(val)\n# param_2 = obj.remove(val)\n# param_3 = obj.getRandom()\n", "class RandomizedCollection:\n  def __init__(self):\n    self.vals = []\n    self.valToIndices = collections.defaultdict(list)\n\n  def insert(self, val: int) -> bool:\n    self.valToIndices[val].append(len(self.vals))\n    self.vals.append([val, len(self.valToIndices[val]) - 1])\n    return len(self.valToIndices[val]) == 1\n\n  def remove(self, val: int) -> bool:\n    if val not in self.valToIndices or self.valToIndices[val] == []:\n      return False\n\n    index = self.valToIndices[val][-1]\n    self.valToIndices[self.vals[-1][0]][self.vals[-1][1]] = index\n    self.valToIndices[val].pop()\n    self.vals[index] = self.vals[-1]\n    self.vals.pop()\n    return True\n\n  def getRandom(self) -> int:\n    index = random.randint(0, len(self.vals) - 1)\n    return self.vals[index][0]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 343, "slug": "integer-break", "solutions": ["class Solution:\n    def integerBreak(self, n: int) -> int:\n        f = [1] * (n + 1)\n        for i in range(2, n + 1):\n            for j in range(1, i):\n                f[i] = max(f[i], f[i - j] * j, (i - j) * j)\n        return f[n]\n", "class Solution:\n  def integerBreak(self, n: int) -> int:\n    # If an optimal product contains a factor f >= 4, then we can replace it\n    # with 2 and f - 2 without losing optimality. As 2(f - 2) = 2f - 4 >= f,\n    # we never need a factor >= 4, meaning we only need factors 1, 2, and 3\n    # (and 1 is wasteful).\n    # Also, 3 * 3 is better than 2 * 2 * 2, so we never use 2 more than twice.\n    if n == 2:  # 1 * 1\n      return 1\n    if n == 3:  # 1 * 2\n      return 2\n\n    ans = 1\n\n    while n > 4:\n      n -= 3\n      ans *= 3\n    ans *= n\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 337, "slug": "house-robber-iii", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def rob(self, root: Optional[TreeNode]) -> int:\n        def dfs(root: Optional[TreeNode]) -> (int, int):\n            if root is None:\n                return 0, 0\n            la, lb = dfs(root.left)\n            ra, rb = dfs(root.right)\n            return root.val + lb + rb, max(la, lb) + max(ra, rb)\n\n        return max(dfs(root))\n", "class Solution:\n  def rob(self, root: TreeNode | None) -> int:\n    def robOrNot(root: TreeNode | None) -> tuple:\n      if not root:\n        return (0, 0)\n\n      robLeft, notRobLeft = robOrNot(root.left)\n      robRight, notRobRight = robOrNot(root.right)\n\n      return (root.val + notRobLeft + notRobRight,\n              max(robLeft, notRobLeft) + max(robRight, notRobRight))\n\n    return max(robOrNot(root))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 357, "slug": "count-numbers-with-unique-digits", "solutions": ["class Solution:\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\n        @cache\n        def dfs(i: int, mask: int, lead: bool) -> int:\n            if i < 0:\n                return 1\n            ans = 0\n            for j in range(10):\n                if mask >> j & 1:\n                    continue\n                if lead and j == 0:\n                    ans += dfs(i - 1, mask, True)\n                else:\n                    ans += dfs(i - 1, mask | 1 << j, False)\n            return ans\n\n        return dfs(n - 1, 0, True)\n", "class Solution:\n  def countNumbersWithUniqueDigits(self, n: int) -> int:\n    if n == 0:\n      return 1\n\n    ans = 10\n    uniqueDigits = 9\n    availableNum = 9\n\n    while n > 1 and availableNum > 0:\n      uniqueDigits *= availableNum\n      ans += uniqueDigits\n      n -= 1\n      availableNum -= 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 354, "slug": "russian-doll-envelopes", "solutions": ["class Solution:\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        d = [envelopes[0][1]]\n        for _, h in envelopes[1:]:\n            if h > d[-1]:\n                d.append(h)\n            else:\n                idx = bisect_left(d, h)\n                d[idx] = h\n        return len(d)\n", "class Solution:\n  def maxEnvelopes(self, envelopes: list[list[int]]) -> int:\n    envelopes.sort(key=lambda x: (x[0], -x[1]))\n    # Same as 300. Longest Increasing Subsequence\n    ans = 0\n    dp = [0] * len(envelopes)\n\n    for _, h in envelopes:\n      l = 0\n      r = ans\n      while l < r:\n        m = (l + r) // 2\n        if dp[m] >= h:\n          r = m\n        else:\n          l = m + 1\n      dp[l] = h\n      if l == ans:\n        ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 344, "slug": "reverse-string", "solutions": ["class Solution:\n    def reverseString(self, s: List[str]) -> None:\n        i, j = 0, len(s) - 1\n        while i < j:\n            s[i], s[j] = s[j], s[i]\n            i, j = i + 1, j - 1\n", "class Solution:\n  def reverseString(self, s: list[str]) -> None:\n    l = 0\n    r = len(s) - 1\n\n    while l < r:\n      s[l], s[r] = s[r], s[l]\n      l += 1\n      r -= 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 389, "slug": "find-the-difference", "solutions": ["class Solution:\n    def findTheDifference(self, s: str, t: str) -> str:\n        cnt = Counter(s)\n        for c in t:\n            cnt[c] -= 1\n            if cnt[c] < 0:\n                return c\n", "class Solution:\n  def findTheDifference(self, s: str, t: str) -> str:\n    sXors = chr(functools.reduce(operator.xor, map(ord, s), 0))\n    tXors = chr(functools.reduce(operator.xor, map(ord, t), 0))\n    return chr(ord(sXors) ^ ord(tXors))\n", "class Solution:\n  def findTheDifference(self, s: str, t: str) -> str:\n    count = collections.Counter(s)\n\n    for c in t:\n      if count[c] == 0:\n        return c\n      count[c] -= 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 348, "slug": "design-tic-tac-toe", "solutions": ["class TicTacToe:\n\n    def __init__(self, n: int):\n        self.n = n\n        self.cnt = [defaultdict(int), defaultdict(int)]\n\n    def move(self, row: int, col: int, player: int) -> int:\n        cur = self.cnt[player - 1]\n        n = self.n\n        cur[row] += 1\n        cur[n + col] += 1\n        if row == col:\n            cur[n << 1] += 1\n        if row + col == n - 1:\n            cur[n << 1 | 1] += 1\n        if any(cur[i] == n for i in (row, n + col, n << 1, n << 1 | 1)):\n            return player\n        return 0\n\n\n# Your TicTacToe object will be instantiated and called as such:\n# obj = TicTacToe(n)\n# param_1 = obj.move(row,col,player)\n", "class TicTacToe:\n  def __init__(self, n: int):\n    self.n = n\n    # Record count('X') - count('O').\n    self.rows = [0] * n\n    self.cols = [0] * n\n    self.diag = 0\n    self.antiDiag = 0\n\n  \"\"\" Player {player} makes a move at ({row}, {col}).\n\n      @param row    The row of the board.\n      @param col    The column of the board.\n      @param player The player, can be either 1 or 2.\n      @return The current winning condition, can be either:\n              0: No one wins.\n              1: Player 1 wins.\n              2: Player 2 wins.\n  \"\"\"\n\n  def move(self, row: int, col: int, player: int) -> int:\n    toAdd = 1 if player == 1 else -1\n    target = self.n if player == 1 else -self.n\n\n    if row == col:\n      self.diag += toAdd\n      if self.diag == target:\n        return player\n\n    if row + col == self.n - 1:\n      self.antiDiag += toAdd\n      if self.antiDiag == target:\n        return player\n\n    self.rows[row] += toAdd\n    if self.rows[row] == target:\n      return player\n\n    self.cols[col] += toAdd\n    if self.cols[col] == target:\n      return player\n\n    return 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 313, "slug": "super-ugly-number", "solutions": ["class Solution:\n    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\n        q = [1]\n        x = 0\n        mx = (1 << 31) - 1\n        for _ in range(n):\n            x = heappop(q)\n            for k in primes:\n                if x <= mx // k:\n                    heappush(q, k * x)\n                if x % k == 0:\n                    break\n        return x\n", "class Solution:\n  def nthSuperUglyNumber(self, n: int, primes: list[int]) -> int:\n    k = len(primes)\n    nums = [1]\n    indices = [0] * k\n\n    while len(nums) < n:\n      nexts = [0] * k\n      for i in range(k):\n        nexts[i] = nums[indices[i]] * primes[i]\n      next = min(nexts)\n      for i in range(k):\n        if next == nexts[i]:\n          indices[i] += 1\n      nums.append(next)\n\n    return nums[-1]\n", "class UglyNum:\n  def __init__(self, prime: int, index: int, value: int):\n    self.prime = prime\n    self.index = index  # Point the next index of uglyNums.\n    self.value = value  # prime * uglyNums[index]\n\n\nclass Solution:\n  def nthSuperUglyNumber(self, n: int, primes: list[int]) -> int:\n    minHeap = []  # (value, prime, index)\n    uglyNums = [1]\n\n    for prime in primes:\n      heapq.heappush(minHeap, (prime * uglyNums[0], prime, 1))\n\n    while len(uglyNums) < n:\n      uglyNums.append(minHeap[0][0])\n      while minHeap[0][0] == uglyNums[-1]:\n        _, prime, index = heapq.heappop(minHeap)\n        heapq.heappush(minHeap, (prime * uglyNums[index], prime, index + 1))\n\n    return uglyNums[-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 359, "slug": "logger-rate-limiter", "solutions": ["class Logger:\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.limiter = {}\n\n    def shouldPrintMessage(self, timestamp: int, message: str) -> bool:\n        \"\"\"\n        Returns true if the message should be printed in the given timestamp, otherwise returns false.\n        If this method returns false, the message will not be printed.\n        The timestamp is in seconds granularity.\n        \"\"\"\n        t = self.limiter.get(message, 0)\n        if t > timestamp:\n            return False\n        self.limiter[message] = timestamp + 10\n        return True\n\n\n# Your Logger object will be instantiated and called as such:\n# obj = Logger()\n# param_1 = obj.shouldPrintMessage(timestamp,message)\n", "class Logger:\n  def __init__(self):\n    self.okTime = {}  # {message: ok time}\n\n  def shouldPrintMessage(self, timestamp: int, message: str) -> bool:\n    if timestamp < self.okTime.get(message, 0):\n      return False\n\n    self.okTime[message] = timestamp + 10\n    return True\n", "class Logger:\n  def __init__(self):\n    # [(timestamp, message)]\n    self.messageQueue = collections.deque()\n    self.messageSet = set()\n\n  def shouldPrintMessage(self, timestamp: int, message: str) -> bool:\n    # Remove the messages that are 10 seconds from the current timestamp.\n    while self.messageQueue:\n      headTimestamp, headMessage = self.messageQueue[0]\n      if timestamp < headTimestamp + 10:\n        break\n      self.messageQueue.popleft()\n      self.messageSet.remove(headMessage)\n\n    if message in self.messageSet:\n      return False\n\n    self.messageQueue.append((timestamp, message))\n    self.messageSet.add(message)\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 376, "slug": "wiggle-subsequence", "solutions": ["class Solution:\n    def wiggleMaxLength(self, nums: List[int]) -> int:\n        n = len(nums)\n        ans = 1\n        f = [1] * n\n        g = [1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if nums[j] < nums[i]:\n                    f[i] = max(f[i], g[j] + 1)\n                elif nums[j] > nums[i]:\n                    g[i] = max(g[i], f[j] + 1)\n            ans = max(ans, f[i], g[i])\n        return ans\n", "class Solution:\n  def wiggleMaxLength(self, nums: list[int]) -> int:\n    increasing = 1\n    decreasing = 1\n\n    for a, b in itertools.pairwise(nums):\n      if b > a:\n        increasing = decreasing + 1\n      elif b < a:\n        decreasing = increasing + 1\n\n    return max(increasing, decreasing)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 358, "slug": "rearrange-string-k-distance-apart", "solutions": ["class Solution:\n    def rearrangeString(self, s: str, k: int) -> str:\n        h = [(-v, c) for c, v in Counter(s).items()]\n        heapify(h)\n        q = deque()\n        ans = []\n        while h:\n            v, c = heappop(h)\n            v *= -1\n            ans.append(c)\n            q.append((v - 1, c))\n            if len(q) >= k:\n                w, c = q.popleft()\n                if w:\n                    heappush(h, (-w, c))\n        return \"\" if len(ans) != len(s) else \"\".join(ans)\n", "class Solution:\n  def rearrangeString(self, s: str, k: int) -> str:\n    n = len(s)\n    ans = []\n    count = collections.Counter(s)\n    # valid[i] := the leftmost index i can appear\n    valid = collections.Counter()\n\n    def getBestLetter(index: int) -> str:\n      \"\"\"Returns the valid letter that has the most count.\"\"\"\n      maxCount = -1\n      bestLetter = '*'\n\n      for c in string.ascii_lowercase:\n        if count[c] > 0 and count[c] > maxCount and index >= valid[c]:\n          bestLetter = c\n          maxCount = count[c]\n\n      return bestLetter\n\n    for i in range(n):\n      c = getBestLetter(i)\n      if c == '*':\n        return ''\n      ans.append(c)\n      count[c] -= 1\n      valid[c] = i + k\n\n    return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 334, "slug": "increasing-triplet-subsequence", "solutions": ["class Solution:\n    def increasingTriplet(self, nums: List[int]) -> bool:\n        mi, mid = inf, inf\n        for num in nums:\n            if num > mid:\n                return True\n            if num <= mi:\n                mi = num\n            else:\n                mid = num\n        return False\n", "class Solution:\n  def increasingTriplet(self, nums: list[int]) -> bool:\n    first = math.inf\n    second = math.inf\n\n    for num in nums:\n      if num <= first:\n        first = num\n      elif num <= second:  # first < num <= second\n        second = num\n      else:\n        return True  # first < second < num (third)\n\n    return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 392, "slug": "is-subsequence", "solutions": ["class Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        i = j = 0\n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        return i == len(s)\n", "class Solution:\n  def isSubsequence(self, s: str, t: str) -> bool:\n    if not s:\n      return True\n\n    i = 0\n    for c in t:\n      if s[i] == c:\n        i += 1\n        if i == len(s):\n          return True\n\n    return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 383, "slug": "ransom-note", "solutions": ["class Solution:\n    def canConstruct(self, ransomNote: str, magazine: str) -> bool:\n        cnt = Counter(magazine)\n        for c in ransomNote:\n            cnt[c] -= 1\n            if cnt[c] < 0:\n                return False\n        return True\n", "class Solution:\n  def canConstruct(self, ransomNote: str, magazine: str) -> bool:\n    count1 = collections.Counter(ransomNote)\n    count2 = collections.Counter(magazine)\n    return all(count1[c] <= count2[c] for c in string.ascii_lowercase)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 396, "slug": "rotate-function", "solutions": ["class Solution:\n    def maxRotateFunction(self, nums: List[int]) -> int:\n        f = sum(i * v for i, v in enumerate(nums))\n        n, s = len(nums), sum(nums)\n        ans = f\n        for i in range(1, n):\n            f = f + s - n * nums[n - i]\n            ans = max(ans, f)\n        return ans\n", "class Solution:\n  def maxRotateFunction(self, nums: list[int]) -> int:\n    f = sum(i * num for i, num in enumerate(nums))\n    ans = f\n    summ = sum(nums)\n\n    for a in reversed(nums):\n      f += summ - len(nums) * a\n      ans = max(ans, f)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 311, "slug": "sparse-matrix-multiplication", "solutions": ["class Solution:\n    def multiply(self, mat1: List[List[int]], mat2: List[List[int]]) -> List[List[int]]:\n        m, n = len(mat1), len(mat2[0])\n        ans = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                for k in range(len(mat2)):\n                    ans[i][j] += mat1[i][k] * mat2[k][j]\n        return ans\n", "class Solution:\n  def multiply(self, mat1: list[list[int]],\n               mat2: list[list[int]]) -> list[list[int]]:\n    m = len(mat1)\n    n = len(mat2)\n    l = len(mat2[0])\n    ans = [[0] * l for _ in range(m)]\n\n    for i in range(m):\n      for j in range(l):\n        for k in range(n):\n          ans[i][j] += mat1[i][k] * mat2[k][j]\n\n    return ans\n", "class Solution:\n  def multiply(self, mat1: list[list[int]],\n               mat2: list[list[int]]) -> list[list[int]]:\n    m = len(mat1)\n    n = len(mat2)\n    l = len(mat2[0])\n    ans = [[0] * l for _ in range(m)]\n    nonZeroColIndicesInMat2 = [\n        [j for j, a in enumerate(row) if a]\n        for row in mat2\n    ]\n\n    for i in range(m):\n      for j, a in enumerate(mat1[i]):\n        if a == 0:\n          continue\n        # mat1s j-th column matches mat2's j-th row\n        for colIndex in nonZeroColIndicesInMat2[j]:\n          ans[i][colIndex] += a * mat2[j][colIndex]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 384, "slug": "shuffle-an-array", "solutions": ["class Solution:\n    def __init__(self, nums: List[int]):\n        self.nums = nums\n        self.original = nums.copy()\n\n    def reset(self) -> List[int]:\n        self.nums = self.original.copy()\n        return self.nums\n\n    def shuffle(self) -> List[int]:\n        for i in range(len(self.nums)):\n            j = random.randrange(i, len(self.nums))\n            self.nums[i], self.nums[j] = self.nums[j], self.nums[i]\n        return self.nums\n\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution(nums)\n# param_1 = obj.reset()\n# param_2 = obj.shuffle()\n", "class Solution:\n  def __init__(self, nums: list[int]):\n    self.nums = nums\n\n  def reset(self) -> list[int]:\n    return self.nums\n\n  def shuffle(self) -> list[int]:\n    arr = self.nums.copy()\n    for i in range(len(arr) - 1, 0, -1):\n      j = random.randint(0, i)\n      arr[i], arr[j] = arr[j], arr[i]\n    return arr\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 377, "slug": "combination-sum-iv", "solutions": ["class Solution:\n    def combinationSum4(self, nums: List[int], target: int) -> int:\n        f = [1] + [0] * target\n        for i in range(1, target + 1):\n            for x in nums:\n                if i >= x:\n                    f[i] += f[i - x]\n        return f[target]\n", "class Solution:\n  def combinationSum4(self, nums: list[int], target: int) -> int:\n    dp = [1] + [-1] * target\n\n    def dfs(target: int) -> int:\n      if target < 0:\n        return 0\n      if dp[target] != -1:\n        return dp[target]\n\n      dp[target] = sum(dfs(target - num) for num in nums)\n      return dp[target]\n\n    return dfs(target)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 340, "slug": "longest-substring-with-at-most-k-distinct-characters", "solutions": ["class Solution:\n    def lengthOfLongestSubstringKDistinct(self, s: str, k: int) -> int:\n        l = 0\n        cnt = Counter()\n        for c in s:\n            cnt[c] += 1\n            if len(cnt) > k:\n                cnt[s[l]] -= 1\n                if cnt[s[l]] == 0:\n                    del cnt[s[l]]\n                l += 1\n        return len(s) - l\n", "class Solution:\n  def lengthOfLongestSubstringKDistinct(self, s: str, k: int) -> int:\n    ans = 0\n    distinct = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] += 1\n      if count[c] == 1:\n        distinct += 1\n      while distinct == k + 1:\n        count[s[l]] -= 1\n        if count[s[l]] == 0:\n          distinct -= 1\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 356, "slug": "line-reflection", "solutions": ["class Solution:\n    def isReflected(self, points: List[List[int]]) -> bool:\n        min_x, max_x = inf, -inf\n        point_set = set()\n        for x, y in points:\n            min_x = min(min_x, x)\n            max_x = max(max_x, x)\n            point_set.add((x, y))\n        s = min_x + max_x\n        return all((s - x, y) in point_set for x, y in points)\n", "class Solution:\n  def isReflected(self, points: list[list[int]]) -> bool:\n    minX = math.inf\n    maxX = -math.inf\n    seen = set()\n\n    for x, y in points:\n      minX = min(minX, x)\n      maxX = max(maxX, x)\n      seen.add((x, y))\n\n    summ = minX + maxX\n    # (leftX + rightX) / 2 = (minX + maxX) / 2\n    #  leftX = minX + maxX - rightX\n    # rightX = minX + maxX - leftX\n\n    return all((summ - x, y) in seen for x, y in points)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 386, "slug": "lexicographical-numbers", "solutions": ["class Solution:\n    def lexicalOrder(self, n: int) -> List[int]:\n        ans = []\n        v = 1\n        for _ in range(n):\n            ans.append(v)\n            if v * 10 <= n:\n                v *= 10\n            else:\n                while v % 10 == 9 or v + 1 > n:\n                    v //= 10\n                v += 1\n        return ans\n", "class Solution:\n  def lexicalOrder(self, n: int) -> list[int]:\n    ans = []\n    curr = 1\n\n    while len(ans) < n:\n      ans.append(curr)\n      if curr * 10 <= n:\n        curr *= 10\n      else:\n        while curr % 10 == 9 or curr == n:\n          curr //= 10\n        curr += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 307, "slug": "range-sum-query-mutable", "solutions": ["class BinaryIndexedTree:\n    __slots__ = [\"n\", \"c\"]\n\n    def __init__(self, n):\n        self.n = n\n        self.c = [0] * (n + 1)\n\n    def update(self, x: int, delta: int):\n        while x <= self.n:\n            self.c[x] += delta\n            x += x & -x\n\n    def query(self, x: int) -> int:\n        s = 0\n        while x > 0:\n            s += self.c[x]\n            x -= x & -x\n        return s\n\n\nclass NumArray:\n    __slots__ = [\"tree\"]\n\n    def __init__(self, nums: List[int]):\n        self.tree = BinaryIndexedTree(len(nums))\n        for i, v in enumerate(nums, 1):\n            self.tree.update(i, v)\n\n    def update(self, index: int, val: int) -> None:\n        prev = self.sumRange(index, index)\n        self.tree.update(index + 1, val - prev)\n\n    def sumRange(self, left: int, right: int) -> int:\n        return self.tree.query(right + 1) - self.tree.query(left)\n\n\n# Your NumArray object will be instantiated and called as such:\n# obj = NumArray(nums)\n# obj.update(index,val)\n# param_2 = obj.sumRange(left,right)\n", "class FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def add(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass NumArray:\n  def __init__(self, nums: list[int]):\n    self.nums = nums\n    self.tree = FenwickTree(len(nums))\n    for i, num in enumerate(nums):\n      self.tree.add(i + 1, num)\n\n  def update(self, index: int, val: int) -> None:\n    self.tree.add(index + 1, val - self.nums[index])\n    self.nums[index] = val\n\n  def sumRange(self, left: int, right: int) -> int:\n    return self.tree.get(right + 1) - self.tree.get(left)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 368, "slug": "largest-divisible-subset", "solutions": ["class Solution:\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\n        nums.sort()\n        n = len(nums)\n        f = [1] * n\n        k = 0\n        for i in range(n):\n            for j in range(i):\n                if nums[i] % nums[j] == 0:\n                    f[i] = max(f[i], f[j] + 1)\n            if f[k] < f[i]:\n                k = i\n        m = f[k]\n        i = k\n        ans = []\n        while m:\n            if nums[k] % nums[i] == 0 and f[i] == m:\n                ans.append(nums[i])\n                k, m = i, m - 1\n            i -= 1\n        return ans\n", "class Solution:\n  def largestDivisibleSubset(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n    ans = []\n    count = [1] * n\n    prevIndex = [-1] * n\n    maxCount = 0\n    index = -1\n\n    nums.sort()\n\n    for i, num in enumerate(nums):\n      for j in reversed(range(i)):\n        if num % nums[j] == 0 and count[i] < count[j] + 1:\n          count[i] = count[j] + 1\n          prevIndex[i] = j\n      if count[i] > maxCount:\n        maxCount = count[i]\n        index = i\n\n    while index != -1:\n      ans.append(nums[index])\n      index = prevIndex[index]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 323, "slug": "number-of-connected-components-in-an-undirected-graph", "solutions": ["class Solution:\n    def countComponents(self, n: int, edges: List[List[int]]) -> int:\n        def dfs(i: int) -> int:\n            if i in vis:\n                return 0\n            vis.add(i)\n            for j in g[i]:\n                dfs(j)\n            return 1\n\n        g = [[] for _ in range(n)]\n        for a, b in edges:\n            g[a].append(b)\n            g[b].append(a)\n        vis = set()\n        return sum(dfs(i) for i in range(n))\n", "class Solution:\n  def countComponents(self, n: int, edges: list[list[int]]) -> int:\n    ans = 0\n    graph = [[] for _ in range(n)]\n    seen = set()\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    def bfs(node: int, seen: set[int]) -> None:\n      q = collections.deque([node])\n      seen.add(node)\n\n      while q:\n        u = q.pop()\n        for v in graph[u]:\n          if v not in seen:\n            q.append(v)\n            seen.add(v)\n\n    for i in range(n):\n      if i not in seen:\n        bfs(i, seen)\n        ans += 1\n\n    return ans\n", "class UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def countComponents(self, n: int, edges: list[list[int]]) -> int:\n    uf = UnionFind(n)\n\n    for u, v in edges:\n      uf.unionByRank(u, v)\n\n    return uf.count\n", "class Solution:\n  def countComponents(self, n: int, edges: list[list[int]]) -> int:\n    ans = 0\n    graph = [[] for _ in range(n)]\n    seen = set()\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    def dfs(u: int, seen: set[int]) -> None:\n      for v in graph[u]:\n        if v not in seen:\n          seen.add(v)\n          dfs(v, seen)\n\n    for i in range(n):\n      if i not in seen:\n        seen.add(i)\n        dfs(graph, i, seen)\n        ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 374, "slug": "guess-number-higher-or-lower", "solutions": ["# The guess API is already defined for you.\n# @param num, your guess\n# @return -1 if num is higher than the picked number\n#          1 if num is lower than the picked number\n#          otherwise return 0\n# def guess(num: int) -> int:\n\n\nclass Solution:\n    def guessNumber(self, n: int) -> int:\n        return bisect.bisect(range(1, n + 1), 0, key=lambda x: -guess(x))\n", "# The guess API is already defined for you.\n# @param num, your guess\n# @return -1 if num is higher than the picked number\n#          1 if num is lower than the picked number\n#          otherwise return 0\n# def guess(num: int) -> int:\n\nclass Solution:\n  def guessNumber(self, n: int) -> int:\n    l = 1\n    r = n\n\n    # Find the first guess number that >= the target number\n    while l < r:\n      m = (l + r) // 2\n      if guess(m) <= 0:  # -1, 0\n        r = m\n      else:\n        l = m + 1\n\n    return l\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 371, "slug": "sum-of-two-integers", "solutions": ["class Solution:\n    def getSum(self, a: int, b: int) -> int:\n        a, b = a & 0xFFFFFFFF, b & 0xFFFFFFFF\n        while b:\n            carry = ((a & b) << 1) & 0xFFFFFFFF\n            a, b = a ^ b, carry\n        return a if a < 0x80000000 else ~(a ^ 0xFFFFFFFF)\n", "class Solution:\n  def getSum(self, a: int, b: int) -> int:\n    mask = 0xFFFFFFFF\n    MAX = 2000\n\n    while b != 0:\n      a, b = (a ^ b) & mask, ((a & b) << 1) & mask\n\n    return a if a < MAX else ~(a ^ mask)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 331, "slug": "verify-preorder-serialization-of-a-binary-tree", "solutions": ["class Solution:\n    def isValidSerialization(self, preorder: str) -> bool:\n        stk = []\n        for c in preorder.split(\",\"):\n            stk.append(c)\n            while len(stk) > 2 and stk[-1] == stk[-2] == \"#\" and stk[-3] != \"#\":\n                stk = stk[:-3]\n                stk.append(\"#\")\n        return len(stk) == 1 and stk[0] == \"#\"\n", "class Solution:\n  def isValidSerialization(self, preorder: str) -> bool:\n    degree = 1  # out-degree (children) - in-degree (parent)\n\n    for node in preorder.split(','):\n      degree -= 1\n      if degree < 0:\n        return False\n      if node != '#':\n        degree += 2\n\n    return degree == 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 363, "slug": "max-sum-of-rectangle-no-larger-than-k", "solutions": ["class Solution:\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\n        m, n = len(matrix), len(matrix[0])\n        ans = -inf\n        for i in range(m):\n            nums = [0] * n\n            for j in range(i, m):\n                for h in range(n):\n                    nums[h] += matrix[j][h]\n                s = 0\n                ts = SortedSet([0])\n                for x in nums:\n                    s += x\n                    p = ts.bisect_left(s - k)\n                    if p != len(ts):\n                        ans = max(ans, s - ts[p])\n                    ts.add(s)\n        return ans\n", "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def maxSumSubmatrix(self, matrix: list[list[int]], k: int) -> int:\n    m = len(matrix)\n    n = len(matrix[0])\n    ans = -math.inf\n\n    for baseCol in range(n):\n      # sums[i] := sum(matrix[i][baseCol..j])\n      sums = [0] * m\n      for j in range(baseCol, n):\n        for i in range(m):\n          sums[i] += matrix[i][j]\n        # Find the maximum sum <= k of all the subarrays.\n        accumulate = SortedList([0])\n        prefix = 0\n        for summ in sums:\n          prefix += summ\n          it = accumulate.bisect_left(prefix - k)\n          if it != len(accumulate):\n            ans = max(ans, prefix - accumulate[it])\n          accumulate.add(prefix)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 362, "slug": "design-hit-counter", "solutions": ["class HitCounter:\n\n    def __init__(self):\n        self.ts = []\n\n    def hit(self, timestamp: int) -> None:\n        self.ts.append(timestamp)\n\n    def getHits(self, timestamp: int) -> int:\n        return len(self.ts) - bisect_left(self.ts, timestamp - 300 + 1)\n\n\n# Your HitCounter object will be instantiated and called as such:\n# obj = HitCounter()\n# obj.hit(timestamp)\n# param_2 = obj.getHits(timestamp)\n", "class HitCounter:\n  def __init__(self):\n    self.timestamps = [0] * 300\n    self.hits = [0] * 300\n\n  def hit(self, timestamp: int) -> None:\n    i = timestamp % 300\n    if self.timestamps[i] == timestamp:\n      self.hits[i] += 1\n    else:\n      self.timestamps[i] = timestamp\n      self.hits[i] = 1  # Reset the hit count to 1.\n\n  def getHits(self, timestamp: int) -> int:\n    return sum(h for t, h in zip(self.timestamps, self.hits)\n               if timestamp - t < 300)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 315, "slug": "count-of-smaller-numbers-after-self", "solutions": ["class BinaryIndexedTree:\n    def __init__(self, n):\n        self.n = n\n        self.c = [0] * (n + 1)\n\n    @staticmethod\n    def lowbit(x):\n        return x & -x\n\n    def update(self, x, delta):\n        while x <= self.n:\n            self.c[x] += delta\n            x += BinaryIndexedTree.lowbit(x)\n\n    def query(self, x):\n        s = 0\n        while x > 0:\n            s += self.c[x]\n            x -= BinaryIndexedTree.lowbit(x)\n        return s\n\n\nclass Solution:\n    def countSmaller(self, nums: List[int]) -> List[int]:\n        alls = sorted(set(nums))\n        m = {v: i for i, v in enumerate(alls, 1)}\n        tree = BinaryIndexedTree(len(m))\n        ans = []\n        for v in nums[::-1]:\n            x = m[v]\n            tree.update(x, 1)\n            ans.append(tree.query(x - 1))\n        return ans[::-1]\n", "from dataclasses import dataclass\n\n\n@dataclass\nclass Item:\n  num: int = 0\n  index: int = 0\n\n\nclass Solution:\n  def countSmaller(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n    ans = [0] * n\n    items = [Item(num, i) for i, num in enumerate(nums)]\n\n    self._mergeSort(items, 0, n - 1, ans)\n    return ans\n\n  def _mergeSort(\n      self,\n      items: list[Item],\n      l: int,\n      r: int,\n      ans: list[int],\n  ) -> None:\n    if l >= r:\n      return\n\n    m = (l + r) // 2\n    self._mergeSort(items, l, m, ans)\n    self._mergeSort(items, m + 1, r, ans)\n    self._merge(items, l, m, r, ans)\n\n  def _merge(\n      self,\n      items: list[Item],\n      l: int,\n      m: int,\n      r: int,\n      ans: list[int],\n  ) -> None:\n    sorted = [Item()] * (r - l + 1)\n    k = 0  # sorted's index\n    i = l  # left's index\n    j = m + 1  # right's index\n    rightCount = 0  # the number of numbers < items[i].num\n\n    while i <= m and j <= r:\n      if items[i].num > items[j].num:\n        rightCount += 1\n        sorted[k] = items[j]\n        k += 1\n        j += 1\n      else:\n        ans[items[i].index] += rightCount\n        sorted[k] = items[i]\n        k += 1\n        i += 1\n\n    # Put the possible remaining left part into the sorted array.\n    while i <= m:\n      ans[items[i].index] += rightCount\n      sorted[k] = items[i]\n      k += 1\n      i += 1\n\n    # Put the possible remaining right part into the sorted array.\n    while j <= r:\n      sorted[k] = items[j]\n      k += 1\n      j += 1\n\n    items[l:l + len(sorted)] = sorted\n", "class FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def add(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def countSmaller(self, nums: list[int]) -> list[int]:\n    ans = []\n    ranks = self._getRanks(nums)\n    tree = FenwickTree(len(ranks))\n\n    for num in reversed(nums):\n      ans.append(tree.get(ranks[num] - 1))\n      tree.add(ranks[num], 1)\n\n    return ans[::-1]\n\n  def _getRanks(self, nums: list[int]) -> dict[int, int]:\n    ranks = collections.Counter()\n    rank = 0\n    for num in sorted(set(nums)):\n      rank += 1\n      ranks[num] = rank\n    return ranks\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 314, "slug": "binary-tree-vertical-order-traversal", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def verticalOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def dfs(root, depth, offset):\n            if root is None:\n                return\n            d[offset].append((depth, root.val))\n            dfs(root.left, depth + 1, offset - 1)\n            dfs(root.right, depth + 1, offset + 1)\n\n        d = defaultdict(list)\n        dfs(root, 0, 0)\n        ans = []\n        for _, v in sorted(d.items()):\n            v.sort(key=lambda x: x[0])\n            ans.append([x[1] for x in v])\n        return ans\n", "class Solution:\n  def verticalOrder(self, root: TreeNode | None) -> list[list[int]]:\n    if not root:\n      return []\n\n    range_ = [0] * 2\n\n    def getRange(root: TreeNode | None, x: int) -> None:\n      if not root:\n        return\n\n      range_[0] = min(range_[0], x)\n      range_[1] = max(range_[1], x)\n\n      getRange(root.left, x - 1)\n      getRange(root.right, x + 1)\n\n    getRange(root, 0)  # Get the leftmost and the rightmost x index.\n\n    ans = [[] for _ in range(range_[1] - range_[0] + 1)]\n    q = collections.deque([(root, -range_[0])])  # (TreeNode, x)\n\n    while q:\n      node, x = q.popleft()\n      ans[x].append(node.val)\n      if node.left:\n        q.append((node.left, x - 1))\n      if node.right:\n        q.append((node.right, x + 1))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 319, "slug": "bulb-switcher", "solutions": ["class Solution:\n    def bulbSwitch(self, n: int) -> int:\n        return int(sqrt(n))\n", "class Solution:\n  def bulbSwitch(self, n: int) -> int:\n    # The k-th bulb can only be switched when k % i == 0.\n    # So, we can rephrase the problem:\n    # To find number of numbers <= n that have odd factors.\n    # Obviously, only square numbers have odd factor(s).\n    # e.g. n = 10, only 1, 4, and 9 are square numbers that <= 10\n    return math.isqrt(n)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 309, "slug": "best-time-to-buy-and-sell-stock-with-cooldown", "solutions": ["class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        @cache\n        def dfs(i: int, j: int) -> int:\n            if i >= len(prices):\n                return 0\n            ans = dfs(i + 1, j)\n            if j:\n                ans = max(ans, prices[i] + dfs(i + 2, 0))\n            else:\n                ans = max(ans, -prices[i] + dfs(i + 1, 1))\n            return ans\n\n        return dfs(0, 0)\n", "class Solution:\n  def maxProfit(self, prices: list[int]) -> int:\n    sell = 0\n    hold = -math.inf\n    prev = 0\n\n    for price in prices:\n      cache = sell\n      sell = max(sell, hold + price)\n      hold = max(hold, prev - price)\n      prev = cache\n\n    return sell\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 347, "slug": "top-k-frequent-elements", "solutions": ["class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        cnt = Counter(nums)\n        return [x for x, _ in cnt.most_common(k)]\n", "class Solution:\n  def topKFrequent(self, nums: list[int], k: int) -> list[int]:\n    ans = []\n    bucket = [[] for _ in range(len(nums) + 1)]\n\n    for num, freq in collections.Counter(nums).items():\n      bucket[freq].append(num)\n\n    for b in reversed(bucket):\n      ans += b\n      if len(ans) == k:\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 372, "slug": "super-pow", "solutions": ["class Solution:\n    def superPow(self, a: int, b: List[int]) -> int:\n        mod = 1337\n        ans = 1\n        for e in b[::-1]:\n            ans = ans * pow(a, e, mod) % mod\n            a = pow(a, 10, mod)\n        return ans\n", "class Solution:\n  def superPow(self, a: int, b: list[int]) -> int:\n    MOD = 1337\n    ans = 1\n\n    for i in b:\n      ans = pow(ans, 10, MOD) * pow(a, i, MOD)\n\n    return ans % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 305, "slug": "number-of-islands-ii", "solutions": ["class UnionFind:\n    def __init__(self, n: int):\n        self.p = list(range(n))\n        self.size = [1] * n\n\n    def find(self, x: int):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n\n    def union(self, a: int, b: int) -> bool:\n        pa, pb = self.find(a - 1), self.find(b - 1)\n        if pa == pb:\n            return False\n        if self.size[pa] > self.size[pb]:\n            self.p[pb] = pa\n            self.size[pa] += self.size[pb]\n        else:\n            self.p[pa] = pb\n            self.size[pb] += self.size[pa]\n        return True\n\n\nclass Solution:\n    def numIslands2(self, m: int, n: int, positions: List[List[int]]) -> List[int]:\n        uf = UnionFind(m * n)\n        grid = [[0] * n for _ in range(m)]\n        ans = []\n        dirs = (-1, 0, 1, 0, -1)\n        cnt = 0\n        for i, j in positions:\n            if grid[i][j]:\n                ans.append(cnt)\n                continue\n            grid[i][j] = 1\n            cnt += 1\n            for a, b in pairwise(dirs):\n                x, y = i + a, j + b\n                if (\n                    0 <= x < m\n                    and 0 <= y < n\n                    and grid[x][y]\n                    and uf.union(i * n + j, x * n + y)\n                ):\n                    cnt -= 1\n            ans.append(cnt)\n        return ans\n", "class UnionFind:\n  def __init__(self, n: int):\n    self.id = [-1] * n\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def numIslands2(\n      self,\n      m: int,\n      n: int,\n      positions: list[list[int]],\n  ) -> list[int]:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    ans = []\n    seen = [[False] * n for _ in range(m)]\n    uf = UnionFind(m * n)\n    count = 0\n\n    def getId(i: int, j: int, n: int) -> int:\n      return i * n + j\n\n    for i, j in positions:\n      if seen[i][j]:\n        ans.append(count)\n        continue\n      seen[i][j] = True\n      id = getId(i, j, n)\n      uf.id[id] = id\n      count += 1\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        neighborId = getId(x, y, n)\n        if uf.id[neighborId] == -1:  # water\n          continue\n        currentParent = uf.find(id)\n        neighborParent = uf.find(neighborId)\n        if currentParent != neighborParent:\n          uf.unionByRank(currentParent, neighborParent)\n          count -= 1\n      ans.append(count)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 318, "slug": "maximum-product-of-word-lengths", "solutions": ["class Solution:\n    def maxProduct(self, words: List[str]) -> int:\n        mask = [0] * len(words)\n        ans = 0\n        for i, s in enumerate(words):\n            for c in s:\n                mask[i] |= 1 << (ord(c) - ord(\"a\"))\n            for j, t in enumerate(words[:i]):\n                if (mask[i] & mask[j]) == 0:\n                    ans = max(ans, len(s) * len(t))\n        return ans\n", "class Solution:\n  def maxProduct(self, words: list[str]) -> int:\n    ans = 0\n\n    def getMask(word: str) -> int:\n      mask = 0\n      for c in word:\n        mask |= 1 << ord(c) - ord('a')\n      return mask\n\n    masks = [getMask(word) for word in words]\n\n    for i in range(len(words)):\n      for j in range(i):\n        if not (masks[i] & masks[j]):\n          ans = max(ans, len(words[i]) * len(words[j]))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 312, "slug": "burst-balloons", "solutions": ["class Solution:\n    def maxCoins(self, nums: List[int]) -> int:\n        n = len(nums)\n        arr = [1] + nums + [1]\n        f = [[0] * (n + 2) for _ in range(n + 2)]\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 2, n + 2):\n                for k in range(i + 1, j):\n                    f[i][j] = max(f[i][j], f[i][k] + f[k][j] + arr[i] * arr[k] * arr[j])\n        return f[0][-1]\n", "class Solution:\n  def maxCoins(self, nums: list[int]) -> int:\n    n = len(nums)\n    # dp[i][j] := maxCoins(nums[i..j])\n    dp = [[0] * (n + 2) for _ in range(n + 2)]\n\n    nums = [1] + nums + [1]\n\n    for d in range(n):\n      for i in range(1, n - d + 1):\n        j = i + d\n        for k in range(i, j + 1):\n          dp[i][j] = max(\n              dp[i][j],\n              dp[i][k - 1] +\n              dp[k + 1][j] +\n              nums[i - 1] * nums[k] * nums[j + 1])\n\n    return dp[1][n]\n", "class Solution:\n  def maxCoins(self, nums: list[int]) -> int:\n    n = len(nums)\n    nums = [1] + nums + [1]\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int) -> int:\n      \"\"\"Returns maxCoins(nums[i..j]).\"\"\"\n      if i > j:\n        return 0\n      return max(dp(i, k - 1) +\n                 dp(k + 1, j) +\n                 nums[i - 1] * nums[k] * nums[j + 1]\n                 for k in range(i, j + 1))\n\n    return dp(1, n)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 360, "slug": "sort-transformed-array", "solutions": ["class Solution:\n    def sortTransformedArray(\n        self, nums: List[int], a: int, b: int, c: int\n    ) -> List[int]:\n        def f(x):\n            return a * x * x + b * x + c\n\n        n = len(nums)\n        i, j, k = 0, n - 1, 0 if a < 0 else n - 1\n        res = [0] * n\n        while i <= j:\n            v1, v2 = f(nums[i]), f(nums[j])\n            if a < 0:\n                if v1 <= v2:\n                    res[k] = v1\n                    i += 1\n                else:\n                    res[k] = v2\n                    j -= 1\n                k += 1\n            else:\n                if v1 >= v2:\n                    res[k] = v1\n                    i += 1\n                else:\n                    res[k] = v2\n                    j -= 1\n                k -= 1\n        return res\n", "class Solution:\n  def sortTransformedArray(\n      self,\n      nums: list[int],\n      a: int,\n      b: int,\n      c: int,\n  ) -> list[int]:\n    n = len(nums)\n    upward = a > 0\n    ans = [0] * n\n\n    # The concavity of f only depends on a's sign.\n    def f(x: int, a: int, b: int, c: int) -> int:\n      return (a * x + b) * x + c\n\n    quad = [f(num, a, b, c) for num in nums]\n\n    i = n - 1 if upward else 0\n    l = 0\n    r = n - 1\n    while l <= r:\n      if upward:  # is the maximum in the both ends\n        if quad[l] > quad[r]:\n          ans[i] = quad[l]\n          l += 1\n        else:\n          ans[i] = quad[r]\n          r -= 1\n        i -= 1\n      else:  # is the minimum in the both ends\n        if quad[l] < quad[r]:\n          ans[i] = quad[l]\n          l += 1\n        else:\n          ans[i] = quad[r]\n          r -= 1\n        i += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 310, "slug": "minimum-height-trees", "solutions": ["class Solution:\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\n        if n == 1:\n            return [0]\n        g = [[] for _ in range(n)]\n        degree = [0] * n\n        for a, b in edges:\n            g[a].append(b)\n            g[b].append(a)\n            degree[a] += 1\n            degree[b] += 1\n        q = deque(i for i in range(n) if degree[i] == 1)\n        ans = []\n        while q:\n            ans.clear()\n            for _ in range(len(q)):\n                a = q.popleft()\n                ans.append(a)\n                for b in g[a]:\n                    degree[b] -= 1\n                    if degree[b] == 1:\n                        q.append(b)\n        return ans\n", "class Solution:\n  def findMinHeightTrees(self, n: int, edges: list[list[int]]) -> list[int]:\n    if n == 1 or not edges:\n      return [0]\n\n    ans = []\n    graph = collections.defaultdict(set)\n\n    for u, v in edges:\n      graph[u].add(v)\n      graph[v].add(u)\n\n    for label, children in graph.items():\n      if len(children) == 1:\n        ans.append(label)\n\n    while n > 2:\n      n -= len(ans)\n      nextLeaves = []\n      for leaf in ans:\n        u = next(iter(graph[leaf]))\n        graph[u].remove(leaf)\n        if len(graph[u]) == 1:\n          nextLeaves.append(u)\n      ans = nextLeaves\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 336, "slug": "palindrome-pairs", "solutions": ["class Solution:\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\n        d = {w: i for i, w in enumerate(words)}\n        ans = []\n        for i, w in enumerate(words):\n            for j in range(len(w) + 1):\n                a, b = w[:j], w[j:]\n                ra, rb = a[::-1], b[::-1]\n                if ra in d and d[ra] != i and b == rb:\n                    ans.append([i, d[ra]])\n                if j and rb in d and d[rb] != i and a == ra:\n                    ans.append([d[rb], i])\n        return ans\n", "class Solution:\n  def palindromePairs(self, words: list[str]) -> list[list[int]]:\n    ans = []\n    dict = {word[::-1]: i for i, word in enumerate(words)}\n\n    for i, word in enumerate(words):\n      if \"\" in dict and dict[\"\"] != i and word == word[::-1]:\n        ans.append([i, dict[\"\"]])\n\n      for j in range(1, len(word) + 1):\n        l = word[:j]\n        r = word[j:]\n        if l in dict and dict[l] != i and r == r[::-1]:\n          ans.append([i, dict[l]])\n        if r in dict and dict[r] != i and l == l[::-1]:\n          ans.append([dict[r], i])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 379, "slug": "design-phone-directory", "solutions": ["class PhoneDirectory:\n\n    def __init__(self, maxNumbers: int):\n        self.available = set(range(maxNumbers))\n\n    def get(self) -> int:\n        if not self.available:\n            return -1\n        return self.available.pop()\n\n    def check(self, number: int) -> bool:\n        return number in self.available\n\n    def release(self, number: int) -> None:\n        self.available.add(number)\n\n\n# Your PhoneDirectory object will be instantiated and called as such:\n# obj = PhoneDirectory(maxNumbers)\n# param_1 = obj.get()\n# param_2 = obj.check(number)\n# obj.release(number)\n", "class PhoneDirectory:\n  def __init__(self, maxNumbers: int):\n    # the next available numbers\n    self.next = [i + 1 for i in range(maxNumbers - 1)] + [0]\n    # the current possible available number\n    self.number = 0\n\n  def get(self) -> int:\n    if self.next[self.number] == -1:\n      return -1\n    ans = self.number\n    self.number = self.next[self.number]\n    self.next[ans] = -1  # Mark as used.\n    return ans\n\n  def check(self, number: int) -> bool:\n    return self.next[number] != -1\n\n  def release(self, number: int) -> None:\n    if self.next[number] != -1:\n      return\n    self.next[number] = self.number\n    self.number = number\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 339, "slug": "nested-list-weight-sum", "solutions": ["# \"\"\"\n# This is the interface that allows for creating nested lists.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# class NestedInteger:\n#    def __init__(self, value=None):\n#        \"\"\"\n#        If value is not specified, initializes an empty list.\n#        Otherwise initializes a single integer equal to value.\n#        \"\"\"\n#\n#    def isInteger(self):\n#        \"\"\"\n#        @return True if this NestedInteger holds a single integer, rather than a nested list.\n#        :rtype bool\n#        \"\"\"\n#\n#    def add(self, elem):\n#        \"\"\"\n#        Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\n#        :rtype void\n#        \"\"\"\n#\n#    def setInteger(self, value):\n#        \"\"\"\n#        Set this NestedInteger to hold a single integer equal to value.\n#        :rtype void\n#        \"\"\"\n#\n#    def getInteger(self):\n#        \"\"\"\n#        @return the single integer that this NestedInteger holds, if it holds a single integer\n#        Return None if this NestedInteger holds a nested list\n#        :rtype int\n#        \"\"\"\n#\n#    def getList(self):\n#        \"\"\"\n#        @return the nested list that this NestedInteger holds, if it holds a nested list\n#        Return None if this NestedInteger holds a single integer\n#        :rtype List[NestedInteger]\n#        \"\"\"\nclass Solution:\n    def depthSum(self, nestedList: List[NestedInteger]) -> int:\n        def dfs(nestedList, depth):\n            depth_sum = 0\n            for item in nestedList:\n                if item.isInteger():\n                    depth_sum += item.getInteger() * depth\n                else:\n                    depth_sum += dfs(item.getList(), depth + 1)\n            return depth_sum\n\n        return dfs(nestedList, 1)\n", "class Solution:\n  def depthSum(self, nestedList: list[NestedInteger]) -> int:\n    ans = 0\n    depth = 0\n    q = collections.deque()\n\n    def addIntegers(nestedList: list[NestedInteger]) -> None:\n      for ni in nestedList:\n        q.append(ni)\n\n    addIntegers(nestedList)\n\n    while q:\n      depth += 1\n      for _ in range(len(q)):\n        ni = q.popleft()\n        if ni.isInteger():\n          ans += ni.getInteger() * depth\n        else:\n          addIntegers(ni.getList())\n\n    return ans\n", "class Solution:\n  def depthSum(self, nestedList: list[NestedInteger]) -> int:\n    ans = 0\n\n    def dfs(nestedList: list[NestedInteger], depth: int) -> None:\n      nonlocal ans\n      for ni in nestedList:\n        if ni.isInteger():\n          ans += ni.getInteger() * depth\n        else:\n          dfs(ni.getList(), depth + 1)\n\n    dfs(nestedList, 1)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 370, "slug": "range-addition", "solutions": ["class Solution:\n    def getModifiedArray(self, length: int, updates: List[List[int]]) -> List[int]:\n        d = [0] * length\n        for l, r, c in updates:\n            d[l] += c\n            if r + 1 < length:\n                d[r + 1] -= c\n        return list(accumulate(d))\n", "class Solution:\n  def getModifiedArray(\n      self,\n      length: int,\n      updates: list[list[int]],\n  ) -> list[int]:\n    line = [0] * length\n\n    for start, end, inc in updates:\n      line[start] += inc\n      if end + 1 < length:\n        line[end + 1] -= inc\n\n    return itertools.accumulate(line)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 390, "slug": "elimination-game", "solutions": ["class Solution:\n    def lastRemaining(self, n: int) -> int:\n        a1, an = 1, n\n        i, step, cnt = 0, 1, n\n        while cnt > 1:\n            if i % 2:\n                an -= step\n                if cnt % 2:\n                    a1 += step\n            else:\n                a1 += step\n                if cnt % 2:\n                    an -= step\n            cnt >>= 1\n            step <<= 1\n            i += 1\n        return a1\n", "class Solution:\n  def lastRemaining(self, n: int) -> int:\n    return 1 if n == 1 else 2 * (1 + n // 2 - self.lastRemaining(n // 2))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 301, "slug": "remove-invalid-parentheses", "solutions": ["class Solution:\n    def removeInvalidParentheses(self, s: str) -> List[str]:\n        def dfs(i, l, r, lcnt, rcnt, t):\n            if i == n:\n                if l == 0 and r == 0:\n                    ans.add(t)\n                return\n            if n - i < l + r or lcnt < rcnt:\n                return\n            if s[i] == '(' and l:\n                dfs(i + 1, l - 1, r, lcnt, rcnt, t)\n            elif s[i] == ')' and r:\n                dfs(i + 1, l, r - 1, lcnt, rcnt, t)\n            dfs(i + 1, l, r, lcnt + (s[i] == '('), rcnt + (s[i] == ')'), t + s[i])\n\n        l = r = 0\n        for c in s:\n            if c == '(':\n                l += 1\n            elif c == ')':\n                if l:\n                    l -= 1\n                else:\n                    r += 1\n        ans = set()\n        n = len(s)\n        dfs(0, l, r, 0, 0, '')\n        return list(ans)\n", "class Solution:\n  def removeInvalidParentheses(self, s: str) -> list[str]:\n    # Similar to 921. Minimum Add to Make Parentheses Valid\n    def getLeftAndRightCounts(s: str) -> tuple[int, int]:\n      \"\"\"Returns how many '(' and ')' need to be deleted.\"\"\"\n      l = 0\n      r = 0\n\n      for c in s:\n        if c == '(':\n          l += 1\n        elif c == ')':\n          if l == 0:\n            r += 1\n          else:\n            l -= 1\n\n      return l, r\n\n    def isValid(s: str):\n      opened = 0  # the number of '(' - # of ')'\n      for c in s:\n        if c == '(':\n          opened += 1\n        elif c == ')':\n          opened -= 1\n        if opened < 0:\n          return False\n      return True  # opened == 0\n\n    ans = []\n\n    def dfs(s: str, start: int, l: int, r: int) -> None:\n      if l == 0 and r == 0 and isValid(s):\n        ans.append(s)\n        return\n\n      for i in range(start, len(s)):\n        if i > start and s[i] == s[i - 1]:\n          continue\n        if r > 0 and s[i] == ')':  # Delete s[i]\n          dfs(s[:i] + s[i + 1:], i, l, r - 1)\n        elif l > 0 and s[i] == '(':  # Delete s[i]\n          dfs(s[:i] + s[i + 1:], i, l - 1, r)\n\n    l, r = getLeftAndRightCounts(s)\n    dfs(s, 0, l, r)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 388, "slug": "longest-absolute-file-path", "solutions": ["class Solution:\n    def lengthLongestPath(self, input: str) -> int:\n        i, n = 0, len(input)\n        ans = 0\n        stk = []\n        while i < n:\n            ident = 0\n            while input[i] == '\\t':\n                ident += 1\n                i += 1\n\n            cur, isFile = 0, False\n            while i < n and input[i] != '\\n':\n                cur += 1\n                if input[i] == '.':\n                    isFile = True\n                i += 1\n            i += 1\n\n            # popd\n            while len(stk) > 0 and len(stk) > ident:\n                stk.pop()\n\n            if len(stk) > 0:\n                cur += stk[-1] + 1\n\n            # pushd\n            if not isFile:\n                stk.append(cur)\n                continue\n\n            ans = max(ans, cur)\n\n        return ans\n", "class Solution:\n  def lengthLongestPath(self, input: str) -> int:\n    ans = 0\n    stack = [(-1, 0)]  # placeholder\n\n    for token in input.split('\\n'):\n      depth = token.count('\\t')\n      token = token.replace('\\t', '')\n      while depth <= stack[-1][0]:\n        stack.pop()\n      if '.' in token:  # `token` is file.\n        ans = max(ans, stack[-1][1] + len(token))\n      else:  # directory + '/'\n        stack.append((depth, stack[-1][1] + len(token) + 1))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 308, "slug": "range-sum-query-2d-mutable", "solutions": ["class BinaryIndexedTree:\n    def __init__(self, n):\n        self.n = n\n        self.c = [0] * (n + 1)\n\n    @staticmethod\n    def lowbit(x):\n        return x & -x\n\n    def update(self, x, delta):\n        while x <= self.n:\n            self.c[x] += delta\n            x += BinaryIndexedTree.lowbit(x)\n\n    def query(self, x):\n        s = 0\n        while x > 0:\n            s += self.c[x]\n            x -= BinaryIndexedTree.lowbit(x)\n        return s\n\n\nclass NumMatrix:\n    def __init__(self, matrix: List[List[int]]):\n        self.trees = []\n        n = len(matrix[0])\n        for row in matrix:\n            tree = BinaryIndexedTree(n)\n            for j, v in enumerate(row):\n                tree.update(j + 1, v)\n            self.trees.append(tree)\n\n    def update(self, row: int, col: int, val: int) -> None:\n        tree = self.trees[row]\n        prev = tree.query(col + 1) - tree.query(col)\n        tree.update(col + 1, val - prev)\n\n    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:\n        return sum(\n            tree.query(col2 + 1) - tree.query(col1)\n            for tree in self.trees[row1 : row2 + 1]\n        )\n\n\n# Your NumMatrix object will be instantiated and called as such:\n# obj = NumMatrix(matrix)\n# obj.update(row,col,val)\n# param_2 = obj.sumRegion(row1,col1,row2,col2)\n", "class FenwickTree:\n  def __init__(self, m: int, n: int):\n    self.sums = [[0] * (n + 1) for _ in range(m + 1)]\n\n  def add(self, row: int, col: int, delta: int) -> None:\n    i = row\n    while i < len(self.sums):\n      j = col\n      while j < len(self.sums[0]):\n        self.sums[i][j] += delta\n        j += FenwickTree.lowbit(j)\n      i += FenwickTree.lowbit(i)\n\n  def get(self, row: int, col: int) -> int:\n    summ = 0\n    i = row\n    while i > 0:\n      j = col\n      while j > 0:\n        summ += self.sums[i][j]\n        j -= FenwickTree.lowbit(j)\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass NumMatrix:\n  def __init__(self, matrix: list[list[int]]):\n    self.matrix = matrix\n    self.tree = FenwickTree(len(matrix), len(matrix[0]))\n\n    for i in range(len(matrix)):\n      for j, val in enumerate(matrix[i]):\n        self.tree.add(i + 1, j + 1, val)\n\n  def update(self, row: int, col: int, val: int) -> None:\n    self.tree.add(row + 1, col + 1, val - self.matrix[row][col])\n    self.matrix[row][col] = val\n\n  def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:\n    return (self.tree.get(row2 + 1, col2 + 1) - self.tree.get(row1, col2 + 1) -\n            self.tree.get(row2 + 1, col1) + self.tree.get(row1, col1))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 338, "slug": "counting-bits", "solutions": ["class Solution:\n    def countBits(self, n: int) -> List[int]:\n        return [i.bit_count() for i in range(n + 1)]\n", "class Solution:\n  def countBits(self, n: int) -> list[int]:\n    # f(i) := i's number of 1s in bitmask\n    # f(i) = f(i / 2) + i % 2\n    ans = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n      ans[i] = ans[i // 2] + (i & 1)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 395, "slug": "longest-substring-with-at-least-k-repeating-characters", "solutions": ["class Solution:\n    def longestSubstring(self, s: str, k: int) -> int:\n        def dfs(l, r):\n            cnt = Counter(s[l : r + 1])\n            split = next((c for c, v in cnt.items() if v < k), '')\n            if not split:\n                return r - l + 1\n            i = l\n            ans = 0\n            while i <= r:\n                while i <= r and s[i] == split:\n                    i += 1\n                if i >= r:\n                    break\n                j = i\n                while j <= r and s[j] != split:\n                    j += 1\n                t = dfs(i, j - 1)\n                ans = max(ans, t)\n                i = j\n            return ans\n\n        return dfs(0, len(s) - 1)\n", "class Solution:\n  def longestSubstring(self, s: str, k: int) -> int:\n    def longestSubstringWithNUniqueLetters(n: int) -> int:\n      res = 0\n      uniqueLetters = 0  # the number of unique letters\n      lettersHavingKFreq = 0  # the number of letters having frequency >= k\n      count = collections.Counter()\n\n      l = 0\n      for r, c in enumerate(s):\n        count[c] += 1\n        if count[c] == 1:\n          uniqueLetters += 1\n        if count[c] == k:\n          lettersHavingKFreq += 1\n        while uniqueLetters > n:\n          if count[s[l]] == k:\n            lettersHavingKFreq -= 1\n          count[s[l]] -= 1\n          if count[s[l]] == 0:\n            uniqueLetters -= 1\n          l += 1\n        # Since both the number of unique letters and the number of letters\n        # having frequency >= k are equal to n, this is a valid window.\n        if lettersHavingKFreq == n:  # Implicit: uniqueLetters == n\n          res = max(res, r - l + 1)\n\n      return res\n\n    return max(longestSubstringWithNUniqueLetters(n)\n               for n in range(1, 27))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 324, "slug": "wiggle-sort-ii", "solutions": ["class Solution:\n    def wiggleSort(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        arr = sorted(nums)\n        n = len(arr)\n        i, j = (n - 1) >> 1, n - 1\n        for k in range(n):\n            if k % 2 == 0:\n                nums[k] = arr[i]\n                i -= 1\n            else:\n                nums[k] = arr[j]\n                j -= 1\n", "class Solution:\n  def wiggleSort(self, nums: list[int]) -> None:\n    n = len(nums)\n    median = self._findKthLargest(nums, (n + 1) // 2)\n\n    def A(i: int):\n      return (1 + 2 * i) % (n | 1)\n\n    i = 0\n    j = 0\n    k = n - 1\n\n    while i <= k:\n      if nums[A(i)] > median:\n        nums[A(i)], nums[A(j)] = nums[A(j)], nums[A(i)]\n        i, j = i + 1, j + 1\n      elif nums[A(i)] < median:\n        nums[A(i)], nums[A(k)] = nums[A(k)], nums[A(i)]\n        k -= 1\n      else:\n        i += 1\n\n  # Same as 215. Kth Largest Element in an Array\n  def _findKthLargest(self, nums: list[int], k: int) -> int:\n    def quickSelect(l: int, r: int, k: int) -> int:\n      randIndex = random.randint(0, r - l) + l\n      nums[randIndex], nums[r] = nums[r], nums[randIndex]\n      pivot = nums[r]\n\n      nextSwapped = l\n      for i in range(l, r):\n        if nums[i] >= pivot:\n          nums[nextSwapped], nums[i] = nums[i], nums[nextSwapped]\n          nextSwapped += 1\n      nums[nextSwapped], nums[r] = nums[r], nums[nextSwapped]\n\n      count = nextSwapped - l + 1  # Number of nums >= pivot\n      if count == k:\n        return nums[nextSwapped]\n      if count > k:\n        return quickSelect(l, nextSwapped - 1, k)\n      return quickSelect(nextSwapped + 1, r, k - count)\n\n    return quickSelect(0, len(nums) - 1, k)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 316, "slug": "remove-duplicate-letters", "solutions": ["class Solution:\n    def removeDuplicateLetters(self, s: str) -> str:\n        last = {c: i for i, c in enumerate(s)}\n        stk = []\n        vis = set()\n        for i, c in enumerate(s):\n            if c in vis:\n                continue\n            while stk and stk[-1] > c and last[stk[-1]] > i:\n                vis.remove(stk.pop())\n            stk.append(c)\n            vis.add(c)\n        return ''.join(stk)\n", "class Solution:\n  def removeDuplicateLetters(self, s: str) -> str:\n    ans = []\n    count = collections.Counter(s)\n    used = [False] * 26\n\n    for c in s:\n      count[c] -= 1\n      if used[ord(c) - ord('a')]:\n        continue\n      while ans and ans[-1] > c and count[ans[-1]] > 0:\n        used[ord(ans[-1]) - ord('a')] = False\n        ans.pop()\n      ans.append(c)\n      used[ord(ans[-1]) - ord('a')] = True\n\n    return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 345, "slug": "reverse-vowels-of-a-string", "solutions": ["class Solution:\n    def reverseVowels(self, s: str) -> str:\n        vowels = \"aeiouAEIOU\"\n        i, j = 0, len(s) - 1\n        cs = list(s)\n        while i < j:\n            while i < j and cs[i] not in vowels:\n                i += 1\n            while i < j and cs[j] not in vowels:\n                j -= 1\n            if i < j:\n                cs[i], cs[j] = cs[j], cs[i]\n                i, j = i + 1, j - 1\n        return \"\".join(cs)\n", "class Solution:\n  def reverseVowels(self, s: str) -> str:\n    chars = list(s)\n    VOWELS = 'aeiouAEIOU'\n    l = 0\n    r = len(s) - 1\n\n    while l < r:\n      while l < r and chars[l] not in VOWELS:\n        l += 1\n      while l < r and chars[r] not in VOWELS:\n        r -= 1\n      chars[l], chars[r] = chars[r], chars[l]\n      l += 1\n      r -= 1\n\n    return ''.join(chars)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 399, "slug": "evaluate-division", "solutions": ["class Solution:\n    def calcEquation(\n        self, equations: List[List[str]], values: List[float], queries: List[List[str]]\n    ) -> List[float]:\n        def find(x):\n            if p[x] != x:\n                origin = p[x]\n                p[x] = find(p[x])\n                w[x] *= w[origin]\n            return p[x]\n\n        w = defaultdict(lambda: 1)\n        p = defaultdict()\n        for a, b in equations:\n            p[a], p[b] = a, b\n        for i, v in enumerate(values):\n            a, b = equations[i]\n            pa, pb = find(a), find(b)\n            if pa == pb:\n                continue\n            p[pa] = pb\n            w[pa] = w[b] * v / w[a]\n        return [\n            -1 if c not in p or d not in p or find(c) != find(d) else w[c] / w[d]\n            for c, d in queries\n        ]\n", "class Solution:\n  def calcEquation(\n      self,\n      equations: list[list[str]],\n      values: list[float],\n      queries: list[list[str]],\n  ) -> list[float]:\n    ans = []\n    # graph[A][B] := A / B\n    graph = collections.defaultdict(dict)\n\n    for (A, B), value in zip(equations, values):\n      graph[A][B] = value\n      graph[B][A] = 1 / value\n\n    def devide(A: str, C: str, seen: set[str]) -> float:\n      \"\"\"Returns A / C.\"\"\"\n      if A == C:\n        return 1.0\n\n      seen.add(A)\n\n      # value := A / B\n      for B, value in graph[A].items():\n        if B in seen:\n          continue\n        res = devide(B, C, seen)  # B / C\n        if res > 0:  # valid result\n          return value * res  # (A / B) * (B / C) = A / C\n\n      return -1.0  # invalid result\n\n    for A, C in queries:\n      if A not in graph or C not in graph:\n        ans.append(-1.0)\n      else:\n        ans.append(devide(A, C, set()))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 327, "slug": "count-of-range-sum", "solutions": ["class BinaryIndexedTree:\n    def __init__(self, n):\n        self.n = n\n        self.c = [0] * (n + 1)\n\n    def update(self, x, v):\n        while x <= self.n:\n            self.c[x] += v\n            x += x & -x\n\n    def query(self, x):\n        s = 0\n        while x > 0:\n            s += self.c[x]\n            x -= x & -x\n        return s\n\n\nclass Solution:\n    def countRangeSum(self, nums: List[int], lower: int, upper: int) -> int:\n        s = list(accumulate(nums, initial=0))\n        arr = sorted(set(v for x in s for v in (x, x - lower, x - upper)))\n        tree = BinaryIndexedTree(len(arr))\n        ans = 0\n        for x in s:\n            l = bisect_left(arr, x - upper) + 1\n            r = bisect_left(arr, x - lower) + 1\n            ans += tree.query(r) - tree.query(l - 1)\n            tree.update(bisect_left(arr, x) + 1, 1)\n        return ans\n", "class Solution:\n  def countRangeSum(self, nums: list[int], lower: int, upper: int) -> int:\n    n = len(nums)\n    self.ans = 0\n    prefix = list(itertools.accumulate(nums, initial=0))\n\n    self._mergeSort(prefix, 0, n, lower, upper)\n    return self.ans\n\n  def _mergeSort(\n      self,\n      prefix: list[int],\n      l: int,\n      r: int,\n      lower: int,\n      upper: int,\n  ) -> None:\n    if l >= r:\n      return\n\n    m = (l + r) // 2\n    self._mergeSort(prefix, l, m, lower, upper)\n    self._mergeSort(prefix, m + 1, r, lower, upper)\n    self._merge(prefix, l, m, r, lower, upper)\n\n  def _merge(\n      self,\n      prefix: list[int],\n      l: int,\n      m: int,\n      r: int,\n      lower: int,\n      upper: int,\n  ) -> None:\n    lo = m + 1  # the first index s.t. prefix[lo] - prefix[i] >= lower\n    hi = m + 1  # the first index s.t. prefix[hi] - prefix[i] > upper\n\n    # For each index i in range [l, m], add hi - lo to `ans`.\n    for i in range(l, m + 1):\n      while lo <= r and prefix[lo] - prefix[i] < lower:\n        lo += 1\n      while hi <= r and prefix[hi] - prefix[i] <= upper:\n        hi += 1\n      self.ans += hi - lo\n\n    sorted = [0] * (r - l + 1)\n    k = 0  # sorted's index\n    i = l  # left's index\n    j = m + 1  # right's index\n\n    while i <= m and j <= r:\n      if prefix[i] < prefix[j]:\n        sorted[k] = prefix[i]\n        k += 1\n        i += 1\n      else:\n        sorted[k] = prefix[j]\n        k += 1\n        j += 1\n\n    # Put the possible remaining left part into the sorted array.\n    while i <= m:\n      sorted[k] = prefix[i]\n      k += 1\n      i += 1\n\n    # Put the possible remaining right part into the sorted array.\n    while j <= r:\n      sorted[k] = prefix[j]\n      k += 1\n      j += 1\n\n    prefix[l:l + len(sorted)] = sorted\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 382, "slug": "linked-list-random-node", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def __init__(self, head: Optional[ListNode]):\n        self.head = head\n\n    def getRandom(self) -> int:\n        n = ans = 0\n        head = self.head\n        while head:\n            n += 1\n            x = random.randint(1, n)\n            if n == x:\n                ans = head.val\n            head = head.next\n        return ans\n\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution(head)\n# param_1 = obj.getRandom()\n", "# Definition for singly-linked list.\n# class ListNode:\n#   def __init__(self, val=0, next=None):\n#     self.val = val\n#     self.next = next\n\nclass Solution:\n  def __init__(self, head: ListNode | None):\n    self.head = head\n\n  def getRandom(self) -> int:\n    res = -1\n    i = 1\n    curr = self.head\n\n    while curr:\n      if random.randint(0, i - 1) == 0:\n        res = curr.val\n      curr = curr.next\n      i += 1\n\n    return res\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 328, "slug": "odd-even-linked-list", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def oddEvenList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head is None:\n            return None\n        a = head\n        b = c = head.next\n        while b and b.next:\n            a.next = b.next\n            a = a.next\n            b.next = a.next\n            b = b.next\n        a.next = c\n        return head\n", "class Solution:\n  def oddEvenList(self, head: ListNode) -> ListNode:\n    oddHead = ListNode(0)\n    evenHead = ListNode(0)\n    odd = oddHead\n    even = evenHead\n    isOdd = True\n\n    while head:\n      if isOdd:\n        odd.next = head\n        odd = head\n      else:\n        even.next = head\n        even = head\n      head = head.next\n      isOdd = not isOdd\n\n    even.next = None\n    odd.next = evenHead.next\n    return oddHead.next\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1394, "slug": "find-lucky-integer-in-an-array", "solutions": ["class Solution:\n    def findLucky(self, arr: List[int]) -> int:\n        cnt = Counter(arr)\n        ans = -1\n        for x, v in cnt.items():\n            if x == v and ans < x:\n                ans = x\n        return ans\n", "class Solution:\n  def findLucky(self, arr: list[int]) -> int:\n    count = [0] * (len(arr) + 1)\n\n    for a in arr:\n      if a <= len(arr):\n        count[a] += 1\n\n    for i in range(len(arr), 0, -1):\n      if count[i] == i:\n        return i\n\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1344, "slug": "angle-between-hands-of-a-clock", "solutions": ["class Solution:\n    def angleClock(self, hour: int, minutes: int) -> float:\n        h = 30 * hour + 0.5 * minutes\n        m = 6 * minutes\n        diff = abs(h - m)\n        return min(diff, 360 - diff)\n", "class Solution:\n  def angleClock(self, hour: int, minutes: int) -> float:\n    hourAngle = (hour % 12) * 30 + minutes * 0.5\n    minuteAngle = minutes * 6\n    ans = abs(hourAngle - minuteAngle)\n\n    return min(ans, 360 - ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1312, "slug": "minimum-insertion-steps-to-make-a-string-palindrome", "solutions": ["class Solution:\n    def minInsertions(self, s: str) -> int:\n        @cache\n        def dfs(i: int, j: int) -> int:\n            if i >= j:\n                return 0\n            if s[i] == s[j]:\n                return dfs(i + 1, j - 1)\n            return 1 + min(dfs(i + 1, j), dfs(i, j - 1))\n\n        return dfs(0, len(s) - 1)\n", "class Solution:\n  def minInsertions(self, s: str) -> int:\n    return len(s) - self._longestPalindromeSubseq(s)\n\n  # Same as 516. Longest Palindromic Subsequence\n  def _longestPalindromeSubseq(self, s: str) -> int:\n    n = len(s)\n    # dp[i][j] := the length of LPS(s[i..j])\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i] = 1\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        if s[i] == s[j]:\n          dp[i][j] = 2 + dp[i + 1][j - 1]\n        else:\n          dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n\n    return dp[0][n - 1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1346, "slug": "check-if-n-and-its-double-exist", "solutions": ["class Solution:\n    def checkIfExist(self, arr: List[int]) -> bool:\n        s = set()\n        for x in arr:\n            if x * 2 in s or (x % 2 == 0 and x // 2 in s):\n                return True\n            s.add(x)\n        return False\n", "class Solution:\n  def checkIfExist(self, arr: list[int]) -> bool:\n    seen = set()\n\n    for a in arr:\n      if a * 2 in seen or a % 2 == 0 and a // 2 in seen:\n        return True\n      seen.add(a)\n\n    return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1321, "slug": "restaurant-growth", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1337, "slug": "the-k-weakest-rows-in-a-matrix", "solutions": ["class Solution:\n    def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:\n        m, n = len(mat), len(mat[0])\n        ans = [n - bisect_right(row[::-1], 0) for row in mat]\n        idx = list(range(m))\n        idx.sort(key=lambda i: ans[i])\n        return idx[:k]\n", "class Solution:\n  def kWeakestRows(self, mat: list[list[int]], k: int) -> list[int]:\n    rowSums = [(sum(row), i) for i, row in enumerate(mat)]\n    return [i for _, i in sorted(rowSums)[:k]]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1393, "slug": "capital-gainloss", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1390, "slug": "four-divisors", "solutions": ["class Solution:\n    def sumFourDivisors(self, nums: List[int]) -> int:\n        def f(x: int) -> int:\n            i = 2\n            cnt, s = 2, x + 1\n            while i <= x // i:\n                if x % i == 0:\n                    cnt += 1\n                    s += i\n                    if i * i != x:\n                        cnt += 1\n                        s += x // i\n                i += 1\n            return s if cnt == 4 else 0\n\n        return sum(f(x) for x in nums)\n", "class Solution:\n  def sumFourDivisors(self, nums: list[int]) -> int:\n    ans = 0\n\n    for num in nums:\n      divisor = 0\n      for i in range(2, math.isqrt(num) + 1):\n        if num % i == 0:\n          if divisor == 0:\n            divisor = i\n          else:\n            divisor = 0\n            break\n      if divisor > 0 and divisor * divisor < num:\n        ans += 1 + num + divisor + num // divisor\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1320, "slug": "minimum-distance-to-type-a-word-using-two-fingers", "solutions": ["class Solution:\n    def minimumDistance(self, word: str) -> int:\n        def dist(a: int, b: int) -> int:\n            x1, y1 = divmod(a, 6)\n            x2, y2 = divmod(b, 6)\n            return abs(x1 - x2) + abs(y1 - y2)\n\n        n = len(word)\n        f = [[[inf] * 26 for _ in range(26)] for _ in range(n)]\n        for j in range(26):\n            f[0][ord(word[0]) - ord('A')][j] = 0\n            f[0][j][ord(word[0]) - ord('A')] = 0\n        for i in range(1, n):\n            a, b = ord(word[i - 1]) - ord('A'), ord(word[i]) - ord('A')\n            d = dist(a, b)\n            for j in range(26):\n                f[i][b][j] = min(f[i][b][j], f[i - 1][a][j] + d)\n                f[i][j][b] = min(f[i][j][b], f[i - 1][j][a] + d)\n                if j == a:\n                    for k in range(26):\n                        t = dist(k, b)\n                        f[i][b][j] = min(f[i][b][j], f[i - 1][k][a] + t)\n                        f[i][j][b] = min(f[i][j][b], f[i - 1][a][k] + t)\n        a = min(f[n - 1][ord(word[-1]) - ord('A')])\n        b = min(f[n - 1][j][ord(word[-1]) - ord('A')] for j in range(26))\n        return int(min(a, b))\n", "class Solution:\n  def minimumDistance(self, word: str) -> int:\n    def dist(a: int, b: int) -> int:\n      if a == 26:  # the first hovering state\n        return 0\n      x1, y1 = a // 6, a % 6\n      x2, y2 = b // 6, b % 6\n      return abs(x1 - x2) + abs(y1 - y2)\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, k: int) -> int:\n      \"\"\"\n      Returns the minimum distance to type the `word`, where the left finger is\n      on the i-th letter, the right finger is on the j-th letter, and the\n      words[0..k) have been written.\n      \"\"\"\n      if k == len(word):\n        return 0\n      nxt = ord(word[k]) - ord('A')\n      moveLeft = dist(i, nxt) + dp(nxt, j, k + 1)\n      moveRight = dist(j, nxt) + dp(i, nxt, k + 1)\n      return min(moveLeft, moveRight)\n\n    return dp(26, 26, 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1330, "slug": "reverse-subarray-to-maximize-array-value", "solutions": ["class Solution:\n    def maxValueAfterReverse(self, nums: List[int]) -> int:\n        ans = s = sum(abs(x - y) for x, y in pairwise(nums))\n        for x, y in pairwise(nums):\n            ans = max(ans, s + abs(nums[0] - y) - abs(x - y))\n            ans = max(ans, s + abs(nums[-1] - x) - abs(x - y))\n        for k1, k2 in pairwise((1, -1, -1, 1, 1)):\n            mx, mi = -inf, inf\n            for x, y in pairwise(nums):\n                a = k1 * x + k2 * y\n                b = abs(x - y)\n                mx = max(mx, a - b)\n                mi = min(mi, a + b)\n            ans = max(ans, s + max(mx - mi, 0))\n        return ans\n", "class Solution:\n  def maxValueAfterReverse(self, nums: list[int]) -> int:\n    mn = math.inf\n    mx = -math.inf\n\n    for a, b in zip(nums, nums[1:]):\n      mn = min(mn, max(a, b))\n      mx = max(mx, min(a, b))\n    diff = max(0, (mx - mn) * 2)\n\n    for a, b in zip(nums, nums[1:]):\n      headDiff = -abs(a - b) + abs(nums[0] - b)\n      tailDiff = -abs(a - b) + abs(nums[-1] - a)\n      diff = max(diff, headDiff, tailDiff)\n\n    return sum(abs(a - b) for a, b in zip(nums, nums[1:])) + diff\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1395, "slug": "count-number-of-teams", "solutions": ["class Solution:\n    def numTeams(self, rating: List[int]) -> int:\n        ans, n = 0, len(rating)\n        for i, b in enumerate(rating):\n            l = sum(a < b for a in rating[:i])\n            r = sum(c > b for c in rating[i + 1 :])\n            ans += l * r\n            ans += (i - l) * (n - i - 1 - r)\n        return ans\n", "class Solution:\n  def numTeams(self, rating: list[int]) -> int:\n    ans = 0\n\n    for i in range(1, len(rating) - 1):\n      # Calculate soldiers on the left with less//greater ratings.\n      leftLess = 0\n      leftGreater = 0\n      for j in range(i):\n        if rating[j] < rating[i]:\n          leftLess += 1\n        elif rating[j] > rating[i]:\n          leftGreater += 1\n      # Calculate soldiers on the right with less//greater ratings.\n      rightLess = 0\n      rightGreater = 0\n      for j in range(i + 1, len(rating)):\n        if rating[j] < rating[i]:\n          rightLess += 1\n        elif rating[j] > rating[i]:\n          rightGreater += 1\n      ans += leftLess * rightGreater + leftGreater * rightLess\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1398, "slug": "customers-who-bought-products-a-and-b-but-not-c", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1368, "slug": "minimum-cost-to-make-at-least-one-valid-path-in-a-grid", "solutions": ["class Solution:\n    def minCost(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        dirs = [[0, 0], [0, 1], [0, -1], [1, 0], [-1, 0]]\n        q = deque([(0, 0, 0)])\n        vis = set()\n        while q:\n            i, j, d = q.popleft()\n            if (i, j) in vis:\n                continue\n            vis.add((i, j))\n            if i == m - 1 and j == n - 1:\n                return d\n            for k in range(1, 5):\n                x, y = i + dirs[k][0], j + dirs[k][1]\n                if 0 <= x < m and 0 <= y < n:\n                    if grid[i][j] == k:\n                        q.appendleft((x, y, d))\n                    else:\n                        q.append((x, y, d + 1))\n        return -1\n", "class Solution:\n  def minCost(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    DIRS = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    dp = [[-1] * n for _ in range(m)]\n    q = collections.deque()\n\n    def dfs(i: int, j: int, cost: int) -> None:\n      if i < 0 or i == m or j < 0 or j == n:\n        return\n      if dp[i][j] != -1:\n        return\n      dp[i][j] = cost\n      q.append((i, j))\n      dx, dy = DIRS[grid[i][j] - 1]\n      dfs(i + dx, j + dy, cost)\n\n    dfs(0, 0, 0)\n\n    cost = 0\n    while q:\n      cost += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in DIRS:\n          dfs(i + dx, j + dy, cost)\n\n    return dp[-1][-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1306, "slug": "jump-game-iii", "solutions": ["class Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        q = deque([start])\n        while q:\n            i = q.popleft()\n            if arr[i] == 0:\n                return True\n            x = arr[i]\n            arr[i] = -1\n            for j in (i + x, i - x):\n                if 0 <= j < len(arr) and arr[j] >= 0:\n                    q.append(j)\n        return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1334, "slug": "find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance", "solutions": ["class Solution:\n    def findTheCity(\n        self, n: int, edges: List[List[int]], distanceThreshold: int\n    ) -> int:\n        def dijkstra(u: int) -> int:\n            dist = [inf] * n\n            dist[u] = 0\n            vis = [False] * n\n            for _ in range(n):\n                k = -1\n                for j in range(n):\n                    if not vis[j] and (k == -1 or dist[k] > dist[j]):\n                        k = j\n                vis[k] = True\n                for j in range(n):\n                    # dist[j] = min(dist[j], dist[k] + g[k][j])\n                    if dist[k] + g[k][j] < dist[j]:\n                        dist[j] = dist[k] + g[k][j]\n            return sum(d <= distanceThreshold for d in dist)\n\n        g = [[inf] * n for _ in range(n)]\n        for f, t, w in edges:\n            g[f][t] = g[t][f] = w\n        ans, cnt = n, inf\n        for i in range(n - 1, -1, -1):\n            if (t := dijkstra(i)) < cnt:\n                cnt, ans = t, i\n        return ans\n", "class Solution:\n  def findTheCity(\n      self,\n      n: int,\n      edges: list[list[int]],\n      distanceThreshold: int,\n  ) -> int:\n    ans = -1\n    minCitiesCount = n\n    dist = self._floydWarshall(n, edges, distanceThreshold)\n\n    for i in range(n):\n      citiesCount = sum(dist[i][j] <= distanceThreshold for j in range(n))\n      if citiesCount <= minCitiesCount:\n        ans = i\n        minCitiesCount = citiesCount\n\n    return ans\n\n  def _floydWarshall(\n      self,\n      n: int,\n      edges: list[list[int]],\n      distanceThreshold: int,\n  ) -> list[list[int]]:\n    dist = [[distanceThreshold + 1] * n for _ in range(n)]\n\n    for i in range(n):\n      dist[i][i] = 0\n\n    for u, v, w in edges:\n      dist[u][v] = w\n      dist[v][u] = w\n\n    for k in range(n):\n      for i in range(n):\n        for j in range(n):\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    return dist\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1343, "slug": "number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold", "solutions": ["class Solution:\n    def numOfSubarrays(self, arr: List[int], k: int, threshold: int) -> int:\n        threshold *= k\n        s = sum(arr[:k])\n        ans = int(s >= threshold)\n        for i in range(k, len(arr)):\n            s += arr[i] - arr[i - k]\n            ans += int(s >= threshold)\n        return ans\n", "class Solution:\n  def numOfSubarrays(self, arr: list[int], k: int, threshold: int) -> int:\n    ans = 0\n    windowSum = 0\n\n    for i in range(len(arr)):\n      windowSum += arr[i]\n      if i >= k:\n        windowSum -= arr[i - k]\n      if i >= k - 1 and windowSum // k >= threshold:\n        ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1323, "slug": "maximum-69-number", "solutions": ["class Solution:\n    def maximum69Number(self, num: int) -> int:\n        return int(str(num).replace(\"6\", \"9\", 1))\n", "class Solution:\n  def maximum69Number(self, num: int) -> int:\n    return int(str(num).replace('6', '9', 1))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1351, "slug": "count-negative-numbers-in-a-sorted-matrix", "solutions": ["class Solution:\n    def countNegatives(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        i, j = m - 1, 0\n        ans = 0\n        while i >= 0 and j < n:\n            if grid[i][j] < 0:\n                ans += n - j\n                i -= 1\n            else:\n                j += 1\n        return ans\n", "class Solution:\n  def countNegatives(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    i = m - 1\n    j = 0\n\n    while i >= 0 and j < n:\n      if grid[i][j] < 0:\n        ans += n - j\n        i -= 1\n      else:\n        j += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1326, "slug": "minimum-number-of-taps-to-open-to-water-a-garden", "solutions": ["class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        last = [0] * (n + 1)\n        for i, x in enumerate(ranges):\n            l, r = max(0, i - x), i + x\n            last[l] = max(last[l], r)\n\n        ans = mx = pre = 0\n        for i in range(n):\n            mx = max(mx, last[i])\n            if mx <= i:\n                return -1\n            if pre == i:\n                ans += 1\n                pre = mx\n        return ans\n", "class Solution:\n  def minTaps(self, n: int, ranges: list[int]) -> int:\n    nums = [0] * (n + 1)\n\n    for i, range_ in enumerate(ranges):\n      l = max(0, i - range_)\n      r = min(n, range_ + i)\n      nums[l] = max(nums[l], r - l)\n\n    ans = 0\n    end = 0\n    farthest = 0\n\n    for i in range(n):\n      farthest = max(farthest, i + nums[i])\n      if i == end:\n        ans += 1\n        end = farthest\n\n    return ans if end == n else -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1325, "slug": "delete-leaves-with-a-given-value", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def removeLeafNodes(\n        self, root: Optional[TreeNode], target: int\n    ) -> Optional[TreeNode]:\n        if root is None:\n            return None\n        root.left = self.removeLeafNodes(root.left, target)\n        root.right = self.removeLeafNodes(root.right, target)\n        if root.left is None and root.right is None and root.val == target:\n            return None\n        return root\n", "class Solution:\n  def removeLeafNodes(\n      self,\n      root: TreeNode | None,\n      target: int,\n  ) -> TreeNode | None:\n    if not root:\n      return None\n    root.left = self.removeLeafNodes(root.left, target)\n    root.right = self.removeLeafNodes(root.right, target)\n    return None if self._isLeaf(root) and root.val == target else root\n\n  def _isLeaf(self, root: TreeNode | None) -> bool:\n    return not root.left and not root.right\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1354, "slug": "construct-target-array-with-multiple-sums", "solutions": ["class Solution:\n    def isPossible(self, target: List[int]) -> bool:\n        s = sum(target)\n        pq = [-x for x in target]\n        heapify(pq)\n        while -pq[0] > 1:\n            mx = -heappop(pq)\n            t = s - mx\n            if t == 0 or mx - t < 1:\n                return False\n            x = (mx % t) or t\n            heappush(pq, -x)\n            s = s - mx + x\n        return True\n", "class Solution:\n  def isPossible(self, target: list[int]) -> bool:\n    if len(target) == 1:\n      return target[0] == 1\n\n    summ = sum(target)\n    maxHeap = [-num for num in target]\n    heapq.heapify(maxHeap)\n\n    while -maxHeap[0] > 1:\n      mx = -heapq.heappop(maxHeap)\n      restSum = summ - mx\n      # Only occurs if n == 2.\n      if restSum == 1:\n        return True\n      updated = mx % restSum\n      # updated == 0 (invalid) or didn't change.\n      if updated == 0 or updated == mx:\n        return False\n      heapq.heappush(maxHeap, -updated)\n      summ = summ - mx + updated\n\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1338, "slug": "reduce-array-size-to-the-half", "solutions": ["class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        cnt = Counter(arr)\n        ans = m = 0\n        for _, v in cnt.most_common():\n            m += v\n            ans += 1\n            if m * 2 >= len(arr):\n                break\n        return ans\n", "class Solution:\n  def minSetSize(self, arr: list[int]) -> int:\n    count = collections.Counter(arr).most_common()\n    count.sort(key=lambda x: -x[1])\n\n    summ = 0\n    for i, (_, freq) in enumerate(count):\n      summ += freq\n      if summ >= len(arr) // 2:\n        return i + 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1349, "slug": "maximum-students-taking-exam", "solutions": ["class Solution:\n    def maxStudents(self, seats: List[List[str]]) -> int:\n        def f(seat: List[str]) -> int:\n            mask = 0\n            for i, c in enumerate(seat):\n                if c == '.':\n                    mask |= 1 << i\n            return mask\n\n        @cache\n        def dfs(seat: int, i: int) -> int:\n            ans = 0\n            for mask in range(1 << n):\n                if (seat | mask) != seat or (mask & (mask << 1)):\n                    continue\n                cnt = mask.bit_count()\n                if i == len(ss) - 1:\n                    ans = max(ans, cnt)\n                else:\n                    nxt = ss[i + 1]\n                    nxt &= ~(mask << 1)\n                    nxt &= ~(mask >> 1)\n                    ans = max(ans, cnt + dfs(nxt, i + 1))\n            return ans\n\n        n = len(seats[0])\n        ss = [f(s) for s in seats]\n        return dfs(ss[0], 0)\n", "class Solution:\n  def maxStudents(self, seats: list[list[str]]) -> int:\n    m = len(seats)\n    n = len(seats[0])\n    DIRS = ((-1, -1), (0, -1), (1, -1), (-1, 1), (0, 1), (1, 1))\n    seen = [[0] * n for _ in range(m)]\n    match = [[-1] * n for _ in range(m)]\n\n    def dfs(i: int, j: int, sessionId: int) -> int:\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if seats[x][y] != '.' or seen[x][y] == sessionId:\n          continue\n        seen[x][y] = sessionId\n        if match[x][y] == -1 or dfs(*divmod(match[x][y], n), sessionId):\n          match[x][y] = i * n + j\n          match[i][j] = x * n + y\n          return 1\n      return 0\n\n    def hungarian() -> int:\n      count = 0\n      for i in range(m):\n        for j in range(n):\n          if seats[i][j] == '.' and match[i][j] == -1:\n            sessionId = i * n + j\n            seen[i][j] = sessionId\n            count += dfs(i, j, sessionId)\n      return count\n\n    return sum(seats[i][j] == '.'\n               for i in range(m)\n               for j in range(n)) - hungarian()\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1389, "slug": "create-target-array-in-the-given-order", "solutions": ["class Solution:\n    def createTargetArray(self, nums: List[int], index: List[int]) -> List[int]:\n        target = []\n        for x, i in zip(nums, index):\n            target.insert(i, x)\n        return target\n", "class Solution:\n  def createTargetArray(self, nums, index):\n    ans = []\n    for num, i in zip(nums, index):\n      ans.insert(i, num)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1348, "slug": "tweet-counts-per-frequency", "solutions": ["class TweetCounts:\n    def __init__(self):\n        self.d = {\"minute\": 60, \"hour\": 3600, \"day\": 86400}\n        self.data = defaultdict(SortedList)\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        self.data[tweetName].add(time)\n\n    def getTweetCountsPerFrequency(\n        self, freq: str, tweetName: str, startTime: int, endTime: int\n    ) -> List[int]:\n        f = self.d[freq]\n        tweets = self.data[tweetName]\n        t = startTime\n        ans = []\n        while t <= endTime:\n            l = tweets.bisect_left(t)\n            r = tweets.bisect_left(min(t + f, endTime + 1))\n            ans.append(r - l)\n            t += f\n        return ans\n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "from sortedcontainers import SortedList\n\n\nclass TweetCounts:\n  def __init__(self):\n    self.tweetNameToTimes = collections.defaultdict(SortedList)\n\n  def recordTweet(self, tweetName: str, time: int) -> None:\n    self.tweetNameToTimes[tweetName].add(time)\n\n  def getTweetCountsPerFrequency(self, freq: str, tweetName: str,\n                                 startTime: int, endTime: int) -> list[int]:\n    counts = []\n    times = self.tweetNameToTimes[tweetName]\n    chunk = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400\n\n    # I := startTime of each chunk\n    for i in range(startTime, endTime + 1, chunk):\n      j = min(i + chunk, endTime + 1)  # EndTime of each chunk\n      counts.append(bisect_left(times, j) - bisect_left(times, i))\n\n    return counts\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1376, "slug": "time-needed-to-inform-all-employees", "solutions": ["class Solution:\n    def numOfMinutes(\n        self, n: int, headID: int, manager: List[int], informTime: List[int]\n    ) -> int:\n        def dfs(i: int) -> int:\n            ans = 0\n            for j in g[i]:\n                ans = max(ans, dfs(j) + informTime[i])\n            return ans\n\n        g = defaultdict(list)\n        for i, x in enumerate(manager):\n            g[x].append(i)\n        return dfs(headID)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1331, "slug": "rank-transform-of-an-array", "solutions": ["class Solution:\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\n        t = sorted(set(arr))\n        return [bisect_right(t, x) for x in arr]\n", "class Solution:\n  def arrayRankTransform(self, arr: list[int]) -> list[int]:\n    rank = {}\n\n    for a in sorted(arr):\n      if a not in rank:\n        rank[a] = len(rank) + 1\n\n    return map(rank.get, arr)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1342, "slug": "number-of-steps-to-reduce-a-number-to-zero", "solutions": ["class Solution:\n    def numberOfSteps(self, num: int) -> int:\n        ans = 0\n        while num:\n            if num & 1:\n                num -= 1\n            else:\n                num >>= 1\n            ans += 1\n        return ans\n", "class Solution:\n  def numberOfSteps(self, num: int) -> int:\n    if num == 0:\n      return 0\n    subtractSteps = num.bit_count()\n    divideSteps = num.bit_length() - 1\n    return subtractSteps + divideSteps\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1340, "slug": "jump-game-v", "solutions": ["class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        @cache\n        def dfs(i):\n            ans = 1\n            for j in range(i - 1, -1, -1):\n                if i - j > d or arr[j] >= arr[i]:\n                    break\n                ans = max(ans, 1 + dfs(j))\n            for j in range(i + 1, n):\n                if j - i > d or arr[j] >= arr[i]:\n                    break\n                ans = max(ans, 1 + dfs(j))\n            return ans\n\n        n = len(arr)\n        return max(dfs(i) for i in range(n))\n", "class Solution:\n  def maxJumps(self, arr: list[int], d: int) -> int:\n    n = len(arr)\n    # dp[i] := the maximum jumps starting from arr[i]\n    dp = [1] * n\n    # a dcreasing stack that stores indices\n    stack = []\n\n    for i in range(n + 1):\n      while stack and (i == n or arr[stack[-1]] < arr[i]):\n        indices = [stack.pop()]\n        while stack and arr[stack[-1]] == arr[indices[0]]:\n          indices.append(stack.pop())\n        for j in indices:\n          if i < n and i - j <= d:\n            # Can jump from i to j.\n            dp[i] = max(dp[i], dp[j] + 1)\n          if stack and j - stack[-1] <= d:\n            # Can jump from stack[-1] to j\n            dp[stack[-1]] = max(dp[stack[-1]], dp[j] + 1)\n      stack.append(i)\n\n    return max(dp)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1388, "slug": "pizza-with-3n-slices", "solutions": ["class Solution:\n    def maxSizeSlices(self, slices: List[int]) -> int:\n        def g(nums: List[int]) -> int:\n            m = len(nums)\n            f = [[0] * (n + 1) for _ in range(m + 1)]\n            for i in range(1, m + 1):\n                for j in range(1, n + 1):\n                    f[i][j] = max(\n                        f[i - 1][j], (f[i - 2][j - 1] if i >= 2 else 0) + nums[i - 1]\n                    )\n            return f[m][n]\n\n        n = len(slices) // 3\n        a, b = g(slices[:-1]), g(slices[1:])\n        return max(a, b)\n", "class Solution:\n  def maxSizeSlices(self, slices: list[int]) -> int:\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, k: int) -> int:\n      \"\"\"\n      Returns the maximum the sum of slices if you can pick k slices from\n      slices[i..j).\n      \"\"\"\n      if k == 1:\n        return max(slices[i:j])\n      # Note that j - i is not the number of all the left slices. Since you\n      # Might have chosen not to take a slice in a previous step, there would be\n      # Leftovers outside [i:j]. If you take slices[i], one of the slices your\n      # Friends take will be outside of [i:j], so the length of [i:j] is reduced\n      # By 2 instead of 3. Therefore, the minimum # Is 2 * k - 1 (the last step only\n      # Requires one slice).\n      if j - i < 2 * k - 1:\n        return -math.inf\n      return max(slices[i] + dp(i + 2, j, k - 1),\n                 dp(i + 1, j, k))\n\n    k = len(slices) // 3\n    return max(dp(0, len(slices) - 1, k),\n               dp(1, len(slices), k))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1380, "slug": "lucky-numbers-in-a-matrix", "solutions": ["class Solution:\n    def luckyNumbers(self, matrix: List[List[int]]) -> List[int]:\n        rows = {min(row) for row in matrix}\n        cols = {max(col) for col in zip(*matrix)}\n        return list(rows & cols)\n", "class Solution:\n  def luckyNumbers(self, matrix: list[list[int]]) -> list[int]:\n    for row in matrix:\n      minIndex = row.index(min(row))\n      if row[minIndex] == max(list(zip(*matrix))[minIndex]):\n        return [row[minIndex]]\n    return []\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1358, "slug": "number-of-substrings-containing-all-three-characters", "solutions": ["class Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        d = {\"a\": -1, \"b\": -1, \"c\": -1}\n        ans = 0\n        for i, c in enumerate(s):\n            d[c] = i\n            ans += min(d[\"a\"], d[\"b\"], d[\"c\"]) + 1\n        return ans\n", "class Solution:\n  # Similar to 3. Longest SubWithout Repeating Characters\n  def numberOfSubstrings(self, s: str) -> int:\n    ans = 0\n    # lastSeen[c] := the index of the last time c appeared\n    lastSeen = {c: -1 for c in 'abc'}\n\n    for i, c in enumerate(s):\n      lastSeen[c] = i\n      # s[0..i], s[1..i], s[min(lastSeen)..i] are satisfied strings.\n      ans += 1 + min(lastSeen.values())\n\n    return ans\n", "class Solution:\n  # Similar to 3. Longest SubWithout Repeating Characters\n  def numberOfSubstrings(self, s: str) -> int:\n    ans = 0\n    count = {c: 0 for c in 'abc'}\n\n    l = 0\n    for c in s:\n      count[c] += 1\n      while min(count.values()) > 0:\n        count[s[l]] -= 1\n        l += 1\n      # s[0..r], s[1..r], ..., s[l - 1..r] are satified strings.\n      ans += l\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1381, "slug": "design-a-stack-with-increment-operation", "solutions": ["class CustomStack:\n    def __init__(self, maxSize: int):\n        self.stk = [0] * maxSize\n        self.add = [0] * maxSize\n        self.i = 0\n\n    def push(self, x: int) -> None:\n        if self.i < len(self.stk):\n            self.stk[self.i] = x\n            self.i += 1\n\n    def pop(self) -> int:\n        if self.i <= 0:\n            return -1\n        self.i -= 1\n        ans = self.stk[self.i] + self.add[self.i]\n        if self.i > 0:\n            self.add[self.i - 1] += self.add[self.i]\n        self.add[self.i] = 0\n        return ans\n\n    def increment(self, k: int, val: int) -> None:\n        i = min(k, self.i) - 1\n        if i >= 0:\n            self.add[i] += val\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n", "class CustomStack:\n  def __init__(self, maxSize: int):\n    self.maxSize = maxSize\n    self.stack = []\n    # pendingIncrements[i] := the pending increment for stack[0..i].\n    self.pendingIncrements = []\n\n  def push(self, x: int) -> None:\n    if len(self.stack) == self.maxSize:\n      return\n    self.stack.append(x)\n    self.pendingIncrements.append(0)\n\n  def pop(self) -> int:\n    if not self.stack:\n      return -1\n    if len(self.stack) > 1:\n      self.pendingIncrements[-2] += self.pendingIncrements[-1]\n    return self.stack.pop() + self.pendingIncrements.pop()\n\n  def increment(self, k: int, val: int) -> None:\n    if not self.stack:\n      return\n    i = min(k - 1, len(self.stack) - 1)\n    self.pendingIncrements[i] += val\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1319, "slug": "number-of-operations-to-make-network-connected", "solutions": ["class Solution:\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\n        def find(x: int) -> int:\n            if p[x] != x:\n                p[x] = find(p[x])\n            return p[x]\n\n        cnt = 0\n        p = list(range(n))\n        for a, b in connections:\n            pa, pb = find(a), find(b)\n            if pa == pb:\n                cnt += 1\n            else:\n                p[pa] = pb\n                n -= 1\n        return -1 if n - 1 > cnt else n - 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1366, "slug": "rank-teams-by-votes", "solutions": ["class Solution:\n    def rankTeams(self, votes: List[str]) -> str:\n        m = len(votes[0])\n        cnt = defaultdict(lambda: [0] * m)\n        for vote in votes:\n            for i, c in enumerate(vote):\n                cnt[c][i] += 1\n        return \"\".join(sorted(cnt, key=lambda c: (cnt[c], -ord(c)), reverse=True))\n", "from dataclasses import dataclass\n\n\n@dataclass\nclass Team:\n  name: str\n  rank: list[int]\n\n  def __init__(self, name: str, teamSize: int):\n    self.name = name\n    self.rank = [0] * teamSize\n\n\nclass Solution:\n  def rankTeams(self, votes: list[str]) -> str:\n    teamSize = len(votes[0])\n    teams = [Team(chr(ord('A') + i), teamSize) for i in range(26)]\n\n    for vote in votes:\n      for i in range(teamSize):\n        teams[ord(vote[i]) - ord('A')].rank[i] += 1\n\n    teams.sort(key=lambda x: (x.rank, -ord(x.name)), reverse=True)\n    return ''.join(team.name for team in teams[:teamSize])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1310, "slug": "xor-queries-of-a-subarray", "solutions": ["class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        s = list(accumulate(arr, xor, initial=0))\n        return [s[r + 1] ^ s[l] for l, r in queries]\n", "class Solution:\n  def xorQueries(self, arr: list[int], queries: list[list[int]]) -> list[int]:\n    ans = []\n    xors = [0] * (len(arr) + 1)\n\n    for i, a in enumerate(arr):\n      xors[i + 1] = xors[i] ^ a\n\n    for left, right in queries:\n      ans.append(xors[left] ^ xors[right + 1])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1353, "slug": "maximum-number-of-events-that-can-be-attended", "solutions": ["class Solution:\n    def maxEvents(self, events: List[List[int]]) -> int:\n        d = defaultdict(list)\n        i, j = inf, 0\n        for s, e in events:\n            d[s].append(e)\n            i = min(i, s)\n            j = max(j, e)\n        h = []\n        ans = 0\n        for s in range(i, j + 1):\n            while h and h[0] < s:\n                heappop(h)\n            for e in d[s]:\n                heappush(h, e)\n            if h:\n                ans += 1\n                heappop(h)\n        return ans\n", "class Solution:\n  def maxEvents(self, events: list[list[int]]) -> int:\n    ans = 0\n    minHeap = []\n    i = 0  # events' index\n\n    events.sort(key=lambda x: x[0])\n\n    while minHeap or i < len(events):\n      # If no events are available to attend today, let time flies to the next\n      # available event.\n      if not minHeap:\n        d = events[i][0]\n      # All the events starting from today are newly available.\n      while i < len(events) and events[i][0] == d:\n        heapq.heappush(minHeap, events[i][1])\n        i += 1\n      # Greedily attend the event that'll end the earliest since it has higher\n      # chance can't be attended in the future.\n      heapq.heappop(minHeap)\n      ans += 1\n      d += 1\n      # Pop the events that can't be attended.\n      while minHeap and minHeap[0] < d:\n        heapq.heappop(minHeap)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1332, "slug": "remove-palindromic-subsequences", "solutions": ["class Solution:\n    def removePalindromeSub(self, s: str) -> int:\n        return 1 if s[::-1] == s else 2\n", "class Solution:\n  def removePalindromeSub(self, s: str) -> int:\n    return 1 if s == s[::-1] else 2\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1329, "slug": "sort-the-matrix-diagonally", "solutions": ["class Solution:\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\n        m, n = len(mat), len(mat[0])\n        g = [[] for _ in range(m + n)]\n        for i, row in enumerate(mat):\n            for j, x in enumerate(row):\n                g[m - i + j].append(x)\n        for e in g:\n            e.sort(reverse=True)\n        for i in range(m):\n            for j in range(n):\n                mat[i][j] = g[m - i + j].pop()\n        return mat\n", "class Solution:\n  def diagonalSort(self, mat: list[list[int]]) -> list[list[int]]:\n    m = len(mat)\n    n = len(mat[0])\n\n    count = collections.defaultdict(list)\n\n    for i in range(m):\n      for j in range(n):\n        count[i - j].append(mat[i][j])\n\n    for value in count.values():\n      value.sort(reverse=1)\n\n    for i in range(m):\n      for j in range(n):\n        mat[i][j] = count[i - j].pop()\n\n    return mat\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1324, "slug": "print-words-vertically", "solutions": ["class Solution:\n    def printVertically(self, s: str) -> List[str]:\n        words = s.split()\n        n = max(len(w) for w in words)\n        ans = []\n        for j in range(n):\n            t = [w[j] if j < len(w) else ' ' for w in words]\n            while t[-1] == ' ':\n                t.pop()\n            ans.append(''.join(t))\n        return ans\n", "class Solution:\n  def printVertically(self, s: str) -> list[str]:\n    ans = []\n    words = s.split()\n    maxLength = max(len(word) for word in words)\n\n    for i in range(maxLength):\n      row = []\n      for word in words:\n        row.append(word[i] if i < len(word) else ' ')\n      ans.append(''.join(row).rstrip())\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1392, "slug": "longest-happy-prefix", "solutions": ["class Solution:\n    def longestPrefix(self, s: str) -> str:\n        for i in range(1, len(s)):\n            if s[:-i] == s[i:]:\n                return s[i:]\n        return ''\n", "class Solution:\n  def longestPrefix(self, s: str) -> str:\n    BASE = 26\n    HASH = 8_417_508_174_513\n    n = len(s)\n    maxLength = 0\n    pow = 1\n    prefixHash = 0  # the hash of s[0..i]\n    suffixHash = 0  # the hash of s[j..n)\n\n    def val(c: str) -> int:\n      return ord(c) - ord('a')\n\n    j = n - 1\n    for i in range(n - 1):\n      prefixHash = (prefixHash * BASE + val(s[i])) % HASH\n      suffixHash = (val(s[j]) * pow + suffixHash) % HASH\n      pow = pow * BASE % HASH\n      if prefixHash == suffixHash:\n        maxLength = i + 1\n      j -= 1\n\n    return s[:maxLength]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1371, "slug": "find-the-longest-substring-containing-vowels-in-even-counts", "solutions": ["class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        d = {0: -1}\n        ans = mask = 0\n        for i, c in enumerate(s):\n            if c in \"aeiou\":\n                mask ^= 1 << (ord(c) - ord(\"a\"))\n            if mask in d:\n                j = d[mask]\n                ans = max(ans, i - j)\n            else:\n                d[mask] = i\n        return ans\n", "class Solution:\n  def findTheLongestSubstring(self, s: str) -> int:\n    VOWELS = 'aeiou'\n    ans = 0\n    prefix = 0  # the binary prefix\n    prefixToIndex = {0: -1}\n\n    for i, c in enumerate(s):\n      index = VOWELS.find(c)\n      if index != -1:\n        prefix ^= 1 << index\n      prefixToIndex.setdefault(prefix, i)\n      ans = max(ans, i - prefixToIndex[prefix])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1341, "slug": "movie-rating", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1308, "slug": "running-total-for-different-genders", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1369, "slug": "get-the-second-most-recent-activity", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1396, "slug": "design-underground-system", "solutions": ["class UndergroundSystem:\n    def __init__(self):\n        self.ts = {}\n        self.d = {}\n\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\n        self.ts[id] = (t, stationName)\n\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\n        t0, station = self.ts[id]\n        x = self.d.get((station, stationName), (0, 0))\n        self.d[(station, stationName)] = (x[0] + t - t0, x[1] + 1)\n\n    def getAverageTime(self, startStation: str, endStation: str) -> float:\n        x = self.d[(startStation, endStation)]\n        return x[0] / x[1]\n\n\n# Your UndergroundSystem object will be instantiated and called as such:\n# obj = UndergroundSystem()\n# obj.checkIn(id,stationName,t)\n# obj.checkOut(id,stationName,t)\n# param_3 = obj.getAverageTime(startStation,endStation)\n", "class UndergroundSystem:\n  def __init__(self):\n    # {id: (stationName, time)}\n    self.checkIns = {}\n    # {route: (numTrips, totalTime)}\n    self.checkOuts = collections.defaultdict(lambda: [0, 0])\n\n  def checkIn(self, id: int, stationName: str, t: int) -> None:\n    self.checkIns[id] = (stationName, t)\n\n  def checkOut(self, id: int, stationName: str, t: int) -> None:\n    startStation, startTime = self.checkIns.pop(id)\n    route = (startStation, stationName)\n    self.checkOuts[route][0] += 1\n    self.checkOuts[route][1] += t - startTime\n\n  def getAverageTime(self, startStation: str, endStation: str) -> float:\n    numTrips, totalTime = self.checkOuts[(startStation, endStation)]\n    return totalTime / numTrips\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1316, "slug": "distinct-echo-substrings", "solutions": ["class Solution:\n    def distinctEchoSubstrings(self, text: str) -> int:\n        def get(l, r):\n            return (h[r] - h[l - 1] * p[r - l + 1]) % mod\n\n        n = len(text)\n        base = 131\n        mod = int(1e9) + 7\n        h = [0] * (n + 10)\n        p = [1] * (n + 10)\n        for i, c in enumerate(text):\n            t = ord(c) - ord('a') + 1\n            h[i + 1] = (h[i] * base) % mod + t\n            p[i + 1] = (p[i] * base) % mod\n        vis = set()\n        for i in range(n - 1):\n            for j in range(i + 1, n, 2):\n                k = (i + j) >> 1\n                a = get(i + 1, k + 1)\n                b = get(k + 2, j + 1)\n                if a == b:\n                    vis.add(a)\n        return len(vis)\n", "class Solution:\n  def distinctEchoSubstrings(self, text: str) -> int:\n    seen = set()\n\n    for k in range(1, len(text) // 2 + 1):  # the target length\n      same = 0\n      l = 0\n      for r in range(k, len(text)):\n        if text[l] == text[r]:\n          same += 1\n        else:\n          same = 0\n        if same == k:\n          seen.add(text[l - k + 1:l + 1])\n          # Move the window thus leaving a letter behind, so we need to\n          # decrease the counter.\n          same -= 1\n        l += 1\n\n    return len(seen)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1361, "slug": "validate-binary-tree-nodes", "solutions": ["class Solution:\n    def validateBinaryTreeNodes(\n        self, n: int, leftChild: List[int], rightChild: List[int]\n    ) -> bool:\n        def find(x: int) -> int:\n            if p[x] != x:\n                p[x] = find(p[x])\n            return p[x]\n\n        p = list(range(n))\n        vis = [False] * n\n        for i, (a, b) in enumerate(zip(leftChild, rightChild)):\n            for j in (a, b):\n                if j != -1:\n                    if vis[j] or find(i) == find(j):\n                        return False\n                    p[find(i)] = find(j)\n                    vis[j] = True\n                    n -= 1\n        return n == 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1370, "slug": "increasing-decreasing-string", "solutions": ["class Solution:\n    def sortString(self, s: str) -> str:\n        cnt = Counter(s)\n        cs = ascii_lowercase + ascii_lowercase[::-1]\n        ans = []\n        while len(ans) < len(s):\n            for c in cs:\n                if cnt[c]:\n                    ans.append(c)\n                    cnt[c] -= 1\n        return \"\".join(ans)\n", "class Solution:\n  def sortString(self, s: str) -> str:\n    ans = []\n    count = collections.Counter(s)\n\n    while count:\n      for chars in string.ascii_lowercase, reversed(string.ascii_lowercase):\n        ans += [c for c in chars if c in count]\n        count -= dict.fromkeys(count, 1)\n\n    return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1359, "slug": "count-all-valid-pickup-and-delivery-options", "solutions": ["class Solution:\n    def countOrders(self, n: int) -> int:\n        mod = 10**9 + 7\n        f = 1\n        for i in range(2, n + 1):\n            f = (f * i * (2 * i - 1)) % mod\n        return f\n", "class Solution:\n  def countOrders(self, n: int) -> int:\n    MOD = 1_000_000_007\n    ans = 1\n\n    for i in range(1, n + 1):\n      ans = ans * i * (i * 2 - 1) % MOD\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1374, "slug": "generate-a-string-with-characters-that-have-odd-counts", "solutions": ["class Solution:\n    def generateTheString(self, n: int) -> str:\n        return 'a' * n if n & 1 else 'a' * (n - 1) + 'b'\n", "class Solution:\n  def generateTheString(self, n: int) -> str:\n    s = 'a' * n\n    if n % 2 == 0:\n      s = s[:-1] + 'b'\n    return s\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1303, "slug": "find-the-team-size", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1336, "slug": "number-of-transactions-per-visit", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1378, "slug": "replace-employee-id-with-the-unique-identifier", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1365, "slug": "how-many-numbers-are-smaller-than-the-current-number", "solutions": ["class Solution:\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\n        arr = sorted(nums)\n        return [bisect_left(arr, x) for x in nums]\n", "class Solution:\n  def smallerNumbersThanCurrent(self, nums: list[int]) -> list[int]:\n    MAX = 100\n    count = collections.Counter(nums)\n\n    for i in range(1, MAX + 1):\n      count[i] += count[i - 1]\n\n    return [0 if num == 0 else count[num - 1]\n            for num in nums]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1318, "slug": "minimum-flips-to-make-a-or-b-equal-to-c", "solutions": ["class Solution:\n    def minFlips(self, a: int, b: int, c: int) -> int:\n        ans = 0\n        for i in range(32):\n            x, y, z = a >> i & 1, b >> i & 1, c >> i & 1\n            ans += x + y if z == 0 else int(x == 0 and y == 0)\n        return ans\n", "class Solution:\n  def minFlips(self, a: int, b: int, c: int) -> int:\n    MAX_BIT = 30\n    ans = 0\n\n    for i in range(MAX_BIT):\n      if c >> i & 1:\n        ans += (a >> i & 1) == 0 and (b >> i & 1) == 0\n      else:  # (c >> i & 1) == 0\n        ans += (a >> i & 1) + (b >> i & 1)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1302, "slug": "deepest-leaves-sum", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def deepestLeavesSum(self, root: Optional[TreeNode]) -> int:\n        q = deque([root])\n        while q:\n            ans = 0\n            for _ in range(len(q)):\n                node = q.popleft()\n                ans += node.val\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1309, "slug": "decrypt-string-from-alphabet-to-integer-mapping", "solutions": ["class Solution:\n    def freqAlphabets(self, s: str) -> str:\n        ans = []\n        i, n = 0, len(s)\n        while i < n:\n            if i + 2 < n and s[i + 2] == \"#\":\n                ans.append(chr(int(s[i : i + 2]) + ord(\"a\") - 1))\n                i += 3\n            else:\n                ans.append(chr(int(s[i]) + ord(\"a\") - 1))\n                i += 1\n        return \"\".join(ans)\n", "class Solution:\n  def freqAlphabets(self, s: str) -> str:\n    ans = ''\n    i = 0\n\n    while i < len(s):\n      if i + 2 < len(s) and s[i + 2] == '#':\n        ans += chr(int(s[i:i + 2]) + ord('a') - 1)\n        i += 3\n      else:\n        ans += chr(int(s[i]) + ord('a') - 1)\n        i += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1307, "slug": "verbal-arithmetic-puzzle", "solutions": ["class Solution:\n    def isAnyMapping(\n        self, words, row, col, bal, letToDig, digToLet, totalRows, totalCols\n    ):\n        # If traversed all columns.\n        if col == totalCols:\n            return bal == 0\n\n        # At the end of a particular column.\n        if row == totalRows:\n            return bal % 10 == 0 and self.isAnyMapping(\n                words, 0, col + 1, bal // 10, letToDig, digToLet, totalRows, totalCols\n            )\n\n        w = words[row]\n\n        # If the current string 'w' has no character in the ('col')th index.\n        if col >= len(w):\n            return self.isAnyMapping(\n                words, row + 1, col, bal, letToDig, digToLet, totalRows, totalCols\n            )\n\n        # Take the current character in the variable letter.\n        letter = w[len(w) - 1 - col]\n\n        # Create a variable 'sign' to check whether we have to add it or subtract it.\n        if row < totalRows - 1:\n            sign = 1\n        else:\n            sign = -1\n\n        # If we have a prior valid mapping, then use that mapping.\n        # The second condition is for the leading zeros.\n        if letter in letToDig and (\n            letToDig[letter] != 0\n            or (letToDig[letter] == 0 and len(w) == 1)\n            or col != len(w) - 1\n        ):\n\n            return self.isAnyMapping(\n                words,\n                row + 1,\n                col,\n                bal + sign * letToDig[letter],\n                letToDig,\n                digToLet,\n                totalRows,\n                totalCols,\n            )\n\n        # Choose a new mapping.\n        else:\n            for i in range(10):\n                # If 'i'th mapping is valid then select it.\n                if digToLet[i] == \"-\" and (\n                    i != 0 or (i == 0 and len(w) == 1) or col != len(w) - 1\n                ):\n                    digToLet[i] = letter\n                    letToDig[letter] = i\n\n                    # Call the function again with the new mapping.\n                    if self.isAnyMapping(\n                        words,\n                        row + 1,\n                        col,\n                        bal + sign * letToDig[letter],\n                        letToDig,\n                        digToLet,\n                        totalRows,\n                        totalCols,\n                    ):\n                        return True\n\n                    # Unselect the mapping.\n                    digToLet[i] = \"-\"\n                    if letter in letToDig:\n                        del letToDig[letter]\n\n        # If nothing is correct then just return false.\n        return False\n\n    def isSolvable(self, words, result):\n        # Add the string 'result' in the list 'words'.\n        words.append(result)\n\n        # Initialize 'totalRows' with the size of the list.\n        totalRows = len(words)\n\n        # Find the longest string in the list and set 'totalCols' with the size of that string.\n        totalCols = max(len(word) for word in words)\n\n        # Create a HashMap for the letter to digit mapping.\n        letToDig = {}\n\n        # Create a list for the digit to letter mapping.\n        digToLet = [\"-\"] * 10\n\n        return self.isAnyMapping(\n            words, 0, 0, 0, letToDig, digToLet, totalRows, totalCols\n        )\n", "class Solution:\n  def isSolvable(self, words: list[str], result: str) -> bool:\n    words.append(result)\n    rows = len(words)\n    cols = max(map(len, words))\n    letterToDigit = {}\n    usedDigit = [False] * 10\n\n    def dfs(row: int, col: int, summ: int) -> bool:\n      if col == cols:\n        return summ == 0\n      if row == rows:\n        return summ % 10 == 0 and dfs(0, col + 1, summ // 10)\n\n      word = words[row]\n      if col >= len(word):\n        return dfs(row + 1, col, summ)\n\n      letter = word[~col]\n      sign = -1 if row == rows - 1 else 1\n\n      if letter in letterToDigit and (\n              letterToDigit[letter] > 0 or col < len(word) - 1):\n        return dfs(row + 1, col, summ + sign * letterToDigit[letter])\n\n      for digit, used in enumerate(usedDigit):\n        if not used and (digit > 0 or col < len(word) - 1):\n          letterToDigit[letter] = digit\n          usedDigit[digit] = True\n          if dfs(row + 1, col, summ + sign * digit):\n            return True\n          usedDigit[digit] = False\n          if letter in letterToDigit:\n            del letterToDigit[letter]\n\n      return False\n\n    return dfs(0, 0, 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1328, "slug": "break-a-palindrome", "solutions": ["class Solution:\n    def breakPalindrome(self, palindrome: str) -> str:\n        n = len(palindrome)\n        if n == 1:\n            return \"\"\n        s = list(palindrome)\n        i = 0\n        while i < n // 2 and s[i] == \"a\":\n            i += 1\n        if i == n // 2:\n            s[-1] = \"b\"\n        else:\n            s[i] = \"a\"\n        return \"\".join(s)\n", "class Solution:\n  def breakPalindrome(self, palindrome: str) -> str:\n    if len(palindrome) == 1:\n      return ''\n\n    ans = list(palindrome)\n\n    for i in range(len(palindrome) // 2):\n      if palindrome[i] != 'a':\n        ans[i] = 'a'\n        return ''.join(ans)\n\n    ans[-1] = 'b'\n    return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1350, "slug": "students-with-invalid-departments", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1339, "slug": "maximum-product-of-splitted-binary-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxProduct(self, root: Optional[TreeNode]) -> int:\n        def sum(root: Optional[TreeNode]) -> int:\n            if root is None:\n                return 0\n            return root.val + sum(root.left) + sum(root.right)\n\n        def dfs(root: Optional[TreeNode]) -> int:\n            if root is None:\n                return 0\n            t = root.val + dfs(root.left) + dfs(root.right)\n            nonlocal ans, s\n            if t < s:\n                ans = max(ans, t * (s - t))\n            return t\n\n        mod = 10**9 + 7\n        s = sum(root)\n        ans = 0\n        dfs(root)\n        return ans % mod\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1305, "slug": "all-elements-in-two-binary-search-trees", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def getAllElements(\n        self, root1: Optional[TreeNode], root2: Optional[TreeNode]\n    ) -> List[int]:\n        def dfs(root: Optional[TreeNode], nums: List[int]) -> int:\n            if root is None:\n                return\n            dfs(root.left, nums)\n            nums.append(root.val)\n            dfs(root.right, nums)\n\n        a, b = [], []\n        dfs(root1, a)\n        dfs(root2, b)\n        m, n = len(a), len(b)\n        i = j = 0\n        ans = []\n        while i < m and j < n:\n            if a[i] <= b[j]:\n                ans.append(a[i])\n                i += 1\n            else:\n                ans.append(b[j])\n                j += 1\n        while i < m:\n            ans.append(a[i])\n            i += 1\n        while j < n:\n            ans.append(b[j])\n            j += 1\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1313, "slug": "decompress-run-length-encoded-list", "solutions": ["class Solution:\n    def decompressRLElist(self, nums: List[int]) -> List[int]:\n        return [nums[i + 1] for i in range(0, len(nums), 2) for _ in range(nums[i])]\n", "class Solution:\n  def decompressRLElist(self, nums: list[int]) -> list[int]:\n    ans = []\n\n    for i in range(0, len(nums), 2):\n      ans += [nums[i + 1]] * nums[i]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1315, "slug": "sum-of-nodes-with-even-valued-grandparent", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\n        def dfs(root: TreeNode, x: int) -> int:\n            if root is None:\n                return 0\n            ans = dfs(root.left, root.val) + dfs(root.right, root.val)\n            if x % 2 == 0:\n                if root.left:\n                    ans += root.left.val\n                if root.right:\n                    ans += root.right.val\n            return ans\n\n        return dfs(root, 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1385, "slug": "find-the-distance-value-between-two-arrays", "solutions": ["class Solution:\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\n        arr2.sort()\n        ans = 0\n        for x in arr1:\n            i = bisect_left(arr2, x - d)\n            ans += i == len(arr2) or arr2[i] > x + d\n        return ans\n", "class Solution:\n  def findTheDistanceValue(\n      self,\n      arr1: list[int],\n      arr2: list[int],\n      d: int,\n  ) -> int:\n    ans = 0\n\n    arr2.sort()\n\n    for a in arr1:\n      i = bisect.bisect_left(arr2, a)\n      if ((i == len(arr2) or arr2[i] - a > d) and\n              (i == 0 or a - arr2[i - 1] > d)):\n        ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1357, "slug": "apply-discount-every-n-orders", "solutions": ["class Cashier:\n    def __init__(self, n: int, discount: int, products: List[int], prices: List[int]):\n        self.i = 0\n        self.n = n\n        self.discount = discount\n        self.d = {product: price for product, price in zip(products, prices)}\n\n    def getBill(self, product: List[int], amount: List[int]) -> float:\n        self.i += 1\n        discount = self.discount if self.i % self.n == 0 else 0\n        ans = 0\n        for p, a in zip(product, amount):\n            x = self.d[p] * a\n            ans += x - (discount * x) / 100\n        return ans\n\n\n# Your Cashier object will be instantiated and called as such:\n# obj = Cashier(n, discount, products, prices)\n# param_1 = obj.getBill(product,amount)\n", "class Cashier:\n  def __init__(\n      self,\n      n: int,\n      discount: int,\n      products: list[int],\n      prices: list[int],\n  ):\n    self.n = n\n    self.discount = discount\n    self.productToPrice = dict(zip(products, prices))\n    self.count = 0\n\n  def getBill(self, product: list[int], amount: list[int]) -> float:\n    self.count += 1\n    total = sum(self.productToPrice[p] * amount[i]\n                for i, p in enumerate(product))\n    if self.count % self.n == 0:\n      return total * (1 - self.discount / 100)\n    return total\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1397, "slug": "find-all-good-strings", "solutions": ["class Solution:\n  def findGoodStrings(self, n: int, s1: str, s2: str, evil: str) -> int:\n    MOD = 1_000_000_007\n    evilLPS = self._getLPS(evil)\n\n    @functools.lru_cache(None)\n    def getNextMatchedEvilCount(j: int, currChar: str) -> int:\n      \"\"\"\n      Returns the number of next matched evil count, where there're j matches\n      with `evil` and the current letter is ('a' + j).\n      \"\"\"\n      while j > 0 and evil[j] != currChar:\n        j = evilLPS[j - 1]\n      return j + 1 if evil[j] == currChar else j\n\n    @functools.lru_cache(None)\n    def dp(i: int, matchedEvilCount: int, isS1Prefix: bool, isS2Prefix: bool) -> int:\n      \"\"\"\n      Returns the number of good strings for s[i..n), where there're j matches\n      with `evil`, `isS1Prefix` indicates if the current letter is tightly bound\n      for `s1` and `isS2Prefix` indicates if the current letter is tightly bound\n      for `s2`.\n      \"\"\"\n      # s[0..i) contains `evil`, so don't consider any ongoing strings.\n      if matchedEvilCount == len(evil):\n        return 0\n      # Run out of strings, so contribute one.\n      if i == n:\n        return 1\n      ans = 0\n      minCharIndex = ord(s1[i]) if isS1Prefix else ord('a')\n      maxCharIndex = ord(s2[i]) if isS2Prefix else ord('z')\n      for charIndex in range(minCharIndex, maxCharIndex + 1):\n        c = chr(charIndex)\n        nextMatchedEvilCount = getNextMatchedEvilCount(matchedEvilCount, c)\n        ans += dp(i + 1, nextMatchedEvilCount,\n                  isS1Prefix and c == s1[i],\n                  isS2Prefix and c == s2[i])\n        ans %= MOD\n      return ans\n\n    return dp(0, 0, True, True)\n\n  def _getLPS(self, pattern: str) -> list[int]:\n    \"\"\"\n    Returns the lps array, where lps[i] is the length of the longest prefix of\n    pattern[0..i] which is also a suffix of this substring.\n    \"\"\"\n    lps = [0] * len(pattern)\n    j = 0\n    for i in range(1, len(pattern)):\n      while j > 0 and pattern[j] != pattern[i]:\n        j = lps[j - 1]\n      if pattern[i] == pattern[j]:\n        lps[i] = j + 1\n        j += 1\n    return lps\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1360, "slug": "number-of-days-between-two-dates", "solutions": ["class Solution:\n    def daysBetweenDates(self, date1: str, date2: str) -> int:\n        def isLeapYear(year: int) -> bool:\n            return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n\n        def daysInMonth(year: int, month: int) -> int:\n            days = [\n                31,\n                28 + int(isLeapYear(year)),\n                31,\n                30,\n                31,\n                30,\n                31,\n                31,\n                30,\n                31,\n                30,\n                31,\n            ]\n            return days[month - 1]\n\n        def calcDays(date: str) -> int:\n            year, month, day = map(int, date.split(\"-\"))\n            days = 0\n            for y in range(1971, year):\n                days += 365 + int(isLeapYear(y))\n            for m in range(1, month):\n                days += daysInMonth(year, m)\n            days += day\n            return days\n\n        return abs(calcDays(date1) - calcDays(date2))\n", "class Solution:\n  def daysBetweenDates(self, date1: str, date2: str) -> int:\n    days = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n    def isLeapYear(year: int) -> bool:\n      return year % 4 == 0 and year % 100 != 0 or year % 400 == 0\n\n    def daysFrom1971(date: str) -> int:\n      year, month, day = map(int, date.split('-'))\n      return (365 * (year - 1971) + sum(map(isLeapYear, range(1971, year))) +\n              sum(days[:month]) + day + (month > 2 and isLeapYear(year)))\n\n    return abs(daysFrom1971(date1) - daysFrom1971(date2))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1379, "slug": "find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\n\nclass Solution:\n    def getTargetCopy(\n        self, original: TreeNode, cloned: TreeNode, target: TreeNode\n    ) -> TreeNode:\n        def dfs(root1: TreeNode, root2: TreeNode) -> TreeNode:\n            if root1 is None:\n                return None\n            if root1 == target:\n                return root2\n            return dfs(root1.left, root2.left) or dfs(root1.right, root2.right)\n\n        return dfs(original, cloned)\n", "class Solution:\n  def getTargetCopy(\n      self,\n      original: TreeNode,\n      cloned: TreeNode,\n      target: TreeNode,\n  ) -> TreeNode:\n    ans = None\n\n    def dfs(original: TreeNode, cloned: TreeNode) -> None:\n      nonlocal ans\n      if ans:\n        return\n      if not original:\n        return\n      if original == target:\n        ans = cloned\n        return\n\n      dfs(original.left, cloned.left)\n      dfs(original.right, cloned.right)\n\n    dfs(original, cloned)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1314, "slug": "matrix-block-sum", "solutions": ["class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\n        m, n = len(mat), len(mat[0])\n        s = [[0] * (n + 1) for _ in range(m + 1)]\n        for i, row in enumerate(mat, 1):\n            for j, x in enumerate(row, 1):\n                s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + x\n        ans = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                x1, y1 = max(i - k, 0), max(j - k, 0)\n                x2, y2 = min(m - 1, i + k), min(n - 1, j + k)\n                ans[i][j] = (\n                    s[x2 + 1][y2 + 1] - s[x1][y2 + 1] - s[x2 + 1][y1] + s[x1][y1]\n                )\n        return ans\n", "class Solution:\n  def matrixBlockSum(self, mat: list[list[int]], k: int) -> list[list[int]]:\n    m = len(mat)\n    n = len(mat[0])\n    ans = [[0] * n for _ in range(m)]\n    prefix = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m):\n      for j in range(n):\n        prefix[i + 1][j + 1] = (mat[i][j] + prefix[i][j + 1] +\n                                prefix[i + 1][j] - prefix[i][j])\n\n    for i in range(m):\n      for j in range(n):\n        r1 = max(0, i - k) + 1\n        c1 = max(0, j - k) + 1\n        r2 = min(m - 1, i + k) + 1\n        c2 = min(n - 1, j + k) + 1\n        ans[i][j] = (prefix[r2][c2] - prefix[r2][c1 - 1] -\n                     prefix[r1 - 1][c2] + prefix[r1 - 1][c1 - 1])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1372, "slug": "longest-zigzag-path-in-a-binary-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        def dfs(root, l, r):\n            if root is None:\n                return\n            nonlocal ans\n            ans = max(ans, l, r)\n            dfs(root.left, r + 1, 0)\n            dfs(root.right, 0, l + 1)\n\n        ans = 0\n        dfs(root, 0, 0)\n        return ans\n", "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass T:\n  leftMax: int\n  rightMax: int\n  subtreeMax: int\n\n\nclass Solution:\n  def longestZigZag(self, root: TreeNode | None) -> int:\n    def dfs(root: TreeNode | None) -> T:\n      if not root:\n        return T(-1, -1, -1)\n      left = dfs(root.left)\n      right = dfs(root.right)\n      leftZigZag = left.rightMax + 1\n      rightZigZag = right.leftMax + 1\n      subtreeMax = max(leftZigZag, rightZigZag,\n                       left.subtreeMax, right.subtreeMax)\n      return T(leftZigZag, rightZigZag, subtreeMax)\n\n    return dfs(root).subtreeMax\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1375, "slug": "number-of-times-binary-string-is-prefix-aligned", "solutions": ["class Solution:\n    def numTimesAllBlue(self, flips: List[int]) -> int:\n        ans = mx = 0\n        for i, x in enumerate(flips, 1):\n            mx = max(mx, x)\n            ans += mx == i\n        return ans\n", "class Solution:\n  def numTimesAllBlue(self, flips: list[int]) -> int:\n    ans = 0\n    rightmost = 0\n\n    for i, flip in enumerate(flips):\n      rightmost = max(rightmost, flip)\n      # max(flips[0..i]) = rightmost = i + 1,\n      # so flips[0..i] is a permutation of 1, 2, ..., i + 1.\n      if rightmost == i + 1:\n        ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1300, "slug": "sum-of-mutated-array-closest-to-target", "solutions": ["class Solution:\n    def findBestValue(self, arr: List[int], target: int) -> int:\n        arr.sort()\n        s = list(accumulate(arr, initial=0))\n        ans, diff = 0, inf\n        for value in range(max(arr) + 1):\n            i = bisect_right(arr, value)\n            d = abs(s[i] + (len(arr) - i) * value - target)\n            if diff > d:\n                diff = d\n                ans = value\n        return ans\n", "class Solution:\n  def findBestValue(self, arr: list[int], target: int) -> int:\n    prefix = 0\n\n    arr.sort()\n\n    for i, a in enumerate(arr):\n      ans = round((target - prefix) / (len(arr) - i))\n      if ans <= a:\n        return ans\n      prefix += a\n\n    return arr[-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1304, "slug": "find-n-unique-integers-sum-up-to-zero", "solutions": ["class Solution:\n    def sumZero(self, n: int) -> List[int]:\n        ans = []\n        for i in range(n >> 1):\n            ans.append(i + 1)\n            ans.append(-(i + 1))\n        if n & 1:\n            ans.append(0)\n        return ans\n", "class Solution:\n  def sumZero(self, n: int) -> list[int]:\n    return list(range(1 - n, n, 2))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1345, "slug": "jump-game-iv", "solutions": ["class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        g = defaultdict(list)\n        for i, x in enumerate(arr):\n            g[x].append(i)\n        q = deque([0])\n        vis = {0}\n        ans = 0\n        while 1:\n            for _ in range(len(q)):\n                i = q.popleft()\n                if i == len(arr) - 1:\n                    return ans\n                for j in (i + 1, i - 1, *g.pop(arr[i], [])):\n                    if 0 <= j < len(arr) and j not in vis:\n                        q.append(j)\n                        vis.add(j)\n            ans += 1\n", "class Solution:\n  def minJumps(self, arr: list[int]) -> int:\n    n = len(arr)\n    # {num: indices}\n    graph = collections.defaultdict(list)\n    step = 0\n    q = collections.deque([0])\n    seen = {0}\n\n    for i, a in enumerate(arr):\n      graph[a].append(i)\n\n    while q:\n      for _ in range(len(q)):\n        i = q.popleft()\n        if i == n - 1:\n          return step\n        seen.add(i)\n        u = arr[i]\n        if i + 1 < n:\n          graph[u].append(i + 1)\n        if i - 1 >= 0:\n          graph[u].append(i - 1)\n        for v in graph[u]:\n          if v in seen:\n            continue\n          q.append(v)\n        graph[u].clear()\n      step += 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1333, "slug": "filter-restaurants-by-vegan-friendly-price-and-distance", "solutions": ["class Solution:\n    def filterRestaurants(\n        self,\n        restaurants: List[List[int]],\n        veganFriendly: int,\n        maxPrice: int,\n        maxDistance: int,\n    ) -> List[int]:\n        restaurants.sort(key=lambda x: (-x[1], -x[0]))\n        ans = []\n        for idx, _, vegan, price, dist in restaurants:\n            if vegan >= veganFriendly and price <= maxPrice and dist <= maxDistance:\n                ans.append(idx)\n        return ans\n", "class Solution:\n  def filterRestaurants(\n      self,\n      restaurants: list[list[int]],\n      veganFriendly: int,\n      maxPrice: int,\n      maxDistance: int,\n  ) -> list[int]:\n    restaurants.sort(key=lambda x: (-x[1], -x[0]))\n    return [i for i, _, v, p, d in restaurants\n            if v >= veganFriendly and p <= maxPrice and d <= maxDistance]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1355, "slug": "activity-participants", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1367, "slug": "linked-list-in-binary-tree", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\n        def dfs(head, root):\n            if head is None:\n                return True\n            if root is None or root.val != head.val:\n                return False\n            return dfs(head.next, root.left) or dfs(head.next, root.right)\n\n        if root is None:\n            return False\n        return (\n            dfs(head, root)\n            or self.isSubPath(head, root.left)\n            or self.isSubPath(head, root.right)\n        )\n", "class Solution:\n  def isSubPath(self, head: ListNode | None, root: TreeNode | None) -> bool:\n    if not root:\n      return False\n    return (self._isContinuousSubPath(head, root) or\n            self.isSubPath(head, root.left) or\n            self.isSubPath(head, root.right))\n\n  def _isContinuousSubPath(\n      self,\n      head: ListNode | None,\n      root: TreeNode | None,\n  ) -> bool:\n    if not head:\n      return True\n    if not root:\n      return False\n    return (head.val == root.val and\n            (self._isContinuousSubPath(head.next, root.left) or\n             self._isContinuousSubPath(head.next, root.right)))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1384, "slug": "total-sales-amount-by-year", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1362, "slug": "closest-divisors", "solutions": ["class Solution:\n    def closestDivisors(self, num: int) -> List[int]:\n        def f(x):\n            for i in range(int(sqrt(x)), 0, -1):\n                if x % i == 0:\n                    return [i, x // i]\n\n        a = f(num + 1)\n        b = f(num + 2)\n        return a if abs(a[0] - a[1]) < abs(b[0] - b[1]) else b\n", "class Solution:\n  def closestDivisors(self, num: int) -> list[int]:\n    for root in reversed(range(math.isqrt(num + 2) + 1)):\n      for cand in [num + 1, num + 2]:\n        if cand % root == 0:\n          return [root, cand // root]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1386, "slug": "cinema-seat-allocation", "solutions": ["class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        d = defaultdict(int)\n        for i, j in reservedSeats:\n            d[i] |= 1 << (10 - j)\n        masks = (0b0111100000, 0b0000011110, 0b0001111000)\n        ans = (n - len(d)) * 2\n        for x in d.values():\n            for mask in masks:\n                if (x & mask) == 0:\n                    x |= mask\n                    ans += 1\n        return ans\n", "class Solution:\n  def maxNumberOfFamilies(self, n: int, reservedSeats: list[list[int]]) -> int:\n    ans = 0\n    rowToSeats = collections.Counter()\n\n    for row, seat in reservedSeats:\n      rowToSeats[row] |= 1 << (seat - 1)\n\n    for seats in rowToSeats.values():\n      if (seats & 0b0111111110) == 0:\n        # Can fit 2 four-person groups.\n        ans += 2\n      elif ((seats & 0b0111100000) == 0 or\n            (seats & 0b0001111000) == 0 or\n            (seats & 0b0000011110) == 0):\n        # Can fit 1 four-person group.\n        ans += 1\n\n    # Any empty row can fit 2 four-person groups.\n    return ans + (n - len(rowToSeats)) * 2\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1377, "slug": "frog-position-after-t-seconds", "solutions": ["class Solution:\n    def frogPosition(\n        self, n: int, edges: List[List[int]], t: int, target: int\n    ) -> float:\n        g = defaultdict(list)\n        for u, v in edges:\n            g[u].append(v)\n            g[v].append(u)\n        q = deque([(1, 1.0)])\n        vis = [False] * (n + 1)\n        vis[1] = True\n        while q and t >= 0:\n            for _ in range(len(q)):\n                u, p = q.popleft()\n                cnt = len(g[u]) - int(u != 1)\n                if u == target:\n                    return p if cnt * t == 0 else 0\n                for v in g[u]:\n                    if not vis[v]:\n                        vis[v] = True\n                        q.append((v, p / cnt))\n            t -= 1\n        return 0\n", "class Solution:\n  def frogPosition(\n      self,\n      n: int,\n      edges: list[list[int]],\n      t: int,\n      target: int,\n  ) -> float:\n    tree = [[] for _ in range(n + 1)]\n    q = collections.deque([1])\n    seen = [False] * (n + 1)\n    prob = [0] * (n + 1)\n\n    prob[1] = 1\n    seen[1] = True\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    for _ in range(t):\n      for _ in range(len(q)):\n        a = q.popleft()\n        nChildren = sum(not seen[b] for b in tree[a])\n        for b in tree[a]:\n          if seen[b]:\n            continue\n          seen[b] = True\n          prob[b] = prob[a] / nChildren\n          q.append(b)\n        if nChildren > 0:\n          prob[a] = 0\n\n    return prob[target]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1364, "slug": "number-of-trusted-contacts-of-a-customer", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1382, "slug": "balance-a-binary-search-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def balanceBST(self, root: TreeNode) -> TreeNode:\n        def dfs(root: TreeNode):\n            if root is None:\n                return\n            dfs(root.left)\n            nums.append(root.val)\n            dfs(root.right)\n\n        def build(i: int, j: int) -> TreeNode:\n            if i > j:\n                return None\n            mid = (i + j) >> 1\n            left = build(i, mid - 1)\n            right = build(mid + 1, j)\n            return TreeNode(nums[mid], left, right)\n\n        nums = []\n        dfs(root)\n        return build(0, len(nums) - 1)\n", "class Solution:\n  def balanceBST(self, root: TreeNode | None) -> TreeNode | None:\n    nums = []\n\n    def inorder(root: TreeNode | None) -> None:\n      if not root:\n        return\n      inorder(root.left)\n      nums.append(root.val)\n      inorder(root.right)\n\n    inorder(root)\n\n    # Same as 108. Convert Sorted Array to Binary Search Tree\n    def build(l: int, r: int) -> TreeNode | None:\n      if l > r:\n        return None\n      m = (l + r) // 2\n      return TreeNode(nums[m],\n                      build(l, m - 1),\n                      build(m + 1, r))\n\n    return build(0, len(nums) - 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1373, "slug": "maximum-sum-bst-in-binary-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxSumBST(self, root: Optional[TreeNode]) -> int:\n        def dfs(root: Optional[TreeNode]) -> tuple:\n            if root is None:\n                return 1, inf, -inf, 0\n            lbst, lmi, lmx, ls = dfs(root.left)\n            rbst, rmi, rmx, rs = dfs(root.right)\n            if lbst and rbst and lmx < root.val < rmi:\n                nonlocal ans\n                s = ls + rs + root.val\n                ans = max(ans, s)\n                return 1, min(lmi, root.val), max(rmx, root.val), s\n            return 0, 0, 0, 0\n\n        ans = 0\n        dfs(root)\n        return ans\n", "from dataclasses import dataclass\n\n\n@dataclass\nclass T:\n  isBST: bool | None = False\n  mx: int | None = None\n  mn: int | None = None\n  summ: int | None = None\n\n\nclass Solution:\n  def maxSumBST(self, root: TreeNode | None) -> int:\n    self.ans = 0\n\n    def traverse(root: TreeNode | None) -> T:\n      if not root:\n        return T(True, -math.inf, math.inf, 0)\n\n      left: T = traverse(root.left)\n      right: T = traverse(root.right)\n\n      if not left.isBST or not right.isBST:\n        return T()\n      if root.val <= left.mx or root.val >= right.mn:\n        return T()\n\n      # The `root` is a valid BST.\n      summ = root.val + left.summ + right.summ\n      self.ans = max(self.ans, summ)\n      return T(True, max(root.val, right.mx), min(root.val, left.mn), summ)\n\n    traverse(root)\n    return self.ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1347, "slug": "minimum-number-of-steps-to-make-two-strings-anagram", "solutions": ["class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        cnt = Counter(s)\n        ans = 0\n        for c in t:\n            cnt[c] -= 1\n            ans += cnt[c] < 0\n        return ans\n", "class Solution:\n  def minSteps(self, s: str, t: str) -> int:\n    count = collections.Counter(s)\n    count.subtract(collections.Counter(t))\n    return sum(abs(value) for value in count.values()) // 2\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1387, "slug": "sort-integers-by-the-power-value", "solutions": ["@cache\ndef f(x: int) -> int:\n    ans = 0\n    while x != 1:\n        if x % 2 == 0:\n            x //= 2\n        else:\n            x = 3 * x + 1\n        ans += 1\n    return ans\n\n\nclass Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        return sorted(range(lo, hi + 1), key=f)[k - 1]\n", "class Solution:\n  def getKth(self, lo: int, hi: int, k: int) -> int:\n    return sorted([(self._getPow(i), i) for i in range(lo, hi + 1)])[k - 1][1]\n\n  def _getPow(self, n: int) -> int:\n    if n == 1:\n      return 0\n    if n % 2 == 0:\n      return 1 + self._getPow(n // 2)\n    return 1 + self._getPow(n * 3 + 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1363, "slug": "largest-multiple-of-three", "solutions": ["class Solution:\n    def largestMultipleOfThree(self, digits: List[int]) -> str:\n        digits.sort()\n        n = len(digits)\n        f = [[-inf] * 3 for _ in range(n + 1)]\n        f[0][0] = 0\n        for i, x in enumerate(digits, 1):\n            for j in range(3):\n                f[i][j] = max(f[i - 1][j], f[i - 1][(j - x % 3 + 3) % 3] + 1)\n        if f[n][0] <= 0:\n            return \"\"\n        arr = []\n        j = 0\n        for i in range(n, 0, -1):\n            k = (j - digits[i - 1] % 3 + 3) % 3\n            if f[i - 1][k] + 1 == f[i][j]:\n                arr.append(digits[i - 1])\n                j = k\n        i = 0\n        while i < len(arr) - 1 and arr[i] == 0:\n            i += 1\n        return \"\".join(map(str, arr[i:]))\n", "class Solution:\n  def largestMultipleOfThree(self, digits: list[int]) -> str:\n    ans = ''\n    mod1 = [1, 4, 7, 2, 5, 8]\n    mod2 = [2, 5, 8, 1, 4, 7]\n    count = collections.Counter(digits)\n    summ = sum(digits)\n\n    while summ % 3 != 0:\n      for digit in (mod1 if summ % 3 == 1 else mod2):\n        if count[digit]:\n          count[digit] -= 1\n          summ -= digit\n          break\n\n    for digit in reversed(range(10)):\n      ans += str(digit) * count[digit]\n\n    return '0' if len(ans) and ans[0] == '0' else ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1383, "slug": "maximum-performance-of-a-team", "solutions": ["class Solution:\n    def maxPerformance(\n        self, n: int, speed: List[int], efficiency: List[int], k: int\n    ) -> int:\n        t = sorted(zip(speed, efficiency), key=lambda x: -x[1])\n        ans = tot = 0\n        mod = 10**9 + 7\n        h = []\n        for s, e in t:\n            tot += s\n            ans = max(ans, tot * e)\n            heappush(h, s)\n            if len(h) == k:\n                tot -= heappop(h)\n        return ans % mod\n", "class Solution:\n  # Similar to 857. Minimum Cost to Hire K Workers\n  def maxPerformance(\n      self,\n      n: int,\n      speed: list[int],\n      efficiency: list[int],\n      k: int,\n  ) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    speedSum = 0\n    # (efficiency[i], speed[i]) sorted by efficiency[i] in descending order\n    A = sorted([(e, s) for s, e in zip(speed, efficiency)], reverse=True)\n    minHeap = []\n\n    for e, s in A:\n      heapq.heappush(minHeap, s)\n      speedSum += s\n      if len(minHeap) > k:\n        speedSum -= heapq.heappop(minHeap)\n      ans = max(ans, speedSum * e)\n\n    return ans % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1311, "slug": "get-watched-videos-by-your-friends", "solutions": ["class Solution:\n    def watchedVideosByFriends(\n        self,\n        watchedVideos: List[List[str]],\n        friends: List[List[int]],\n        id: int,\n        level: int,\n    ) -> List[str]:\n        q = deque([id])\n        vis = {id}\n        for _ in range(level):\n            for _ in range(len(q)):\n                i = q.popleft()\n                for j in friends[i]:\n                    if j not in vis:\n                        vis.add(j)\n                        q.append(j)\n        cnt = Counter()\n        for i in q:\n            for v in watchedVideos[i]:\n                cnt[v] += 1\n        return sorted(cnt.keys(), key=lambda k: (cnt[k], k))\n", "class Solution:\n  def watchedVideosByFriends(\n      self,\n      watchedVideos: list[list[str]],\n      friends: list[list[int]],\n      id: int,\n      level: int,\n  ) -> list[str]:\n    seen = [False] * 100\n    seen[id] = True\n    q = collections.deque([id])\n    count = collections.Counter()\n\n    for _ in range(level):\n      for _ in range(len(q)):\n        curr = q.popleft()\n        for friend in friends[curr]:\n          if not seen[friend]:\n            seen[friend] = True\n            q.append(friend)\n\n    for friend in q:\n      for video in watchedVideos[friend]:\n        count[video] += 1\n\n    return sorted(count, key=lambda video: (count[video], video))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1356, "slug": "sort-integers-by-the-number-of-1-bits", "solutions": ["class Solution:\n    def sortByBits(self, arr: List[int]) -> List[int]:\n        return sorted(arr, key=lambda x: (x.bit_count(), x))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1399, "slug": "count-largest-group", "solutions": ["class Solution:\n    def countLargestGroup(self, n: int) -> int:\n        cnt = Counter()\n        ans = mx = 0\n        for i in range(1, n + 1):\n            s = 0\n            while i:\n                s += i % 10\n                i //= 10\n            cnt[s] += 1\n            if mx < cnt[s]:\n                mx = cnt[s]\n                ans = 1\n            elif mx == cnt[s]:\n                ans += 1\n        return ans\n", "class Solution:\n  def countLargestGroup(self, n: int) -> int:\n    count = [0] * (9 * 4 + 1)\n    for i in range(1, n + 1):\n      count[self._getDigitSum(i)] += 1\n    return count.count(max(count))\n\n  def _getDigitSum(self, num: int) -> int:\n    return sum(int(digit) for digit in str(num))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1327, "slug": "list-the-products-ordered-in-a-period", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1301, "slug": "number-of-paths-with-max-score", "solutions": ["class Solution:\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\n        def update(i, j, x, y):\n            if x >= n or y >= n or f[x][y] == -1 or board[i][j] in \"XS\":\n                return\n            if f[x][y] > f[i][j]:\n                f[i][j] = f[x][y]\n                g[i][j] = g[x][y]\n            elif f[x][y] == f[i][j]:\n                g[i][j] += g[x][y]\n\n        n = len(board)\n        f = [[-1] * n for _ in range(n)]\n        g = [[0] * n for _ in range(n)]\n        f[-1][-1], g[-1][-1] = 0, 1\n        for i in range(n - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                update(i, j, i + 1, j)\n                update(i, j, i, j + 1)\n                update(i, j, i + 1, j + 1)\n                if f[i][j] != -1 and board[i][j].isdigit():\n                    f[i][j] += int(board[i][j])\n        mod = 10**9 + 7\n        return [0, 0] if f[0][0] == -1 else [f[0][0], g[0][0] % mod]\n", "class Solution:\n  def pathsWithMaxScore(self, board: list[str]) -> list[int]:\n    MOD = 1_000_000_007\n    DIRS = ((0, 1), (1, 0), (1, 1))\n    n = len(board)\n    # dp[i][j] := the maximum sum from (n - 1, n - 1) to (i, j)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    # count[i][j] := the number of paths to get dp[i][j] from (n - 1, n - 1) to\n    # (i, j)\n    count = [[0] * (n + 1) for _ in range(n + 1)]\n\n    dp[0][0] = 0\n    dp[n - 1][n - 1] = 0\n    count[n - 1][n - 1] = 1\n\n    for i in reversed(range(n)):\n      for j in reversed(range(n)):\n        if board[i][j] == 'S' or board[i][j] == 'X':\n          continue\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if dp[i][j] < dp[x][y]:\n            dp[i][j] = dp[x][y]\n            count[i][j] = count[x][y]\n          elif dp[i][j] == dp[x][y]:\n            count[i][j] += count[x][y]\n            count[i][j] %= MOD\n\n        # If there's path(s) from 'S' to (i, j) and the cell is not 'E'.\n        if dp[i][j] != -1 and board[i][j] != 'E':\n          dp[i][j] += int(board[i][j])\n          dp[i][j] %= MOD\n\n    return [dp[0][0], count[0][0]]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1322, "slug": "ads-performance", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1352, "slug": "product-of-the-last-k-numbers", "solutions": ["class ProductOfNumbers:\n    def __init__(self):\n        self.s = [1]\n\n    def add(self, num: int) -> None:\n        if num == 0:\n            self.s = [1]\n            return\n        self.s.append(self.s[-1] * num)\n\n    def getProduct(self, k: int) -> int:\n        return 0 if len(self.s) <= k else self.s[-1] // self.s[-k - 1]\n\n\n# Your ProductOfNumbers object will be instantiated and called as such:\n# obj = ProductOfNumbers()\n# obj.add(num)\n# param_2 = obj.getProduct(k)\n", "class ProductOfNumbers:\n  def __init__(self):\n    self.prefix = [1]\n\n  def add(self, num: int) -> None:\n    if num == 0:\n      self.prefix = [1]\n    else:\n      self.prefix.append(self.prefix[-1] * num)\n\n  def getProduct(self, k: int) -> int:\n    return 0 if k >= len(self.prefix) else self.prefix[-1] // self.prefix[len(self.prefix) - k - 1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1317, "slug": "convert-integer-to-the-sum-of-two-no-zero-integers", "solutions": ["class Solution:\n    def getNoZeroIntegers(self, n: int) -> List[int]:\n        for a in range(1, n):\n            b = n - a\n            if \"0\" not in str(a) + str(b):\n                return [a, b]\n", "class Solution:\n  def getNoZeroIntegers(self, n: int) -> list[int]:\n    for A in range(n):\n      B = n - A\n      if '0' not in str(A) and '0' not in str(B):\n        return A, B\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1335, "slug": "minimum-difficulty-of-a-job-schedule", "solutions": ["class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        n = len(jobDifficulty)\n        f = [[inf] * (d + 1) for _ in range(n + 1)]\n        f[0][0] = 0\n        for i in range(1, n + 1):\n            for j in range(1, min(d + 1, i + 1)):\n                mx = 0\n                for k in range(i, 0, -1):\n                    mx = max(mx, jobDifficulty[k - 1])\n                    f[i][j] = min(f[i][j], f[k - 1][j - 1] + mx)\n        return -1 if f[n][d] >= inf else f[n][d]\n", "class Solution:\n  def minDifficulty(self, jobDifficulty: list[int], d: int) -> int:\n    n = len(jobDifficulty)\n    if d > n:\n      return -1\n\n    # dp[i][k] := the minimum difficulty to schedule the first i jobs in k days\n    dp = [[math.inf] * (d + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i in range(1, n + 1):\n      for k in range(1, d + 1):\n        maxDifficulty = 0  # max(job[j + 1..i])\n        for j in range(i - 1, k - 2, -1):  # 1-based\n          maxDifficulty = max(maxDifficulty, jobDifficulty[j])  # 0-based\n          dp[i][k] = min(dp[i][k], dp[j][k - 1] + maxDifficulty)\n\n    return dp[n][d]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1391, "slug": "check-if-there-is-a-valid-path-in-a-grid", "solutions": ["class Solution:\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        p = list(range(m * n))\n\n        def find(x):\n            if p[x] != x:\n                p[x] = find(p[x])\n            return p[x]\n\n        def left(i, j):\n            if j > 0 and grid[i][j - 1] in (1, 4, 6):\n                p[find(i * n + j)] = find(i * n + j - 1)\n\n        def right(i, j):\n            if j < n - 1 and grid[i][j + 1] in (1, 3, 5):\n                p[find(i * n + j)] = find(i * n + j + 1)\n\n        def up(i, j):\n            if i > 0 and grid[i - 1][j] in (2, 3, 4):\n                p[find(i * n + j)] = find((i - 1) * n + j)\n\n        def down(i, j):\n            if i < m - 1 and grid[i + 1][j] in (2, 5, 6):\n                p[find(i * n + j)] = find((i + 1) * n + j)\n\n        for i in range(m):\n            for j in range(n):\n                e = grid[i][j]\n                if e == 1:\n                    left(i, j)\n                    right(i, j)\n                elif e == 2:\n                    up(i, j)\n                    down(i, j)\n                elif e == 3:\n                    left(i, j)\n                    down(i, j)\n                elif e == 4:\n                    right(i, j)\n                    down(i, j)\n                elif e == 5:\n                    left(i, j)\n                    up(i, j)\n                else:\n                    right(i, j)\n                    up(i, j)\n        return find(0) == find(m * n - 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2998, "slug": "minimum-number-of-operations-to-make-x-and-y-equal", "solutions": ["class Solution:\n    def minimumOperationsToMakeEqual(self, x: int, y: int) -> int:\n        @cache\n        def dfs(x: int) -> int:\n            if y >= x:\n                return y - x\n            ans = x - y\n            ans = min(ans, x % 5 + 1 + dfs(x // 5))\n            ans = min(ans, 5 - x % 5 + 1 + dfs(x // 5 + 1))\n            ans = min(ans, x % 11 + 1 + dfs(x // 11))\n            ans = min(ans, 11 - x % 11 + 1 + dfs(x // 11 + 1))\n            return ans\n\n        return dfs(x)\n", "class Solution:\n  def minimumOperationsToMakeEqual(self, x, y):\n    if x <= y:\n      return y - x\n\n    queue = collections.deque([x])\n    seen = set()\n\n    ans = 0\n    while queue:\n      for _ in range(len(queue)):\n        num = queue.popleft()\n        if num == y:\n          return ans\n        if num in seen:\n          continue\n        seen.add(num)\n        if num % 11 == 0:\n          queue.append(num // 11)\n        if num % 5 == 0:\n          queue.append(num // 5)\n        queue.append(num - 1)\n        queue.append(num + 1)\n      ans += 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2941, "slug": "maximum-gcd-sum-of-a-subarray", "solutions": ["class Solution:\n    def maxGcdSum(self, nums: List[int], k: int) -> int:\n        s = list(accumulate(nums, initial=0))\n        f = []\n        ans = 0\n        for i, v in enumerate(nums):\n            g = []\n            for j, x in f:\n                y = gcd(x, v)\n                if not g or g[-1][1] != y:\n                    g.append((j, y))\n            f = g\n            f.append((i, v))\n            for j, x in f:\n                if i - j + 1 >= k:\n                    ans = max(ans, (s[i + 1] - s[j]) * x)\n        return ans\n", "class Solution:\n  def maxGcdSum(self, nums: list[int], k: int) -> int:\n    ans = 0\n    # [(startIndex, gcd of subarray starting at startIndex)]\n    startIndexAndGcds = []\n    prefix = list(itertools.accumulate(nums, initial=0))\n\n    for i, num in enumerate(nums):\n      nextStartIndexAndGcds = []\n      for startIndex, gcd in startIndexAndGcds:\n        nextGcd = math.gcd(gcd, nums[i])\n        if (not nextStartIndexAndGcds or\n                nextStartIndexAndGcds[-1][1] != nextGcd):  # Skip duplicates.\n          nextStartIndexAndGcds.append((startIndex, nextGcd))\n      startIndexAndGcds = nextStartIndexAndGcds\n      startIndexAndGcds.append((i, nums[i]))\n      for startIndex, gcd in startIndexAndGcds:\n        if i - startIndex + 1 >= k:\n          ans = max(ans, (prefix[i + 1] - prefix[startIndex]) * gcd)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2928, "slug": "distribute-candies-among-children-i", "solutions": ["class Solution:\n    def distributeCandies(self, n: int, limit: int) -> int:\n        if n > 3 * limit:\n            return 0\n        ans = comb(n + 2, 2)\n        if n > limit:\n            ans -= 3 * comb(n - limit + 1, 2)\n        if n - 2 >= 2 * limit:\n            ans += 3 * comb(n - 2 * limit, 2)\n        return ans\n", "class Solution:\n  def distributeCandies(self, n: int, limit: int) -> int:\n    def ways(n: int) -> int:\n      \"\"\"Returns the number of ways to distribute n candies to 3 children.\"\"\"\n      if n < 0:\n        return 0\n      # Stars and bars method:\n      # e.g. '**|**|*' means to distribute 5 candies to 3 children, where\n      # stars (*) := candies and bars (|) := dividers between children.\n      return math.comb(n + 2, 2)\n\n    limitPlusOne = limit + 1\n    oneChildExceedsLimit = ways(n - limitPlusOne)\n    twoChildrenExceedLimit = ways(n - 2 * limitPlusOne)\n    threeChildrenExceedLimit = ways(n - 3 * limitPlusOne)\n    # Principle of Inclusion-Exclusion (PIE)\n    return (ways(n)\n            - 3 * oneChildExceedsLimit\n            + 3 * twoChildrenExceedLimit\n            - threeChildrenExceedLimit)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2906, "slug": "construct-product-matrix", "solutions": ["class Solution:\n    def constructProductMatrix(self, grid: List[List[int]]) -> List[List[int]]:\n        n, m = len(grid), len(grid[0])\n        p = [[0] * m for _ in range(n)]\n        mod = 12345\n        suf = 1\n        for i in range(n - 1, -1, -1):\n            for j in range(m - 1, -1, -1):\n                p[i][j] = suf\n                suf = suf * grid[i][j] % mod\n        pre = 1\n        for i in range(n):\n            for j in range(m):\n                p[i][j] = p[i][j] * pre % mod\n                pre = pre * grid[i][j] % mod\n        return p\n", "class Solution:\n  def constructProductMatrix(self, grid: list[list[int]]) -> list[list[int]]:\n    MOD = 12345\n    m = len(grid)\n    n = len(grid[0])\n    ans = [[0] * n for _ in range(m)]\n    prefix = [1]\n    suffix = 1\n\n    for row in grid:\n      for num in row:\n        prefix.append(prefix[-1] * num % MOD)\n\n    for i in reversed(range(m)):\n      for j in reversed(range(n)):\n        ans[i][j] = prefix[i * n + j] * suffix % MOD\n        suffix = suffix * grid[i][j] % MOD\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2959, "slug": "number-of-possible-sets-of-closing-branches", "solutions": ["class Solution:\n    def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:\n        ans = 0\n        for mask in range(1 << n):\n            g = [[inf] * n for _ in range(n)]\n            for u, v, w in roads:\n                if mask >> u & 1 and mask >> v & 1:\n                    g[u][v] = min(g[u][v], w)\n                    g[v][u] = min(g[v][u], w)\n            for k in range(n):\n                if mask >> k & 1:\n                    g[k][k] = 0\n                    for i in range(n):\n                        for j in range(n):\n                            # g[i][j] = min(g[i][j], g[i][k] + g[k][j])\n                            if g[i][k] + g[k][j] < g[i][j]:\n                                g[i][j] = g[i][k] + g[k][j]\n            if all(\n                g[i][j] <= maxDistance\n                for i in range(n)\n                for j in range(n)\n                if mask >> i & 1 and mask >> j & 1\n            ):\n                ans += 1\n        return ans\n", "class Solution:\n  def numberOfSets(\n      self,\n      n: int,\n      maxDistance: int,\n      roads: list[list[int]],\n  ) -> int:\n    return sum(self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance\n               for mask in range(1 << n))\n\n  def _floydWarshall(\n      self,\n      n: int,\n      maxDistanceThreshold: int,\n      roads: list[list[int]],\n      mask: int,\n  ) -> list[list[int]]:\n    \"\"\"\n    Returns the maximum distance between any two branches, where the mask\n    represents the selected branches.\n    \"\"\"\n    maxDistance = 0\n    dist = [[maxDistanceThreshold + 1] * n for _ in range(n)]\n\n    for i in range(n):\n      if mask >> i & 1:\n        dist[i][i] = 0\n\n    for u, v, w in roads:\n      if mask >> u & 1 and mask >> v & 1:\n        dist[u][v] = min(dist[u][v], w)\n        dist[v][u] = min(dist[v][u], w)\n\n    for k in range(n):\n      if mask >> k & 1:\n        for i in range(n):\n          if mask >> i & 1:\n            for j in range(n):\n              if mask >> j & 1:\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    for i in range(n):\n      if mask >> i & 1:\n        for j in range(i + 1, n):\n          if mask >> j & 1:\n            maxDistance = max(maxDistance, dist[i][j])\n\n    return maxDistance\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2999, "slug": "count-the-number-of-powerful-integers", "solutions": ["class Solution:\n    def numberOfPowerfulInt(self, start: int, finish: int, limit: int, s: str) -> int:\n        @cache\n        def dfs(pos: int, lim: int):\n            if len(t) < n:\n                return 0\n            if len(t) - pos == n:\n                return int(s <= t[pos:]) if lim else 1\n            up = min(int(t[pos]) if lim else 9, limit)\n            ans = 0\n            for i in range(up + 1):\n                ans += dfs(pos + 1, lim and i == int(t[pos]))\n            return ans\n\n        n = len(s)\n        t = str(start - 1)\n        a = dfs(0, True)\n        dfs.cache_clear()\n        t = str(finish)\n        b = dfs(0, True)\n        return b - a\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2973, "slug": "find-number-of-coins-to-place-in-tree-nodes", "solutions": ["class Solution:\n    def placedCoins(self, edges: List[List[int]], cost: List[int]) -> List[int]:\n        def dfs(a: int, fa: int) -> List[int]:\n            res = [cost[a]]\n            for b in g[a]:\n                if b != fa:\n                    res.extend(dfs(b, a))\n            res.sort()\n            if len(res) >= 3:\n                ans[a] = max(res[-3] * res[-2] * res[-1], res[0] * res[1] * res[-1], 0)\n            if len(res) > 5:\n                res = res[:2] + res[-3:]\n            return res\n\n        n = len(cost)\n        g = [[] for _ in range(n)]\n        for a, b in edges:\n            g[a].append(b)\n            g[b].append(a)\n        ans = [1] * n\n        dfs(0, -1)\n        return ans\n", "class ChildCost:\n  def __init__(self, cost: int):\n    self.numNodes = 1\n    self.maxPosCosts = [cost] if cost > 0 else []\n    self.minNegCosts = [cost] if cost < 0 else []\n\n  def update(self, childCost: 'ChildCost') -> None:\n    self.numNodes += childCost.numNodes\n    self.maxPosCosts.extend(childCost.maxPosCosts)\n    self.minNegCosts.extend(childCost.minNegCosts)\n    self.maxPosCosts.sort(reverse=True)\n    self.minNegCosts.sort()\n    self.maxPosCosts = self.maxPosCosts[:3]\n    self.minNegCosts = self.minNegCosts[:2]\n\n  def maxProduct(self) -> int:\n    if self.numNodes < 3:\n      return 1\n    if not self.maxPosCosts:\n      return 0\n    res = 0\n    if len(self.maxPosCosts) == 3:\n      res = self.maxPosCosts[0] * self.maxPosCosts[1] * self.maxPosCosts[2]\n    if len(self.minNegCosts) == 2:\n      res = max(res,\n                self.minNegCosts[0] * self.minNegCosts[1] * self.maxPosCosts[0])\n    return res\n\n\nclass Solution:\n  def placedCoins(self, edges: list[list[int]], cost: list[int]) -> list[int]:\n    n = len(cost)\n    ans = [0] * n\n    tree = [[] for _ in range(n)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, prev: int) -> None:\n      res = ChildCost(cost[u])\n      for v in tree[u]:\n        if v != prev:\n          res.update(dfs(v, u))\n      ans[u] = res.maxProduct()\n      return res\n\n    dfs(0, -1)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2953, "slug": "count-complete-substrings", "solutions": ["class Solution:\n    def countCompleteSubstrings(self, word: str, k: int) -> int:\n        def f(s: str) -> int:\n            m = len(s)\n            ans = 0\n            for i in range(1, 27):\n                l = i * k\n                if l > m:\n                    break\n                cnt = Counter(s[:l])\n                freq = Counter(cnt.values())\n                ans += freq[k] == i\n                for j in range(l, m):\n                    freq[cnt[s[j]]] -= 1\n                    cnt[s[j]] += 1\n                    freq[cnt[s[j]]] += 1\n\n                    freq[cnt[s[j - l]]] -= 1\n                    cnt[s[j - l]] -= 1\n                    freq[cnt[s[j - l]]] += 1\n\n                    ans += freq[k] == i\n            return ans\n\n        n = len(word)\n        ans = i = 0\n        while i < n:\n            j = i + 1\n            while j < n and abs(ord(word[j]) - ord(word[j - 1])) <= 2:\n                j += 1\n            ans += f(word[i:j])\n            i = j\n        return ans\n", "class Solution:\n  def countCompleteSubstrings(self, word: str, k: int) -> int:\n    uniqueLetters = len(set(word))\n    return sum(self._countCompleteStrings(word, k, windowSize)\n               for windowSize in range(k, k * uniqueLetters + 1, k))\n\n  def _countCompleteStrings(self, word: str, k: int, windowSize: int) -> int:\n    \"\"\"\n    Returns the number of complete substrings of `windowSize` of `word`.\n    \"\"\"\n    res = 0\n    countLetters = 0  # the number of letters in the running substring\n    count = collections.Counter()\n\n    for i, c in enumerate(word):\n      count[c] += 1\n      countLetters += 1\n      if i > 0 and abs(ord(c) - ord(word[i - 1])) > 2:\n        count = collections.Counter()\n        # Start a new substring starting at word[i].\n        count[c] += 1\n        countLetters = 1\n      if countLetters == windowSize + 1:\n        count[word[i - windowSize]] -= 1\n        countLetters -= 1\n      if countLetters == windowSize:\n        res += all(freq == 0 or freq == k for freq in count.values())\n\n    return res\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2902, "slug": "count-of-sub-multisets-with-bounded-sum", "solutions": ["class Solution:\n    def countSubMultisets(self, nums: List[int], l: int, r: int) -> int:\n        kMod = 1_000_000_007\n        # dp[i] := # of submultisets of nums with sum i\n        dp = [1] + [0] * r\n        count = collections.Counter(nums)\n        zeros = count.pop(0, 0)\n\n        for num, freq in count.items():\n            # stride[i] := dp[i] + dp[i - num] + dp[i - 2 * num] + ...\n            stride = dp.copy()\n            for i in range(num, r + 1):\n                stride[i] += stride[i - num]\n            for i in range(r, 0, -1):\n                if i >= num * (freq + 1):\n                    # dp[i] + dp[i - num] + dp[i - freq * num]\n                    dp[i] = stride[i] - stride[i - num * (freq + 1)]\n                else:\n                    dp[i] = stride[i]\n\n        return (zeros + 1) * sum(dp[l : r + 1]) % kMod\n", "class Solution:\n  def countSubMultisets(self, nums: list[int], l: int, r: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i] := the number of submultisets of `nums` with sum i\n    dp = [1] + [0] * r\n    count = collections.Counter(nums)\n    zeros = count.pop(0, 0)\n\n    for num, freq in count.items():\n      # stride[i] := dp[i] + dp[i - num] + dp[i - 2 * num] + ...\n      stride = dp.copy()\n      for i in range(num, r + 1):\n        stride[i] += stride[i - num]\n      for i in range(r, 0, -1):\n        if i >= num * (freq + 1):\n          # dp[i] + dp[i - num] + dp[i - freq * num]\n          dp[i] = stride[i] - stride[i - num * (freq + 1)]\n        else:\n          dp[i] = stride[i]\n\n    return (zeros + 1) * sum(dp[l:r + 1]) % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2900, "slug": "longest-unequal-adjacent-groups-subsequence-i", "solutions": ["class Solution:\n    def getWordsInLongestSubsequence(\n        self, n: int, words: List[str], groups: List[int]\n    ) -> List[str]:\n        return [words[i] for i, x in enumerate(groups) if i == 0 or x != groups[i - 1]]\n", "class Solution:\n  def getWordsInLongestSubsequence(\n      self,\n      n: int,\n      words: list[str],\n      groups: list[int],\n  ) -> list[str]:\n    ans = []\n    groupId = -1\n\n    for word, group in zip(words, groups):\n      if group != groupId:\n        groupId = group\n        ans.append(word)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2986, "slug": "find-third-transaction", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2943, "slug": "maximize-area-of-square-hole-in-grid", "solutions": ["class Solution:\n    def maximizeSquareHoleArea(\n        self, n: int, m: int, hBars: List[int], vBars: List[int]\n    ) -> int:\n        def f(nums: List[int]) -> int:\n            nums.sort()\n            ans = cnt = 1\n            for i in range(1, len(nums)):\n                if nums[i] == nums[i - 1] + 1:\n                    cnt += 1\n                    ans = max(ans, cnt)\n                else:\n                    cnt = 1\n            return ans + 1\n\n        return min(f(hBars), f(vBars)) ** 2\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2909, "slug": "minimum-sum-of-mountain-triplets-ii", "solutions": ["class Solution:\n    def minimumSum(self, nums: List[int]) -> int:\n        n = len(nums)\n        right = [inf] * (n + 1)\n        for i in range(n - 1, -1, -1):\n            right[i] = min(right[i + 1], nums[i])\n        ans = left = inf\n        for i, x in enumerate(nums):\n            if left < x and right[i + 1] < x:\n                ans = min(ans, left + x + right[i + 1])\n            left = min(left, x)\n        return -1 if ans == inf else ans\n", "class Solution:\n  # Same as 2908. Minimum Sum of Mountain Triplets I\n  def minimumSum(self, nums: list[int]) -> int:\n    ans = math.inf\n    minPrefix = list(itertools.accumulate(nums, min))\n    minSuffix = list(itertools.accumulate(reversed(nums), min))[::-1]\n\n    for i, num in enumerate(nums):\n      if num > minPrefix[i] and num > minSuffix[i]:\n        ans = min(ans, num + minPrefix[i] + minSuffix[i])\n\n    return -1 if ans == math.inf else ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2904, "slug": "shortest-and-lexicographically-smallest-beautiful-string", "solutions": ["class Solution:\n    def shortestBeautifulSubstring(self, s: str, k: int) -> str:\n        n = len(s)\n        ans = \"\"\n        for i in range(n):\n            for j in range(i + k, n + 1):\n                t = s[i:j]\n                if t.count(\"1\") == k and (\n                    not ans or j - i < len(ans) or (j - i == len(ans) and t < ans)\n                ):\n                    ans = t\n        return ans\n", "class Solution:\n  # Same as 76. Minimum Window Substring\n  def shortestBeautifulSubstring(self, s: str, k: int) -> str:\n    bestLeft = -1\n    minLength = len(s) + 1\n    ones = 0\n\n    l = 0\n    for r, c in enumerate(s):\n      if c == '1':\n        ones += 1\n      while ones == k:\n        if r - l + 1 < minLength:\n          bestLeft = l\n          minLength = r - l + 1\n        elif r - l + 1 == minLength and s[l:l + minLength] < s[bestLeft:bestLeft + minLength]:\n          bestLeft = l\n        if s[l] == '1':\n          ones -= 1\n        l += 1\n\n    return \"\" if bestLeft == -1 else s[bestLeft:bestLeft + minLength]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2996, "slug": "smallest-missing-integer-greater-than-sequential-prefix-sum", "solutions": ["class Solution:\n    def missingInteger(self, nums: List[int]) -> int:\n        s, j = nums[0], 1\n        while j < len(nums) and nums[j] == nums[j - 1] + 1:\n            s += nums[j]\n            j += 1\n        vis = set(nums)\n        for x in count(s):\n            if x not in vis:\n                return x\n", "class Solution:\n  def missingInteger(self, nums: list[int]) -> int:\n    numsSet = set(nums)\n    ans = nums[0]\n\n    for i in range(1, len(nums)):\n      if nums[i] != nums[i - 1] + 1:\n        break\n      ans += nums[i]\n\n    while ans in numsSet:\n      ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2964, "slug": "number-of-divisible-triplet-sums", "solutions": ["class Solution:\n    def divisibleTripletCount(self, nums: List[int], d: int) -> int:\n        cnt = defaultdict(int)\n        ans, n = 0, len(nums)\n        for j in range(n):\n            for k in range(j + 1, n):\n                x = (d - (nums[j] + nums[k]) % d) % d\n                ans += cnt[x]\n            cnt[nums[j] % d] += 1\n        return ans\n", "class Solution:\n  # Similar to 1995. Count Special Quadruplets\n  def divisibleTripletCount(self, nums: list[int], d: int) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    for j in range(len(nums) - 1, 0, -1):  # `j` also represents k.\n      for i in range(j - 1, -1, -1):\n        ans += count[-(nums[i] + nums[j]) % d]\n      count[nums[j] % d] += 1  # j := k\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2971, "slug": "find-polygon-with-the-largest-perimeter", "solutions": ["class Solution:\n    def largestPerimeter(self, nums: List[int]) -> int:\n        nums.sort()\n        s = list(accumulate(nums, initial=0))\n        ans = -1\n        for k in range(3, len(nums) + 1):\n            if s[k - 1] > nums[k - 1]:\n                ans = max(ans, s[k])\n        return ans\n", "class Solution:\n  def largestPerimeter(self, nums: list[int]) -> int:\n    prefix = sum(nums)\n\n    for num in sorted(nums, reverse=True):\n      prefix -= num\n      # Let `num` be the longest side. Check if the sum of all the edges with\n      # length no longer than `num` > `num``.\n      if prefix > num:\n        return prefix + num\n\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2932, "slug": "maximum-strong-pair-xor-i", "solutions": ["class Solution:\n    def maximumStrongPairXor(self, nums: List[int]) -> int:\n        return max(x ^ y for x in nums for y in nums if abs(x - y) <= min(x, y))\n", "class TrieNode:\n  def __init__(self):\n    self.children: list[TrieNode | None] = [None] * 2\n    self.mn = math.inf\n    self.mx = -math.inf\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n      node.mn = min(node.mn, num)\n      node.mx = max(node.mx, num)\n\n  def getMaxXor(self, x: int) -> int:\n    \"\"\"Returns max(x ^ y) where |x - y| <= min(x, y).\n\n    If x <= y, |x - y| <= min(x, y) can be written as y - x <= x.\n    So, y <= 2 * x.\n    \"\"\"\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = x >> i & 1\n      toggleBit = bit ^ 1\n      # If `node.children[toggleBit].mx > x`, it means there's a number in the\n      # node that satisfies the condition to ensure that x <= y among x and y.\n      # If `node.children[toggleBit].mn <= 2 * x`, it means there's a number in\n      # the node that satisfies the condition for a valid y.\n      if (node.children[toggleBit] and\n          node.children[toggleBit].mx > x and\n              node.children[toggleBit].mn <= 2 * x):\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:  # There's nothing in the Bit Trie.\n        return 0\n    return maxXor\n\n\nclass Solution:\n  # Similar to 421. Maximum XOR of Two Numbers in an Array\n  def maximumStrongPairXor(self, nums: list[int]) -> int:\n    maxNum = max(nums)\n    maxBit = int(math.log2(maxNum))\n    bitTrie = BitTrie(maxBit)\n\n    for num in nums:\n      bitTrie.insert(num)\n\n    return max(bitTrie.getMaxXor(num) for num in nums)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2972, "slug": "count-the-number-of-incremovable-subarrays-ii", "solutions": ["class Solution:\n    def incremovableSubarrayCount(self, nums: List[int]) -> int:\n        i, n = 0, len(nums)\n        while i + 1 < n and nums[i] < nums[i + 1]:\n            i += 1\n        if i == n - 1:\n            return n * (n + 1) // 2\n        ans = i + 2\n        j = n - 1\n        while j:\n            while i >= 0 and nums[i] >= nums[j]:\n                i -= 1\n            ans += i + 2\n            if nums[j - 1] >= nums[j]:\n                break\n            j -= 1\n        return ans\n", "class Solution:\n  # Same as 2970. Count the Number of Incremovable Subarrays I\n  def incremovableSubarrayCount(self, nums: list[int]) -> int:\n    n = len(nums)\n    startIndex = self._getStartIndexOfSuffix(nums)\n    # If the complete array is strictly increasing, the total number of ways we\n    # can remove elements equals the total number of possible subarrays.\n    if startIndex == 0:\n      return n * (n + 1) // 2\n\n    # The valid removals starting from nums[0] include nums[0..startIndex - 1],\n    # nums[0..startIndex], ..., nums[0..n).\n    ans = n - startIndex + 1\n\n    # Enumerate each prefix subarray that is strictly increasing.\n    j = startIndex\n    for i in range(startIndex):\n      if i > 0 and nums[i] <= nums[i - 1]:\n        break\n      # Since nums[0..i] is strictly increasing, move j to the place such that\n      # nums[j] > nums[i]. The valid removals will then be nums[i + 1..j - 1],\n      # nums[i + 1..j], ..., nums[i + 1..n).\n      while j < n and nums[i] >= nums[j]:\n        j += 1\n      ans += n - j + 1\n\n    return ans\n\n  def _getStartIndexOfSuffix(self, nums: list[int]) -> int:\n    for i in range(len(nums) - 2, -1, -1):\n      if nums[i] >= nums[i + 1]:\n        return i + 1\n    return 0\n", "class Solution:\n  # Same as 2970. Count the Number of Incremovable Subarrays I\n  def incremovableSubarrayCount(self, nums: list[int]) -> int:\n    n = len(nums)\n    startIndex = self._getStartIndexOfSuffix(nums)\n    # If the complete array is strictly increasing, the total number of ways we\n    # can remove elements equals the total number of possible subarrays.\n    if startIndex == 0:\n      return n * (n + 1) // 2\n\n    # The valid removals starting from nums[0] include nums[0..startIndex - 1],\n    # nums[0..startIndex], ..., nums[0..n).\n    ans = n - startIndex + 1\n\n    # Enumerate each prefix subarray that is strictly increasing.\n    for i in range(startIndex):\n      if i > 0 and nums[i] <= nums[i - 1]:\n        break\n      # Since nums[0..i] is strictly increasing, find the first index j in\n      # nums[startIndex..n) such that nums[j] > nums[i]. The valid removals\n      # will then be nums[i + 1..j - 1], nums[i + 1..j], ..., nums[i + 1..n).\n      ans += n - bisect.bisect_right(nums, nums[i], startIndex) + 1\n\n    return ans\n\n  def _getStartIndexOfSuffix(self, nums: list[int]) -> int:\n    for i in range(len(nums) - 2, -1, -1):\n      if nums[i] >= nums[i + 1]:\n        return i + 1\n    return 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2975, "slug": "maximum-square-area-by-removing-fences-from-a-field", "solutions": ["class Solution:\n    def maximizeSquareArea(\n        self, m: int, n: int, hFences: List[int], vFences: List[int]\n    ) -> int:\n        def f(nums: List[int], k: int) -> Set[int]:\n            nums.extend([1, k])\n            nums.sort()\n            return {b - a for a, b in combinations(nums, 2)}\n\n        mod = 10**9 + 7\n        hs = f(hFences, m)\n        vs = f(vFences, n)\n        ans = max(hs & vs, default=0)\n        return ans**2 % mod if ans else -1\n", "class Solution:\n  def maximizeSquareArea(\n      self,\n      m: int,\n      n: int,\n      hFences: list[int],\n      vFences: list[int],\n  ) -> int:\n    hFences = sorted(hFences + [1, m])\n    vFences = sorted(vFences + [1, n])\n    hGaps = {hFences[i] - hFences[j]\n             for i in range(len(hFences))\n             for j in range(i)}\n    vGaps = {vFences[i] - vFences[j]\n             for i in range(len(vFences))\n             for j in range(i)}\n    maxGap = next((hGap\n                  for hGap in sorted(hGaps, reverse=True)\n                  if hGap in vGaps), -1)\n    return -1 if maxGap == -1 else maxGap**2 % (10**9 + 7)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2957, "slug": "remove-adjacent-almost-equal-characters", "solutions": ["class Solution:\n    def removeAlmostEqualCharacters(self, word: str) -> int:\n        ans = 0\n        i, n = 1, len(word)\n        while i < n:\n            if abs(ord(word[i]) - ord(word[i - 1])) < 2:\n                ans += 1\n                i += 2\n            else:\n                i += 1\n        return ans\n", "class Solution:\n  def removeAlmostEqualCharacters(self, word: str) -> int:\n    ans = 0\n    i = 1\n    while i < len(word):\n      if abs(ord(word[i]) - ord(word[i - 1])) <= 1:\n        ans += 1\n        i += 2\n      else:\n        i += 1\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2917, "slug": "find-the-k-or-of-an-array", "solutions": ["class Solution:\n    def findKOr(self, nums: List[int], k: int) -> int:\n        ans = 0\n        for i in range(32):\n            cnt = sum(x >> i & 1 for x in nums)\n            if cnt >= k:\n                ans |= 1 << i\n        return ans\n", "class Solution:\n  def findKOr(self, nums: list[int], k: int) -> int:\n    MAX_BIT = 30\n    return sum(2**i\n               for i in range(MAX_BIT + 1)\n               if sum(num >> i & 1 for num in nums) >= k)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2920, "slug": "maximum-points-after-collecting-coins-from-all-nodes", "solutions": ["class Solution:\n    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:\n        @cache\n        def dfs(i: int, fa: int, j: int) -> int:\n            a = (coins[i] >> j) - k\n            b = coins[i] >> (j + 1)\n            for c in g[i]:\n                if c != fa:\n                    a += dfs(c, i, j)\n                    if j < 14:\n                        b += dfs(c, i, j + 1)\n            return max(a, b)\n\n        n = len(coins)\n        g = [[] for _ in range(n)]\n        for a, b in edges:\n            g[a].append(b)\n            g[b].append(a)\n        ans = dfs(0, -1, 0)\n        dfs.cache_clear()\n        return ans\n", "class Solution:\n  def maximumPoints(\n      self,\n      edges: list[list[int]],\n      coins: list[int],\n      k: int,\n  ) -> int:\n    MAX_COIN = 10000\n    MAX_HALVED = int(MAX_COIN).bit_length()\n    n = len(coins)\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    @functools.lru_cache(None)\n    def dfs(u: int, prev: int, halved: int) -> int:\n      # All the children will be 0, so no need to explore.\n      if halved > MAX_HALVED:\n        return 0\n\n      val = coins[u] // (1 << halved)\n      takeAll = val - k\n      takeHalf = math.floor(val / 2)\n\n      for v in graph[u]:\n        if v == prev:\n          continue\n        takeAll += dfs(v, u, halved)\n        takeHalf += dfs(v, u, halved + 1)\n\n      return max(takeAll, takeHalf)\n\n    return dfs(0, -1, 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2985, "slug": "calculate-compressed-mean", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2944, "slug": "minimum-number-of-coins-for-fruits", "solutions": ["class Solution:\n    def minimumCoins(self, prices: List[int]) -> int:\n        @cache\n        def dfs(i: int) -> int:\n            if i * 2 >= len(prices):\n                return prices[i - 1]\n            return prices[i - 1] + min(dfs(j) for j in range(i + 1, i * 2 + 2))\n\n        return dfs(1)\n", "class Solution:\n  def minimumCoins(self, prices: list[int]) -> int:\n    n = len(prices)\n    # Convert to 0-indexed for easy computation.\n    # dp[i] := the minimum number of coins to acquire fruits[i:]\n    dp = [math.inf] * n + [0]\n\n    for i in range(n - 1, -1, -1):\n      # Convert back to 1-indexed.\n      for j in range(i + 1, min((i + 1) * 2 + 1, n + 1)):\n        dp[i] = min(dp[i], prices[i] + dp[j])\n\n    return dp[0]\n", "class Solution:\n  def minimumCoins(self, prices: list[int]) -> int:\n    n = len(prices)\n    # Stores (dp[i], i), where dp[i] is the minimum number of coins to acquire\n    # fruits[i:] (0-indexed).\n    minHeap = [(0, n)]\n    ans = 0\n\n    for i in range(n - 1, -1, -1):\n      while minHeap and minHeap[0][1] > (i + 1) * 2:\n        heapq.heappop(minHeap)\n      ans = prices[i] + minHeap[0][0]\n      heapq.heappush(minHeap, (ans, i))\n\n    return ans\n", "class Solution:\n  def minimumCoins(self, prices: list[int]) -> int:\n    n = len(prices)\n    ans = math.inf\n    # Stores (dp[i], i), where dp[i] := the minimum number of coins to acquire\n    # fruits[i:] (0-indexed) in ascending order.\n    minQ = collections.deque([(0, n)])\n\n    for i in range(n - 1, -1, -1):\n      while minQ and minQ[0][1] > (i + 1) * 2:\n        minQ.popleft()\n      ans = prices[i] + minQ[0][0]\n      while minQ and minQ[-1][0] >= ans:\n        minQ.pop()\n      minQ.append((ans, i))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2990, "slug": "loan-types", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2930, "slug": "number-of-strings-which-can-be-rearranged-to-contain-substring", "solutions": ["class Solution:\n    def stringCount(self, n: int) -> int:\n        @cache\n        def dfs(i: int, l: int, e: int, t: int) -> int:\n            if i == 0:\n                return int(l == 1 and e == 2 and t == 1)\n            a = dfs(i - 1, l, e, t) * 23 % mod\n            b = dfs(i - 1, min(1, l + 1), e, t)\n            c = dfs(i - 1, l, min(2, e + 1), t)\n            d = dfs(i - 1, l, e, min(1, t + 1))\n            return (a + b + c + d) % mod\n\n        mod = 10**9 + 7\n        return dfs(n, 0, 0, 0)\n", "class Solution:\n  def stringCount(self, n: int) -> int:\n    # There're three invalid conditions:\n    #   a. count('l') == 0\n    #   b. count('e') < 2\n    #   c. count('t') == 0\n    #\n    # By Principle of Inclusion-Exclusion (PIE):\n    #   ans = allCount - a - b - c + ab + ac + bc - abc\n    MOD = 1_000_000_007\n    allCount = pow(26, n, MOD)\n    a = pow(25, n, MOD)\n    b = pow(25, n, MOD)\n    c = pow(25, n, MOD) + n * pow(25, n - 1, MOD)\n    ab = pow(24, n, MOD) + n * pow(24, n - 1, MOD)\n    ac = pow(24, n, MOD)\n    bc = pow(24, n, MOD) + n * pow(24, n - 1, MOD)\n    abc = pow(23, n, MOD) + n * pow(23, n - 1, MOD)\n    return (allCount - a - b - c + ab + ac + bc - abc) % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2940, "slug": "find-building-where-alice-and-bob-can-meet", "solutions": ["class BinaryIndexedTree:\n    __slots__ = [\"n\", \"c\"]\n\n    def __init__(self, n: int):\n        self.n = n\n        self.c = [inf] * (n + 1)\n\n    def update(self, x: int, v: int):\n        while x <= self.n:\n            self.c[x] = min(self.c[x], v)\n            x += x & -x\n\n    def query(self, x: int) -> int:\n        mi = inf\n        while x:\n            mi = min(mi, self.c[x])\n            x -= x & -x\n        return -1 if mi == inf else mi\n\n\nclass Solution:\n    def leftmostBuildingQueries(\n        self, heights: List[int], queries: List[List[int]]\n    ) -> List[int]:\n        n, m = len(heights), len(queries)\n        for i in range(m):\n            queries[i] = [min(queries[i]), max(queries[i])]\n        j = n - 1\n        s = sorted(set(heights))\n        ans = [-1] * m\n        tree = BinaryIndexedTree(n)\n        for i in sorted(range(m), key=lambda i: -queries[i][1]):\n            l, r = queries[i]\n            while j > r:\n                k = n - bisect_left(s, heights[j]) + 1\n                tree.update(k, j)\n                j -= 1\n            if l == r or heights[l] < heights[r]:\n                ans[i] = r\n            else:\n                k = n - bisect_left(s, heights[l])\n                ans[i] = tree.query(k)\n        return ans\n", "from dataclasses import dataclass\n\n\n@dataclass\nclass IndexedQuery:\n  queryIndex: int\n  a: int  # Alice's index\n  b: int  # Bob's index\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.a\n    yield self.b\n\n\nclass Solution:\n  # Similar to 2736. Maximum Sum Queries\n  def leftmostBuildingQueries(\n      self,\n      heights: list[int],\n      queries: list[list[int]],\n  ) -> list[int]:\n    ans = [-1] * len(queries)\n    # Store indices (heightsIndex) of heights with heights[heightsIndex] in\n    # descending order.\n    stack = []\n\n    # Iterate through queries and heights simultaneously.\n    heightsIndex = len(heights) - 1\n    for queryIndex, a, b in sorted([IndexedQuery(i, min(a, b), max(a, b))\n                                    for i, (a, b) in enumerate(queries)],\n                                   key=lambda x: -x.b):\n      if a == b or heights[a] < heights[b]:\n        # 1. Alice and Bob are already in the same index (a == b) or\n        # 2. Alice can jump from a -> b (heights[a] < heights[b]).\n        ans[queryIndex] = b\n      else:\n        # Now, a < b and heights[a] >= heights[b].\n        # Gradually add heights with an index > b to the monotonic stack.\n        while heightsIndex > b:\n          # heights[heightsIndex] is a better candidate, given that\n          # heightsIndex is smaller than the indices in the stack and\n          # heights[heightsIndex] is larger or equal to the heights mapped in\n          # the stack.\n          while stack and heights[stack[-1]] <= heights[heightsIndex]:\n            stack.pop()\n          stack.append(heightsIndex)\n          heightsIndex -= 1\n        # Binary search to find the smallest index j such that j > b and\n        # heights[j] > heights[a], thereby ensuring heights[j] > heights[b].\n        j = self._lastGreater(stack, a, heights)\n        if j != -1:\n          ans[queryIndex] = stack[j]\n\n    return ans\n\n  def _lastGreater(self, A: list[int], target: int, heights: list[int]):\n    \"\"\"\n    Returns the last index i in A s.t. heights[A.get(i)] is > heights[target].\n    \"\"\"\n    l = -1\n    r = len(A) - 1\n    while l < r:\n      m = (l + r + 1) // 2\n      if heights[A[m]] > heights[target]:\n        l = m\n      else:\n        r = m - 1\n    return l\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2958, "slug": "length-of-longest-subarray-with-at-most-k-frequency", "solutions": ["class Solution:\n    def maxSubarrayLength(self, nums: List[int], k: int) -> int:\n        cnt = defaultdict(int)\n        ans = j = 0\n        for i, x in enumerate(nums):\n            cnt[x] += 1\n            while cnt[x] > k:\n                cnt[nums[j]] -= 1\n                j += 1\n            ans = max(ans, i - j + 1)\n        return ans\n", "class Solution:\n  def maxSubarrayLength(self, nums: list[int], k: int) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, num in enumerate(nums):\n      count[num] += 1\n      while count[num] == k + 1:\n        count[nums[l]] -= 1\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2914, "slug": "minimum-number-of-changes-to-make-binary-string-beautiful", "solutions": ["class Solution:\n    def minChanges(self, s: str) -> int:\n        return sum(s[i] != s[i - 1] for i in range(1, len(s), 2))\n", "class Solution:\n  def minChanges(self, s: str) -> int:\n    return sum(a != b for a, b in zip(s[::2], s[1::2]))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2949, "slug": "count-beautiful-substrings-ii", "solutions": ["class Solution:\n  # Same as 2947. Count Beautiful Substrings I\n  def beautifulSubstrings(self, s: str, k: int) -> int:\n    VOWELS = 'aeiou'\n    root = self._getRoot(k)\n    ans = 0\n    vowels = 0\n    vowelsMinusConsonants = 0\n    # {(vowels, vowelsMinusConsonants): count}\n    prefixCount = collections.Counter({(0, 0): 1})\n\n    for c in s:\n      if c in VOWELS:\n        vowelsMinusConsonants += 1\n        vowels = (vowels + 1) % root\n      else:\n        vowelsMinusConsonants -= 1\n      ans += prefixCount[(vowels, vowelsMinusConsonants)]\n      prefixCount[(vowels, vowelsMinusConsonants)] += 1\n\n    return ans\n\n  def _getRoot(self, k: int) -> int:\n    for i in range(1, k + 1):\n      if i * i % k == 0:\n        return i\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2956, "slug": "find-common-elements-between-two-arrays", "solutions": ["class Solution:\n    def findIntersectionValues(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        s1, s2 = set(nums1), set(nums2)\n        return [sum(x in s2 for x in nums1), sum(x in s1 for x in nums2)]\n", "class Solution:\n  def findIntersectionValues(\n      self,\n      nums1: list[int],\n      nums2: list[int],\n  ) -> list[int]:\n    nums1Set = set(nums1)\n    nums2Set = set(nums2)\n    return [sum(num in nums2Set for num in nums1),\n            sum(num in nums1Set for num in nums2)]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2901, "slug": "longest-unequal-adjacent-groups-subsequence-ii", "solutions": ["class Solution:\n    def getWordsInLongestSubsequence(\n        self, n: int, words: List[str], groups: List[int]\n    ) -> List[str]:\n        def check(s: str, t: str) -> bool:\n            return len(s) == len(t) and sum(a != b for a, b in zip(s, t)) == 1\n\n        f = [1] * n\n        g = [-1] * n\n        mx = 1\n        for i, x in enumerate(groups):\n            for j, y in enumerate(groups[:i]):\n                if x != y and f[i] < f[j] + 1 and check(words[i], words[j]):\n                    f[i] = f[j] + 1\n                    g[i] = j\n                    mx = max(mx, f[i])\n        ans = []\n        for i in range(n):\n            if f[i] == mx:\n                j = i\n                while j >= 0:\n                    ans.append(words[j])\n                    j = g[j]\n                break\n        return ans[::-1]\n", "class Solution:\n  def getWordsInLongestSubsequence(\n      self,\n      n: int,\n      words: list[str],\n      groups: list[int],\n  ) -> list[str]:\n    ans = []\n    # dp[i] := the length of the longest subsequence ending in `words[i]`\n    dp = [1] * n\n    # prev[i] := the best index of words[i]\n    prev = [-1] * n\n\n    for i in range(1, n):\n      for j in range(i):\n        if groups[i] == groups[j]:\n          continue\n        if len(words[i]) != len(words[j]):\n          continue\n        if sum(a != b for a, b in zip(words[i], words[j])) != 1:\n          continue\n        if dp[i] < dp[j] + 1:\n          dp[i] = dp[j] + 1\n          prev[i] = j\n\n    # Find the last index of the subsequence.\n    index = dp.index(max(dp))\n    while index != -1:\n      ans.append(words[index])\n      index = prev[index]\n\n    return ans[::-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2970, "slug": "count-the-number-of-incremovable-subarrays-i", "solutions": ["class Solution:\n    def incremovableSubarrayCount(self, nums: List[int]) -> int:\n        i, n = 0, len(nums)\n        while i + 1 < n and nums[i] < nums[i + 1]:\n            i += 1\n        if i == n - 1:\n            return n * (n + 1) // 2\n        ans = i + 2\n        j = n - 1\n        while j:\n            while i >= 0 and nums[i] >= nums[j]:\n                i -= 1\n            ans += i + 2\n            if nums[j - 1] >= nums[j]:\n                break\n            j -= 1\n        return ans\n", "class Solution:\n  def incremovableSubarrayCount(self, nums: list[int]) -> int:\n    n = len(nums)\n    startIndex = self._getStartIndexOfSuffix(nums)\n    # If the complete array is strictly increasing, the total number of ways we\n    # can remove elements equals the total number of possible subarrays.\n    if startIndex == 0:\n      return n * (n + 1) // 2\n\n    # The valid removals starting from nums[0] include nums[0..startIndex - 1],\n    # nums[0..startIndex], ..., nums[0..n).\n    ans = n - startIndex + 1\n\n    # Enumerate each prefix subarray that is strictly increasing.\n    for i in range(startIndex):\n      if i > 0 and nums[i] <= nums[i - 1]:\n        break\n      # Since nums[0..i] is strictly increasing, find the first index j in\n      # nums[startIndex..n) such that nums[j] > nums[i]. The valid removals\n      # will then be nums[i + 1..j - 1], nums[i + 1..j], ..., nums[i + 1..n).\n      ans += n - bisect.bisect_right(nums, nums[i], startIndex) + 1\n\n    return ans\n\n  def _getStartIndexOfSuffix(self, nums: list[int]) -> int:\n    for i in range(len(nums) - 2, -1, -1):\n      if nums[i] >= nums[i + 1]:\n        return i + 1\n    return 0\n", "class Solution:\n  def incremovableSubarrayCount(self, nums: list[int]) -> int:\n    n = len(nums)\n    startIndex = self._getStartIndexOfSuffix(nums)\n    # If the complete array is strictly increasing, the total number of ways we\n    # can remove elements equals the total number of possible subarrays.\n    if startIndex == 0:\n      return n * (n + 1) // 2\n\n    # The valid removals starting from nums[0] include nums[0..startIndex - 1],\n    # nums[0..startIndex], ..., nums[0..n).\n    ans = n - startIndex + 1\n\n    # Enumerate each prefix subarray that is strictly increasing.\n    j = startIndex\n    for i in range(startIndex):\n      if i > 0 and nums[i] <= nums[i - 1]:\n        break\n      # Since nums[0..i] is strictly increasing, move j to the place such that\n      # nums[j] > nums[i]. The valid removals will then be nums[i + 1..j - 1],\n      # nums[i + 1..j], ..., nums[i + 1..n).\n      while j < n and nums[i] >= nums[j]:\n        j += 1\n      ans += n - j + 1\n\n    return ans\n\n  def _getStartIndexOfSuffix(self, nums: list[int]) -> int:\n    for i in range(len(nums) - 2, -1, -1):\n      if nums[i] >= nums[i + 1]:\n        return i + 1\n    return 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2961, "slug": "double-modular-exponentiation", "solutions": ["class Solution:\n    def getGoodIndices(self, variables: List[List[int]], target: int) -> List[int]:\n        return [\n            i\n            for i, (a, b, c, m) in enumerate(variables)\n            if pow(pow(a, b, 10), c, m) == target\n        ]\n", "class Solution:\n  def getGoodIndices(\n      self,\n      variables: list[list[int]],\n      target: int,\n  ) -> list[int]:\n    return [i for i, (a, b, c, m) in enumerate(variables)\n            if pow(pow(a, b, 10), c, m) == target]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2950, "slug": "number-of-divisible-substrings", "solutions": ["class Solution:\n    def countDivisibleSubstrings(self, word: str) -> int:\n        d = [\"ab\", \"cde\", \"fgh\", \"ijk\", \"lmn\", \"opq\", \"rst\", \"uvw\", \"xyz\"]\n        mp = {}\n        for i, s in enumerate(d, 1):\n            for c in s:\n                mp[c] = i\n        ans = 0\n        n = len(word)\n        for i in range(n):\n            s = 0\n            for j in range(i, n):\n                s += mp[word[j]]\n                ans += s % (j - i + 1) == 0\n        return ans\n", "class Solution:\n  def countDivisibleSubstrings(self, word: str) -> int:\n    # Let f(c) = d, where d = 1, 2, ..., 9.\n    # Rephrase the question to return the number of substrings that satisfy\n    #    f(c1) + f(c2) + ... + f(ck) // k = avg\n    # => f(c1) + f(c2) + ... + f(ck) - k * avg, where avg in [1, 9].\n    ans = 0\n\n    def f(c: str) -> int:\n      return 9 - (ord('z') - ord(c)) // 3\n\n    for avg in range(1, 10):\n      prefix = 0\n      prefixCount = collections.Counter({0: 1})\n      for c in word:\n        prefix += f(c) - avg\n        ans += prefixCount[prefix]\n        prefixCount[prefix] += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2997, "slug": "minimum-number-of-operations-to-make-array-xor-equal-to-k", "solutions": ["class Solution:\n    def minOperations(self, nums: List[int], k: int) -> int:\n        return reduce(xor, nums, k).bit_count()\n", "class Solution:\n  def minOperations(self, nums: list[int], k: int) -> int:\n    return functools.reduce(operator.xor, nums, k).bit_count()\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2988, "slug": "manager-of-the-largest-department", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2969, "slug": "minimum-number-of-coins-for-fruits-ii", "solutions": ["class Solution:\n    def minimumCoins(self, prices: List[int]) -> int:\n        n = len(prices)\n        q = deque()\n        for i in range(n, 0, -1):\n            while q and q[0] > i * 2 + 1:\n                q.popleft()\n            if i <= (n - 1) // 2:\n                prices[i - 1] += prices[q[0] - 1]\n            while q and prices[q[-1] - 1] >= prices[i - 1]:\n                q.pop()\n            q.append(i)\n        return prices[0]\n", "class Solution:\n  # Same as 2944. Minimum Number of Coins for Fruits\n  def minimumCoins(self, prices: list[int]) -> int:\n    n = len(prices)\n    ans = math.inf\n    # Stores (dp[i], i), where dp[i] := the minimum number of coins to acquire\n    # fruits[i:] (0-indexed) in ascending order.\n    minQ = collections.deque([(0, n)])\n\n    for i in range(n - 1, -1, -1):\n      while minQ and minQ[0][1] > (i + 1) * 2:\n        minQ.popleft()\n      ans = prices[i] + minQ[0][0]\n      while minQ and minQ[-1][0] >= ans:\n        minQ.pop()\n      minQ.append((ans, i))\n\n    return ans\n", "class Solution:\n  # Same as 2944. Minimum Number of Coins for Fruits\n  def minimumCoins(self, prices: list[int]) -> int:\n    n = len(prices)\n    # Stores (dp[i], i), where dp[i] is the minimum number of coins to acquire\n    # fruits[i:] (0-indexed).\n    minHeap = [(0, n)]\n    ans = 0\n\n    for i in range(n - 1, -1, -1):\n      while minHeap and minHeap[0][1] > (i + 1) * 2:\n        heapq.heappop(minHeap)\n      ans = prices[i] + minHeap[0][0]\n      heapq.heappush(minHeap, (ans, i))\n\n    return ans\n", "class Solution:\n  # Same as 2944. Minimum Number of Coins for Fruits\n  def minimumCoins(self, prices: list[int]) -> int:\n    n = len(prices)\n    # Convert to 0-indexed for easy computation.\n    # dp[i] := the minimum number of coins to acquire fruits[i:]\n    dp = [math.inf] * n + [0]\n\n    for i in range(n - 1, -1, -1):\n      # Convert back to 1-indexed.\n      for j in range(i + 1, min((i + 1) * 2 + 1, n + 1)):\n        dp[i] = min(dp[i], prices[i] + dp[j])\n\n    return dp[0]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2923, "slug": "find-champion-i", "solutions": ["class Solution:\n    def findChampion(self, grid: List[List[int]]) -> int:\n        for i, row in enumerate(grid):\n            if all(x == 1 for j, x in enumerate(row) if i != j):\n                return i\n", "class Solution:\n  def findChampion(self, grid: list[list[int]]) -> int:\n    return max(range(len(grid)), key=lambda x: sum(grid[x]))\n", "class Solution:\n  def findChampion(self, grid: list[list[int]]) -> int:\n    n = len(grid)\n    inDegrees = [0] * n\n\n    for i in range(n):\n      for j in range(n):\n        if i == j:\n          continue\n        if grid[i][j] == 1:\n          inDegrees[j] += 1\n        else:\n          inDegrees[i] += 1\n\n    return (-1 if inDegrees.count(0) > 1\n            else inDegrees.index(0))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2979, "slug": "most-expensive-item-that-can-not-be-bought", "solutions": ["class Solution:\n    def mostExpensiveItem(self, primeOne: int, primeTwo: int) -> int:\n        return primeOne * primeTwo - primeOne - primeTwo\n", "class Solution:\n  def mostExpensiveItem(self, primeOne: int, primeTwo: int) -> int:\n    # https://en.wikipedia.org/wiki/Coin_problem\n    return primeOne * primeTwo - primeOne - primeTwo\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2981, "slug": "find-longest-special-substring-that-occurs-thrice-i", "solutions": ["class Solution:\n    def maximumLength(self, s: str) -> int:\n        def check(x: int) -> bool:\n            cnt = defaultdict(int)\n            i = 0\n            while i < n:\n                j = i + 1\n                while j < n and s[j] == s[i]:\n                    j += 1\n                cnt[s[i]] += max(0, j - i - x + 1)\n                i = j\n            return max(cnt.values()) >= 3\n\n        n = len(s)\n        l, r = 0, n\n        while l < r:\n            mid = (l + r + 1) >> 1\n            if check(mid):\n                l = mid\n            else:\n                r = mid - 1\n        return -1 if l == 0 else l\n", "class Solution:\n  def maximumLength(self, s: str) -> int:\n    n = len(s)\n    runningLen = 0\n    prevLetter = '@'\n    # counts[i][j] := the frequency of ('a' + i) repeating j times\n    counts = [[0] * (n + 1) for _ in range(26)]\n\n    for c in s:\n      if c == prevLetter:\n        runningLen += 1\n        counts[ord(c) - ord('a')][runningLen] += 1\n      else:\n        runningLen = 1\n        counts[ord(c) - ord('a')][runningLen] += 1\n        prevLetter = c\n\n    def getMaxFreq(count: list[int]) -> int:\n      \"\"\"Returns the maximum frequency that occurs more than three times.\"\"\"\n      times = 0\n      for freq in range(n, 0, -1):\n        times += count[freq]\n        if times >= 3:\n          return freq\n      return -1\n\n    return max(getMaxFreq(count) for count in counts)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2926, "slug": "maximum-balanced-subsequence-sum", "solutions": ["class BinaryIndexedTree:\n    def __init__(self, n: int):\n        self.n = n\n        self.c = [-inf] * (n + 1)\n\n    def update(self, x: int, v: int):\n        while x <= self.n:\n            self.c[x] = max(self.c[x], v)\n            x += x & -x\n\n    def query(self, x: int) -> int:\n        mx = -inf\n        while x:\n            mx = max(mx, self.c[x])\n            x -= x & -x\n        return mx\n\n\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        arr = [x - i for i, x in enumerate(nums)]\n        s = sorted(set(arr))\n        tree = BinaryIndexedTree(len(s))\n        for i, x in enumerate(nums):\n            j = bisect_left(s, x - i) + 1\n            v = max(tree.query(j), 0) + x\n            tree.update(j, v)\n        return tree.query(len(s))\n", "class FenwickTree:\n  def __init__(self, n: int):\n    self.vals = [0] * (n + 1)\n\n  def maximize(self, i: int, val: int) -> None:\n    \"\"\"Updates the maximum sum of subsequence ending in (i - 1) with `val`.\"\"\"\n    while i < len(self.vals):\n      self.vals[i] = max(self.vals[i], val)\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    \"\"\"Returns the maximum sum of subsequence ending in (i - 1).\"\"\"\n    res = 0\n    while i > 0:\n      res = max(res, self.vals[i])\n      i -= FenwickTree.lowbit(i)\n    return res\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def maxBalancedSubsequenceSum(self, nums: list[int]) -> int:\n    # Let's define maxSum[i] := subsequence with the maximum sum ending in i\n    # By observation:\n    #    nums[i] - nums[j] >= i - j\n    # => nums[i] - i >= nums[j] - j\n    # So, if nums[i] - i >= nums[j] - j, where i > j,\n    # maxSum[i] = max(maxSum[i], maxSum[j] + nums[i])\n    ans = -math.inf\n    tree = FenwickTree(len(nums))\n\n    for _, i in sorted([(num - i, i) for i, num in enumerate(nums)]):\n      subseqSum = tree.get(i) + nums[i]\n      tree.maximize(i + 1, subseqSum)\n      ans = max(ans, subseqSum)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2948, "slug": "make-lexicographically-smallest-array-by-swapping-elements", "solutions": ["class Solution:\n    def lexicographicallySmallestArray(self, nums: List[int], limit: int) -> List[int]:\n        n = len(nums)\n        arr = sorted(zip(nums, range(n)))\n        ans = [0] * n\n        i = 0\n        while i < n:\n            j = i + 1\n            while j < n and arr[j][0] - arr[j - 1][0] <= limit:\n                j += 1\n            idx = sorted(k for _, k in arr[i:j])\n            for k, (x, _) in zip(idx, arr[i:j]):\n                ans[k] = x\n            i = j\n        return ans\n", "class Solution:\n  def lexicographicallySmallestArray(\n      self,\n      nums: list[int],\n      limit: int,\n  ) -> list[int]:\n    ans = [0] * len(nums)\n    numAndIndexes = sorted([(num, i) for i, num in enumerate(nums)])\n    # [[(num, index)]], where the difference between in each pair in each\n    # `[(num, index)]` group <= `limit`\n    numAndIndexesGroups: list[list[tuple[int, int]]] = []\n\n    for numAndIndex in numAndIndexes:\n      if (not numAndIndexesGroups or\n              numAndIndex[0] - numAndIndexesGroups[-1][-1][0] > limit):\n        # Start a new group.\n        numAndIndexesGroups.append([numAndIndex])\n      else:\n        # Append to the existing group.\n        numAndIndexesGroups[-1].append(numAndIndex)\n\n    for numAndIndexesGroup in numAndIndexesGroups:\n      sortedNums = [num for num, _ in numAndIndexesGroup]\n      sortedIndices = sorted([index for _, index in numAndIndexesGroup])\n      for num, index in zip(sortedNums, sortedIndices):\n        ans[index] = num\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2993, "slug": "friday-purchases-i", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2987, "slug": "find-expensive-cities", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2966, "slug": "divide-array-into-arrays-with-max-difference", "solutions": ["class Solution:\n    def divideArray(self, nums: List[int], k: int) -> List[List[int]]:\n        nums.sort()\n        ans = []\n        n = len(nums)\n        for i in range(0, n, 3):\n            t = nums[i : i + 3]\n            if t[2] - t[0] > k:\n                return []\n            ans.append(t)\n        return ans\n", "class Solution:\n  def divideArray(self, nums: list[int], k: int) -> list[list[int]]:\n    ans = []\n\n    nums.sort()\n\n    for i in range(2, len(nums), 3):\n      if nums[i] - nums[i - 2] > k:\n        return []\n      ans.append([nums[i - 2], nums[i - 1], nums[i]])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2942, "slug": "find-words-containing-character", "solutions": ["class Solution:\n    def findWordsContaining(self, words: List[str], x: str) -> List[int]:\n        return [i for i, w in enumerate(words) if x in w]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2974, "slug": "minimum-number-game", "solutions": ["class Solution:\n    def numberGame(self, nums: List[int]) -> List[int]:\n        heapify(nums)\n        ans = []\n        while nums:\n            a, b = heappop(nums), heappop(nums)\n            ans.append(b)\n            ans.append(a)\n        return ans\n", "class Solution:\n  def numberGame(self, nums: list[int]) -> list[int]:\n    nums.sort()\n    return [nums[i + 1] if i % 2 == 0\n            else nums[i - 1]\n            for i in range(len(nums))]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2918, "slug": "minimum-equal-sum-of-two-arrays-after-replacing-zeros", "solutions": ["class Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        s1 = sum(nums1) + nums1.count(0)\n        s2 = sum(nums2) + nums2.count(0)\n        if s1 > s2:\n            return self.minSum(nums2, nums1)\n        if s1 == s2:\n            return s1\n        return -1 if nums1.count(0) == 0 else s2\n", "class Solution:\n  def minSum(self, nums1: list[int], nums2: list[int]) -> int:\n    sum1 = sum(nums1)\n    sum2 = sum(nums2)\n    zero1 = nums1.count(0)\n    zero2 = nums2.count(0)\n    if zero1 == 0 and sum1 < sum2 + zero2:\n      return -1\n    if zero2 == 0 and sum2 < sum1 + zero1:\n      return -1\n    return max(sum1 + zero1, sum2 + zero2)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2955, "slug": "number-of-same-end-substrings", "solutions": ["class Solution:\n    def sameEndSubstringCount(self, s: str, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        cs = set(s)\n        cnt = {c: [0] * (n + 1) for c in cs}\n        for i, a in enumerate(s, 1):\n            for c in cs:\n                cnt[c][i] = cnt[c][i - 1]\n            cnt[a][i] += 1\n        ans = []\n        for l, r in queries:\n            t = r - l + 1\n            for c in cs:\n                x = cnt[c][r + 1] - cnt[c][l]\n                t += x * (x - 1) // 2\n            ans.append(t)\n        return ans\n", "class Solution:\n  def sameEndSubstringCount(\n      self,\n      s: str,\n      queries: list[list[int]],\n  ) -> list[int]:\n    count = collections.Counter()\n    # counts[i] := the count of s[0..i)\n    counts = [count.copy()]\n\n    for c in s:\n      count[c] += 1\n      counts.append(count.copy())\n\n    ans = []\n\n    for l, r in queries:\n      sameEndCount = 0\n      for c in string.ascii_lowercase:\n        #   the count of s[0..r] - the count of s[0..l - 1]\n        # = the count of s[l..r]\n        freq = counts[r + 1][c] - counts[l][c]\n        #   C(freq, 2) + freq\n        # = freq * (freq - 1) / 2 + freq\n        # = freq * (freq + 1) / 2\n        sameEndCount += freq * (freq + 1) // 2\n      ans.append(sameEndCount)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2960, "slug": "count-tested-devices-after-test-operations", "solutions": ["class Solution:\n    def countTestedDevices(self, batteryPercentages: List[int]) -> int:\n        ans = 0\n        for x in batteryPercentages:\n            ans += x > ans\n        return ans\n", "class Solution:\n  def countTestedDevices(self, batteryPercentages: list[int]) -> int:\n    ans = 0\n\n    for batteryPercentage in batteryPercentages:\n      if batteryPercentage - ans > 0:\n        ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2951, "slug": "find-the-peaks", "solutions": ["class Solution:\n    def findPeaks(self, mountain: List[int]) -> List[int]:\n        return [\n            i\n            for i in range(1, len(mountain) - 1)\n            if mountain[i - 1] < mountain[i] > mountain[i + 1]\n        ]\n", "class Solution:\n  def findPeaks(self, mountain: list[int]) -> list[int]:\n    return [i for i in range(1, len(mountain) - 1)\n            if mountain[i - 1] < mountain[i] > mountain[i + 1]]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2933, "slug": "high-access-employees", "solutions": ["class Solution:\n    def findHighAccessEmployees(self, access_times: List[List[str]]) -> List[str]:\n        d = defaultdict(list)\n        for name, t in access_times:\n            d[name].append(int(t[:2]) * 60 + int(t[2:]))\n        ans = []\n        for name, ts in d.items():\n            ts.sort()\n            if any(ts[i] - ts[i - 2] < 60 for i in range(2, len(ts))):\n                ans.append(name)\n        return ans\n", "class Solution:\n  def findHighAccessEmployees(self, access_times: list[list[str]]) -> list[str]:\n    ans = set()\n\n    access_times.sort()\n\n    for i in range(len(access_times) - 2):\n      name = access_times[i][0]\n      if name in ans:\n        continue\n      if name != access_times[i + 2][0]:\n        continue\n      if int(access_times[i + 2][1]) - int(access_times[i][1]) < 100:\n        ans.add(name)\n\n    return list(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2946, "slug": "matrix-similarity-after-cyclic-shifts", "solutions": ["class Solution:\n    def areSimilar(self, mat: List[List[int]], k: int) -> bool:\n        n = len(mat[0])\n        for i, row in enumerate(mat):\n            for j, x in enumerate(row):\n                if i % 2 == 1 and x != mat[i][(j + k) % n]:\n                    return False\n                if i % 2 == 0 and x != mat[i][(j - k + n) % n]:\n                    return False\n        return True\n", "class Solution:\n  def areSimilar(self, mat: list[list[int]], k: int) -> bool:\n    n = len(mat[0])\n    for row in mat:\n      for j in range(n):\n        if row[j] != row[(j + k) % n]:\n          return False\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2929, "slug": "distribute-candies-among-children-ii", "solutions": ["class Solution:\n    def distributeCandies(self, n: int, limit: int) -> int:\n        if n > 3 * limit:\n            return 0\n        ans = comb(n + 2, 2)\n        if n > limit:\n            ans -= 3 * comb(n - limit + 1, 2)\n        if n - 2 >= 2 * limit:\n            ans += 3 * comb(n - 2 * limit, 2)\n        return ans\n", "class Solution:\n  def distributeCandies(self, n: int, limit: int) -> int:\n    def ways(n: int) -> int:\n      \"\"\"Returns the number of ways to distribute n candies to 3 children.\"\"\"\n      if n < 0:\n        return 0\n      # Stars and bars method:\n      # e.g. '**|**|*' means to distribute 5 candies to 3 children, where\n      # stars (*) := candies and bars (|) := dividers between children.\n      return math.comb(n + 2, 2)\n\n    limitPlusOne = limit + 1\n    oneChildExceedsLimit = ways(n - limitPlusOne)\n    twoChildrenExceedLimit = ways(n - 2 * limitPlusOne)\n    threeChildrenExceedLimit = ways(n - 3 * limitPlusOne)\n    # Principle of Inclusion-Exclusion (PIE)\n    return (ways(n)\n            - 3 * oneChildExceedsLimit\n            + 3 * twoChildrenExceedLimit\n            - threeChildrenExceedLimit)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2919, "slug": "minimum-increment-operations-to-make-array-beautiful", "solutions": ["class Solution:\n    def minIncrementOperations(self, nums: List[int], k: int) -> int:\n        f = g = h = 0\n        for x in nums:\n            f, g, h = g, h, min(f, g, h) + max(k - x, 0)\n        return min(f, g, h)\n", "class Solution:\n  def minIncrementOperations(self, nums: list[int], k: int) -> int:\n    # the minimum operations to increase nums[i - 3] and nums[0..i - 3)\n    prev3 = 0\n    # the minimum operations to increase nums[i - 2] and nums[0..i - 2)\n    prev2 = 0\n    # the minimum operations to increase nums[i - 1] and nums[0..i - 1)\n    prev1 = 0\n\n    for num in nums:\n      dp = min(prev1, prev2, prev3) + max(0, k - num)\n      prev3 = prev2\n      prev2 = prev1\n      prev1 = dp\n\n    return min(prev1, prev2, prev3)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2911, "slug": "minimum-changes-to-make-k-semi-palindromes", "solutions": ["class Solution:\n    def minimumChanges(self, s: str, k: int) -> int:\n        n = len(s)\n        g = [[inf] * (n + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                m = j - i + 1\n                for d in range(1, m):\n                    if m % d == 0:\n                        cnt = 0\n                        for l in range(m):\n                            r = (m // d - 1 - l // d) * d + l % d\n                            if l >= r:\n                                break\n                            if s[i - 1 + l] != s[i - 1 + r]:\n                                cnt += 1\n                        g[i][j] = min(g[i][j], cnt)\n\n        f = [[inf] * (k + 1) for _ in range(n + 1)]\n        f[0][0] = 0\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                for h in range(i - 1):\n                    f[i][j] = min(f[i][j], f[h][j - 1] + g[h + 1][i])\n        return f[n][k]\n", "class Solution:\n  def minimumChanges(self, s: str, k: int) -> int:\n    n = len(s)\n    # factors[i] := factors of i\n    factors = self._getFactors(n)\n    # cost[i][j] := changes to make s[i..j] a semi-palindrome\n    cost = self._getCost(s, n, factors)\n    # dp[i][j] := the minimum changes to split s[i:] into j valid parts\n    dp = [[n] * (k + 1) for _ in range(n + 1)]\n\n    dp[n][0] = 0\n\n    for i in range(n - 1, -1, -1):\n      for j in range(1, k + 1):\n        for l in range(i + 1, n):\n          dp[i][j] = min(dp[i][j], dp[l + 1][j - 1] + cost[i][l])\n\n    return dp[0][k]\n\n  def _getFactors(self, n: int) -> list[list[int]]:\n    factors = [[1] for _ in range(n + 1)]\n    for d in range(2, n):\n      for i in range(d * 2, n + 1, d):\n        factors[i].append(d)\n    return factors\n\n  def _getCost(self, s: str, n: int, factors: list[list[int]]) -> list[list[int]]:\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n      for j in range(i + 1, n):\n        length = j - i + 1\n        minCost = length\n        for d in factors[length]:\n          minCost = min(minCost, self._getCostD(s, i, j, d))\n        cost[i][j] = minCost\n    return cost\n\n  def _getCostD(self, s: str, i: int, j: int, d: int) -> int:\n    \"\"\"Returns the cost to make s[i..j] a semi-palindrome of `d`.\"\"\"\n    cost = 0\n    for offset in range(d):\n      l = i + offset\n      r = j - d + 1 + offset\n      while l < r:\n        if s[l] != s[r]:\n          cost += 1\n        l += d\n        r -= d\n    return cost\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2939, "slug": "maximum-xor-product", "solutions": ["class Solution:\n    def maximumXorProduct(self, a: int, b: int, n: int) -> int:\n        mod = 10**9 + 7\n        ax, bx = (a >> n) << n, (b >> n) << n\n        for i in range(n - 1, -1, -1):\n            x = a >> i & 1\n            y = b >> i & 1\n            if x == y:\n                ax |= 1 << i\n                bx |= 1 << i\n            elif ax > bx:\n                bx |= 1 << i\n            else:\n                ax |= 1 << i\n        return ax * bx % mod\n", "class Solution:\n  def maximumXorProduct(self, a: int, b: int, n: int) -> int:\n    MOD = 1_000_000_007\n    for bit in (2**i for i in range(n)):\n      # Pick a bit if it makes min(a, b) larger.\n      if a * b < (a ^ bit) * (b ^ bit):\n        a ^= bit\n        b ^= bit\n    return a * b % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2983, "slug": "palindrome-rearrangement-queries", "solutions": ["class Solution:\n    def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n        def count(pre: List[List[int]], i: int, j: int) -> List[int]:\n            return [x - y for x, y in zip(pre[j + 1], pre[i])]\n\n        def sub(cnt1: List[int], cnt2: List[int]) -> List[int]:\n            res = []\n            for x, y in zip(cnt1, cnt2):\n                if x - y < 0:\n                    return []\n                res.append(x - y)\n            return res\n\n        def check(\n            pre1: List[List[int]], pre2: List[List[int]], a: int, b: int, c: int, d: int\n        ) -> bool:\n            if diff[a] > 0 or diff[m] - diff[max(b, d) + 1] > 0:\n                return False\n            if d <= b:\n                return count(pre1, a, b) == count(pre2, a, b)\n            if b < c:\n                return (\n                    diff[c] - diff[b + 1] == 0\n                    and count(pre1, a, b) == count(pre2, a, b)\n                    and count(pre1, c, d) == count(pre2, c, d)\n                )\n            cnt1 = sub(count(pre1, a, b), count(pre2, a, c - 1))\n            cnt2 = sub(count(pre2, c, d), count(pre1, b + 1, d))\n            return bool(cnt1) and bool(cnt2) and cnt1 == cnt2\n\n        n = len(s)\n        m = n // 2\n        t = s[m:][::-1]\n        s = s[:m]\n        pre1 = [[0] * 26 for _ in range(m + 1)]\n        pre2 = [[0] * 26 for _ in range(m + 1)]\n        diff = [0] * (m + 1)\n        for i, (c1, c2) in enumerate(zip(s, t), 1):\n            pre1[i] = pre1[i - 1][:]\n            pre2[i] = pre2[i - 1][:]\n            pre1[i][ord(c1) - ord(\"a\")] += 1\n            pre2[i][ord(c2) - ord(\"a\")] += 1\n            diff[i] = diff[i - 1] + int(c1 != c2)\n        ans = []\n        for a, b, c, d in queries:\n            c, d = n - 1 - d, n - 1 - c\n            ok = (\n                check(pre1, pre2, a, b, c, d)\n                if a <= c\n                else check(pre2, pre1, c, d, a, b)\n            )\n            ans.append(ok)\n        return ans\n", "class Solution:\n  def canMakePalindromeQueries(\n      self,\n      s: str,\n      queries: list[list[int]],\n  ) -> list[bool]:\n    n = len(s)\n    # mirroredDiffs[i] := the number of different letters between the first i\n    # letters of s[0..n / 2) and the first i letters of s[n / 2..n)[::-1]\n    mirroredDiffs = self._getMirroredDiffs(s)\n    # counts[i] := the count of s[0..i)\n    counts = self._getCounts(s)\n    ans = []\n\n    def subtractArrays(a: list[int], b: list[int]):\n      return [x - y for x, y in zip(a, b)]\n\n    for a, b, c, d in queries:\n      # Use left-closed, right-open intervals to facilitate the calculation.\n      #   ...... [a, b) ...|... [rb, ra) ......\n      #   .... [rd, rc) .....|..... [c, d) ....\n      b += 1\n      d += 1\n      ra = n - a  # the reflected index of a in s[n / 2..n)\n      rb = n - b  # the reflected index of b in s[n / 2..n)\n      rc = n - c  # the reflected index of c in s[n / 2..n)\n      rd = n - d  # the reflected index of d in s[n / 2..n)\n      # No difference is allowed outside the query ranges.\n      if ((min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0) or\n         (n // 2 > max(b, rc) and\n          mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or\n         (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or\n         (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0)):\n        ans.append(False)\n      else:\n        # The `count` map of the intersection of [a, b) and [rd, rc) in\n        # s[0..n / 2) must equate to the `count` map of the intersection of\n        # [c, d) and [rb, ra) in s[n / 2..n).\n        leftRangeCount = subtractArrays(counts[b], counts[a])\n        rightRangeCount = subtractArrays(counts[d], counts[c])\n        if a > rd:\n          rightRangeCount = subtractArrays(\n              rightRangeCount, subtractArrays(counts[min(a, rc)], counts[rd]))\n        if rc > b:\n          rightRangeCount = subtractArrays(\n              rightRangeCount, subtractArrays(counts[rc], counts[max(b, rd)]))\n        if c > rb:\n          leftRangeCount = subtractArrays(\n              leftRangeCount, subtractArrays(counts[min(c, ra)], counts[rb]))\n        if ra > d:\n          leftRangeCount = subtractArrays(\n              leftRangeCount, subtractArrays(counts[ra], counts[max(d, rb)]))\n        ans.append(min(leftRangeCount) >= 0\n                   and min(rightRangeCount) >= 0\n                   and leftRangeCount == rightRangeCount)\n\n    return ans\n\n  def _getMirroredDiffs(self, s: str) -> list[int]:\n    diffs = [0]\n    for i, j in zip(range(len(s)), reversed(range(len(s)))):\n      if i >= j:\n        break\n      diffs.append(diffs[-1] + (s[i] != s[j]))\n    return diffs\n\n  def _getCounts(self, s: str) -> list[list[int]]:\n    count = [0] * 26\n    counts = [count.copy()]\n    for c in s:\n      count[ord(c) - ord('a')] += 1\n      counts.append(count.copy())\n    return counts\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2907, "slug": "maximum-profitable-triplets-with-increasing-prices-i", "solutions": ["class Solution:\n    def maxProfit(self, prices: List[int], profits: List[int]) -> int:\n        n = len(prices)\n        ans = -1\n        for j, x in enumerate(profits):\n            left = right = 0\n            for i in range(j):\n                if prices[i] < prices[j] and left < profits[i]:\n                    left = profits[i]\n            for k in range(j + 1, n):\n                if prices[j] < prices[k] and right < profits[k]:\n                    right = profits[k]\n            if left and right:\n                ans = max(ans, left + x + right)\n        return ans\n", "class FenwickTree:\n  def __init__(self, n: int):\n    self.vals = [0] * (n + 1)\n\n  def maximize(self, i: int, val: int) -> None:\n    while i < len(self.vals):\n      self.vals[i] = max(self.vals[i], val)\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    res = 0\n    while i > 0:\n      res = max(res, self.vals[i])\n      i -= FenwickTree.lowbit(i)\n    return res\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def maxProfit(self, prices: list[int], profits: list[int]) -> int:\n    ans = -1\n    maxPrice = max(prices)\n    maxProfitTree1 = FenwickTree(maxPrice)\n    maxProfitTree2 = FenwickTree(maxPrice)\n\n    for price, profit in zip(prices, profits):\n      # max(proftis[i])\n      maxProfit1 = maxProfitTree1.get(price - 1)\n      # max(proftis[i]) + max(profits[j])\n      maxProfit2 = maxProfitTree2.get(price - 1)\n      maxProfitTree1.maximize(price, profit)\n      if maxProfit1 > 0:\n        maxProfitTree2.maximize(price, profit + maxProfit1)\n      if maxProfit2 > 0:\n        ans = max(ans, profit + maxProfit2)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2967, "slug": "minimum-cost-to-make-array-equalindromic", "solutions": ["ps = []\nfor i in range(1, 10**5 + 1):\n    s = str(i)\n    t1 = s[::-1]\n    t2 = s[:-1][::-1]\n    ps.append(int(s + t1))\n    ps.append(int(s + t2))\nps.sort()\n\n\nclass Solution:\n    def minimumCost(self, nums: List[int]) -> int:\n        def f(x: int) -> int:\n            return sum(abs(v - x) for v in nums)\n\n        nums.sort()\n        i = bisect_left(ps, nums[len(nums) // 2])\n        return min(f(ps[j]) for j in range(i - 1, i + 2) if 0 <= j < len(ps))\n", "class Solution:\n  def minimumCost(self, nums: list[int]) -> int:\n    nums.sort()\n    median = nums[len(nums) // 2]\n    nextPalindrome = self._getPalindrome(median, delta=1)\n    prevPalindrome = self._getPalindrome(median, delta=-1)\n    return min(self._cost(nums, nextPalindrome),\n               self._cost(nums, prevPalindrome))\n\n  def _cost(self, nums: list[int], palindrome: int) -> int:\n    \"\"\"Returns the cost to change all the numbers to `palindrome`.\"\"\"\n    return sum(abs(palindrome - num) for num in nums)\n\n  def _getPalindrome(self, num: int, delta: int) -> int:\n    \"\"\"Returns the palindrome `p`, where p = num + a * delta and a > 0.\"\"\"\n    while not self._isPalindrome(num):\n      num += delta\n    return num\n\n  def _isPalindrome(self, num: int) -> int:\n    original = str(num)\n    return original == original[::-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2905, "slug": "find-indices-with-index-and-value-difference-ii", "solutions": ["class Solution:\n    def findIndices(\n        self, nums: List[int], indexDifference: int, valueDifference: int\n    ) -> List[int]:\n        mi = mx = 0\n        for i in range(indexDifference, len(nums)):\n            j = i - indexDifference\n            if nums[j] < nums[mi]:\n                mi = j\n            if nums[j] > nums[mx]:\n                mx = j\n            if nums[i] - nums[mi] >= valueDifference:\n                return [mi, i]\n            if nums[mx] - nums[i] >= valueDifference:\n                return [mx, i]\n        return [-1, -1]\n", "class Solution:\n  def findIndices(\n      self,\n      nums: list[int],\n      indexDifference: int,\n      valueDifference: int,\n  ) -> list[int]:\n    # nums[minIndex] := the minimum number with enough index different from the current number\n    minIndex = 0\n    # nums[maxIndex] := the maximum number with enough index different from the current number\n    maxIndex = 0\n\n    for i in range(indexDifference, len(nums)):\n      if nums[i - indexDifference] < nums[minIndex]:\n        minIndex = i - indexDifference\n      if nums[i - indexDifference] > nums[maxIndex]:\n        maxIndex = i - indexDifference\n      if nums[i] - nums[minIndex] >= valueDifference:\n        return [i, minIndex]\n      if nums[maxIndex] - nums[i] >= valueDifference:\n        return [i, maxIndex]\n\n    return [-1, -1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2924, "slug": "find-champion-ii", "solutions": ["class Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        indeg = [0] * n\n        for _, v in edges:\n            indeg[v] += 1\n        return -1 if indeg.count(0) != 1 else indeg.index(0)\n", "class Solution:\n  def findChampion(self, n: int, edges: list[list[int]]) -> int:\n    inDegrees = [0] * n\n\n    for _, v in edges:\n      inDegrees[v] += 1\n\n    return (-1 if inDegrees.count(0) > 1\n            else inDegrees.index(0))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2968, "slug": "apply-operations-to-maximize-frequency-score", "solutions": ["class Solution:\n    def maxFrequencyScore(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        s = list(accumulate(nums, initial=0))\n        n = len(nums)\n        l, r = 0, n\n        while l < r:\n            mid = (l + r + 1) >> 1\n            ok = False\n            for i in range(n - mid + 1):\n                j = i + mid\n                x = nums[(i + j) // 2]\n                left = ((i + j) // 2 - i) * x - (s[(i + j) // 2] - s[i])\n                right = (s[j] - s[(i + j) // 2]) - ((j - (i + j) // 2) * x)\n                if left + right <= k:\n                    ok = True\n                    break\n            if ok:\n                l = mid\n            else:\n                r = mid - 1\n        return l\n", "class Solution:\n  def maxFrequencyScore(self, nums: list[int], k: int) -> int:\n    nums.sort()\n    ans = 0\n    cost = 0\n\n    l = 0\n    for r, num in enumerate(nums):\n      cost += num - nums[(l + r) // 2]\n      while cost > k:\n        cost -= nums[(l + r + 1) // 2] - nums[l]\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2916, "slug": "subarrays-distinct-element-sum-of-squares-ii", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2921, "slug": "maximum-profitable-triplets-with-increasing-prices-ii", "solutions": ["class BinaryIndexedTree:\n    def __init__(self, n: int):\n        self.n = n\n        self.c = [0] * (n + 1)\n\n    def update(self, x: int, v: int):\n        while x <= self.n:\n            self.c[x] = max(self.c[x], v)\n            x += x & -x\n\n    def query(self, x: int) -> int:\n        mx = 0\n        while x:\n            mx = max(mx, self.c[x])\n            x -= x & -x\n        return mx\n\n\nclass Solution:\n    def maxProfit(self, prices: List[int], profits: List[int]) -> int:\n        n = len(prices)\n        left = [0] * n\n        right = [0] * n\n\n        m = max(prices)\n        tree1 = BinaryIndexedTree(m + 1)\n        tree2 = BinaryIndexedTree(m + 1)\n\n        for i, x in enumerate(prices):\n            left[i] = tree1.query(x - 1)\n            tree1.update(x, profits[i])\n        for i in range(n - 1, -1, -1):\n            x = m + 1 - prices[i]\n            right[i] = tree2.query(x - 1)\n            tree2.update(x, profits[i])\n\n        return max(\n            (l + x + r for l, x, r in zip(left, profits, right) if l and r), default=-1\n        )\n", "class FenwickTree:\n  def __init__(self, n: int):\n    self.vals = [0] * (n + 1)\n\n  def maximize(self, i: int, val: int) -> None:\n    while i < len(self.vals):\n      self.vals[i] = max(self.vals[i], val)\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    res = 0\n    while i > 0:\n      res = max(res, self.vals[i])\n      i -= FenwickTree.lowbit(i)\n    return res\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  # Same as 2907. Maximum Profitable Triplets With Increasing Prices I\n  def maxProfit(self, prices: list[int], profits: list[int]) -> int:\n    ans = -1\n    maxPrice = max(prices)\n    maxProfitTree1 = FenwickTree(maxPrice)\n    maxProfitTree2 = FenwickTree(maxPrice)\n\n    for price, profit in zip(prices, profits):\n      # max(proftis[i])\n      maxProfit1 = maxProfitTree1.get(price - 1)\n      # max(proftis[i]) + max(profits[j])\n      maxProfit2 = maxProfitTree2.get(price - 1)\n      maxProfitTree1.maximize(price, profit)\n      if maxProfit1 > 0:\n        maxProfitTree2.maximize(price, profit + maxProfit1)\n      if maxProfit2 > 0:\n        ans = max(ans, profit + maxProfit2)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2992, "slug": "number-of-self-divisible-permutations", "solutions": ["class Solution:\n    def selfDivisiblePermutationCount(self, n: int) -> int:\n        @cache\n        def dfs(mask: int) -> int:\n            i = mask.bit_count() + 1\n            if i > n:\n                return 1\n            ans = 0\n            for j in range(1, n + 1):\n                if (mask >> j & 1) == 0 and gcd(i, j) == 1:\n                    ans += dfs(mask | 1 << j)\n            return ans\n\n        return dfs(0)\n", "class Solution:\n  def selfDivisiblePermutationCount(self, n: int) -> int:\n    def dfs(num: int, used: int) -> int:\n      if num > n:\n        return 1\n\n      count = 0\n      for i in range(1, n + 1):\n        if (used >> i & 1) == 0 and (num % i == 0 or i % num == 0):\n          count += dfs(num + 1, used | 1 << i)\n\n      return count\n\n    return dfs(1, 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2954, "slug": "count-the-number-of-infection-sequences", "solutions": ["mod = 10**9 + 7\nmx = 10**5\nfac = [1] * (mx + 1)\nfor i in range(2, mx + 1):\n    fac[i] = fac[i - 1] * i % mod\n\n\nclass Solution:\n    def numberOfSequence(self, n: int, sick: List[int]) -> int:\n        nums = [b - a - 1 for a, b in pairwise([-1] + sick + [n])]\n        ans = 1\n        s = sum(nums)\n        ans = fac[s]\n        for x in nums:\n            if x:\n                ans = ans * pow(fac[x], mod - 2, mod) % mod\n        for x in nums[1:-1]:\n            if x > 1:\n                ans = ans * pow(2, x - 1, mod) % mod\n        return ans\n", "class Solution:\n  def numberOfSequence(self, n: int, sick: list[int]) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def fact(i: int) -> int:\n      return 1 if i <= 1 else i * fact(i - 1) % MOD\n\n    @functools.lru_cache(None)\n    def inv(i: int) -> int:\n      return pow(i, MOD - 2, MOD)\n\n    ans = fact(n - len(sick))  # the number of infected children\n    prevSick = -1\n\n    for i, s in enumerate(sick):\n      # The segment [prevSick + 1, sick - 1] are the current non-infected\n      # children.\n      nonInfected = sick[i] - prevSick - 1\n      prevSick = sick[i]\n      if nonInfected == 0:\n        continue\n      ans *= inv(fact(nonInfected))\n      ans %= MOD\n      if i > 0:\n        # There're two choices per second since the children at the two\n        # endpoints can both be the infect candidates. So, there are\n        # 2^[nonInfected - 1] ways to infect all children in the current\n        # segment.\n        ans *= pow(2, nonInfected - 1, MOD)\n\n    nonInfected = n - sick[-1] - 1\n    return ans * inv(fact(nonInfected)) % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2938, "slug": "separate-black-and-white-balls", "solutions": ["class Solution:\n    def minimumSteps(self, s: str) -> int:\n        n = len(s)\n        ans = cnt = 0\n        for i in range(n - 1, -1, -1):\n            if s[i] == '1':\n                cnt += 1\n                ans += n - i - cnt\n        return ans\n", "class Solution:\n  def minimumSteps(self, s: str) -> int:\n    ans = 0\n    ones = 0\n\n    for c in s:\n      if c == '1':\n        ones += 1\n      else:  # Move 1s to the front of the current '0'.\n        ans += ones\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2925, "slug": "maximum-score-after-applying-operations-on-a-tree", "solutions": ["class Solution:\n    def maximumScoreAfterOperations(\n        self, edges: List[List[int]], values: List[int]\n    ) -> int:\n        def dfs(i: int, fa: int = -1) -> (int, int):\n            a = b = 0\n            leaf = True\n            for j in g[i]:\n                if j != fa:\n                    leaf = False\n                    aa, bb = dfs(j, i)\n                    a += aa\n                    b += bb\n            if leaf:\n                return values[i], 0\n            return values[i] + a, max(values[i] + b, a)\n\n        g = [[] for _ in range(len(values))]\n        for a, b in edges:\n            g[a].append(b)\n            g[b].append(a)\n        return dfs(0)[1]\n", "class Solution:\n  def maximumScoreAfterOperations(\n      self,\n      edges: list[list[int]],\n      values: list[int],\n  ) -> int:\n    tree = [[] for _ in values]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, prev: int) -> None:\n      if u > 0 and len(tree[u]) == 1:\n        return values[u]\n      childrenSum = sum(dfs(v, u)\n                        for v in tree[u]\n                        if v != prev)\n      return min(childrenSum, values[u])\n\n    return sum(values) - dfs(0, -1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2935, "slug": "maximum-strong-pair-xor-ii", "solutions": ["class Trie:\n    __slots__ = (\"children\", \"cnt\")\n\n    def __init__(self):\n        self.children: List[Trie | None] = [None, None]\n        self.cnt = 0\n\n    def insert(self, x: int):\n        node = self\n        for i in range(20, -1, -1):\n            v = x >> i & 1\n            if node.children[v] is None:\n                node.children[v] = Trie()\n            node = node.children[v]\n            node.cnt += 1\n\n    def search(self, x: int) -> int:\n        node = self\n        ans = 0\n        for i in range(20, -1, -1):\n            v = x >> i & 1\n            if node.children[v ^ 1] and node.children[v ^ 1].cnt:\n                ans |= 1 << i\n                node = node.children[v ^ 1]\n            else:\n                node = node.children[v]\n        return ans\n\n    def remove(self, x: int):\n        node = self\n        for i in range(20, -1, -1):\n            v = x >> i & 1\n            node = node.children[v]\n            node.cnt -= 1\n\n\nclass Solution:\n    def maximumStrongPairXor(self, nums: List[int]) -> int:\n        nums.sort()\n        tree = Trie()\n        ans = i = 0\n        for y in nums:\n            tree.insert(y)\n            while y > nums[i] * 2:\n                tree.remove(nums[i])\n                i += 1\n            ans = max(ans, tree.search(y))\n        return ans\n", "class TrieNode:\n  def __init__(self):\n    self.children: list[TrieNode | None] = [None] * 2\n    self.mn = math.inf\n    self.mx = -math.inf\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n      node.mn = min(node.mn, num)\n      node.mx = max(node.mx, num)\n\n  def getMaxXor(self, x: int) -> int:\n    \"\"\"Returns max(x ^ y) where |x - y| <= min(x, y).\n\n    If x <= y, |x - y| <= min(x, y) can be written as y - x <= x.\n    So, y <= 2 * x.\n    \"\"\"\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = x >> i & 1\n      toggleBit = bit ^ 1\n      # If `node.children[toggleBit].mx > x`, it means there's a number in the\n      # node that satisfies the condition to ensure that x <= y among x and y.\n      # If `node.children[toggleBit].mn <= 2 * x`, it means there's a number in\n      # the node that satisfies the condition for a valid y.\n      if (node.children[toggleBit] and\n          node.children[toggleBit].mx > x and\n              node.children[toggleBit].mn <= 2 * x):\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:  # There's nothing in the Bit Trie.\n        return 0\n    return maxXor\n\n\nclass Solution:\n  # Same as 2932. Maximum Strong Pair XOR I\n  def maximumStrongPairXor(self, nums: list[int]) -> int:\n    maxNum = max(nums)\n    maxBit = int(math.log2(maxNum))\n    bitTrie = BitTrie(maxBit)\n\n    for num in nums:\n      bitTrie.insert(num)\n\n    return max(bitTrie.getMaxXor(num) for num in nums)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2965, "slug": "find-missing-and-repeated-values", "solutions": ["class Solution:\n    def findMissingAndRepeatedValues(self, grid: List[List[int]]) -> List[int]:\n        n = len(grid)\n        cnt = [0] * (n * n + 1)\n        for row in grid:\n            for v in row:\n                cnt[v] += 1\n        ans = [0] * 2\n        for i in range(1, n * n + 1):\n            if cnt[i] == 2:\n                ans[0] = i\n            if cnt[i] == 0:\n                ans[1] = i\n        return ans\n", "class Solution:\n  def findMissingAndRepeatedValues(self, grid: list[list[int]]) -> list[int]:\n    count = [1] + [0] * len(grid)**2  # padding for 1-indexed\n\n    for row in grid:\n      for num in row:\n        count[num] += 1\n\n    return [count.index(2), count.index(0)]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2991, "slug": "top-three-wineries", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2934, "slug": "minimum-operations-to-maximize-last-elements-in-arrays", "solutions": ["class Solution:\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\n        def f(x: int, y: int) -> int:\n            cnt = 0\n            for a, b in zip(nums1[:-1], nums2[:-1]):\n                if a <= x and b <= y:\n                    continue\n                if not (a <= y and b <= x):\n                    return -1\n                cnt += 1\n            return cnt\n\n        a, b = f(nums1[-1], nums2[-1]), f(nums2[-1], nums1[-1])\n        return -1 if a + b == -2 else min(a, b + 1)\n", "class Solution:\n  def minOperations(self, nums1: list[int], nums2: list[int]) -> int:\n    n = len(nums1)\n    mn = min(nums1[-1], nums2[-1])\n    mx = max(nums1[-1], nums2[-1])\n    # the number of the minimum operations, where nums1[n - 1] is not swapped\n    # with nums2[n - 1]\n    dp1 = 0\n    # the number of the minimum operations, where nums1[n - 1] is swapped with\n    # nums2[n - 1]\n    dp2 = 0\n\n    for a, b in zip(nums1, nums2):\n      if min(a, b) > mn:\n        return -1\n      if max(a, b) > mx:\n        return -1\n      if a > nums1[-1] or b > nums2[-1]:\n        dp1 += 1\n      if a > nums2[-1] or b > nums1[-1]:\n        dp2 += 1\n\n    return min(dp1, dp2)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2903, "slug": "find-indices-with-index-and-value-difference-i", "solutions": ["class Solution:\n    def findIndices(\n        self, nums: List[int], indexDifference: int, valueDifference: int\n    ) -> List[int]:\n        mi = mx = 0\n        for i in range(indexDifference, len(nums)):\n            j = i - indexDifference\n            if nums[j] < nums[mi]:\n                mi = j\n            if nums[j] > nums[mx]:\n                mx = j\n            if nums[i] - nums[mi] >= valueDifference:\n                return [mi, i]\n            if nums[mx] - nums[i] >= valueDifference:\n                return [mx, i]\n        return [-1, -1]\n", "class Solution:\n  def findIndices(\n      self,\n      nums: list[int],\n      indexDifference: int,\n      valueDifference: int,\n  ) -> list[int]:\n    # nums[minIndex] := the minimum number with enough index different from the\n    # current number\n    minIndex = 0\n    # nums[maxIndex] := the maximum number with enough index different from the\n    # current number\n    maxIndex = 0\n\n    for i in range(indexDifference, len(nums)):\n      if nums[i - indexDifference] < nums[minIndex]:\n        minIndex = i - indexDifference\n      if nums[i - indexDifference] > nums[maxIndex]:\n        maxIndex = i - indexDifference\n      if nums[i] - nums[minIndex] >= valueDifference:\n        return [i, minIndex]\n      if nums[maxIndex] - nums[i] >= valueDifference:\n        return [i, maxIndex]\n\n    return [-1, -1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2980, "slug": "check-if-bitwise-or-has-trailing-zeros", "solutions": ["class Solution:\n    def hasTrailingZeros(self, nums: List[int]) -> bool:\n        return sum(x & 1 ^ 1 for x in nums) >= 2\n", "class Solution:\n  def hasTrailingZeros(self, nums: list[int]) -> bool:\n    return sum(num % 2 == 0 for num in nums) >= 2\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2977, "slug": "minimum-cost-to-convert-string-ii", "solutions": ["class Node:\n    __slots__ = [\"children\", \"v\"]\n\n    def __init__(self):\n        self.children: List[Node | None] = [None] * 26\n        self.v = -1\n\n\nclass Solution:\n    def minimumCost(\n        self,\n        source: str,\n        target: str,\n        original: List[str],\n        changed: List[str],\n        cost: List[int],\n    ) -> int:\n        m = len(cost)\n        g = [[inf] * (m << 1) for _ in range(m << 1)]\n        for i in range(m << 1):\n            g[i][i] = 0\n        root = Node()\n        idx = 0\n\n        def insert(w: str) -> int:\n            node = root\n            for c in w:\n                i = ord(c) - ord(\"a\")\n                if node.children[i] is None:\n                    node.children[i] = Node()\n                node = node.children[i]\n            if node.v < 0:\n                nonlocal idx\n                node.v = idx\n                idx += 1\n            return node.v\n\n        @cache\n        def dfs(i: int) -> int:\n            if i >= len(source):\n                return 0\n            res = dfs(i + 1) if source[i] == target[i] else inf\n            p = q = root\n            for j in range(i, len(source)):\n                p = p.children[ord(source[j]) - ord(\"a\")]\n                q = q.children[ord(target[j]) - ord(\"a\")]\n                if p is None or q is None:\n                    break\n                if p.v < 0 or q.v < 0:\n                    continue\n                res = min(res, dfs(j + 1) + g[p.v][q.v])\n            return res\n\n        for x, y, z in zip(original, changed, cost):\n            x = insert(x)\n            y = insert(y)\n            g[x][y] = min(g[x][y], z)\n        for k in range(idx):\n            for i in range(idx):\n                if g[i][k] >= inf:\n                    continue\n                for j in range(idx):\n                    # g[i][j] = min(g[i][j], g[i][k] + g[k][j])\n                    if g[i][k] + g[k][j] < g[i][j]:\n                        g[i][j] = g[i][k] + g[k][j]\n\n        ans = dfs(0)\n        return -1 if ans >= inf else ans\n", "class Solution:\n  def minimumCost(\n      self,\n      source: str,\n      target: str,\n      original: list[str],\n      changed: list[str],\n      cost: list[int],\n  ) -> int:\n    subLengths = set(len(s) for s in original)\n    subToId = self._getSubToId(original, changed)\n    subCount = len(subToId)\n    # dist[u][v] := the minimum distance to change the substring with id u to\n    # the substring with id v\n    dist = [[math.inf for _ in range(subCount)] for _ in range(subCount)]\n    # dp[i] := the minimum cost to change the first i letters of `source` into\n    # `target`, leaving the suffix untouched\n    dp = [math.inf for _ in range(len(source) + 1)]\n\n    for a, b, c in zip(original, changed, cost):\n      u = subToId[a]\n      v = subToId[b]\n      dist[u][v] = min(dist[u][v], c)\n\n    for k in range(subCount):\n      for i in range(subCount):\n        if dist[i][k] < math.inf:\n          for j in range(subCount):\n            if dist[k][j] < math.inf:\n              dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    dp[0] = 0\n\n    for i, (s, t) in enumerate(zip(source, target)):\n      if dp[i] == math.inf:\n        continue\n      if s == t:\n        dp[i + 1] = min(dp[i + 1], dp[i])\n      for subLength in subLengths:\n        if i + subLength > len(source):\n          continue\n        subSource = source[i:i + subLength]\n        subTarget = target[i:i + subLength]\n        if subSource not in subToId or subTarget not in subToId:\n          continue\n        u = subToId[subSource]\n        v = subToId[subTarget]\n        if dist[u][v] != math.inf:\n          dp[i + subLength] = min(dp[i + subLength], dp[i] + dist[u][v])\n\n    return -1 if dp[len(source)] == math.inf else dp[len(source)]\n\n  def _getSubToId(self, original: str, changed: str) -> dict[str, int]:\n    subToId = {}\n    for s in original + changed:\n      if s not in subToId:\n        subToId[s] = len(subToId)\n    return subToId\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2982, "slug": "find-longest-special-substring-that-occurs-thrice-ii", "solutions": ["class Solution:\n    def maximumLength(self, s: str) -> int:\n        def check(x: int) -> bool:\n            cnt = defaultdict(int)\n            i = 0\n            while i < n:\n                j = i + 1\n                while j < n and s[j] == s[i]:\n                    j += 1\n                cnt[s[i]] += max(0, j - i - x + 1)\n                i = j\n            return max(cnt.values()) >= 3\n\n        n = len(s)\n        l, r = 0, n\n        while l < r:\n            mid = (l + r + 1) >> 1\n            if check(mid):\n                l = mid\n            else:\n                r = mid - 1\n        return -1 if l == 0 else l\n", "class Solution:\n  def maximumLength(self, s: str) -> int:\n    n = len(s)\n    runningLen = 0\n    prevLetter = '@'\n    # counts[i][j] := the frequency of ('a' + i) repeating j times\n    counts = [[0] * (n + 1) for _ in range(26)]\n\n    for c in s:\n      if c == prevLetter:\n        runningLen += 1\n        counts[ord(c) - ord('a')][runningLen] += 1\n      else:\n        runningLen = 1\n        counts[ord(c) - ord('a')][runningLen] += 1\n        prevLetter = c\n\n    def getMaxFreq(count: list[int]) -> int:\n      \"\"\"Returns the maximum frequency that occurs more than three times.\"\"\"\n      times = 0\n      for freq in range(n, 0, -1):\n        times += count[freq]\n        if times >= 3:\n          return freq\n      return -1\n\n    return max(getMaxFreq(count) for count in counts)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2976, "slug": "minimum-cost-to-convert-string-i", "solutions": ["class Solution:\n    def minimumCost(\n        self,\n        source: str,\n        target: str,\n        original: List[str],\n        changed: List[str],\n        cost: List[int],\n    ) -> int:\n        g = [[inf] * 26 for _ in range(26)]\n        for i in range(26):\n            g[i][i] = 0\n        for x, y, z in zip(original, changed, cost):\n            x = ord(x) - ord('a')\n            y = ord(y) - ord('a')\n            g[x][y] = min(g[x][y], z)\n        for k in range(26):\n            for i in range(26):\n                for j in range(26):\n                    g[i][j] = min(g[i][j], g[i][k] + g[k][j])\n        ans = 0\n        for a, b in zip(source, target):\n            if a != b:\n                x, y = ord(a) - ord('a'), ord(b) - ord('a')\n                if g[x][y] >= inf:\n                    return -1\n                ans += g[x][y]\n        return ans\n", "class Solution:\n  def minimumCost(\n      self,\n      source: str,\n      target: str,\n      original: list[str],\n      changed: list[str],\n      cost: list[int],\n  ) -> int:\n    ans = 0\n    # dist[u][v] := the minimum distance to change ('a' + u) to ('a' + v)\n    dist = [[math.inf] * 26 for _ in range(26)]\n\n    for a, b, c in zip(original, changed, cost):\n      u = ord(a) - ord('a')\n      v = ord(b) - ord('a')\n      dist[u][v] = min(dist[u][v], c)\n\n    for k in range(26):\n      for i in range(26):\n        if dist[i][k] < math.inf:\n          for j in range(26):\n            if dist[k][j] < math.inf:\n              dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    for s, t in zip(source, target):\n      if s == t:\n        continue\n      u = ord(s) - ord('a')\n      v = ord(t) - ord('a')\n      if dist[u][v] == math.inf:\n        return -1\n      ans += dist[u][v]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2952, "slug": "minimum-number-of-coins-to-be-added", "solutions": ["class Solution:\n    def minimumAddedCoins(self, coins: List[int], target: int) -> int:\n        coins.sort()\n        s = 1\n        ans = i = 0\n        while s <= target:\n            if i < len(coins) and coins[i] <= s:\n                s += coins[i]\n                i += 1\n            else:\n                s <<= 1\n                ans += 1\n        return ans\n", "class Solution:\n  # Same as 330. Patching Array\n  def minimumAddedCoins(self, coins: list[int], target: int) -> int:\n    ans = 0\n    i = 0  # coins' index\n    miss = 1  # the minimum sum in [1, n] we might miss\n\n    coins.sort()\n\n    while miss <= target:\n      if i < len(coins) and coins[i] <= miss:\n        miss += coins[i]\n        i += 1\n      else:\n        # Greedily add `miss` itself to increase the range from\n        # [1, miss) to [1, 2 * miss).\n        miss += miss\n        ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2937, "slug": "make-three-strings-equal", "solutions": ["class Solution:\n    def findMinimumOperations(self, s1: str, s2: str, s3: str) -> int:\n        s = len(s1) + len(s2) + len(s3)\n        n = min(len(s1), len(s2), len(s3))\n        for i in range(n):\n            if not s1[i] == s2[i] == s3[i]:\n                return -1 if i == 0 else s - 3 * i\n        return s - 3 * n\n", "class Solution:\n  def findMinimumOperations(self, s1: str, s2: str, s3: str) -> int:\n    minLength = min(map(len, [s1, s2, s3]))\n    i = 0\n    while i < minLength and s1[i] == s2[i] and s2[i] == s3[i]:\n      i += 1\n    return -1 if i == 0 else len(s1) + len(s2) + len(s3) - i * 3\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2913, "slug": "subarrays-distinct-element-sum-of-squares-i", "solutions": ["class Solution:\n    def sumCounts(self, nums: List[int]) -> int:\n        ans, n = 0, len(nums)\n        for i in range(n):\n            s = set()\n            for j in range(i, n):\n                s.add(nums[j])\n                ans += len(s) * len(s)\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2936, "slug": "number-of-equal-numbers-blocks", "solutions": ["# Definition for BigArray.\n# class BigArray:\n#     def at(self, index: long) -> int:\n#         pass\n#     def size(self) -> long:\n#         pass\nclass Solution(object):\n    def countBlocks(self, nums: Optional[\"BigArray\"]) -> int:\n        i, n = 0, nums.size()\n        ans = 0\n        while i < n:\n            ans += 1\n            x = nums.at(i)\n            if i + 1 < n and nums.at(i + 1) != x:\n                i += 1\n            else:\n                i += bisect_left(range(i, n), True, key=lambda j: nums.at(j) != x)\n        return ans\n", "# Definition for BigArray.\n# class BigArray:\n#   def at(self, index: long) -> int:\n#     pass\n#   def size(self) -> long:\n#     pass\n\nclass Solution(object):\n  def countBlocks(self, nums: Optional['BigArray']) -> int:\n    def countBlocks(l: int, r: int, leftValue: int, rightValue: int) -> int:\n      \"\"\"Returns the number of maximal blocks in nums[l..r].\"\"\"\n      if leftValue == rightValue:\n        return 1\n      if l + 1 == r:\n        return 2\n      m = (l + r) // 2\n      midValue = nums.at(m)\n      return (countBlocks(l, m, leftValue, midValue) +\n              countBlocks(m, r, midValue, rightValue) - 1)\n    # Substract nums[m], which will be counted twice.\n    return countBlocks(0, nums.size() - 1,\n                       nums.at(0), nums.at(nums.size() - 1))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2978, "slug": "symmetric-coordinates", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2995, "slug": "viewers-turned-streamers", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2927, "slug": "distribute-candies-among-children-iii", "solutions": ["class Solution:\n    def distributeCandies(self, n: int, limit: int) -> int:\n        if n > 3 * limit:\n            return 0\n        ans = comb(n + 2, 2)\n        if n > limit:\n            ans -= 3 * comb(n - limit + 1, 2)\n        if n - 2 >= 2 * limit:\n            ans += 3 * comb(n - 2 * limit, 2)\n        return ans\n", "class Solution:\n  def distributeCandies(self, n: int, limit: int) -> int:\n    def ways(n: int) -> int:\n      \"\"\"Returns the number of ways to distribute n candies to 3 children.\"\"\"\n      if n < 0:\n        return 0\n      # Stars and bars method:\n      # e.g. '**|**|*' means to distribute 5 candies to 3 children, where\n      # stars (*) := candies and bars (|) := dividers between children.\n      return math.comb(n + 2, 2)\n\n    limitPlusOne = limit + 1\n    oneChildExceedsLimit = ways(n - limitPlusOne)\n    twoChildrenExceedLimit = ways(n - 2 * limitPlusOne)\n    threeChildrenExceedLimit = ways(n - 3 * limitPlusOne)\n    # Principle of Inclusion-Exclusion (PIE)\n    return (ways(n)\n            - 3 * oneChildExceedsLimit\n            + 3 * twoChildrenExceedLimit\n            - threeChildrenExceedLimit)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2962, "slug": "count-subarrays-where-max-element-appears-at-least-k-times", "solutions": ["class Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        mx = max(nums)\n        n = len(nums)\n        ans = cnt = j = 0\n        for x in nums:\n            while j < n and cnt < k:\n                cnt += nums[j] == mx\n                j += 1\n            if cnt < k:\n                break\n            ans += n - j + 1\n            cnt -= x == mx\n        return ans\n", "class Solution:\n  def countSubarrays(self, nums: list[int], k: int) -> int:\n    maxNum = max(nums)\n    ans = 0\n    count = 0\n\n    l = 0\n    for r, num in enumerate(nums):\n      if num == maxNum:\n        count += 1\n      # Keep the window to include k - 1 times of the maxNummum number.\n      while count == k:\n        if nums[l] == maxNum:\n          count -= 1\n        l += 1\n      # If l > 0, nums[l:r+1] has k - 1 times of the maxNummum number. For any\n      # subarray nums[i:r+1], where i < l, it will have at least k times of the\n      # maxNummum number, since nums[l - 1] equals the maxNummum number.\n      ans += l\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2915, "slug": "length-of-the-longest-subsequence-that-sums-to-target", "solutions": ["class Solution:\n    def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        f = [[-inf] * (target + 1) for _ in range(n + 1)]\n        f[0][0] = 0\n        for i, x in enumerate(nums, 1):\n            for j in range(target + 1):\n                f[i][j] = f[i - 1][j]\n                if j >= x:\n                    f[i][j] = max(f[i][j], f[i - 1][j - x] + 1)\n        return -1 if f[n][target] <= 0 else f[n][target]\n", "class Solution:\n  def lengthOfLongestSubsequence(self, nums: list[int], target: int) -> int:\n    # dp[i] := the maximum length of any subsequence of numbers so far that\n    # sum to j\n    dp = [0] * (target + 1)\n\n    for num in nums:\n      for i in range(target, num - 1, -1):\n        if i == num or dp[i - num] > 0:\n          dp[i] = max(dp[i], 1 + dp[i - num])\n\n    return dp[target] if dp[target] > 0 else -1\n", "class Solution:\n  def lengthOfLongestSubsequence(self, nums: list[int], target: int) -> int:\n    n = len(nums)\n    # dp[i][j] := the maximum length of any subsequence of the first i numbers\n    # that sum to j\n    dp = [[-1] * (target + 1) for _ in range(n + 1)]\n\n    for i in range(n + 1):\n      dp[i][0] = 0\n\n    for i in range(1, n + 1):\n      num = nums[i - 1]\n      for j in range(1, target + 1):\n        # 1. Skip `num`.\n        if j < num or dp[i - 1][j - num] == -1:\n          dp[i][j] = dp[i - 1][j]\n        # 2. Skip `num` or pick `num`.\n        else:\n          dp[i][j] = max(dp[i - 1][j], 1 + dp[i - 1][j - num])\n\n    return dp[n][target]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2910, "slug": "minimum-number-of-groups-to-create-a-valid-assignment", "solutions": ["class Solution:\n    def minGroupsForValidAssignment(self, nums: List[int]) -> int:\n        cnt = Counter(nums)\n        for k in range(min(cnt.values()), 0, -1):\n            ans = 0\n            for v in cnt.values():\n                if v // k < v % k:\n                    ans = 0\n                    break\n                ans += (v + k) // (k + 1)\n            if ans:\n                return ans\n", "class Solution:\n  def minGroupsForValidAssignment(self, nums: list[int]) -> int:\n    count = collections.Counter(nums)\n    minFreq = min(count.values())\n\n    for groupSize in range(minFreq, 0, -1):\n      numGroups = self.getNumGroups(count, groupSize)\n      if numGroups > 0:\n        return numGroups\n\n    raise ValueError(\"Invalid argument\")\n\n  def getNumGroups(self, count: dict[int, int], groupSize: int) -> int:\n    \"\"\"Returns the number of groups if each group's size is `groupSize` or `groupSize + 1`.\"\"\"\n    numGroups = 0\n    for freq in count.values():\n      a = freq // (groupSize + 1)\n      b = freq % (groupSize + 1)\n      if b == 0:\n        # Assign 1 number from `groupSize - b` out of `a` groups to this group,\n        # so we'll have `a - (groupSize - b)` groups of size `groupSize + 1`\n        # and `groupSize - b + 1` groups of size `groupSize`. In total, we have\n        # `a + 1` groups.\n        numGroups += a\n      elif groupSize - b <= a:\n        numGroups += a + 1\n      else:\n        return 0\n    return numGroups\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2931, "slug": "maximum-spending-after-buying-items", "solutions": ["class Solution:\n    def maxSpending(self, values: List[List[int]]) -> int:\n        n = len(values[0])\n        pq = [(row[-1], i, n - 1) for i, row in enumerate(values)]\n        heapify(pq)\n        ans = d = 0\n        while pq:\n            d += 1\n            v, i, j = heappop(pq)\n            ans += v * d\n            if j:\n                heappush(pq, (values[i][j - 1], i, j - 1))\n        return ans\n", "class Solution:\n  def maxSpending(self, values: list[list[int]]) -> int:\n    items = sorted(item for shop in values for item in shop)\n    return sum(item * d for d, item in enumerate(items, 1))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2984, "slug": "find-peak-calling-hours-for-each-city", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2922, "slug": "market-analysis-iii", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2945, "slug": "find-maximum-non-decreasing-array-length", "solutions": ["class Solution:\n    def findMaximumLength(self, nums: List[int]) -> int:\n        n = len(nums)\n        s = list(accumulate(nums, initial=0))\n        f = [0] * (n + 1)\n        pre = [0] * (n + 2)\n        for i in range(1, n + 1):\n            pre[i] = max(pre[i], pre[i - 1])\n            f[i] = f[pre[i]] + 1\n            j = bisect_left(s, s[i] * 2 - s[pre[i]])\n            pre[j] = i\n        return f[n]\n", "class Solution:\n  def findMaximumLength(self, nums: list[int]) -> int:\n    n = len(nums)\n    # prefix[i] := the sum of the first i nums\n    prefix = list(itertools.accumulate(nums, initial=0))\n    # dp[i] := the maximum number of elements in the increasing\n    # sequence after processing the first i nums\n    dp = [0] * (n + 1)\n    # bestLeft[i] := the index l s.t. merging nums[l..i) is the\n    # optimal strategy among processing the first i nums\n    bestLeft = [0] * (n + 2)\n\n    for i in range(1, n + 1):\n      bestLeft[i] = max(bestLeft[i], bestLeft[i - 1])\n      # When merging nums[l, i), consider the next segment as [i, r).\n      # Find the minimum `r` where sum(nums[l, i)) <= sum(nums[i, r)).\n      # Equivalently, prefix[i] - prefix[l] <= prefix[r] - prefix[i].\n      #            => prefix[r] >= prefix[i] * 2 - prefix[l]\n      # Therefore, we can binary search `prefix` to find the minimum `r`.\n      l = bestLeft[i]\n      r = bisect.bisect_left(prefix, 2 * prefix[i] - prefix[l])\n      dp[i] = dp[l] + 1\n      bestLeft[r] = i\n\n    return dp[n]\n", "class Solution:\n  def findMaximumLength(self, nums: list[int]) -> int:\n    n = len(nums)\n    INF = 10_000_000_000\n    # prefix[i] := the sum of the first i nums\n    prefix = list(itertools.accumulate(nums, initial=0))\n    # dp[i] := the maximum number of elements in the increasing\n    # sequence after processing the first i nums\n    dp = [0] * (n + 1)\n    # last[i] := the last sum after processing the first i nums\n    last = [0] + [INF] * n\n\n    for i in range(n):\n      j = self._findIndex(i, prefix, last)\n      dp[i + 1] = max(dp[i], dp[j] + 1)\n      last[i + 1] = prefix[i + 1] - prefix[j]\n\n    return dp[n]\n\n  def _findIndex(self, i: int, prefix: list[int], last: list[int]) -> int:\n    \"\"\"Returns the index in [0..i].\n\n    Returns the maximum index j in [0..i] s.t.\n    prefix[i + 1] - prefix[j] >= last[j].\n    \"\"\"\n    for j in range(i, -1, -1):\n      if prefix[i + 1] - prefix[j] >= last[j]:\n        return j\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2963, "slug": "count-the-number-of-good-partitions", "solutions": ["class Solution:\n    def numberOfGoodPartitions(self, nums: List[int]) -> int:\n        last = {x: i for i, x in enumerate(nums)}\n        mod = 10**9 + 7\n        j, k = -1, 0\n        for i, x in enumerate(nums):\n            j = max(j, last[x])\n            k += i == j\n        return pow(2, k - 1, mod)\n", "class Solution:\n  def numberOfGoodPartitions(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    ans = 1\n    # lastSeen[num] := the index of the last time `num` appeared\n    lastSeen = {}\n\n    for i, num in enumerate(nums):\n      lastSeen[num] = i\n\n    # Track the maximum right index of each running partition by ensuring that\n    # the first and last occurrences of a number fall within the same partition.\n    maxRight = 0\n    for i, num in enumerate(nums):\n      if i > maxRight:\n        # Start a new partition that starts from nums[i].\n        # Each partition doubles the total number of good partitions.\n        ans = ans * 2 % MOD\n      maxRight = max(maxRight, lastSeen[num])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2908, "slug": "minimum-sum-of-mountain-triplets-i", "solutions": ["class Solution:\n    def minimumSum(self, nums: List[int]) -> int:\n        n = len(nums)\n        right = [inf] * (n + 1)\n        for i in range(n - 1, -1, -1):\n            right[i] = min(right[i + 1], nums[i])\n        ans = left = inf\n        for i, x in enumerate(nums):\n            if left < x and right[i + 1] < x:\n                ans = min(ans, left + x + right[i + 1])\n            left = min(left, x)\n        return -1 if ans == inf else ans\n", "class Solution:\n  # Same as 2908. Minimum Sum of Mountain Triplets I\n  def minimumSum(self, nums: list[int]) -> int:\n    ans = math.inf\n    minPrefix = list(itertools.accumulate(nums, min))\n    minSuffix = list(itertools.accumulate(reversed(nums), min))[::-1]\n\n    for i, num in enumerate(nums):\n      if num > minPrefix[i] and num > minSuffix[i]:\n        ans = min(ans, num + minPrefix[i] + minSuffix[i])\n\n    return -1 if ans == math.inf else ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2912, "slug": "number-of-ways-to-reach-destination-in-the-grid", "solutions": ["class Solution:\n    def numberOfWays(\n        self, n: int, m: int, k: int, source: List[int], dest: List[int]\n    ) -> int:\n        mod = 10**9 + 7\n        a, b, c, d = 1, 0, 0, 0\n        for _ in range(k):\n            aa = ((n - 1) * b + (m - 1) * c) % mod\n            bb = (a + (n - 2) * b + (m - 1) * d) % mod\n            cc = (a + (m - 2) * c + (n - 1) * d) % mod\n            dd = (b + c + (n - 2) * d + (m - 2) * d) % mod\n            a, b, c, d = aa, bb, cc, dd\n        if source[0] == dest[0]:\n            return a if source[1] == dest[1] else c\n        return b if source[1] == dest[1] else d\n", "class Solution:\n  def numberOfWays(\n      self,\n      n: int,\n      m: int,\n      k: int,\n      source: list[int],\n      dest: list[int],\n  ) -> int:\n    MOD = 1_000_000_007\n    # the number of ways of `source` to `dest` using steps so far\n    ans = int(source == dest)\n    # the number of ways of `source` to dest's row using steps so far\n    row = int(source[0] == dest[0] and source[1] != dest[1])\n    # the number of ways of `source` to dest's col using steps so far\n    col = int(source[0] != dest[0] and source[1] == dest[1])\n    # the number of ways of `source` to others using steps so far\n    others = int(source[0] != dest[0] and source[1] != dest[1])\n\n    for _ in range(k):\n      nextAns = (row + col) % MOD\n      nextRow = (ans * (m - 1) +  # -self\n                 row * (m - 2) +  # -self, -center\n                 others) % MOD\n      nextCol = (ans * (n - 1) +  # -self\n                 col * (n - 2) +  # -self, -center\n                 others) % MOD\n      nextOthers = (row * (n - 1) +  # -self\n                    col * (m - 1) +  # -self\n                    others * (m + n - 1 - 3)) % MOD  # -self, -row, -col\n      ans = nextAns\n      row = nextRow\n      col = nextCol\n      others = nextOthers\n\n    return ans\n", "class Solution:\n  def numberOfWays(\n      self,\n      n: int,\n      m: int,\n      k: int,\n      source: list[int],\n      dest: list[int],\n  ) -> int:\n    MOD = 1_000_000_007\n    # dp[i][0] := the the number of ways of `source` to `dest` using i steps\n    # dp[i][1] := the the number of ways of `source` to dest's row using i steps\n    # dp[i][2] := the the number of ways of `source` to dest's col using i steps\n    # dp[i][3] := the the number of ways of `source` to others using i steps\n    dp = [[0] * 4 for _ in range(k + 1)]\n    if source == dest:\n      dp[0][0] = 1\n    elif source[0] == dest[0]:\n      dp[0][1] = 1\n    elif source[1] == dest[1]:\n      dp[0][2] = 1\n    else:\n      dp[0][3] = 1\n\n    for i in range(1, k + 1):\n      dp[i][0] = (dp[i - 1][1] + dp[i - 1][2]) % MOD\n      dp[i][1] = (dp[i - 1][0] * (m - 1) +  # -self\n                  dp[i - 1][1] * (m - 2) +  # -self, -center\n                  dp[i - 1][3]) % MOD\n      dp[i][2] = (dp[i - 1][0] * (n - 1) +  # -self\n                  dp[i - 1][2] * (n - 2) +  # -self, -center\n                  dp[i - 1][3]) % MOD\n      dp[i][3] = (dp[i - 1][1] * (n - 1) +  # -self\n                  dp[i - 1][2] * (m - 1) +  # -self\n                  dp[i - 1][3] * (m + n - 1 - 3)) % MOD  # -self, -row, -col\n\n    return dp[k][0]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2994, "slug": "friday-purchases-ii", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2947, "slug": "count-beautiful-substrings-i", "solutions": ["class Solution:\n    def beautifulSubstrings(self, s: str, k: int) -> int:\n        n = len(s)\n        vs = set(\"aeiou\")\n        ans = 0\n        for i in range(n):\n            vowels = 0\n            for j in range(i, n):\n                vowels += s[j] in vs\n                consonants = j - i + 1 - vowels\n                if vowels == consonants and vowels * consonants % k == 0:\n                    ans += 1\n        return ans\n", "class Solution:\n  def beautifulSubstrings(self, s: str, k: int) -> int:\n    VOWELS = 'aeiou'\n    root = self._getRoot(k)\n    ans = 0\n    vowels = 0\n    vowelsMinusConsonants = 0\n    # {(vowels, vowelsMinusConsonants): count}\n    prefixCount = collections.Counter({(0, 0): 1})\n\n    for c in s:\n      if c in VOWELS:\n        vowelsMinusConsonants += 1\n        vowels = (vowels + 1) % root\n      else:\n        vowelsMinusConsonants -= 1\n      ans += prefixCount[(vowels, vowelsMinusConsonants)]\n      prefixCount[(vowels, vowelsMinusConsonants)] += 1\n\n    return ans\n\n  def _getRoot(self, k: int) -> int:\n    for i in range(1, k + 1):\n      if i * i % k == 0:\n        return i\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2989, "slug": "class-performance", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2298, "slug": "tasks-count-in-the-weekend", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2244, "slug": "minimum-rounds-to-complete-all-tasks", "solutions": ["class Solution:\n    def minimumRounds(self, tasks: List[int]) -> int:\n        cnt = Counter(tasks)\n        ans = 0\n        for v in cnt.values():\n            if v == 1:\n                return -1\n            ans += v // 3 + (v % 3 != 0)\n        return ans\n", "class Solution:\n  def minimumRounds(self, tasks: list[int]) -> int:\n    freqs = collections.Counter(tasks).values()\n    return -1 if 1 in freqs else sum((f + 2) // 3 for f in freqs)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2236, "slug": "root-equals-sum-of-children", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\n        return root.val == root.left.val + root.right.val\n", "class Solution:\n  def checkTree(self, root: TreeNode | None) -> bool:\n    return root.val == root.left.val + root.right.val\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2289, "slug": "steps-to-make-array-non-decreasing", "solutions": ["class Solution:\n    def totalSteps(self, nums: List[int]) -> int:\n        stk = []\n        ans, n = 0, len(nums)\n        dp = [0] * n\n        for i in range(n - 1, -1, -1):\n            while stk and nums[i] > nums[stk[-1]]:\n                dp[i] = max(dp[i] + 1, dp[stk.pop()])\n            stk.append(i)\n        return max(dp)\n", "class Solution:\n  def totalSteps(self, nums: list[int]) -> int:\n    # dp[i] := the number of steps to remove nums[i]\n    dp = [0] * len(nums)\n    stack = []\n\n    for i, num in enumerate(nums):\n      step = 1\n      while stack and nums[stack[-1]] <= num:\n        step = max(step, dp[stack.pop()] + 1)\n      if stack:\n        dp[i] = step\n      stack.append(i)\n\n    return max(dp)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2242, "slug": "maximum-score-of-a-node-sequence", "solutions": ["class Solution:\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\n        g = defaultdict(list)\n        for a, b in edges:\n            g[a].append(b)\n            g[b].append(a)\n        for k in g.keys():\n            g[k] = nlargest(3, g[k], key=lambda x: scores[x])\n        ans = -1\n        for a, b in edges:\n            for c in g[a]:\n                for d in g[b]:\n                    if b != c != d != a:\n                        t = scores[a] + scores[b] + scores[c] + scores[d]\n                        ans = max(ans, t)\n        return ans\n", "class Solution:\n  def maximumScore(self, scores: list[int], edges: list[list[int]]) -> int:\n    n = len(scores)\n    ans = -1\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append((scores[v], v))\n      graph[v].append((scores[u], u))\n\n    for i in range(n):\n      graph[i] = heapq.nlargest(3, graph[i])\n\n    # To find the target sequence: a - u - v - b, enumerate each edge (u, v),\n    # and find a (u's child) and b (v's child). That's why we find the 3\n    # children that have the highest scores because one of the 3 children is\n    # guaranteed to be valid.\n    for u, v in edges:\n      for scoreA, a in graph[u]:\n        for scoreB, b in graph[v]:\n          if a != b and a != v and b != u:\n            ans = max(ans, scoreA + scores[u] + scores[v] + scoreB)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2228, "slug": "users-with-two-purchases-within-seven-days", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2277, "slug": "closest-node-to-path-in-tree", "solutions": ["class Solution:\n  def closestNode(\n      self,\n      n: int,\n      edges: list[list[int]],\n      query: list[list[int]],\n  ) -> list[int]:\n    tree = [[] for _ in range(n)]\n    dist = [[-1] * n for _ in range(n)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def fillDist(start: int, u: int, d: int) -> None:\n      dist[start][u] = d\n      for v in tree[u]:\n        if dist[start][v] == -1:\n          fillDist(start, v, d + 1)\n\n    for i in range(n):\n      fillDist(i, i, 0)\n\n    def findClosest(u: int, end: int, node: int, ans: int) -> int:\n      for v in tree[u]:\n        if dist[v][end] < dist[u][end]:\n          return findClosest(\n              v, end, node, ans if dist[ans][node] < dist[v][node] else v)\n      return ans\n\n    return [findClosest(start, end, node, start)\n            for start, end, node in query]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2296, "slug": "design-a-text-editor", "solutions": ["class TextEditor:\n    def __init__(self):\n        self.left = []\n        self.right = []\n\n    def addText(self, text: str) -> None:\n        self.left.extend(list(text))\n\n    def deleteText(self, k: int) -> int:\n        k = min(k, len(self.left))\n        for _ in range(k):\n            self.left.pop()\n        return k\n\n    def cursorLeft(self, k: int) -> str:\n        k = min(k, len(self.left))\n        for _ in range(k):\n            self.right.append(self.left.pop())\n        return ''.join(self.left[-10:])\n\n    def cursorRight(self, k: int) -> str:\n        k = min(k, len(self.right))\n        for _ in range(k):\n            self.left.append(self.right.pop())\n        return ''.join(self.left[-10:])\n\n\n# Your TextEditor object will be instantiated and called as such:\n# obj = TextEditor()\n# obj.addText(text)\n# param_2 = obj.deleteText(k)\n# param_3 = obj.cursorLeft(k)\n# param_4 = obj.cursorRight(k)\n", "class TextEditor:\n  def __init__(self):\n    self.s = []\n    self.stack = []\n\n  def addText(self, text: str) -> None:\n    for c in text:\n      self.s.append(c)\n\n  def deleteText(self, k: int) -> int:\n    numDeleted = min(k, len(self.s))\n    for _ in range(numDeleted):\n      self.s.pop()\n    return numDeleted\n\n  def cursorLeft(self, k: int) -> str:\n    while self.s and k > 0:\n      self.stack.append(self.s.pop())\n      k -= 1\n    return self._getString()\n\n  def cursorRight(self, k: int) -> str:\n    while self.stack and k > 0:\n      self.s.append(self.stack.pop())\n      k -= 1\n    return self._getString()\n\n  def _getString(self) -> str:\n    if len(self.s) < 10:\n      return ''.join(self.s)\n    return ''.join(self.s[-10:])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2211, "slug": "count-collisions-on-a-road", "solutions": ["class Solution:\n    def countCollisions(self, directions: str) -> int:\n        s = directions.lstrip(\"L\").rstrip(\"R\")\n        return len(s) - s.count(\"S\")\n", "class Solution:\n  def countCollisions(self, directions: str) -> int:\n    l = 0\n    r = len(directions) - 1\n\n    while l < len(directions) and directions[l] == 'L':\n      l += 1\n\n    while r >= 0 and directions[r] == 'R':\n      r -= 1\n\n    return sum(c != 'S' for c in directions[l:r + 1])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2226, "slug": "maximum-candies-allocated-to-k-children", "solutions": ["class Solution:\n    def maximumCandies(self, candies: List[int], k: int) -> int:\n        l, r = 0, max(candies)\n        while l < r:\n            mid = (l + r + 1) >> 1\n            if sum(x // mid for x in candies) >= k:\n                l = mid\n            else:\n                r = mid - 1\n        return l\n", "class Solution:\n  def maximumCandies(self, candies: list[int], k: int) -> int:\n    l = 1\n    r = sum(candies) // k\n\n    def numChildren(m: int) -> bool:\n      return sum(c // m for c in candies)\n\n    while l < r:\n      m = (l + r) // 2\n      if numChildren(m) < k:\n        r = m\n      else:\n        l = m + 1\n\n    return l if numChildren(l) >= k else l - 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2281, "slug": "sum-of-total-strength-of-wizards", "solutions": ["class Solution:\n    def totalStrength(self, strength: List[int]) -> int:\n        n = len(strength)\n        left = [-1] * n\n        right = [n] * n\n        stk = []\n        for i, v in enumerate(strength):\n            while stk and strength[stk[-1]] >= v:\n                stk.pop()\n            if stk:\n                left[i] = stk[-1]\n            stk.append(i)\n        stk = []\n        for i in range(n - 1, -1, -1):\n            while stk and strength[stk[-1]] > strength[i]:\n                stk.pop()\n            if stk:\n                right[i] = stk[-1]\n            stk.append(i)\n\n        ss = list(accumulate(list(accumulate(strength, initial=0)), initial=0))\n        mod = int(1e9) + 7\n        ans = 0\n        for i, v in enumerate(strength):\n            l, r = left[i] + 1, right[i] - 1\n            a = (ss[r + 2] - ss[i + 1]) * (i - l + 1)\n            b = (ss[i + 1] - ss[l]) * (r - i + 1)\n            ans = (ans + (a - b) * v) % mod\n        return ans\n", "class Solution:\n  def totalStrength(self, strength: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(strength)\n    # left[i] := the next index on the left (if any)\n    #            s.t. nums[left[i]] <= nums[i]\n    left = [-1] * n\n    # right[i] := the next index on the right (if any)\n    #             s.t. nums[right[i]] < nums[i]\n    right = [n] * n\n    stack = []\n\n    for i in reversed(range(n)):\n      while stack and strength[stack[-1]] >= strength[i]:\n        left[stack.pop()] = i\n      stack.append(i)\n\n    stack = []\n\n    for i in range(n):\n      while stack and strength[stack[-1]] > strength[i]:\n        right[stack.pop()] = i\n      stack.append(i)\n\n    ans = 0\n    prefixOfPrefix = list(itertools.accumulate(\n        itertools.accumulate(strength), initial=0))\n\n    # For each strength[i] as the minimum, calculate sum.\n    for i, (l, r) in enumerate(zip(left, right)):\n      leftSum = prefixOfPrefix[i] - prefixOfPrefix[max(0, l)]\n      rightSum = prefixOfPrefix[r] - prefixOfPrefix[i]\n      leftLen = i - l\n      rightLen = r - i\n      ans += strength[i] * (rightSum * leftLen - leftSum * rightLen) % MOD\n\n    return ans % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2239, "slug": "find-closest-number-to-zero", "solutions": ["class Solution:\n    def findClosestNumber(self, nums: List[int]) -> int:\n        ans, d = 0, inf\n        for x in nums:\n            if (y := abs(x)) < d or (y == d and x > ans):\n                ans, d = x, y\n        return ans\n", "class Solution:\n  def findClosestNumber(self, nums: list[int]) -> int:\n    nums.sort(key=lambda x: (abs(x), -x))\n    return nums[0]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2278, "slug": "percentage-of-letter-in-string", "solutions": ["class Solution:\n    def percentageLetter(self, s: str, letter: str) -> int:\n        return s.count(letter) * 100 // len(s)\n", "class Solution:\n  def percentageLetter(self, s: str, letter: str) -> int:\n    return 100 * s.count(letter) // len(s)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2283, "slug": "check-if-number-has-equal-digit-count-and-digit-value", "solutions": ["class Solution:\n    def digitCount(self, num: str) -> bool:\n        cnt = Counter(int(x) for x in num)\n        return all(cnt[i] == int(x) for i, x in enumerate(num))\n", "class Solution:\n  def digitCount(self, num: str) -> bool:\n    count = collections.Counter(num)\n    return all(count[str(i)] == int(digit)\n               for i, digit in enumerate(num))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2292, "slug": "products-with-three-or-more-orders-in-two-consecutive-years", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2221, "slug": "find-triangular-sum-of-an-array", "solutions": ["class Solution:\n    def triangularSum(self, nums: List[int]) -> int:\n        for k in range(len(nums) - 1, 0, -1):\n            for i in range(k):\n                nums[i] = (nums[i] + nums[i + 1]) % 10\n        return nums[0]\n", "class Solution:\n  def triangularSum(self, nums: list[int]) -> int:\n    for sz in range(len(nums), 0, -1):\n      for i in range(sz - 1):\n        nums[i] = (nums[i] + nums[i + 1]) % 10\n    return nums[0]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2280, "slug": "minimum-lines-to-represent-a-line-chart", "solutions": ["class Solution:\n    def minimumLines(self, stockPrices: List[List[int]]) -> int:\n        stockPrices.sort()\n        dx, dy = 0, 1\n        ans = 0\n        for (x, y), (x1, y1) in pairwise(stockPrices):\n            dx1, dy1 = x1 - x, y1 - y\n            if dy * dx1 != dx * dy1:\n                ans += 1\n            dx, dy = dx1, dy1\n        return ans\n", "class Solution:\n  def minimumLines(self, stockPrices: list[list[int]]) -> int:\n    ans = 0\n\n    stockPrices.sort()\n\n    def getSlope(p: list[int], q: list[int]) -> tuple[int, int]:\n      dx = p[0] - q[0]\n      dy = p[1] - q[1]\n      if dx == 0:\n        return (0, p[0])\n      if dy == 0:\n        return (p[1], 0)\n      d = gcd(dx, dy)\n      return (dx // d, dy // d)\n\n    for i in range(2, len(stockPrices)):\n      a = getSlope(stockPrices[i - 2], stockPrices[i - 1])\n      b = getSlope(stockPrices[i - 1], stockPrices[i])\n      if a != b:\n        ans += 1\n\n    return ans + (len(stockPrices) > 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2250, "slug": "count-number-of-rectangles-containing-each-point", "solutions": ["class Solution:\n    def countRectangles(\n        self, rectangles: List[List[int]], points: List[List[int]]\n    ) -> List[int]:\n        d = defaultdict(list)\n        for x, y in rectangles:\n            d[y].append(x)\n        for y in d.keys():\n            d[y].sort()\n        ans = []\n        for x, y in points:\n            cnt = 0\n            for h in range(y, 101):\n                xs = d[h]\n                cnt += len(xs) - bisect_left(xs, x)\n            ans.append(cnt)\n        return ans\n", "class Solution:\n  def countRectangles(\n      self,\n      rectangles: list[list[int]],\n      points: list[list[int]],\n  ) -> list[int]:\n    ans = []\n    yToXs = [[] for _ in range(101)]\n\n    for l, h in rectangles:\n      yToXs[h].append(l)\n\n    for xs in yToXs:\n      xs.sort()\n\n    for xi, yi in points:\n      count = 0\n      for y in range(yi, 101):\n        xs = yToXs[y]\n        count += len(xs) - bisect.bisect_left(xs, xi)\n      ans.append(count)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2238, "slug": "number-of-times-a-driver-was-a-passenger", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2295, "slug": "replace-elements-in-an-array", "solutions": ["class Solution:\n    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\n        d = {x: i for i, x in enumerate(nums)}\n        for x, y in operations:\n            nums[d[x]] = y\n            d[y] = d[x]\n        return nums\n", "class Solution:\n  def arrayChange(\n      self,\n      nums: list[int],\n      operations: list[list[int]],\n  ) -> list[int]:\n    numToIndex = {num: i for i, num in enumerate(nums)}\n\n    for original, replaced in operations:\n      index = numToIndex[original]\n      nums[index] = replaced\n      del numToIndex[original]\n      numToIndex[replaced] = index\n\n    return nums\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2279, "slug": "maximum-bags-with-full-capacity-of-rocks", "solutions": ["class Solution:\n    def maximumBags(\n        self, capacity: List[int], rocks: List[int], additionalRocks: int\n    ) -> int:\n        for i, x in enumerate(rocks):\n            capacity[i] -= x\n        capacity.sort()\n        for i, x in enumerate(capacity):\n            additionalRocks -= x\n            if additionalRocks < 0:\n                return i\n        return len(capacity)\n", "class Solution:\n  def maximumBags(\n      self,\n      capacity: list[int],\n      rocks: list[int],\n      additionalRocks: int,\n  ) -> int:\n    for i, d in enumerate(sorted([c - r for c, r in zip(capacity, rocks)])):\n      if d > additionalRocks:\n        return i\n      additionalRocks -= d\n    return len(capacity)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2212, "slug": "maximum-points-in-an-archery-competition", "solutions": ["class Solution:\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\n        st = mx = 0\n        m = len(aliceArrows)\n        for mask in range(1, 1 << m):\n            cnt = s = 0\n            for i, x in enumerate(aliceArrows):\n                if mask >> i & 1:\n                    s += i\n                    cnt += x + 1\n            if cnt <= numArrows and s > mx:\n                mx = s\n                st = mask\n        ans = [0] * m\n        for i, x in enumerate(aliceArrows):\n            if st >> i & 1:\n                ans[i] = x + 1\n                numArrows -= ans[i]\n        ans[0] += numArrows\n        return ans\n", "class Solution:\n  def maximumBobPoints(\n      self,\n      numArrows: int,\n      aliceArrows: list[int],\n  ) -> list[int]:\n    FULL_MASK = (1 << 12) - 1\n    maxPoint = 0\n    maxMask = 0\n\n    def getShotableAndPoint(mask: int, leftArrows: int) -> tuple[bool, int]:\n      point = 0\n      for i in range(12):\n        if mask >> i & 1:\n          leftArrows -= aliceArrows[i] + 1\n          point += i\n      return leftArrows >= 0, point\n\n    for mask in range(FULL_MASK):\n      shotable, point = getShotableAndPoint(mask, numArrows)\n      if shotable and point > maxPoint:\n        maxPoint = point\n        maxMask = mask\n\n    def getBobsArrows(mask: int, leftArrows: int) -> list[int]:\n      bobsArrows = [0] * 12\n      for i in range(12):\n        if mask >> i & 1:\n          bobsArrows[i] = aliceArrows[i] + 1\n          leftArrows -= aliceArrows[i] + 1\n      bobsArrows[0] = leftArrows\n      return bobsArrows\n\n    return getBobsArrows(maxMask, numArrows)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2216, "slug": "minimum-deletions-to-make-array-beautiful", "solutions": ["class Solution:\n    def minDeletion(self, nums: List[int]) -> int:\n        n = len(nums)\n        i = ans = 0\n        while i < n - 1:\n            if nums[i] == nums[i + 1]:\n                ans += 1\n                i += 1\n            else:\n                i += 2\n        ans += (n - ans) % 2\n        return ans\n", "class Solution:\n  def minDeletion(self, nums: list[int]) -> int:\n    ans = 0\n\n    for i in range(len(nums) - 1):\n      # i - ans := the index after deletion\n      if nums[i] == nums[i + 1] and (i - ans) % 2 == 0:\n        ans += 1\n\n    # Add one if the length after deletion is odd\n    return ans + ((len(nums) - ans) & 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2270, "slug": "number-of-ways-to-split-array", "solutions": ["class Solution:\n    def waysToSplitArray(self, nums: List[int]) -> int:\n        s = sum(nums)\n        ans = t = 0\n        for x in nums[:-1]:\n            t += x\n            ans += t >= s - t\n        return ans\n", "class Solution:\n  def waysToSplitArray(self, nums: list[int]) -> int:\n    ans = 0\n    prefix = 0\n    suffix = sum(nums)\n\n    for i in range(len(nums) - 1):\n      prefix += nums[i]\n      suffix -= nums[i]\n      if prefix >= suffix:\n        ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2269, "slug": "find-the-k-beauty-of-a-number", "solutions": ["class Solution:\n    def divisorSubstrings(self, num: int, k: int) -> int:\n        ans = 0\n        s = str(num)\n        for i in range(len(s) - k + 1):\n            t = int(s[i : i + k])\n            if t and num % t == 0:\n                ans += 1\n        return ans\n", "class Solution:\n  def divisorSubstrings(self, num: int, k: int) -> int:\n    s = str(num)\n    ans = 0\n\n    for i in range(len(s) - k + 1):\n      x = int(s[i:i + k])\n      if x != 0 and num % x == 0:\n        ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2285, "slug": "maximum-total-importance-of-roads", "solutions": ["class Solution:\n    def maximumImportance(self, n: int, roads: List[List[int]]) -> int:\n        deg = [0] * n\n        for a, b in roads:\n            deg[a] += 1\n            deg[b] += 1\n        deg.sort()\n        return sum(i * v for i, v in enumerate(deg, 1))\n", "class Solution:\n  def maximumImportance(self, n: int, roads: list[list[int]]) -> int:\n    count = [0] * n\n\n    for u, v in roads:\n      count[u] += 1\n      count[v] += 1\n\n    count.sort()\n    return sum((i + 1) * c for i, c in enumerate(count))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2217, "slug": "find-palindrome-with-fixed-length", "solutions": ["class Solution:\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\n        l = (intLength + 1) >> 1\n        start, end = 10 ** (l - 1), 10**l - 1\n        ans = []\n        for q in queries:\n            v = start + q - 1\n            if v > end:\n                ans.append(-1)\n                continue\n            s = str(v)\n            s += s[::-1][intLength % 2 :]\n            ans.append(int(s))\n        return ans\n", "class Solution:\n  def kthPalindrome(self, queries: list[int], intLength: int) -> list[int]:\n    start = pow(10, (intLength + 1) // 2 - 1)\n    end = pow(10, (intLength + 1) // 2)\n    mul = pow(10, intLength // 2)\n\n    def reverse(num: int) -> int:\n      res = 0\n      while num:\n        res = res * 10 + num % 10\n        num //= 10\n      return res\n\n    def getKthPalindrome(query: int) -> int:\n      prefix = start + query - 1\n      return prefix * mul + reverse(prefix\n                                    if intLength % 2 == 0 else prefix // 10)\n\n    return [-1 if start + query > end else getKthPalindrome(query)\n            for query in queries]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2215, "slug": "find-the-difference-of-two-arrays", "solutions": ["class Solution:\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\n        s1, s2 = set(nums1), set(nums2)\n        return [list(s1 - s2), list(s2 - s1)]\n", "class Solution:\n  def findDifference(self, nums1: list[int],\n                     nums2: list[int]) -> list[list[int]]:\n    set1 = set(nums1)\n    set2 = set(nums2)\n    return [set1 - set2, set2 - set1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2247, "slug": "maximum-cost-of-trip-with-k-highways", "solutions": ["class Solution:\n    def maximumCost(self, n: int, highways: List[List[int]], k: int) -> int:\n        if k >= n:\n            return -1\n        g = defaultdict(list)\n        for a, b, cost in highways:\n            g[a].append((b, cost))\n            g[b].append((a, cost))\n        f = [[-inf] * n for _ in range(1 << n)]\n        for i in range(n):\n            f[1 << i][i] = 0\n        ans = -1\n        for i in range(1 << n):\n            for j in range(n):\n                if i >> j & 1:\n                    for h, cost in g[j]:\n                        if i >> h & 1:\n                            f[i][j] = max(f[i][j], f[i ^ (1 << j)][h] + cost)\n                if i.bit_count() == k + 1:\n                    ans = max(ans, f[i][j])\n        return ans\n", "class Solution:\n  def maximumCost(self, n: int, highways: list[list[int]], k: int) -> int:\n    if k + 1 > n:\n      return -1\n\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in highways:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    @functools.lru_cache(None)\n    def dp(u: int, mask: int) -> int:\n      \"\"\"\n      Returns the maximum cost of trip starting from u, where `mask` is the\n      bitmask of the visited cities.\n      \"\"\"\n      if mask.bit_count() == k + 1:\n        return 0\n\n      res = -1\n      for v, w in graph[u]:\n        if mask >> v & 1:\n          continue\n        nextCost = dp(v, mask | 1 << v)\n        if nextCost != -1:\n          res = max(res, w + nextCost)\n      return res\n\n    return max(dp(i, 1 << i) for i in range(n))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2218, "slug": "maximum-value-of-k-coins-from-piles", "solutions": ["class Solution:\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\n        n = len(piles)\n        f = [[0] * (k + 1) for _ in range(n + 1)]\n        for i, nums in enumerate(piles, 1):\n            s = list(accumulate(nums, initial=0))\n            for j in range(k + 1):\n                for h, w in enumerate(s):\n                    if j < h:\n                        break\n                    f[i][j] = max(f[i][j], f[i - 1][j - h] + w)\n        return f[n][k]\n", "class Solution:\n  def maxValueOfCoins(self, piles: list[list[int]], k: int) -> int:\n    @functools.lru_cache(None)\n    def dp(i: int, k: int) -> int:\n      \"\"\"Returns the maximum value of picking k coins from piles[i..n).\"\"\"\n      if i == len(piles) or k == 0:\n        return 0\n\n      # Pick no coins from the current pile.\n      res = dp(i + 1, k)\n      val = 0  # the coins picked from the current pile\n\n      # Try to pick 1, 2, ..., k coins from the current pile.\n      for j in range(min(len(piles[i]), k)):\n        val += piles[i][j]\n        res = max(res, val + dp(i + 1, k - j - 1))\n\n      return res\n\n    return dp(0, k)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2282, "slug": "number-of-people-that-can-be-seen-in-a-grid", "solutions": ["class Solution:\n    def seePeople(self, heights: List[List[int]]) -> List[List[int]]:\n        def f(nums: List[int]) -> List[int]:\n            n = len(nums)\n            stk = []\n            ans = [0] * n\n            for i in range(n - 1, -1, -1):\n                while stk and stk[-1] < nums[i]:\n                    ans[i] += 1\n                    stk.pop()\n                if stk:\n                    ans[i] += 1\n                while stk and stk[-1] == nums[i]:\n                    stk.pop()\n                stk.append(nums[i])\n            return ans\n\n        ans = [f(row) for row in heights]\n        m, n = len(heights), len(heights[0])\n        for j in range(n):\n            add = f([heights[i][j] for i in range(m)])\n            for i in range(m):\n                ans[i][j] += add[i]\n        return ans\n", "class Solution:\n  def seePeople(self, heights: list[list[int]]) -> list[list[int]]:\n    m = len(heights)\n    n = len(heights[0])\n    ans = [[0] * n for _ in range(m)]\n\n    for i, row in enumerate(heights):\n      stack = []\n      for j, height in enumerate(row):\n        hasEqualHeight = False\n        while stack and row[stack[-1]] <= height:\n          if row[stack[-1]] == height:\n            # edge case: [4, 2, 1, 1, 3]\n            hasEqualHeight = True\n          ans[i][stack.pop()] += 1\n        if stack and not hasEqualHeight:\n          ans[i][stack[-1]] += 1\n        stack.append(j)\n\n    for j, col in enumerate(zip(*heights)):\n      stack = []\n      for i, height in enumerate(col):\n        hasEqualHeight = False\n        while stack and col[stack[-1]] <= height:\n          if col[stack[-1]] == height:\n            hasEqualHeight = True\n          ans[stack.pop()][j] += 1\n        if stack and not hasEqualHeight:\n          ans[stack[-1]][j] += 1\n        stack.append(i)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2284, "slug": "sender-with-largest-word-count", "solutions": ["class Solution:\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\n        cnt = Counter()\n        for message, sender in zip(messages, senders):\n            cnt[sender] += message.count(\" \") + 1\n        ans = senders[0]\n        for k, v in cnt.items():\n            if cnt[ans] < v or (cnt[ans] == v and ans < k):\n                ans = k\n        return ans\n", "class Solution:\n  def largestWordCount(self, messages: list[str], senders: list[str]) -> str:\n    n = len(messages)\n    ans = ''\n    maxWordsSent = 0\n    count = collections.Counter()  # [sender, # Words sent]\n\n    for message, sender in zip(messages, senders):\n      wordsCount = message.count(' ') + 1\n      count[sender] += wordsCount\n      numWordsSent = count[sender]\n      if numWordsSent > maxWordsSent:\n        ans = sender\n        maxWordsSent = numWordsSent\n      elif numWordsSent == maxWordsSent and sender > ans:\n        ans = sender\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2276, "slug": "count-integers-in-intervals", "solutions": ["class Node:\n    __slots__ = (\"left\", \"right\", \"l\", \"r\", \"mid\", \"v\", \"add\")\n\n    def __init__(self, l, r):\n        self.left = None\n        self.right = None\n        self.l = l\n        self.r = r\n        self.mid = (l + r) // 2\n        self.v = 0\n        self.add = 0\n\n\nclass SegmentTree:\n    def __init__(self):\n        self.root = Node(1, int(1e9) + 1)\n\n    def modify(self, l, r, v, node=None):\n        if node is None:\n            node = self.root\n        if l > r:\n            return\n        if node.l >= l and node.r <= r:\n            node.v = node.r - node.l + 1\n            node.add = v\n            return\n        self.pushdown(node)\n        if l <= node.mid:\n            self.modify(l, r, v, node.left)\n        if r > node.mid:\n            self.modify(l, r, v, node.right)\n        self.pushup(node)\n\n    def query(self, l, r, node=None):\n        if node is None:\n            node = self.root\n        if l > r:\n            return 0\n        if node.l >= l and node.r <= r:\n            return node.v\n        self.pushdown(node)\n        v = 0\n        if l <= node.mid:\n            v += self.query(l, r, node.left)\n        if r > node.mid:\n            v += self.query(l, r, node.right)\n        return v\n\n    def pushup(self, node):\n        node.v = node.left.v + node.right.v\n\n    def pushdown(self, node):\n        if node.left is None:\n            node.left = Node(node.l, node.mid)\n        if node.right is None:\n            node.right = Node(node.mid + 1, node.r)\n        if node.add != 0:\n            left, right = node.left, node.right\n            left.add = node.add\n            right.add = node.add\n            left.v = left.r - left.l + 1\n            right.v = right.r - right.l + 1\n            node.add = 0\n\n\nclass CountIntervals:\n    def __init__(self):\n        self.tree = SegmentTree()\n\n    def add(self, left, right):\n        self.tree.modify(left, right, 1)\n\n    def count(self):\n        return self.tree.query(1, int(1e9))\n\n\n# Your CountIntervals object will be instantiated and called as such:\n# obj = CountIntervals()\n# obj.add(left, right)\n# param_2 = obj.count()\n", "from sortedcontainers import SortedDict\n\n\nclass CountIntervals:\n  def __init__(self):\n    self.intervals = SortedDict()\n    self.cnt = 0\n\n  def add(self, left: int, right: int) -> None:\n    while self._isOverlapped(left, right):\n      i = self.intervals.bisect_right(right) - 1\n      l, r = self.intervals.popitem(i)\n      left = min(left, l)\n      right = max(right, r)\n      self.cnt -= r - l + 1\n\n    self.intervals[left] = right\n    self.cnt += right - left + 1\n\n  def count(self) -> int:\n    return self.cnt\n\n  def _isOverlapped(self, left: int, right: int) -> bool:\n    i = self.intervals.bisect_right(right)\n    return i > 0 and self.intervals.peekitem(i - 1)[1] >= left\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2229, "slug": "check-if-an-array-is-consecutive", "solutions": ["class Solution:\n    def isConsecutive(self, nums: List[int]) -> bool:\n        mi, mx = min(nums), max(nums)\n        return len(set(nums)) == mx - mi + 1 == len(nums)\n", "class Solution:\n  def isConsecutive(self, nums: list[int]) -> bool:\n    return max(nums) - min(nums) + 1 == len(set(nums)) == len(nums)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2232, "slug": "minimize-result-by-adding-parentheses-to-expression", "solutions": ["class Solution:\n    def minimizeResult(self, expression: str) -> str:\n        l, r = expression.split(\"+\")\n        m, n = len(l), len(r)\n        mi = inf\n        ans = None\n        for i in range(m):\n            for j in range(n):\n                c = int(l[i:]) + int(r[: j + 1])\n                a = 1 if i == 0 else int(l[:i])\n                b = 1 if j == n - 1 else int(r[j + 1 :])\n                if (t := a * b * c) < mi:\n                    mi = t\n                    ans = f\"{l[:i]}({l[i:]}+{r[: j + 1]}){r[j + 1:]}\"\n        return ans\n", "class Solution:\n  def minimizeResult(self, expression: str) -> str:\n    plusIndex = expression.index('+')\n    left = expression[:plusIndex]\n    right = expression[plusIndex + 1:]\n    ans = ''\n    mn = math.inf\n\n    # the expression -> a * (b + c) * d\n    for i in range(len(left)):\n      for j in range(len(right)):\n        a = 1 if i == 0 else int(left[:i])\n        b = int(left[i:])\n        c = int(right[0:j + 1])\n        d = 1 if j == len(right) - 1 else int(right[j + 1:])\n        val = a * (b + c) * d\n        if val < mn:\n          mn = val\n          ans = (('' if i == 0 else str(a)) +\n                 '(' + str(b) + '+' + str(c) + ')' +\n                 ('' if j == len(right) - 1 else str(d)))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2209, "slug": "minimum-white-tiles-after-covering-with-carpets", "solutions": ["class Solution:\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\n        @cache\n        def dfs(i: int, j: int) -> int:\n            if i >= n:\n                return 0\n            if floor[i] == \"0\":\n                return dfs(i + 1, j)\n            if j == 0:\n                return s[-1] - s[i]\n            return min(1 + dfs(i + 1, j), dfs(i + carpetLen, j - 1))\n\n        n = len(floor)\n        s = [0] * (n + 1)\n        for i, c in enumerate(floor):\n            s[i + 1] = s[i] + int(c == \"1\")\n        ans = dfs(0, numCarpets)\n        dfs.cache_clear()\n        return ans\n", "class Solution:\n  def minimumWhiteTiles(\n      self,\n      floor: str,\n      numCarpets: int,\n      carpetLen: int,\n  ) -> int:\n    n = len(floor)\n    # dp[i][j] := the minimum number of visible white tiles of floor[i..n)\n    # after covering at most j carpets\n    dp = [[0] * (numCarpets + 1) for _ in range(n + 1)]\n\n    for i in reversed(range(n)):\n      dp[i][0] = int(floor[i]) + dp[i + 1][0]\n\n    for i in reversed(range(n)):\n      for j in range(1, numCarpets + 1):\n        cover = dp[i + carpetLen][j - 1] if i + carpetLen < n else 0\n        skip = int(floor[i]) + dp[i + 1][j]\n        dp[i][j] = min(cover, skip)\n\n    return dp[0][numCarpets]\n", "class Solution:\n  def minimumWhiteTiles(\n      self,\n      floor: str,\n      numCarpets: int,\n      carpetLen: int,\n  ) -> int:\n    MAX = 1000\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int) -> int:\n      \"\"\"\n      Returns the minimum number of visible white tiles of floor[i..n) after\n      covering at most j carpets.\n      \"\"\"\n      if j < 0:\n        return MAX\n      if i >= len(floor):\n        return 0\n      return min(dp(i + carpetLen, j - 1),\n                 dp(i + 1, j) + int(floor[i]))\n\n    return dp(0, numCarpets)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2256, "slug": "minimum-average-difference", "solutions": ["class Solution:\n    def minimumAverageDifference(self, nums: List[int]) -> int:\n        pre, suf = 0, sum(nums)\n        n = len(nums)\n        ans, mi = 0, inf\n        for i, x in enumerate(nums):\n            pre += x\n            suf -= x\n            a = pre // (i + 1)\n            b = 0 if n - i - 1 == 0 else suf // (n - i - 1)\n            if (t := abs(a - b)) < mi:\n                ans = i\n                mi = t\n        return ans\n", "class Solution:\n  def minimumAverageDifference(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = 0\n    minDiff = inf\n    prefix = 0\n    suffix = sum(nums)\n\n    for i, num in enumerate(nums):\n      prefix += num\n      suffix -= num\n      prefixAvg = prefix // (i + 1)\n      suffixAvg = 0 if i == n - 1 else suffix // (n - 1 - i)\n      diff = abs(prefixAvg - suffixAvg)\n      if diff < minDiff:\n        ans = i\n        minDiff = diff\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2224, "slug": "minimum-number-of-operations-to-convert-time", "solutions": ["class Solution:\n    def convertTime(self, current: str, correct: str) -> int:\n        a = int(current[:2]) * 60 + int(current[3:])\n        b = int(correct[:2]) * 60 + int(correct[3:])\n        ans, d = 0, b - a\n        for i in [60, 15, 5, 1]:\n            ans += d // i\n            d %= i\n        return ans\n", "class Solution:\n  def convertTime(self, current: str, correct: str) -> int:\n    ops = [60, 15, 5, 1]\n\n    def getMinutes(s: str) -> int:\n      return int(s[:2]) * 60 + int(s[3:])\n\n    diff = getMinutes(correct) - getMinutes(current)\n    ans = 0\n\n    for op in ops:\n      ans += diff // op\n      diff %= op\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2230, "slug": "the-users-that-are-eligible-for-discount", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2288, "slug": "apply-discount-to-prices", "solutions": ["class Solution:\n    def discountPrices(self, sentence: str, discount: int) -> str:\n        ans = []\n        for w in sentence.split():\n            if w[0] == '$' and w[1:].isdigit():\n                w = f'${int(w[1:]) * (1 - discount / 100):.2f}'\n            ans.append(w)\n        return ' '.join(ans)\n", "class Solution:\n  def discountPrices(self, sentence: str, discount: int) -> str:\n    PRECISION = 2\n    ans = []\n\n    for word in sentence.split():\n      if word[0] == '$' and len(word) > 1:\n        digits = word[1:]\n        if all(digit.isdigit() for digit in digits):\n          val = float(digits) * (100 - discount) / 100\n          s = f'{val:.2f}'\n          trimmed = s[:s.index('.') + PRECISION + 1]\n          ans.append('$' + trimmed)\n        else:\n          ans.append(word)\n      else:\n        ans.append(word)\n\n    return ' '.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2251, "slug": "number-of-flowers-in-full-bloom", "solutions": ["class Solution:\n    def fullBloomFlowers(\n        self, flowers: List[List[int]], people: List[int]\n    ) -> List[int]:\n        start, end = sorted(a for a, _ in flowers), sorted(b for _, b in flowers)\n        return [bisect_right(start, p) - bisect_left(end, p) for p in people]\n", "class Solution:\n  def fullBloomFlowers(\n      self,\n      flowers: list[list[int]],\n      persons: list[int],\n  ) -> list[int]:\n    starts = sorted(s for s, _ in flowers)\n    ends = sorted(e for _, e in flowers)\n    return [bisect.bisect_right(starts, person) -\n            bisect.bisect_left(ends, person)\n            for person in persons]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2271, "slug": "maximum-white-tiles-covered-by-a-carpet", "solutions": ["class Solution:\n    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\n        tiles.sort()\n        n = len(tiles)\n        s = ans = j = 0\n        for i, (li, ri) in enumerate(tiles):\n            while j < n and tiles[j][1] - li + 1 <= carpetLen:\n                s += tiles[j][1] - tiles[j][0] + 1\n                j += 1\n            if j < n and li + carpetLen > tiles[j][0]:\n                ans = max(ans, s + li + carpetLen - tiles[j][0])\n            else:\n                ans = max(ans, s)\n            s -= ri - li + 1\n        return ans\n", "class Solution:\n  def maximumWhiteTiles(self, tiles: list[list[int]], carpetLen: int) -> int:\n    if any(tile[1] - tile[0] + 1 >= carpetLen for tile in tiles):\n      return carpetLen\n\n    ans = 0\n    prefix = [0] * (len(tiles) + 1)\n\n    tiles.sort()\n    starts = [tile[0] for tile in tiles]\n\n    for i, tile in enumerate(tiles):\n      length = tile[1] - tile[0] + 1\n      prefix[i + 1] = prefix[i] + length\n\n    for i, (s, _) in enumerate(tiles):\n      carpetEnd = s + carpetLen - 1\n      endIndex = bisect_right(starts, carpetEnd) - 1\n      notCover = max(0, tiles[endIndex][1] - carpetEnd)\n      ans = max(ans, prefix[endIndex + 1] - prefix[i] - notCover)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2220, "slug": "minimum-bit-flips-to-convert-number", "solutions": ["class Solution:\n    def minBitFlips(self, start: int, goal: int) -> int:\n        return (start ^ goal).bit_count()\n", "class Solution:\n  def minBitFlips(self, start: int, goal: int) -> int:\n    return (start ^ goal).bit_count()\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2294, "slug": "partition-array-such-that-maximum-difference-is-k", "solutions": ["class Solution:\n    def partitionArray(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        ans, a = 1, nums[0]\n        for b in nums:\n            if b - a > k:\n                a = b\n                ans += 1\n        return ans\n", "class Solution:\n  def partitionArray(self, nums: list[int], k: int) -> int:\n    nums.sort()\n\n    ans = 1\n    mn = nums[0]\n\n    for i in range(1, len(nums)):\n      if mn + k < nums[i]:\n        ans += 1\n        mn = nums[i]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2254, "slug": "design-video-sharing-platform", "solutions": ["class VideoSharingPlatform:\n  def __init__(self):\n    self.currVideoId = 0\n    self.usedIds = []\n    self.videoIdToVideo = {}\n    self.videoIdToViews = collections.Counter()\n    self.videoIdToLikes = collections.Counter()\n    self.videoIdToDislikes = collections.Counter()\n\n  def upload(self, video: str) -> int:\n    videoId = self._getVideoId()\n    self.videoIdToVideo[videoId] = video\n    return videoId\n\n  def remove(self, videoId: int) -> None:\n    if videoId in self.videoIdToVideo:\n      heapq.heappush(self.usedIds, videoId)\n      del self.videoIdToVideo[videoId]\n      del self.videoIdToViews[videoId]\n      del self.videoIdToLikes[videoId]\n      del self.videoIdToDislikes[videoId]\n\n  def watch(self, videoId: int, startMinute: int, endMinute: int) -> str:\n    if videoId not in self.videoIdToVideo:\n      return '-1'\n    self.videoIdToViews[videoId] += 1\n    video = self.videoIdToVideo[videoId]\n    return video[startMinute:min(endMinute + 1, len(video))]\n\n  def like(self, videoId: int) -> None:\n    if videoId in self.videoIdToVideo:\n      self.videoIdToLikes[videoId] += 1\n\n  def dislike(self, videoId: int) -> None:\n    if videoId in self.videoIdToVideo:\n      self.videoIdToDislikes[videoId] += 1\n\n  def getLikesAndDislikes(self, videoId: int) -> list[int]:\n    if videoId in self.videoIdToVideo:\n      return [self.videoIdToLikes[videoId], self.videoIdToDislikes[videoId]]\n    return [-1]\n\n  def getViews(self, videoId: int) -> int:\n    if videoId in self.videoIdToVideo:\n      return self.videoIdToViews[videoId]\n    return -1\n\n  def _getVideoId(self) -> int:\n    if not self.usedIds:\n      self.currVideoId += 1\n      return self.currVideoId - 1\n    return heapq.heappop(self.usedIds)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2240, "slug": "number-of-ways-to-buy-pens-and-pencils", "solutions": ["class Solution:\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\n        ans = 0\n        for x in range(total // cost1 + 1):\n            y = (total - (x * cost1)) // cost2 + 1\n            ans += y\n        return ans\n", "class Solution:\n  def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\n    maxPen = total // cost1\n    return sum((total - i * cost1) // cost2\n               for i in range(maxPen + 1)) + maxPen + 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2222, "slug": "number-of-ways-to-select-buildings", "solutions": ["class Solution:\n    def numberOfWays(self, s: str) -> int:\n        l = [0, 0]\n        r = [s.count(\"0\"), s.count(\"1\")]\n        ans = 0\n        for x in map(int, s):\n            r[x] -= 1\n            ans += l[x ^ 1] * r[x ^ 1]\n            l[x] += 1\n        return ans\n", "class Solution:\n  def numberOfWays(self, s: str) -> int:\n    ans = 0\n    # before[i] := the number of i before the current digit\n    before = [0] * 2\n    # after[i] := the number of i after the current digit\n    after = [0] * 2\n    after[0] = s.count('0')\n    after[1] = len(s) - after[0]\n\n    for c in s:\n      num = int(c)\n      after[num] -= 1\n      if num == 0:\n        ans += before[1] * after[1]\n      else:\n        ans += before[0] * after[0]\n      before[num] += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2260, "slug": "minimum-consecutive-cards-to-pick-up", "solutions": ["class Solution:\n    def minimumCardPickup(self, cards: List[int]) -> int:\n        last = {}\n        ans = inf\n        for i, x in enumerate(cards):\n            if x in last:\n                ans = min(ans, i - last[x] + 1)\n            last[x] = i\n        return -1 if ans == inf else ans\n", "class Solution:\n  def minimumCardPickup(self, cards: list[int]) -> int:\n    ans = math.inf\n    lastSeen = {}\n\n    for i, card in enumerate(cards):\n      if card in lastSeen:\n        ans = min(ans, i - lastSeen[card] + 1)\n      lastSeen[card] = i\n\n    return -1 if ans == math.inf else ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2265, "slug": "count-nodes-equal-to-average-of-subtree", "solutions": ["class Solution:\n    def averageOfSubtree(self, root: TreeNode) -> int:\n        def dfs(root) -> tuple:\n            if not root:\n                return 0, 0\n            ls, ln = dfs(root.left)\n            rs, rn = dfs(root.right)\n            s = ls + rs + root.val\n            n = ln + rn + 1\n            nonlocal ans\n            ans += int(s // n == root.val)\n            return s, n\n\n        ans = 0\n        dfs(root)\n        return ans\n", "class Solution:\n  def averageOfSubtree(self, root: TreeNode | None) -> int:\n    ans = 0\n\n    def dfs(root: TreeNode | None) -> tuple[int, int]:\n      nonlocal ans\n      if not root:\n        return (0, 0)\n      leftSum, leftCount = dfs(root.left)\n      rightSum, rightCount = dfs(root.right)\n      summ = root.val + leftSum + rightSum\n      count = 1 + leftCount + rightCount\n      if summ // count == root.val:\n        ans += 1\n      return (summ, count)\n\n    dfs(root)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2263, "slug": "make-array-non-decreasing-or-non-increasing", "solutions": ["class Solution:\n    def convertArray(self, nums: List[int]) -> int:\n        def solve(nums):\n            n = len(nums)\n            f = [[0] * 1001 for _ in range(n + 1)]\n            for i, x in enumerate(nums, 1):\n                mi = inf\n                for j in range(1001):\n                    if mi > f[i - 1][j]:\n                        mi = f[i - 1][j]\n                    f[i][j] = mi + abs(x - j)\n            return min(f[n])\n\n        return min(solve(nums), solve(nums[::-1]))\n", "class Solution:\n  def convertArray(self, nums: list[int]) -> int:\n    def cost(nums: list[int]) -> int:\n      ans = 0\n      minHeap = []\n\n      # Greedily make `nums` non-increasing.\n      for num in nums:\n        if minHeap and minHeap[0] < num:\n          ans += num - heapq.heappushpop(minHeap, num)\n        heapq.heappush(minHeap, num)\n\n      return ans\n\n    return min(cost(nums), cost([-num for num in nums]))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2252, "slug": "dynamic-pivoting-of-a-table", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2246, "slug": "longest-path-with-different-adjacent-characters", "solutions": ["class Solution:\n    def longestPath(self, parent: List[int], s: str) -> int:\n        def dfs(i: int) -> int:\n            mx = 0\n            nonlocal ans\n            for j in g[i]:\n                x = dfs(j) + 1\n                if s[i] != s[j]:\n                    ans = max(ans, mx + x)\n                    mx = max(mx, x)\n            return mx\n\n        g = defaultdict(list)\n        for i in range(1, len(parent)):\n            g[parent[i]].append(i)\n        ans = 0\n        dfs(0)\n        return ans + 1\n", "class Solution:\n  def longestPath(self, parent: list[int], s: str) -> int:\n    n = len(parent)\n    ans = 0\n    graph = [[] for _ in range(n)]\n\n    for i in range(1, n):\n      graph[parent[i]].append(i)\n\n    def longestPathDownFrom(u: int) -> int:\n      nonlocal ans\n      max1 = 0\n      max2 = 0\n\n      for v in graph[u]:\n        res = longestPathDownFrom(v)\n        if s[u] == s[v]:\n          continue\n        if res > max1:\n          max2 = max1\n          max1 = res\n        elif res > max2:\n          max2 = res\n\n      ans = max(ans, 1 + max1 + max2)\n      return 1 + max1\n\n    longestPathDownFrom(0)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2208, "slug": "minimum-operations-to-halve-array-sum", "solutions": ["class Solution:\n    def halveArray(self, nums: List[int]) -> int:\n        s = sum(nums) / 2\n        pq = []\n        for x in nums:\n            heappush(pq, -x)\n        ans = 0\n        while s > 0:\n            t = -heappop(pq) / 2\n            s -= t\n            heappush(pq, -t)\n            ans += 1\n        return ans\n", "class Solution:\n  def halveArray(self, nums: list[int]) -> int:\n    halfSum = sum(nums) / 2\n    ans = 0\n    runningSum = 0.0\n    maxHeap = [-num for num in nums]\n\n    heapq.heapify(maxHeap)\n\n    while runningSum < halfSum:\n      maxValue = -heapq.heappop(maxHeap) / 2\n      runningSum += maxValue\n      heapq.heappush(maxHeap, -maxValue)\n      ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2204, "slug": "distance-to-a-cycle-in-undirected-graph", "solutions": ["class Solution:\n    def distanceToCycle(self, n: int, edges: List[List[int]]) -> List[int]:\n        g = defaultdict(set)\n        for a, b in edges:\n            g[a].add(b)\n            g[b].add(a)\n        q = deque(i for i in range(n) if len(g[i]) == 1)\n        f = [0] * n\n        seq = []\n        while q:\n            i = q.popleft()\n            seq.append(i)\n            for j in g[i]:\n                g[j].remove(i)\n                f[i] = j\n                if len(g[j]) == 1:\n                    q.append(j)\n            g[i].clear()\n        ans = [0] * n\n        for i in seq[::-1]:\n            ans[i] = ans[f[i]] + 1\n        return ans\n", "class Solution:\n  def distanceToCycle(self, n: int, edges: list[list[int]]) -> list[int]:\n    ans = [0] * n\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    NO_RANK = -2\n\n    # The minRank that u can reach with forward edges\n    def getRank(u: int, currRank: int, rank: list[int]) -> int:\n      if rank[u] != NO_RANK:  # The rank is already determined\n        return rank[u]\n\n      rank[u] = currRank\n      minRank = currRank\n\n      for v in graph[u]:\n        # Visited or parent (that's why NO_RANK = -2 instead of -1)\n        if rank[v] == len(rank) or rank[v] == currRank - 1:\n          continue\n        nextRank = getRank(v, currRank + 1, rank)\n        # NextRank should > currRank if there's no cycle\n        if nextRank <= currRank:\n          cycle.append(v)\n        minRank = min(minRank, nextRank)\n\n      rank[u] = len(rank)  # Mark as visited.\n      return minRank\n\n    # rank[i] := the minimum node that node i can reach with forward edges\n    # Initialize with NO_RANK = -2 to indicate not visited.\n    cycle = []\n    getRank(0, 0, [NO_RANK] * n)\n\n    q = collections.deque(cycle)\n    seen = set(cycle)\n\n    step = 1\n    while q:\n      for _ in range(len(q)):\n        u = q.popleft()\n        for v in graph[u]:\n          if v in seen:\n            continue\n          q.append(v)\n          seen.add(v)\n          ans[v] = step\n      step += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2273, "slug": "find-resultant-array-after-removing-anagrams", "solutions": ["class Solution:\n    def removeAnagrams(self, words: List[str]) -> List[str]:\n        def check(s: str, t: str) -> bool:\n            if len(s) != len(t):\n                return True\n            cnt = Counter(s)\n            for c in t:\n                cnt[c] -= 1\n                if cnt[c] < 0:\n                    return True\n            return False\n\n        return [words[0]] + [t for s, t in pairwise(words) if check(s, t)]\n", "class Solution:\n  def removeAnagrams(self, words: list[str]) -> list[str]:\n    ans = []\n\n    def isAnagram(a: str, b: str) -> bool:\n      count = collections.Counter(a)\n      count.subtract(collections.Counter(b))\n      return all(value == 0 for value in count.values())\n\n    i = 0\n    while i < len(words):\n      j = i + 1\n      while j < len(words) and isAnagram(words[i], words[j]):\n        j += 1\n      ans.append(words[i])\n      i = j\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2241, "slug": "design-an-atm-machine", "solutions": ["class ATM:\n    def __init__(self):\n        self.d = [20, 50, 100, 200, 500]\n        self.m = len(self.d)\n        self.cnt = [0] * self.m\n\n    def deposit(self, banknotesCount: List[int]) -> None:\n        for i, x in enumerate(banknotesCount):\n            self.cnt[i] += x\n\n    def withdraw(self, amount: int) -> List[int]:\n        ans = [0] * self.m\n        for i in reversed(range(self.m)):\n            ans[i] = min(amount // self.d[i], self.cnt[i])\n            amount -= ans[i] * self.d[i]\n        if amount > 0:\n            return [-1]\n        for i, x in enumerate(ans):\n            self.cnt[i] -= x\n        return ans\n\n\n# Your ATM object will be instantiated and called as such:\n# obj = ATM()\n# obj.deposit(banknotesCount)\n# param_2 = obj.withdraw(amount)\n", "class ATM:\n  def __init__(self):\n    self.banknotes = [20, 50, 100, 200, 500]\n    self.bank = [0] * 5\n\n  def deposit(self, banknotesCount: list[int]) -> None:\n    for i in range(5):\n      self.bank[i] += banknotesCount[i]\n\n  def withdraw(self, amount: int) -> list[int]:\n    withdrew = [0] * 5\n\n    for i in reversed(range(5)):\n      withdrew[i] = min(self.bank[i], amount // self.banknotes[i])\n      amount -= withdrew[i] * self.banknotes[i]\n\n    if amount:\n      return [-1]\n\n    for i in range(5):\n      self.bank[i] -= withdrew[i]\n    return withdrew\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2202, "slug": "maximize-the-topmost-element-after-k-moves", "solutions": ["class Solution:\n    def maximumTop(self, nums: List[int], k: int) -> int:\n        if k == 0:\n            return nums[0]\n        n = len(nums)\n        if n == 1:\n            if k % 2:\n                return -1\n            return nums[0]\n        ans = max(nums[: k - 1], default=-1)\n        if k < n:\n            ans = max(ans, nums[k])\n        return ans\n", "class Solution:\n  def maximumTop(self, nums: list[int], k: int) -> int:\n    n = len(nums)\n    # After taking k elements, if we're left something, then we return nums[k]\n    # Otherwise, return -1.\n    if k == 0 or k == 1:\n      return -1 if n == k else nums[k]\n    # Remove then add even number of times.\n    if n == 1:\n      return -1 if k & 1 else nums[0]\n    # Take min(n, k - 1) elements and put the largest one back.\n    mx = max(nums[:min(n, k - 1)])\n    if k >= n:\n      return mx\n    return max(mx, nums[k])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2245, "slug": "maximum-trailing-zeros-in-a-cornered-path", "solutions": ["class Solution:\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        r2 = [[0] * (n + 1) for _ in range(m + 1)]\n        c2 = [[0] * (n + 1) for _ in range(m + 1)]\n        r5 = [[0] * (n + 1) for _ in range(m + 1)]\n        c5 = [[0] * (n + 1) for _ in range(m + 1)]\n        for i, row in enumerate(grid, 1):\n            for j, x in enumerate(row, 1):\n                s2 = s5 = 0\n                while x % 2 == 0:\n                    x //= 2\n                    s2 += 1\n                while x % 5 == 0:\n                    x //= 5\n                    s5 += 1\n                r2[i][j] = r2[i][j - 1] + s2\n                c2[i][j] = c2[i - 1][j] + s2\n                r5[i][j] = r5[i][j - 1] + s5\n                c5[i][j] = c5[i - 1][j] + s5\n        ans = 0\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                a = min(r2[i][j] + c2[i - 1][j], r5[i][j] + c5[i - 1][j])\n                b = min(r2[i][j] + c2[m][j] - c2[i][j], r5[i][j] + c5[m][j] - c5[i][j])\n                c = min(r2[i][n] - r2[i][j] + c2[i][j], r5[i][n] - r5[i][j] + c5[i][j])\n                d = min(\n                    r2[i][n] - r2[i][j - 1] + c2[m][j] - c2[i][j],\n                    r5[i][n] - r5[i][j - 1] + c5[m][j] - c5[i][j],\n                )\n                ans = max(ans, a, b, c, d)\n        return ans\n", "class Solution:\n  def maxTrailingZeros(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    # leftPrefix2[i][j] := the number of 2 in grid[i][0..j]\n    # leftPrefix5[i][j] := the number of 5 in grid[i][0..j]\n    # topPrefix2[i][j] := the number of 2 in grid[0..i][j]\n    # topPrefix5[i][j] := the number of 5 in grid[0..i][j]\n    leftPrefix2 = [[0] * n for _ in range(m)]\n    leftPrefix5 = [[0] * n for _ in range(m)]\n    topPrefix2 = [[0] * n for _ in range(m)]\n    topPrefix5 = [[0] * n for _ in range(m)]\n\n    def getCount(num: int, factor: int) -> int:\n      count = 0\n      while num % factor == 0:\n        num //= factor\n        count += 1\n      return count\n\n    for i in range(m):\n      for j in range(n):\n        leftPrefix2[i][j] = getCount(grid[i][j], 2)\n        leftPrefix5[i][j] = getCount(grid[i][j], 5)\n        if j:\n          leftPrefix2[i][j] += leftPrefix2[i][j - 1]\n          leftPrefix5[i][j] += leftPrefix5[i][j - 1]\n\n    for j in range(n):\n      for i in range(m):\n        topPrefix2[i][j] = getCount(grid[i][j], 2)\n        topPrefix5[i][j] = getCount(grid[i][j], 5)\n        if i:\n          topPrefix2[i][j] += topPrefix2[i - 1][j]\n          topPrefix5[i][j] += topPrefix5[i - 1][j]\n\n    ans = 0\n    for i in range(m):\n      for j in range(n):\n        curr2 = getCount(grid[i][j], 2)\n        curr5 = getCount(grid[i][j], 5)\n        l2 = leftPrefix2[i][j]\n        l5 = leftPrefix5[i][j]\n        r2 = leftPrefix2[i][n - 1] - (0 if j == 0 else leftPrefix2[i][j - 1])\n        r5 = leftPrefix5[i][n - 1] - (0 if j == 0 else leftPrefix5[i][j - 1])\n        t2 = topPrefix2[i][j]\n        t5 = topPrefix5[i][j]\n        d2 = topPrefix2[m - 1][j] - (0 if i == 0 else topPrefix2[i - 1][j])\n        d5 = topPrefix5[m - 1][j] - (0 if i == 0 else topPrefix5[i - 1][j])\n        ans = max(ans,\n                  min(l2 + t2 - curr2, l5 + t5 - curr5),\n                  min(r2 + t2 - curr2, r5 + t5 - curr5),\n                  min(l2 + d2 - curr2, l5 + d5 - curr5),\n                  min(r2 + d2 - curr2, r5 + d5 - curr5))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2291, "slug": "maximum-profit-from-trading-stocks", "solutions": ["class Solution:\n    def maximumProfit(self, present: List[int], future: List[int], budget: int) -> int:\n        f = [[0] * (budget + 1) for _ in range(len(present) + 1)]\n        for i, w in enumerate(present, 1):\n            for j in range(budget + 1):\n                f[i][j] = f[i - 1][j]\n                if j >= w and future[i - 1] > w:\n                    f[i][j] = max(f[i][j], f[i - 1][j - w] + future[i - 1] - w)\n        return f[-1][-1]\n", "class Solution:\n  def maximumProfit(\n      self,\n      present: list[int],\n      future: list[int],\n      budget: int,\n  ) -> int:\n    # dp[i] := the maximum profit of buying present so far with i budget\n    dp = [0] * (budget + 1)\n\n    for p, f in zip(present, future):\n      for j in range(budget, p - 1, -1):\n        dp[j] = max(dp[j], f - p + dp[j - p])\n\n    return dp[budget]\n", "class Solution:\n  def maximumProfit(\n      self,\n      present: list[int],\n      future: list[int],\n      budget: int,\n  ) -> int:\n    n = len(present)\n    # dp[i][j] := the maximum profit of buying present[0..i) with j budget\n    dp = [[0] * (budget + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n      profit = future[i - 1] - present[i - 1]\n      for j in range(budget + 1):\n        if j < present[i - 1]:\n          dp[i][j] = dp[i - 1][j]\n        else:\n          dp[i][j] = max(dp[i - 1][j], profit + dp[i - 1][j - present[i - 1]])\n\n    return dp[n][budget]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2243, "slug": "calculate-digit-sum-of-a-string", "solutions": ["class Solution:\n    def digitSum(self, s: str, k: int) -> str:\n        while len(s) > k:\n            t = []\n            n = len(s)\n            for i in range(0, n, k):\n                x = 0\n                for j in range(i, min(i + k, n)):\n                    x += int(s[j])\n                t.append(str(x))\n            s = \"\".join(t)\n        return s\n", "class Solution:\n  def digitSum(self, s: str, k: int) -> str:\n    while len(s) > k:\n      next = []\n      for i in range(0, len(s), k):\n        summ = 0\n        for j in range(i, min(len(s), i + k)):\n          summ += int(s[j])\n        next.append(str(summ))\n      s = ''.join(next)\n    return s\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2267, "slug": "check-if-there-is-a-valid-parentheses-string-path", "solutions": ["class Solution:\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\n        @cache\n        def dfs(i: int, j: int, k: int) -> bool:\n            d = 1 if grid[i][j] == \"(\" else -1\n            k += d\n            if k < 0 or k > m - i + n - j:\n                return False\n            if i == m - 1 and j == n - 1:\n                return k == 0\n            for a, b in pairwise((0, 1, 0)):\n                x, y = i + a, j + b\n                if 0 <= x < m and 0 <= y < n and dfs(x, y, k):\n                    return True\n            return False\n\n        m, n = len(grid), len(grid[0])\n        if (m + n - 1) % 2 or grid[0][0] == \")\" or grid[m - 1][n - 1] == \"(\":\n            return False\n        return dfs(0, 0, 0)\n", "class Solution:\n  def hasValidPath(self, grid: list[list[str]]) -> bool:\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, k: int) -> bool:\n      \"\"\"\n      Returns True if there's a path from grid[i][j] to grid[m - 1][n - 1],\n      where the number of '(' - the number of ')' == k.\n      \"\"\"\n      if i == len(grid) or j == len(grid[0]):\n        return False\n      k += 1 if grid[i][j] == '(' else -1\n      if k < 0:\n        return False\n      if i == len(grid) - 1 and j == len(grid[0]) - 1:\n        return k == 0\n      return dp(i + 1, j, k) | dp(i, j + 1, k)\n\n    return dp(0, 0, 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2297, "slug": "jump-game-viii", "solutions": ["class Solution:\n    def minCost(self, nums: List[int], costs: List[int]) -> int:\n        n = len(nums)\n        g = defaultdict(list)\n        stk = []\n        for i in range(n - 1, -1, -1):\n            while stk and nums[stk[-1]] < nums[i]:\n                stk.pop()\n            if stk:\n                g[i].append(stk[-1])\n            stk.append(i)\n\n        stk = []\n        for i in range(n - 1, -1, -1):\n            while stk and nums[stk[-1]] >= nums[i]:\n                stk.pop()\n            if stk:\n                g[i].append(stk[-1])\n            stk.append(i)\n\n        f = [inf] * n\n        f[0] = 0\n        for i in range(n):\n            for j in g[i]:\n                f[j] = min(f[j], f[i] + costs[j])\n        return f[n - 1]\n", "class Solution:\n  def minCost(self, nums: list[int], costs: list[int]) -> int:\n    # dp[i] := the minimum cost to jump to i\n    dp = [math.inf] * len(nums)\n    maxStack = []\n    minStack = []\n\n    dp[0] = 0\n\n    for i, num in enumerate(nums):\n      while maxStack and num >= nums[maxStack[-1]]:\n        dp[i] = min(dp[i], dp[maxStack.pop()] + costs[i])\n      while minStack and num < nums[minStack[-1]]:\n        dp[i] = min(dp[i], dp[minStack.pop()] + costs[i])\n      maxStack.append(i)\n      minStack.append(i)\n\n    return dp[-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2227, "slug": "encrypt-and-decrypt-strings", "solutions": ["class Encrypter:\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\n        self.mp = dict(zip(keys, values))\n        self.cnt = Counter(self.encrypt(v) for v in dictionary)\n\n    def encrypt(self, word1: str) -> str:\n        res = []\n        for c in word1:\n            if c not in self.mp:\n                return ''\n            res.append(self.mp[c])\n        return ''.join(res)\n\n    def decrypt(self, word2: str) -> int:\n        return self.cnt[word2]\n\n\n# Your Encrypter object will be instantiated and called as such:\n# obj = Encrypter(keys, values, dictionary)\n# param_1 = obj.encrypt(word1)\n# param_2 = obj.decrypt(word2)\n", "class Encrypter:\n  def __init__(self, keys: list[str], values: list[str], dictionary: list[str]):\n    self.keyToValue = {k: v for k, v in zip(keys, values)}\n    self.decrypt = collections.Counter(self.encrypt(word)\n                                       for word in dictionary).__getitem__\n\n  def encrypt(self, word1: str) -> str:\n    return ''.join(self.keyToValue[c] for c in word1)\n", "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = collections.defaultdict(TrieNode)\n    self.isWord = False\n\n\nclass Encrypter:\n  def __init__(self, keys: list[str], values: list[str], dictionary: list[str]):\n    self.keyToValue = {k: v for k, v in zip(keys, values)}\n    self.valueToKeys = collections.defaultdict(list)\n    self.root = TrieNode()\n    for k, v in zip(keys, values):\n      self.valueToKeys[v].append(k)\n    for word in dictionary:\n      self._insert(word)\n\n  def encrypt(self, word1: str) -> str:\n    return ''.join(self.keyToValue[c] for c in word1)\n\n  def decrypt(self, word2: str) -> int:\n    return self._find(word2, 0, self.root)\n\n  def _insert(self, word: str) -> None:\n    node = self.root\n    for c in word:\n      node = node.children.setdefault(c, TrieNode())\n    node.isWord = True\n\n  def _find(self, word: str, i: int, node: TrieNode) -> int:\n    value = word[i:i + 2]\n    if value not in self.valueToKeys:\n      return 0\n\n    ans = 0\n    if i + 2 == len(word):\n      for key in self.valueToKeys[value]:\n        ans += node.children[key].isWord\n      return ans\n\n    for key in self.valueToKeys[value]:\n      if key not in node.children:\n        continue\n      ans += self._find(word, i + 2, node.children[key])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2258, "slug": "escape-the-spreading-fire", "solutions": ["class Solution:\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\n        def spread(q: Deque[int]) -> Deque[int]:\n            nq = deque()\n            while q:\n                i, j = q.popleft()\n                for a, b in pairwise(dirs):\n                    x, y = i + a, j + b\n                    if 0 <= x < m and 0 <= y < n and not fire[x][y] and grid[x][y] == 0:\n                        fire[x][y] = True\n                        nq.append((x, y))\n            return nq\n\n        def check(t: int) -> bool:\n            for i in range(m):\n                for j in range(n):\n                    fire[i][j] = False\n            q1 = deque()\n            for i, row in enumerate(grid):\n                for j, x in enumerate(row):\n                    if x == 1:\n                        fire[i][j] = True\n                        q1.append((i, j))\n            while t and q1:\n                q1 = spread(q1)\n                t -= 1\n            if fire[0][0]:\n                return False\n            q2 = deque([(0, 0)])\n            vis = [[False] * n for _ in range(m)]\n            vis[0][0] = True\n            while q2:\n                for _ in range(len(q2)):\n                    i, j = q2.popleft()\n                    if fire[i][j]:\n                        continue\n                    for a, b in pairwise(dirs):\n                        x, y = i + a, j + b\n                        if (\n                            0 <= x < m\n                            and 0 <= y < n\n                            and not vis[x][y]\n                            and not fire[x][y]\n                            and grid[x][y] == 0\n                        ):\n                            if x == m - 1 and y == n - 1:\n                                return True\n                            vis[x][y] = True\n                            q2.append((x, y))\n                q1 = spread(q1)\n            return False\n\n        m, n = len(grid), len(grid[0])\n        l, r = -1, m * n\n        dirs = (-1, 0, 1, 0, -1)\n        fire = [[False] * n for _ in range(m)]\n        while l < r:\n            mid = (l + r + 1) >> 1\n            if check(mid):\n                l = mid\n            else:\n                r = mid - 1\n        return int(1e9) if l == m * n else l\n", "class Solution:\n  def maximumMinutes(self, grid: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    MAX = len(grid) * len(grid[0])\n    fireGrid = [[-1] * len(grid[0]) for _ in range(len(grid[0]))]\n    self._buildFireGrid(grid, fireGrid, DIRS)\n\n    ans = -1\n    l = 0\n    r = MAX\n\n    while l <= r:\n      m = (l + r) // 2\n      if self._canStayFor(grid, fireGrid, m, DIRS):\n        ans = m\n        l = m + 1\n      else:\n        r = m - 1\n\n    return 1e9 if ans == MAX else ans\n\n  def _buildFireGrid(\n      self,\n      grid: list[list[int]],\n      fireMinute: list[list[int]],\n      DIRS: list[int],\n  ) -> None:\n    minuteFromFire = 0\n    q = collections.deque()\n\n    for i in range(len(grid)):\n      for j in range(len(grid[0])):\n        if grid[i][j] == 1:  # the fire\n          q.append((i, j))\n          fireMinute[i][j] = 0\n\n    while q:\n      minuteFromFire += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == len(grid) or y < 0 or y == len(grid[0]):\n            continue\n          if grid[x][y] == 2:  # the wall\n            continue\n          if fireMinute[x][y] != -1:\n            continue\n          fireMinute[x][y] = minuteFromFire\n          q.append((x, y))\n\n  def _canStayFor(\n      self,\n      grid: list[list[int]],\n      fireMinute: list[list[int]],\n      minute: int, DIRS: list[int],\n  ) -> bool:\n    q = collections.deque([(0, 0)])  # the start position\n    seen = {(0, 0)}\n\n    while q:\n      minute += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == len(grid) or y < 0 or y == len(grid[0]):\n            continue\n          if grid[x][y] == 2:  # the wall\n            continue\n          if x == len(grid) - 1 and y == len(grid[0]) - 1:\n            if fireMinute[x][y] != -1 and fireMinute[x][y] < minute:\n              continue\n            return True\n          if fireMinute[x][y] != -1 and fireMinute[x][y] <= minute:\n            continue\n          if seen[x][y]:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n\n    return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2261, "slug": "k-divisible-elements-subarrays", "solutions": ["class Solution:\n    def countDistinct(self, nums: List[int], k: int, p: int) -> int:\n        s = set()\n        n = len(nums)\n        base1, base2 = 131, 13331\n        mod1, mod2 = 10**9 + 7, 10**9 + 9\n        for i in range(n):\n            h1 = h2 = cnt = 0\n            for j in range(i, n):\n                cnt += nums[j] % p == 0\n                if cnt > k:\n                    break\n                h1 = (h1 * base1 + nums[j]) % mod1\n                h2 = (h2 * base2 + nums[j]) % mod2\n                s.add(h1 << 32 | h2)\n        return len(s)\n", "class TrieNode:\n  def __init__(self):\n    self.children: dict[int, TrieNode] = {}\n    self.count = 0\n\n\nclass Solution:\n  def countDistinct(self, nums: list[int], k: int, p: int) -> int:\n    ans = 0\n    root = TrieNode()\n\n    def insert(node: TrieNode, i: int, k: int):\n      nonlocal ans\n      if i == len(nums) or k - (nums[i] % p == 0) < 0:\n        return\n      if nums[i] not in node.children:\n        node.children[nums[i]] = TrieNode()\n        ans += 1\n      insert(node.children[nums[i]], i + 1, k - (nums[i] % p == 0))\n\n    for i in range(len(nums)):\n      insert(root, i, k)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2214, "slug": "minimum-health-to-beat-game", "solutions": ["class Solution:\n    def minimumHealth(self, damage: List[int], armor: int) -> int:\n        return sum(damage) - min(max(damage), armor) + 1\n", "class Solution:\n  def minimumHealth(self, damage: list[int], armor: int) -> int:\n    return 1 + sum(damage) - min(max(damage), armor)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2290, "slug": "minimum-obstacle-removal-to-reach-corner", "solutions": ["class Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        q = deque([(0, 0, 0)])\n        vis = set()\n        dirs = (-1, 0, 1, 0, -1)\n        while 1:\n            i, j, k = q.popleft()\n            if i == m - 1 and j == n - 1:\n                return k\n            if (i, j) in vis:\n                continue\n            vis.add((i, j))\n            for a, b in pairwise(dirs):\n                x, y = i + a, j + b\n                if 0 <= x < m and 0 <= y < n:\n                    if grid[x][y] == 0:\n                        q.appendleft((x, y, k))\n                    else:\n                        q.append((x, y, k + 1))\n", "class Solution:\n  def minimumObstacles(self, grid: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    minHeap = [(grid[0][0], 0, 0)]  # (d, i, j)\n    dist = [[math.inf] * n for _ in range(m)]\n    dist[0][0] = grid[0][0]\n\n    while minHeap:\n      d, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        return d\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        newDist = d + grid[i][j]\n        if newDist < dist[x][y]:\n          dist[x][y] = newDist\n          heapq.heappush(minHeap, (newDist, x, y))\n\n    return dist[m - 1][n - 1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2213, "slug": "longest-substring-of-one-repeating-character", "solutions": ["def max(a: int, b: int) -> int:\n    return a if a > b else b\n\n\nclass Node:\n    __slots__ = \"l\", \"r\", \"lmx\", \"rmx\", \"mx\"\n\n    def __init__(self, l: int, r: int):\n        self.l = l\n        self.r = r\n        self.lmx = self.rmx = self.mx = 1\n\n\nclass SegmentTree:\n    __slots__ = \"s\", \"tr\"\n\n    def __init__(self, s: str):\n        self.s = list(s)\n        n = len(s)\n        self.tr: List[Node | None] = [None] * (n * 4)\n        self.build(1, 1, n)\n\n    def build(self, u: int, l: int, r: int):\n        self.tr[u] = Node(l, r)\n        if l == r:\n            return\n        mid = (l + r) // 2\n        self.build(u << 1, l, mid)\n        self.build(u << 1 | 1, mid + 1, r)\n        self.pushup(u)\n\n    def query(self, u: int, l: int, r: int) -> int:\n        if self.tr[u].l >= l and self.tr[u].r <= r:\n            return self.tr[u].mx\n        mid = (self.tr[u].l + self.tr[u].r) // 2\n        ans = 0\n        if r <= mid:\n            ans = self.query(u << 1, l, r)\n        if l > mid:\n            ans = max(ans, self.query(u << 1 | 1, l, r))\n        return ans\n\n    def modify(self, u: int, x: int, v: str):\n        if self.tr[u].l == self.tr[u].r:\n            self.s[x - 1] = v\n            return\n        mid = (self.tr[u].l + self.tr[u].r) // 2\n        if x <= mid:\n            self.modify(u << 1, x, v)\n        else:\n            self.modify(u << 1 | 1, x, v)\n        self.pushup(u)\n\n    def pushup(self, u: int):\n        root, left, right = self.tr[u], self.tr[u << 1], self.tr[u << 1 | 1]\n        root.lmx = left.lmx\n        root.rmx = right.rmx\n        root.mx = max(left.mx, right.mx)\n        a, b = left.r - left.l + 1, right.r - right.l + 1\n        if self.s[left.r - 1] == self.s[right.l - 1]:\n            if left.lmx == a:\n                root.lmx += right.lmx\n            if right.rmx == b:\n                root.rmx += left.rmx\n            root.mx = max(root.mx, left.rmx + right.lmx)\n\n\nclass Solution:\n    def longestRepeating(\n        self, s: str, queryCharacters: str, queryIndices: List[int]\n    ) -> List[int]:\n        tree = SegmentTree(s)\n        ans = []\n        for x, v in zip(queryIndices, queryCharacters):\n            tree.modify(1, x + 1, v)\n            ans.append(tree.query(1, 1, len(s)))\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2259, "slug": "remove-digit-from-number-to-maximize-result", "solutions": ["class Solution:\n    def removeDigit(self, number: str, digit: str) -> str:\n        return max(\n            number[:i] + number[i + 1 :] for i, d in enumerate(number) if d == digit\n        )\n", ""], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2253, "slug": "dynamic-unpivoting-of-a-table", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2223, "slug": "sum-of-scores-of-built-strings", "solutions": ["class Solution:\n  def sumScores(self, s: str) -> int:\n    n = len(s)\n    # https://cp-algorithms.com/string/z-function.html#implementation\n    z = [0] * n\n    # [l, r] := the indices of the rightmost segment match\n    l = 0\n    r = 0\n\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n\n    return sum(z) + n\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2287, "slug": "rearrange-characters-to-make-target-string", "solutions": ["class Solution:\n    def rearrangeCharacters(self, s: str, target: str) -> int:\n        cnt1 = Counter(s)\n        cnt2 = Counter(target)\n        return min(cnt1[c] // v for c, v in cnt2.items())\n", "class Solution:\n  def rearrangeCharacters(self, s: str, target: str) -> int:\n    countS = collections.Counter(s)\n    countT = collections.Counter(target)\n    return min(countS[c] // countT[c] for c in target)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2262, "slug": "total-appeal-of-a-string", "solutions": ["class Solution:\n    def appealSum(self, s: str) -> int:\n        ans = t = 0\n        pos = [-1] * 26\n        for i, c in enumerate(s):\n            c = ord(c) - ord('a')\n            t += i - pos[c]\n            ans += t\n            pos[c] = i\n        return ans\n", "class Solution:\n  def appealSum(self, s: str) -> int:\n    ans = 0\n    lastSeen = {}\n\n    for i, c in enumerate(s):\n      ans += (i - lastSeen.get(c, -1)) * (len(s) - i)\n      lastSeen[c] = i\n\n    return ans\n", "class Solution:\n  def appealSum(self, s: str) -> int:\n    ans = 0\n    # the total appeal of all substrings ending in the index so far\n    dp = 0\n    lastSeen = {}\n\n    for i, c in enumerate(s):\n      #   the total appeal of all substrings ending in s[i]\n      # = the total appeal of all substrings ending in s[i - 1]\n      # + the number of substrings ending in s[i] that contain only this s[i]\n      dp += i - lastSeen.get(c, -1)\n      ans += dp\n      lastSeen[c] = i\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2201, "slug": "count-artifacts-that-can-be-extracted", "solutions": ["class Solution:\n    def digArtifacts(\n        self, n: int, artifacts: List[List[int]], dig: List[List[int]]\n    ) -> int:\n        def check(a: List[int]) -> bool:\n            x1, y1, x2, y2 = a\n            return all(\n                (x, y) in s for x in range(x1, x2 + 1) for y in range(y1, y2 + 1)\n            )\n\n        s = {(i, j) for i, j in dig}\n        return sum(check(a) for a in artifacts)\n", "class Solution:\n  def digArtifacts(\n      self,\n      n: int,\n      artifacts: list[list[int]],\n      dig: list[list[int]],\n  ) -> int:\n    digged = set((r, c) for r, c in dig)\n\n    def canExtract(a: list[int]) -> bool:\n      for i in range(a[0], a[2] + 1):\n        for j in range(a[1], a[3] + 1):\n          if (i, j) not in digged:\n            return False\n      return True\n\n    return sum(canExtract(a) for a in artifacts)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2293, "slug": "min-max-game", "solutions": ["class Solution:\n    def minMaxGame(self, nums: List[int]) -> int:\n        n = len(nums)\n        while n > 1:\n            n >>= 1\n            for i in range(n):\n                a, b = nums[i << 1], nums[i << 1 | 1]\n                nums[i] = min(a, b) if i % 2 == 0 else max(a, b)\n        return nums[0]\n", "class Solution:\n  def minMaxGame(self, nums: list[int]) -> int:\n    if len(nums) == 1:\n      return nums[0]\n\n    nextNums = []\n    for i in range(len(nums) // 2):\n      nextNums.append(min(nums[2 * i], nums[2 * i + 1]) if i % 2 == 0 else\n                      max(nums[2 * i], nums[2 * i + 1]))\n    return self.minMaxGame(nextNums)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2234, "slug": "maximum-total-beauty-of-the-gardens", "solutions": ["class Solution:\n    def maximumBeauty(\n        self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int\n    ) -> int:\n        flowers.sort()\n        n = len(flowers)\n        s = list(accumulate(flowers, initial=0))\n        ans, i = 0, n - bisect_left(flowers, target)\n        for x in range(i, n + 1):\n            newFlowers -= 0 if x == 0 else max(target - flowers[n - x], 0)\n            if newFlowers < 0:\n                break\n            l, r = 0, n - x - 1\n            while l < r:\n                mid = (l + r + 1) >> 1\n                if flowers[mid] * (mid + 1) - s[mid + 1] <= newFlowers:\n                    l = mid\n                else:\n                    r = mid - 1\n            y = 0\n            if r != -1:\n                cost = flowers[l] * (l + 1) - s[l + 1]\n                y = min(flowers[l] + (newFlowers - cost) // (l + 1), target - 1)\n            ans = max(ans, x * full + y * partial)\n        return ans\n", "class Solution:\n  def maximumBeauty(\n      self,\n      flowers: list[int],\n      newFlowers: int,\n      target: int,\n      full: int,\n      partial: int,\n  ) -> int:\n    n = len(flowers)\n\n    # If a garden is already complete, clamp it to the target.\n    flowers = [min(flower, target) for flower in flowers]\n    flowers.sort()\n\n    # All gardens are complete, so nothing we can do.\n    if flowers[0] == target:\n      return n * full\n\n    # Having many new flowers maximizes the beauty value.\n    if newFlowers >= n * target - sum(flowers):\n      return max(n * full, (n - 1) * full + (target - 1) * partial)\n\n    ans = 0\n    leftFlowers = newFlowers\n    # cost[i] := the cost to make flowers[0..i] the same\n    cost = [0] * n\n\n    for i in range(1, n):\n      # Plant (flowers[i] - flowers[i - 1]) flowers for flowers[0..i - 1].\n      cost[i] = cost[i - 1] + i * (flowers[i] - flowers[i - 1])\n\n    i = n - 1  # flowers' index (flowers[i + 1..n) are complete)\n    while flowers[i] == target:\n      i -= 1\n\n    while leftFlowers >= 0:\n      # To maximize the minimum number of incomplete flowers, we find the first\n      # index j that we can't make flowers[0..j] equal to flowers[j], then we\n      # know we can make flowers[0..j - 1] equal to flowers[j - 1]. In the\n      # meantime, evenly increase each of them to seek a bigger minimum value.\n      j = min(i + 1, bisect_right(cost, leftFlowers))\n      minIncomplete = flowers[j - 1] + (leftFlowers - cost[j - 1]) // j\n      ans = max(ans, (n - 1 - i) * full + minIncomplete * partial)\n      leftFlowers -= max(0, target - flowers[i])\n      i -= 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2235, "slug": "add-two-integers", "solutions": ["class Solution:\n    def sum(self, num1: int, num2: int) -> int:\n        return num1 + num2\n", "class Solution:\n  sum = operator.add\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2268, "slug": "minimum-number-of-keypresses", "solutions": ["class Solution:\n    def minimumKeypresses(self, s: str) -> int:\n        cnt = Counter(s)\n        ans, k = 0, 1\n        for i, x in enumerate(sorted(cnt.values(), reverse=True), 1):\n            ans += k * x\n            if i % 9 == 0:\n                k += 1\n        return ans\n", "class Solution:\n  def minimumKeypresses(self, s: str) -> int:\n    return sum(c * (i // 9 + 1)\n               for i, c in enumerate(sorted(Counter(s).values(), reverse=True)))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2266, "slug": "count-number-of-texts", "solutions": ["mod = 10**9 + 7\nf = [1, 1, 2, 4]\ng = [1, 1, 2, 4]\nfor _ in range(100000):\n    f.append((f[-1] + f[-2] + f[-3]) % mod)\n    g.append((g[-1] + g[-2] + g[-3] + g[-4]) % mod)\n\n\nclass Solution:\n    def countTexts(self, pressedKeys: str) -> int:\n        ans = 1\n        for c, s in groupby(pressedKeys):\n            m = len(list(s))\n            ans = ans * (g[m] if c in \"79\" else f[m]) % mod\n        return ans\n", "class Solution:\n  def countTexts(self, pressedKeys: str) -> int:\n    MOD = 1_000_000_007\n    n = len(pressedKeys)\n    # dp[i] := the number of possible text messages of pressedKeys[i..n)\n    dp = [0] * n + [1]\n\n    def isSame(s: str, i: int, k: int) -> bool:\n      \"\"\"Returns True if s[i..i + k) are the same digits.\"\"\"\n      if i + k > len(s):\n        return False\n      for j in range(i + 1, i + k):\n        if s[j] != s[i]:\n          return False\n      return True\n\n    for i in reversed(range(n)):\n      dp[i] = dp[i + 1]\n      if isSame(pressedKeys, i, 2):\n        dp[i] += dp[i + 2]\n      if isSame(pressedKeys, i, 3):\n        dp[i] += dp[i + 3]\n      if ((pressedKeys[i] == '7' or pressedKeys[i] == '9') and\n              isSame(pressedKeys, i, 4)):\n        dp[i] += dp[i + 4]\n      dp[i] %= MOD\n\n    return dp[0]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2286, "slug": "booking-concert-tickets-in-groups", "solutions": ["class Node:\n    __slots__ = \"l\", \"r\", \"s\", \"mx\"\n\n    def __init__(self):\n        self.l = self.r = 0\n        self.s = self.mx = 0\n\n\nclass SegmentTree:\n    def __init__(self, n, m):\n        self.m = m\n        self.tr = [Node() for _ in range(n << 2)]\n        self.build(1, 1, n)\n\n    def build(self, u, l, r):\n        self.tr[u].l, self.tr[u].r = l, r\n        if l == r:\n            self.tr[u].s = self.tr[u].mx = self.m\n            return\n        mid = (l + r) >> 1\n        self.build(u << 1, l, mid)\n        self.build(u << 1 | 1, mid + 1, r)\n        self.pushup(u)\n\n    def modify(self, u, x, v):\n        if self.tr[u].l == x and self.tr[u].r == x:\n            self.tr[u].s = self.tr[u].mx = v\n            return\n        mid = (self.tr[u].l + self.tr[u].r) >> 1\n        if x <= mid:\n            self.modify(u << 1, x, v)\n        else:\n            self.modify(u << 1 | 1, x, v)\n        self.pushup(u)\n\n    def query_sum(self, u, l, r):\n        if self.tr[u].l >= l and self.tr[u].r <= r:\n            return self.tr[u].s\n        mid = (self.tr[u].l + self.tr[u].r) >> 1\n        v = 0\n        if l <= mid:\n            v += self.query_sum(u << 1, l, r)\n        if r > mid:\n            v += self.query_sum(u << 1 | 1, l, r)\n        return v\n\n    def query_idx(self, u, l, r, k):\n        if self.tr[u].mx < k:\n            return 0\n        if self.tr[u].l == self.tr[u].r:\n            return self.tr[u].l\n        mid = (self.tr[u].l + self.tr[u].r) >> 1\n        if self.tr[u << 1].mx >= k:\n            return self.query_idx(u << 1, l, r, k)\n        if r > mid:\n            return self.query_idx(u << 1 | 1, l, r, k)\n        return 0\n\n    def pushup(self, u):\n        self.tr[u].s = self.tr[u << 1].s + self.tr[u << 1 | 1].s\n        self.tr[u].mx = max(self.tr[u << 1].mx, self.tr[u << 1 | 1].mx)\n\n\nclass BookMyShow:\n    def __init__(self, n: int, m: int):\n        self.n = n\n        self.tree = SegmentTree(n, m)\n\n    def gather(self, k: int, maxRow: int) -> List[int]:\n        maxRow += 1\n        i = self.tree.query_idx(1, 1, maxRow, k)\n        if i == 0:\n            return []\n        s = self.tree.query_sum(1, i, i)\n        self.tree.modify(1, i, s - k)\n        return [i - 1, self.tree.m - s]\n\n    def scatter(self, k: int, maxRow: int) -> bool:\n        maxRow += 1\n        if self.tree.query_sum(1, 1, maxRow) < k:\n            return False\n        i = self.tree.query_idx(1, 1, maxRow, 1)\n        for j in range(i, self.n + 1):\n            s = self.tree.query_sum(1, j, j)\n            if s >= k:\n                self.tree.modify(1, j, s - k)\n                return True\n            k -= s\n            self.tree.modify(1, j, 0)\n        return True\n\n\n# Your BookMyShow object will be instantiated and called as such:\n# obj = BookMyShow(n, m)\n# param_1 = obj.gather(k,maxRow)\n# param_2 = obj.scatter(k,maxRow)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2231, "slug": "largest-number-after-digit-swaps-by-parity", "solutions": ["class Solution:\n    def largestInteger(self, num: int) -> int:\n        nums = [int(c) for c in str(num)]\n        cnt = Counter(nums)\n        idx = [8, 9]\n        ans = 0\n        for x in nums:\n            while cnt[idx[x & 1]] == 0:\n                idx[x & 1] -= 2\n            ans = ans * 10 + idx[x & 1]\n            cnt[idx[x & 1]] -= 1\n        return ans\n", "class Solution:\n  def largestInteger(self, num: int) -> int:\n    s = str(num)\n    ans = 0\n    # maxHeap[0] := the odd digits\n    # maxHeap[1] := the even digits\n    maxHeap = [[] for _ in range(2)]\n\n    for c in s:\n      digit = int(c)\n      heapq.heappush(maxHeap[digit % 2], -digit)\n\n    for c in s:\n      i = int(c) & 1\n      ans = (ans * 10 - heapq.heappop(maxHeap[i]))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2237, "slug": "count-positions-on-street-with-required-brightness", "solutions": ["class Solution:\n    def meetRequirement(\n        self, n: int, lights: List[List[int]], requirement: List[int]\n    ) -> int:\n        d = [0] * (n + 1)\n        for p, r in lights:\n            i, j = max(0, p - r), min(n - 1, p + r)\n            d[i] += 1\n            d[j + 1] -= 1\n        return sum(s >= r for s, r in zip(accumulate(d), requirement))\n", "class Solution:\n  def meetRequirement(\n      self,\n      n: int,\n      lights: list[list[int]],\n      requirement: list[int],\n  ) -> int:\n    ans = 0\n    currBrightness = 0\n    change = [0] * (n + 1)\n\n    for position, rg in lights:\n      change[max(0, position - rg)] += 1\n      change[min(n, position + rg + 1)] -= 1\n\n    for i in range(n):\n      currBrightness += change[i]\n      if currBrightness >= requirement[i]:\n        ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2233, "slug": "maximum-product-after-k-increments", "solutions": ["class Solution:\n    def maximumProduct(self, nums: List[int], k: int) -> int:\n        heapify(nums)\n        for _ in range(k):\n            heapreplace(nums, nums[0] + 1)\n        mod = 10**9 + 7\n        return reduce(lambda x, y: x * y % mod, nums)\n", "class Solution:\n  def maximumProduct(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    ans = 1\n    minHeap = nums.copy()\n    heapq.heapify(minHeap)\n\n    for _ in range(k):\n      minNum = heapq.heappop(minHeap)\n      heapq.heappush(minHeap, minNum + 1)\n\n    while minHeap:\n      ans *= heapq.heappop(minHeap)\n      ans %= MOD\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2203, "slug": "minimum-weighted-subgraph-with-the-required-paths", "solutions": ["class Solution:\n    def minimumWeight(\n        self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int\n    ) -> int:\n        def dijkstra(g, u):\n            dist = [inf] * n\n            dist[u] = 0\n            q = [(0, u)]\n            while q:\n                d, u = heappop(q)\n                if d > dist[u]:\n                    continue\n                for v, w in g[u]:\n                    if dist[v] > dist[u] + w:\n                        dist[v] = dist[u] + w\n                        heappush(q, (dist[v], v))\n            return dist\n\n        g = defaultdict(list)\n        rg = defaultdict(list)\n        for f, t, w in edges:\n            g[f].append((t, w))\n            rg[t].append((f, w))\n        d1 = dijkstra(g, src1)\n        d2 = dijkstra(g, src2)\n        d3 = dijkstra(rg, dest)\n        ans = min(sum(v) for v in zip(d1, d2, d3))\n        return -1 if ans >= inf else ans\n", "class Solution:\n  def minimumWeight(\n      self,\n      n: int,\n      edges: list[list[int]],\n      src1: int,\n      src2: int,\n      dest: int,\n  ) -> int:\n    graph = [[] for _ in range(n)]\n    reversedGraph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      reversedGraph[v].append((u, w))\n\n    fromSrc1 = self._dijkstra(graph, src1)\n    fromSrc2 = self._dijkstra(graph, src2)\n    fromDest = self._dijkstra(reversedGraph, dest)\n    minWeight = min(a + b + c for a, b, c in zip(fromSrc1, fromSrc2, fromDest))\n    return -1 if minWeight == math.inf else minWeight\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n  ) -> list[int]:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2299, "slug": "strong-password-checker-ii", "solutions": ["class Solution:\n    def strongPasswordCheckerII(self, password: str) -> bool:\n        if len(password) < 8:\n            return False\n        mask = 0\n        for i, c in enumerate(password):\n            if i and c == password[i - 1]:\n                return False\n            if c.islower():\n                mask |= 1\n            elif c.isupper():\n                mask |= 2\n            elif c.isdigit():\n                mask |= 4\n            else:\n                mask |= 8\n        return mask == 15\n", "class Solution:\n  def strongPasswordCheckerII(self, password: str) -> bool:\n    if len(password) < 8:\n      return False\n    if not any(c.islower() for c in password):\n      return False\n    if not any(c.isupper() for c in password):\n      return False\n    if not any(c.isdigit() for c in password):\n      return False\n    if not any(\"!@#$%^&*()-+\".find(c) != -1 for c in password):\n      return False\n    return all(a != b for a, b in zip(password, password[1:]))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2225, "slug": "find-players-with-zero-or-one-losses", "solutions": ["class Solution:\n    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:\n        cnt = Counter()\n        for winner, loser in matches:\n            if winner not in cnt:\n                cnt[winner] = 0\n            cnt[loser] += 1\n        ans = [[], []]\n        for x, v in sorted(cnt.items()):\n            if v < 2:\n                ans[v].append(x)\n        return ans\n", "class Solution:\n  def findWinners(self, matches: list[list[int]]) -> list[list[int]]:\n    ans = [[] for _ in range(2)]\n    lossesCount = collections.Counter()\n\n    for winner, loser in matches:\n      if winner not in lossesCount:\n        lossesCount[winner] = 0\n      lossesCount[loser] += 1\n\n    for player, nLosses in lossesCount.items():\n      if nLosses < 2:\n        ans[nLosses].append(player)\n\n    return [sorted(ans[0]), sorted(ans[1])]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2249, "slug": "count-lattice-points-inside-a-circle", "solutions": ["class Solution:\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\n        ans = 0\n        mx = max(x + r for x, _, r in circles)\n        my = max(y + r for _, y, r in circles)\n        for i in range(mx + 1):\n            for j in range(my + 1):\n                for x, y, r in circles:\n                    dx, dy = i - x, j - y\n                    if dx * dx + dy * dy <= r * r:\n                        ans += 1\n                        break\n        return ans\n", "class Solution:\n  def countLatticePoints(self, circles: list[list[int]]) -> int:\n    return sum(any((xc - x)**2 + (yc - y)**2 <= r**2 for xc, yc, r in circles)\n               for x in range(201)\n               for y in range(201))\n", "class Solution:\n  def countLatticePoints(self, circles: list[list[int]]) -> int:\n    points = set()\n\n    # dx := relative to x\n    # dy := relative to y\n    # So, dx^2 + dy^2 = r^2.\n    for x, y, r in circles:\n      for dx in range(-r, r + 1):\n        yMax = int((r**2 - dx**2)**0.5)\n        for dy in range(-yMax, yMax + 1):\n          points.add((x + dx, y + dy))\n\n    return len(points)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2264, "slug": "largest-3-same-digit-number-in-string", "solutions": ["class Solution:\n    def largestGoodInteger(self, num: str) -> str:\n        for i in range(9, -1, -1):\n            if (s := str(i) * 3) in num:\n                return s\n        return \"\"\n", "class Solution:\n  def largestGoodInteger(self, num: str) -> str:\n    return max(num[i - 2:i + 1]\n               if num[i] == num[i - 1] == num[i - 2]\n               else '' for i in range(2, len(num)))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2206, "slug": "divide-array-into-equal-pairs", "solutions": ["class Solution:\n    def divideArray(self, nums: List[int]) -> bool:\n        cnt = Counter(nums)\n        return all(v % 2 == 0 for v in cnt.values())\n", "class Solution:\n  def divideArray(self, nums: list[int]) -> bool:\n    return all(value % 2 == 0 for value in collections.Counter(nums).values())\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2248, "slug": "intersection-of-multiple-arrays", "solutions": ["class Solution:\n    def intersection(self, nums: List[List[int]]) -> List[int]:\n        cnt = [0] * 1001\n        for arr in nums:\n            for x in arr:\n                cnt[x] += 1\n        return [x for x, v in enumerate(cnt) if v == len(nums)]\n", "class Solution:\n  def intersection(self, nums: list[list[int]]) -> list[int]:\n    count = [0] * 1001\n\n    for row in nums:\n      for a in row:\n        count[a] += 1\n\n    return [i for i, c in enumerate(count)\n            if c == len(nums)]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2255, "slug": "count-prefixes-of-a-given-string", "solutions": ["class Solution:\n    def countPrefixes(self, words: List[str], s: str) -> int:\n        return sum(s.startswith(w) for w in words)\n", "class Solution:\n  def countPrefixes(self, words: list[str], s: str) -> int:\n    return sum(map(s.startswith, words))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2200, "slug": "find-all-k-distant-indices-in-an-array", "solutions": ["class Solution:\n    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\n        ans = []\n        n = len(nums)\n        for i in range(n):\n            if any(abs(i - j) <= k and nums[j] == key for j in range(n)):\n                ans.append(i)\n        return ans\n", "class Solution:\n  def findKDistantIndices(self, nums: list[int], key: int, k: int) -> list[int]:\n    n = len(nums)\n    ans = []\n\n    j = 0\n    for i in range(n):\n      # the first index j s.t. nums[j] == key and j >= i - k\n      while j < n and (nums[j] != key or j < i - k):\n        j += 1\n      if j == n:\n        break\n      if abs(i - j) <= k:\n        ans.append(i)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2274, "slug": "maximum-consecutive-floors-without-special-floors", "solutions": ["class Solution:\n    def maxConsecutive(self, bottom: int, top: int, special: List[int]) -> int:\n        special.sort()\n        ans = max(special[0] - bottom, top - special[-1])\n        for x, y in pairwise(special):\n            ans = max(ans, y - x - 1)\n        return ans\n", "class Solution:\n  def maxConsecutive(self, bottom: int, top: int, special: list[int]) -> int:\n    ans = 0\n\n    special.sort()\n\n    for a, b in zip(special, special[1:]):\n      ans = max(ans, b - a - 1)\n\n    return max(ans, special[0] - bottom, top - special[-1])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2257, "slug": "count-unguarded-cells-in-the-grid", "solutions": ["class Solution:\n    def countUnguarded(\n        self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]\n    ) -> int:\n        g = [[0] * n for _ in range(m)]\n        for i, j in guards:\n            g[i][j] = 2\n        for i, j in walls:\n            g[i][j] = 2\n        dirs = (-1, 0, 1, 0, -1)\n        for i, j in guards:\n            for a, b in pairwise(dirs):\n                x, y = i, j\n                while 0 <= x + a < m and 0 <= y + b < n and g[x + a][y + b] < 2:\n                    x, y = x + a, y + b\n                    g[x][y] = 1\n        return sum(v == 0 for row in g for v in row)\n", "class Solution:\n  def countUnguarded(\n      self,\n      m: int,\n      n: int,\n      guards: list[list[int]],\n      walls: list[list[int]],\n  ) -> int:\n    ans = 0\n    grid = [[0] * n for _ in range(m)]\n    left = [[0] * n for _ in range(m)]\n    right = [[0] * n for _ in range(m)]\n    up = [[0] * n for _ in range(m)]\n    down = [[0] * n for _ in range(m)]\n\n    for row, col in guards:\n      grid[row][col] = 'G'\n\n    for row, col in walls:\n      grid[row][col] = 'W'\n\n    for i in range(m):\n      lastCell = 0\n      for j in range(n):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          left[i][j] = lastCell\n      lastCell = 0\n      for j in range(n - 1, -1, -1):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          right[i][j] = lastCell\n\n    for j in range(n):\n      lastCell = 0\n      for i in range(m):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          up[i][j] = lastCell\n      lastCell = 0\n      for i in range(m - 1, -1, -1):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          down[i][j] = lastCell\n\n    for i in range(m):\n      for j in range(n):\n        if (grid[i][j] == 0 and left[i][j] != 'G' and right[i][j] != 'G' and\n                up[i][j] != 'G' and down[i][j] != 'G'):\n          ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2207, "slug": "maximize-number-of-subsequences-in-a-string", "solutions": ["class Solution:\n    def maximumSubsequenceCount(self, text: str, pattern: str) -> int:\n        ans = x = y = 0\n        for c in text:\n            if c == pattern[1]:\n                y += 1\n                ans += x\n            if c == pattern[0]:\n                x += 1\n        ans += max(x, y)\n        return ans\n", "class Solution:\n  def maximumSubsequenceCount(self, text: str, pattern: str) -> int:\n    ans = 0\n    count0 = 0  # the count of the letter pattern[0]\n    count1 = 0  # the count of the letter pattern[1]\n\n    for c in text:\n      if c == pattern[1]:\n        ans += count0\n        count1 += 1\n      if c == pattern[0]:\n        count0 += 1\n\n    # It is optimal to add pattern[0] at the beginning or add pattern[1] at the\n    # end of the text.\n    return ans + max(count0, count1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2219, "slug": "maximum-sum-score-of-array", "solutions": ["class Solution:\n    def maximumSumScore(self, nums: List[int]) -> int:\n        l, r = 0, sum(nums)\n        ans = -inf\n        for x in nums:\n            l += x\n            ans = max(ans, l, r)\n            r -= x\n        return ans\n", "class Solution:\n  def maximumSumScore(self, nums: list[int]) -> int:\n    ans = -math.inf\n    prefix = 0\n    summ = sum(nums)\n\n    for num in nums:\n      prefix += num\n      ans = max(ans, prefix, summ - prefix + num)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2272, "slug": "substring-with-largest-variance", "solutions": ["class Solution:\n    def largestVariance(self, s: str) -> int:\n        ans = 0\n        for a, b in permutations(ascii_lowercase, 2):\n            if a == b:\n                continue\n            f = [0, -inf]\n            for c in s:\n                if c == a:\n                    f[0], f[1] = f[0] + 1, f[1] + 1\n                elif c == b:\n                    f[1] = max(f[1] - 1, f[0] - 1)\n                    f[0] = 0\n                if ans < f[1]:\n                    ans = f[1]\n        return ans\n", "class Solution:\n  def largestVariance(self, s: str) -> int:\n    # a := the letter with the higher frequency\n    # b := the letter with the lower frequency\n    def kadane(a: str, b: str) -> int:\n      ans = 0\n      countA = 0\n      countB = 0\n      canExtendPrevB = False\n\n      for c in s:\n        if c != a and c != b:\n          continue\n        if c == a:\n          countA += 1\n        else:\n          countB += 1\n        if countB > 0:\n          # An interval should contain at least one b.\n          ans = max(ans, countA - countB)\n        elif countB == 0 and canExtendPrevB:\n          # edge case: consider the previous b.\n          ans = max(ans, countA - 1)\n        # Reset if the number of b > the number of a.\n        if countB > countA:\n          countA = 0\n          countB = 0\n          canExtendPrevB = True\n\n      return ans\n\n    return max(kadane(a, b)\n               for a in string.ascii_lowercase\n               for b in string.ascii_lowercase\n               if a != b)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2275, "slug": "largest-combination-with-bitwise-and-greater-than-zero", "solutions": ["class Solution:\n    def largestCombination(self, candidates: List[int]) -> int:\n        ans = 0\n        for i in range(max(candidates).bit_length()):\n            ans = max(ans, sum(x >> i & 1 for x in candidates))\n        return ans\n", "class Solution:\n  def largestCombination(self, candidates: list[int]) -> int:\n    return max(sum(c >> i & 1 for c in candidates) for i in range(24))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2210, "slug": "count-hills-and-valleys-in-an-array", "solutions": ["class Solution:\n    def countHillValley(self, nums: List[int]) -> int:\n        ans = j = 0\n        for i in range(1, len(nums) - 1):\n            if nums[i] == nums[i + 1]:\n                continue\n            if nums[i] > nums[j] and nums[i] > nums[i + 1]:\n                ans += 1\n            if nums[i] < nums[j] and nums[i] < nums[i + 1]:\n                ans += 1\n            j = i\n        return ans\n", "class Solution:\n  def countHillValley(self, nums: list[int]) -> int:\n    ans = 0\n    left = nums[0]\n\n    for i in range(1, len(nums) - 1):\n      if (left < nums[i] and nums[i] > nums[i + 1] or  # the hill\n              left > nums[i] and nums[i] < nums[i + 1]):  # the valley\n        ans += 1\n        left = nums[i]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2205, "slug": "the-number-of-users-that-are-eligible-for-discount", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3279, "slug": "maximum-total-area-occupied-by-pistons", "solutions": ["class Solution:\n    def maxArea(self, height: int, positions: List[int], directions: str) -> int:\n        delta = defaultdict(int)\n        diff = res = 0\n        for pos, dir in zip(positions, directions):\n            res += pos\n            if dir == \"U\":\n                diff += 1\n                delta[height - pos] -= 2\n                delta[height * 2 - pos] += 2\n            else:\n                diff -= 1\n                delta[pos] += 2\n                delta[height + pos] -= 2\n        ans = res\n        pre = 0\n        for cur, d in sorted(delta.items()):\n            res += (cur - pre) * diff\n            pre = cur\n            diff += d\n            ans = max(ans, res)\n        return ans\n", "from sortedcontainers import SortedDict\n\n\nclass Solution:\n  def maxArea(self, height: int, positions: list[int], directions: str) -> int:\n    area = sum(positions)\n    ans = area\n    diffPerSecond = 0\n    timeToIndices: SortedDict[int, list[int]] = SortedDict()\n\n    for i, (position, direction) in enumerate(zip(positions, directions)):\n      if direction == 'U':\n        timeToIndices.setdefault(height - position, []).append(i)\n        timeToIndices.setdefault(height - position + height, []).append(i)\n        diffPerSecond += 1\n      else:\n        timeToIndices.setdefault(position, []).append(i)\n        timeToIndices.setdefault(position + height, []).append(i)\n        diffPerSecond -= 1\n\n    prevTime = 0\n    directionsList = list(directions)\n\n    for time, indices in timeToIndices.items():\n      area += (time - prevTime) * diffPerSecond\n      ans = max(ans, area)\n      prevTime = time\n      for i in indices:\n        if directionsList[i] == 'U':\n          directionsList[i] = 'D'\n          diffPerSecond -= 2\n        else:\n          directionsList[i] = 'U'\n          diffPerSecond += 2\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3246, "slug": "premier-league-table-ranking", "solutions": ["import pandas as pd\n\n\ndef calculate_team_standings(team_stats: pd.DataFrame) -> pd.DataFrame:\n    team_stats[\"points\"] = team_stats[\"wins\"] * 3 + team_stats[\"draws\"]\n    team_stats[\"position\"] = team_stats[\"points\"].rank(method=\"min\", ascending=False)\n    team_stats = team_stats.sort_values(\n        by=[\"points\", \"team_name\"], ascending=[False, True]\n    )\n    return team_stats[[\"team_id\", \"team_name\", \"points\", \"position\"]]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3268, "slug": "find-overlapping-shifts-ii", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3297, "slug": "count-substrings-that-can-be-rearranged-to-contain-a-string-i", "solutions": ["class Solution:\n    def validSubstringCount(self, word1: str, word2: str) -> int:\n        if len(word1) < len(word2):\n            return 0\n        cnt = Counter(word2)\n        need = len(cnt)\n        ans = l = 0\n        win = Counter()\n        for c in word1:\n            win[c] += 1\n            if win[c] == cnt[c]:\n                need -= 1\n            while need == 0:\n                if win[word1[l]] == cnt[word1[l]]:\n                    need += 1\n                win[word1[l]] -= 1\n                l += 1\n            ans += l\n        return ans\n", "class Solution:\n  def validSubstringCount(self, word1: str, word2: str) -> int:\n    ans = 0\n    count = collections.Counter(word2)\n    required = len(word2)\n\n    l = 0\n    for r, c in enumerate(word1):\n      count[c] -= 1\n      if count[c] >= 0:\n        required -= 1\n      while required == 0:\n        # Add valid substrings containing word1[l..r] to the answer. They are\n        # word1[l..r], word1[l..r + 1], ..., word1[l..n - 1].\n        ans += len(word1) - r\n        count[word1[l]] += 1\n        if count[word1[l]] > 0:\n          required += 1\n        l += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3223, "slug": "minimum-length-of-string-after-operations", "solutions": ["class Solution:\n    def minimumLength(self, s: str) -> int:\n        cnt = Counter(s)\n        return sum(1 if x & 1 else 2 for x in cnt.values())\n", "class Solution:\n  def minimumLength(self, s: str) -> int:\n    count = collections.Counter(s)\n    return sum(2 if freq % 2 == 0 else 1 for freq in count.values())\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3210, "slug": "find-the-encrypted-string", "solutions": ["class Solution:\n    def getEncryptedString(self, s: str, k: int) -> str:\n        cs = list(s)\n        n = len(s)\n        for i in range(n):\n            cs[i] = s[(i + k) % n]\n        return \"\".join(cs)\n", "class Solution:\n  def getEncryptedString(self, s: str, k: int) -> str:\n    k %= len(s)\n    return s[k:] + s[0:k]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3278, "slug": "find-candidates-for-data-scientist-position-ii", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3252, "slug": "premier-league-table-ranking-ii", "solutions": ["import pandas as pd\n\n\ndef calculate_team_tiers(team_stats: pd.DataFrame) -> pd.DataFrame:\n    team_stats[\"points\"] = team_stats[\"wins\"] * 3 + team_stats[\"draws\"]\n    team_stats[\"position\"] = (\n        team_stats[\"points\"].rank(method=\"min\", ascending=False).astype(int)\n    )\n    total_teams = len(team_stats)\n    team_stats[\"tier\"] = np.where(\n        team_stats[\"position\"] <= np.ceil(total_teams / 3.0),\n        \"Tier 1\",\n        np.where(\n            team_stats[\"position\"] <= np.ceil(2 * total_teams / 3.0), \"Tier 2\", \"Tier 3\"\n        ),\n    )\n    team_stats = team_stats.sort_values(\n        by=[\"points\", \"team_name\"], ascending=[False, True]\n    )\n    return team_stats[[\"team_name\", \"points\", \"position\", \"tier\"]]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3203, "slug": "find-minimum-diameter-after-merging-two-trees", "solutions": ["class Solution:\n    def minimumDiameterAfterMerge(\n        self, edges1: List[List[int]], edges2: List[List[int]]\n    ) -> int:\n        d1 = self.treeDiameter(edges1)\n        d2 = self.treeDiameter(edges2)\n        return max(d1, d2, (d1 + 1) // 2 + (d2 + 1) // 2 + 1)\n\n    def treeDiameter(self, edges: List[List[int]]) -> int:\n        def dfs(i: int, fa: int, t: int):\n            for j in g[i]:\n                if j != fa:\n                    dfs(j, i, t + 1)\n            nonlocal ans, a\n            if ans < t:\n                ans = t\n                a = i\n\n        g = defaultdict(list)\n        for a, b in edges:\n            g[a].append(b)\n            g[b].append(a)\n        ans = a = 0\n        dfs(0, -1, 0)\n        dfs(a, -1, 0)\n        return ans\n", "class Solution:\n  def minimumDiameterAfterMerge(\n      self,\n      edges1: list[list[int]],\n      edges2: list[list[int]],\n  ) -> int:\n    diameter1 = self._getDiameter(edges1)\n    diameter2 = self._getDiameter(edges2)\n    combinedDiameter = (diameter1 + 1) // 2 + (diameter2 + 1) // 2 + 1\n    return max(diameter1, diameter2, combinedDiameter)\n\n  def _getDiameter(self, edges: list[list[int]]) -> int:\n    n = len(edges) + 1\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    maxDiameter = [0]\n    self._maxDepth(graph, 0, -1, maxDiameter)\n    return maxDiameter[0]\n\n  # Similar to 1522. Diameter of N-Ary Tree\n  def _maxDepth(\n      self,\n      graph: list[list[int]],\n      u: int,\n      prev: int,\n      maxDiameter: list[int],\n  ) -> int:\n    \"\"\"Returns the maximum depth of the subtree rooted at u.\"\"\"\n    maxSubDepth1 = 0\n    maxSubDepth2 = 0\n    for v in graph[u]:\n      if v == prev:\n        continue\n      maxSubDepth = self._maxDepth(graph, v, u, maxDiameter)\n      if maxSubDepth > maxSubDepth1:\n        maxSubDepth2 = maxSubDepth1\n        maxSubDepth1 = maxSubDepth\n      elif maxSubDepth > maxSubDepth2:\n        maxSubDepth2 = maxSubDepth\n    maxDiameter[0] = max(maxDiameter[0], maxSubDepth1 + maxSubDepth2)\n    return 1 + maxSubDepth1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3277, "slug": "maximum-xor-score-subarray-queries", "solutions": ["class Solution:\n    def maximumSubarrayXor(\n        self, nums: List[int], queries: List[List[int]]\n    ) -> List[int]:\n        n = len(nums)\n        f = [[0] * n for _ in range(n)]\n        g = [[0] * n for _ in range(n)]\n        for i in range(n - 1, -1, -1):\n            f[i][i] = g[i][i] = nums[i]\n            for j in range(i + 1, n):\n                f[i][j] = f[i][j - 1] ^ f[i + 1][j]\n                g[i][j] = max(f[i][j], g[i][j - 1], g[i + 1][j])\n        return [g[l][r] for l, r in queries]\n", "class Solution:\n  def maximumSubarrayXor(\n      self,\n      nums: list[int],\n      queries: list[list[int]]\n  ) -> list[int]:\n    n = len(nums)\n    # xors[i][j] := the XOR score of nums[i..j]\n    xors = [[0] * n for _ in range(n)]\n    # dp[i][j] := the maximum XOR score of nums[i..j]\n    dp = [[0] * n for _ in range(n)]\n\n    for i, num in enumerate(nums):\n      xors[i][i] = num\n      dp[i][i] = num\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        xors[i][j] = xors[i][j - 1] ^ xors[i + 1][j]\n        dp[i][j] = max(xors[i][j], dp[i][j - 1], dp[i + 1][j])\n\n    return [dp[l][r] for l, r in queries]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3240, "slug": "minimum-number-of-flips-to-make-binary-grid-palindromic-ii", "solutions": ["class Solution:\n    def minFlips(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        ans = 0\n        for i in range(m // 2):\n            for j in range(n // 2):\n                x, y = m - i - 1, n - j - 1\n                cnt1 = grid[i][j] + grid[x][j] + grid[i][y] + grid[x][y]\n                ans += min(cnt1, 4 - cnt1)\n        if m % 2 and n % 2:\n            ans += grid[m // 2][n // 2]\n        diff = cnt1 = 0\n        if m % 2:\n            for j in range(n // 2):\n                if grid[m // 2][j] == grid[m // 2][n - j - 1]:\n                    cnt1 += grid[m // 2][j] * 2\n                else:\n                    diff += 1\n        if n % 2:\n            for i in range(m // 2):\n                if grid[i][n // 2] == grid[m - i - 1][n // 2]:\n                    cnt1 += grid[i][n // 2] * 2\n                else:\n                    diff += 1\n        ans += diff if cnt1 % 4 == 0 or diff else 2\n        return ans\n", "class Solution:\n  def minFlips(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    middleOnes = 0\n    mismatchedPairs = 0\n\n    # Handle top-left, top-right, bottom-left, bottom-right cells.\n    for i in range(m // 2):\n      for j in range(n // 2):\n        ones = (grid[i][j] + grid[i][n - 1 - j] +\n                grid[m - 1 - i][j] + grid[m - 1 - i][n - 1 - j])\n        ans += min(ones, 4 - ones)\n\n    # Handle the middle row if the number of m is odd.\n    if m % 2 == 1:\n      for j in range(n // 2):\n        leftCell = grid[m // 2][j]\n        rightCell = grid[m // 2][n - 1 - j]\n        mismatchedPairs += leftCell ^ rightCell\n        middleOnes += leftCell + rightCell\n\n    # Handle the middle column if the number of columns is odd.\n    if n % 2 == 1:\n      for i in range(m // 2):\n        topCell = grid[i][n // 2]\n        bottomCell = grid[m - 1 - i][n // 2]\n        mismatchedPairs += topCell ^ bottomCell\n        middleOnes += topCell + bottomCell\n\n    if mismatchedPairs == 0:\n      # Since there's no mismatched pairs, middleOnes % 4 must be 0 or 2.\n      if middleOnes % 4 == 2:\n        ans += 2  # Flip two 1s to 0s.\n    else:\n      # Flip every mismatched pair 01 to 00 or 11. It doesn't matter.\n      ans += mismatchedPairs\n\n    # Handle the center cell if both dimensions are odd.\n    if m % 2 == 1 and n % 2 == 1:\n      ans += grid[m // 2][n // 2]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3208, "slug": "alternating-groups-ii", "solutions": ["class Solution:\n    def numberOfAlternatingGroups(self, colors: List[int], k: int) -> int:\n        n = len(colors)\n        ans = cnt = 0\n        for i in range(n << 1):\n            if i and colors[i % n] == colors[(i - 1) % n]:\n                cnt = 1\n            else:\n                cnt += 1\n            ans += i >= n and cnt >= k\n        return ans\n", "class Solution:\n  def numberOfAlternatingGroups(self, colors: list[int], k: int) -> int:\n    n = len(colors)\n    ans = 0\n    alternating = 1\n\n    for i in range(n + k - 2):\n      alternating = (1 if colors[i % n] == colors[(i - 1) % n]\n                     else alternating + 1)\n      if alternating >= k:\n        ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3276, "slug": "select-cells-in-grid-with-maximum-score", "solutions": ["class Solution:\n    def maxScore(self, grid: List[List[int]]) -> int:\n        g = defaultdict(set)\n        mx = 0\n        for i, row in enumerate(grid):\n            for x in row:\n                g[x].add(i)\n                mx = max(mx, x)\n        m = len(grid)\n        f = [[0] * (1 << m) for _ in range(mx + 1)]\n        for i in range(1, mx + 1):\n            for j in range(1 << m):\n                f[i][j] = f[i - 1][j]\n                for k in g[i]:\n                    if j >> k & 1:\n                        f[i][j] = max(f[i][j], f[i - 1][j ^ 1 << k] + i)\n        return f[-1][-1]\n", "class Solution:\n  def maxScore(self, grid: list[list[int]]) -> int:\n    numToIndices = collections.defaultdict(set)\n    for index, row in enumerate(grid):\n      for num in row:\n        numToIndices[num].add(index)\n    numToIndices = list(numToIndices.items())\n\n    @functools.lru_cache(None)\n    def dp(i: int, mask: int) -> int:\n      \"\"\"\n      Returns the maximum score by selecting numbers from numToIndices[i..],\n      where `mask` is the bitmask of the used row indices.\n      \"\"\"\n      if i == len(numToIndices):\n        return 0\n      # Skip numToIndices[i][0].\n      res = dp(i + 1, mask)\n      for index in numToIndices[i][1]:\n        if (mask >> index & 1) == 0:\n          # Take numToIndices[i][0].\n          res = max(res, numToIndices[i][0] + dp(i + 1, mask | 1 << index))\n      return res\n\n    return dp(0, 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3229, "slug": "minimum-operations-to-make-array-equal-to-target", "solutions": ["class Solution:\n    def minimumOperations(self, nums: List[int], target: List[int]) -> int:\n        n = len(nums)\n        f = abs(target[0] - nums[0])\n        for i in range(1, n):\n            x = target[i] - nums[i]\n            y = target[i - 1] - nums[i - 1]\n            if x * y > 0:\n                d = abs(x) - abs(y)\n                if d > 0:\n                    f += d\n            else:\n                f += abs(x)\n        return f\n", "class Solution:\n  # Similar to 1526. Minimum Number of Increments on Subarrays to Form a Target Array\n  def minimumOperations(self, nums: list[int], target: list[int]) -> int:\n    ans = abs(nums[0] - target[0])\n\n    for (prevNum, prevTarget), (currNum, currTarget) in (\n        itertools.pairwise(zip(nums, target))\n    ):\n      currDiff = currTarget - currNum\n      prevDiff = prevTarget - prevNum\n      if currDiff >= 0 and prevDiff >= 0:\n        ans += max(0, currDiff - prevDiff)\n      elif currDiff <= 0 and prevDiff <= 0:\n        ans += max(0, abs(currDiff) - abs(prevDiff))\n      else:\n        ans += abs(currDiff)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3243, "slug": "shortest-distance-after-road-addition-queries-i", "solutions": ["class Solution:\n    def shortestDistanceAfterQueries(\n        self, n: int, queries: List[List[int]]\n    ) -> List[int]:\n        def bfs(i: int) -> int:\n            q = deque([i])\n            vis = [False] * n\n            vis[i] = True\n            d = 0\n            while 1:\n                for _ in range(len(q)):\n                    u = q.popleft()\n                    if u == n - 1:\n                        return d\n                    for v in g[u]:\n                        if not vis[v]:\n                            vis[v] = True\n                            q.append(v)\n                d += 1\n\n        g = [[i + 1] for i in range(n - 1)]\n        ans = []\n        for u, v in queries:\n            g[u].append(v)\n            ans.append(bfs(0))\n        return ans\n", "class Solution:\n  def shortestDistanceAfterQueries(\n      self,\n      n: int,\n      queries: list[list[int]],\n  ) -> list[int]:\n    ans = []\n    dist = list(range(n))\n    graph = [[] for _ in range(n)]\n\n    for i in range(n - 1):\n      graph[i].append(i + 1)\n\n    for u, v in queries:\n      graph[u].append(v)\n      if dist[u] + 1 < dist[v]:\n        dist[v] = dist[u] + 1\n        self._bfs(graph, v, dist)\n      ans.append(dist[n - 1])\n\n    return ans\n\n  def _bfs(self, graph: list[list[int]], start: int, dist: list[int]) -> None:\n    \"\"\"\n    Performs a BFS to update the shortest distances from the given `start` node\n    to all other reachable nodes in the graph. It updates the `dist` vector\n    with the new shortest distances.\n    \"\"\"\n    q = collections.deque([start])\n    while q:\n      u = q.popleft()\n      for v in graph[u]:\n        if dist[u] + 1 < dist[v]:\n          dist[v] = dist[u] + 1\n          q.append(v)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3267, "slug": "count-almost-equal-pairs-ii", "solutions": ["class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        nums.sort()\n        ans = 0\n        cnt = defaultdict(int)\n        for x in nums:\n            vis = {x}\n            s = list(str(x))\n            m = len(s)\n            for j in range(m):\n                for i in range(j):\n                    s[i], s[j] = s[j], s[i]\n                    vis.add(int(\"\".join(s)))\n                    for q in range(i + 1, m):\n                        for p in range(i + 1, q):\n                            s[p], s[q] = s[q], s[p]\n                            vis.add(int(\"\".join(s)))\n                            s[p], s[q] = s[q], s[p]\n                    s[i], s[j] = s[j], s[i]\n            ans += sum(cnt[x] for x in vis)\n            cnt[x] += 1\n        return ans\n", "class Solution:\n  # Similar to 3265. Count Almost Equal Pairs I\n  def countPairs(self, nums: list[int]) -> int:\n    ans = 0\n    count = collections.Counter()\n    maxLen = len(str(max(nums)))\n\n    for num in nums:\n      digits = list(str(num).zfill(maxLen))\n      for swap in self._getSwaps(digits):\n        ans += count[swap]\n      count[num] += 1\n\n    return ans\n\n  def _getSwaps(self, digits: str) -> set[int]:\n    \"\"\"Returns all possible numbers after 1 or 2 swaps.\"\"\"\n    n = len(digits)\n    swaps = set([int(''.join(digits))])\n\n    # Add all numbers after 1 swap.\n    for i, j in itertools.combinations(range(n), 2):\n      newDigits = digits[:]\n      newDigits[i], newDigits[j] = newDigits[j], newDigits[i]\n      swaps.add(int(''.join(newDigits)))\n\n    # Add all numbers after 2 swaps.\n    for (i1, j1), (i2, j2) in itertools.combinations(\n            itertools.combinations(range(n), 2), 2):\n      newDigits = digits[:]\n      newDigits[i1], newDigits[j1] = newDigits[j1], newDigits[i1]\n      newDigits[i2], newDigits[j2] = newDigits[j2], newDigits[i2]\n      swaps.add(int(''.join(newDigits)))\n\n    return swaps\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3263, "slug": "convert-doubly-linked-list-to-array-i", "solutions": ["\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val, prev=None, next=None):\n        self.val = val\n        self.prev = prev\n        self.next = next\n\"\"\"\n\n\nclass Solution:\n    def toArray(self, root: \"Optional[Node]\") -> List[int]:\n        ans = []\n        while root:\n            ans.append(root.val)\n            root = root.next\n        return ans\n", "class Solution:\n  def toArray(self, head: 'Optional[Node]') -> list[int]:\n    ans = []\n    curr = head\n\n    while curr:\n      ans.append(curr.val)\n      curr = curr.next\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3235, "slug": "check-if-the-rectangle-corner-is-reachable", "solutions": ["class Solution:\n    def canReachCorner(\n        self, xCorner: int, yCorner: int, circles: List[List[int]]\n    ) -> bool:\n        def in_circle(x: int, y: int, cx: int, cy: int, r: int) -> int:\n            return (x - cx) ** 2 + (y - cy) ** 2 <= r**2\n\n        def cross_left_top(cx: int, cy: int, r: int) -> bool:\n            a = abs(cx) <= r and 0 <= cy <= yCorner\n            b = abs(cy - yCorner) <= r and 0 <= cx <= xCorner\n            return a or b\n\n        def cross_right_bottom(cx: int, cy: int, r: int) -> bool:\n            a = abs(cx - xCorner) <= r and 0 <= cy <= yCorner\n            b = abs(cy) <= r and 0 <= cx <= xCorner\n            return a or b\n\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            if cross_right_bottom(x1, y1, r1):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                if vis[j] or not ((x1 - x2) ** 2 + (y1 - y2) ** 2 <= (r1 + r2) ** 2):\n                    continue\n                if (\n                    (x1 * r2 + x2 * r1 < (r1 + r2) * xCorner)\n                    and (y1 * r2 + y2 * r1 < (r1 + r2) * yCorner)\n                    and dfs(j)\n                ):\n                    return True\n            return False\n\n        vis = [False] * len(circles)\n        for i, (x, y, r) in enumerate(circles):\n            if in_circle(0, 0, x, y, r) or in_circle(xCorner, yCorner, x, y, r):\n                return False\n            if (not vis[i]) and cross_left_top(x, y, r) and dfs(i):\n                return False\n        return True\n", "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def canReachCorner(self, X: int, Y: int, circles: list[list[int]]) -> bool:\n    n = len(circles)\n    # Add two virtual nodes, where node n represents (0, 0) and node n + 1\n    # represents (X, Y).\n    uf = UnionFind(n + 2)\n\n    # Iterate through each circle.\n    for i, (x, y, r) in enumerate(circles):\n      # Union the current circle with the node (0, 0) if the circle overlaps\n      # with the left or top edges.\n      if x - r <= 0 or y + r >= Y:\n        uf.unionByRank(i, n)\n      # Union the current circle with the node (X, Y) if the circle overlaps\n      # with the right or bottom edges.\n      if x + r >= X or y - r <= 0:\n        uf.unionByRank(i, n + 1)\n      # Union the current circle with previous circles if they overlap.\n      for j in range(i):\n        x2, y2, r2 = circles[j]\n        if (x - x2)**2 + (y - y2)**2 <= (r + r2)**2:\n          uf.unionByRank(i, j)\n\n    # If nodes (0, 0) and (X, Y) are in the same union set, that means there's\n    # a path of overlapping circles that connects the left or top edges to the\n    # right or bottom edges, implying that (0, 0) cannot reach (X, Y).\n    return uf.find(n) != uf.find(n + 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3200, "slug": "maximum-height-of-a-triangle", "solutions": ["class Solution:\n    def maxHeightOfTriangle(self, red: int, blue: int) -> int:\n        ans = 0\n        for k in range(2):\n            c = [red, blue]\n            i, j = 1, k\n            while i <= c[j]:\n                c[j] -= i\n                j ^= 1\n                ans = max(ans, i)\n                i += 1\n        return ans\n", "class Solution:\n  def maxHeightOfTriangle(self, red: int, blue: int) -> int:\n    return max(self._maxHeight(red, blue),\n               self._maxHeight(blue, red))\n\n  def _maxHeight(self, n1: int, n2: int) -> int:\n    \"\"\"\n    Returns the maximum height of a triangle with the odd levels having `n1`\n    balls and the even levels having `n2` balls.\n    \"\"\"\n    #             1 + 3 + ... + h <= n1\n    # ((1 + h) * (n + 1) / 2) / 2 <= n1\n    #                           h <= sqrt(4 * n1) - 1\n    oddHeight = math.isqrt(4 * n1) - 1\n    #       2 + 4 + ... + h <= n2\n    # ((2 + h) * h / 2) / 2 <= n2\n    #                     h <= sqrt(4 * n2 + 1) - 1\n    evenHeight = math.isqrt(4 * n2 + 1) - 1\n    # If the difference between the odd and even heights is >= 1, we can add an\n    # extra level to the minimum height.\n    return min(oddHeight, evenHeight) + (1 if abs(oddHeight - evenHeight) >= 1\n                                         else 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3281, "slug": "maximize-score-of-numbers-in-ranges", "solutions": ["class Solution:\n    def maxPossibleScore(self, start: List[int], d: int) -> int:\n        def check(mi: int) -> bool:\n            last = -inf\n            for st in start:\n                if last + mi > st + d:\n                    return False\n                last = max(st, last + mi)\n            return True\n\n        start.sort()\n        l, r = 0, start[-1] + d - start[0]\n        while l < r:\n            mid = (l + r + 1) >> 1\n            if check(mid):\n                l = mid\n            else:\n                r = mid - 1\n        return l\n", "class Solution:\n  def maxPossibleScore(self, start: list[int], d: int) -> int:\n    def isPossible(m: int) -> bool:\n      lastPick = start[0]\n      for i in range(1, len(start)):\n        if lastPick + m > start[i] + d:\n          return False\n        lastPick = max(lastPick + m, start[i])\n      return True\n\n    start.sort()\n\n    maxScore = (start[-1] + d) - start[0] + 1\n    l = bisect.bisect_left(range(maxScore), True,\n                           key=lambda m: not isPossible(m))\n    return l - 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3228, "slug": "maximum-number-of-operations-to-move-ones-to-the-end", "solutions": ["class Solution:\n    def maxOperations(self, s: str) -> int:\n        ans = cnt = 0\n        for i, c in enumerate(s):\n            if c == \"1\":\n                cnt += 1\n            elif i and s[i - 1] == \"1\":\n                ans += cnt\n        return ans\n", "class Solution:\n  def maxOperations(self, s: str) -> int:\n    ans = 0\n    ones = 0\n\n    for i, c in enumerate(s):\n      if c == '1':\n        ones += 1\n      elif i + 1 == len(s) or s[i + 1] == '1':\n        ans += ones\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3289, "slug": "the-two-sneaky-numbers-of-digitville", "solutions": ["class Solution:\n    def getSneakyNumbers(self, nums: List[int]) -> List[int]:\n        cnt = Counter(nums)\n        return [x for x, v in cnt.items() if v == 2]\n", "class Solution:\n  def getSneakyNumbers(self, nums: list[int]) -> list[int]:\n    return [num for num, freq in collections.Counter(nums).items()\n            if freq == 2]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3258, "slug": "count-substrings-that-satisfy-k-constraint-i", "solutions": ["class Solution:\n    def countKConstraintSubstrings(self, s: str, k: int) -> int:\n        cnt = [0, 0]\n        ans = l = 0\n        for r, x in enumerate(map(int, s)):\n            cnt[x] += 1\n            while cnt[0] > k and cnt[1] > k:\n                cnt[int(s[l])] -= 1\n                l += 1\n            ans += r - l + 1\n        return ans\n", "class Solution:\n  def countKConstraintSubstrings(self, s: str, k: int) -> int:\n    ans = 0\n    count = [0, 0]\n\n    l = 0\n    for r, c in enumerate(s):\n      count[int(c)] += 1\n      while min(count) > k:\n        count[int(s[l])] -= 1\n        l += 1\n      ans += r - l + 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3253, "slug": "construct-string-with-minimum-cost-easy", "solutions": ["class Trie:\n    def __init__(self):\n        self.children: List[Optional[Trie]] = [None] * 26\n        self.cost = inf\n\n    def insert(self, word: str, cost: int):\n        node = self\n        for c in word:\n            idx = ord(c) - ord(\"a\")\n            if node.children[idx] is None:\n                node.children[idx] = Trie()\n            node = node.children[idx]\n        node.cost = min(node.cost, cost)\n\n\nclass Solution:\n    def minimumCost(self, target: str, words: List[str], costs: List[int]) -> int:\n        @cache\n        def dfs(i: int) -> int:\n            if i >= len(target):\n                return 0\n            ans = inf\n            node = trie\n            for j in range(i, len(target)):\n                idx = ord(target[j]) - ord(\"a\")\n                if node.children[idx] is None:\n                    return ans\n                node = node.children[idx]\n                ans = min(ans, node.cost + dfs(j + 1))\n            return ans\n\n        trie = Trie()\n        for word, cost in zip(words, costs):\n            trie.insert(word, cost)\n        ans = dfs(0)\n        return ans if ans < inf else -1\n", "class Solution:\n  def minimumCost(self, target: str, words: list[str], costs: list[int]) -> int:\n    n = len(target)\n    # dp[i] := the minimum cost to construct target[0:i]\n    dp = [0] + [math.inf] * n\n\n    for i in range(1, n + 1):\n      for j, (word, cost) in enumerate(zip(words, costs)):\n        if (i >= len(word) and\n            target[i - len(word):i] == word and\n                dp[i - len(word)] != math.inf):\n          dp[i] = min(dp[i], dp[i - len(word)] + cost)\n\n    return dp[n] if dp[n] != math.inf else -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3288, "slug": "length-of-the-longest-increasing-path", "solutions": ["class Solution:\n  def maxPathLength(self, coordinates: list[list[int]], k: int) -> int:\n    xk, yk = coordinates[k]\n    leftCoordinates = [(x, y) for x, y in coordinates if x < xk and y < yk]\n    rightCoordinates = [(x, y) for x, y in coordinates if x > xk and y > yk]\n    return (1 +\n            self._lengthOfLIS(leftCoordinates) +\n            self._lengthOfLIS(rightCoordinates))\n\n  # Similar to 300. Longest Increasing Subsequence\n  def _lengthOfLIS(self, coordinates: list[tuple[int, int]]) -> int:\n    coordinates.sort(key=lambda x: (x[0], -x[1]))\n    # tail[i] := the minimum tail of all the increasing subsequences having\n    # length i + 1\n    tail = []\n    for _, y in coordinates:\n      if not tail or y > tail[-1]:\n        tail.append(y)\n      else:\n        tail[bisect.bisect_left(tail, y)] = y\n    return len(tail)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3264, "slug": "final-array-state-after-k-multiplication-operations-i", "solutions": ["class Solution:\n    def getFinalState(self, nums: List[int], k: int, multiplier: int) -> List[int]:\n        pq = [(x, i) for i, x in enumerate(nums)]\n        heapify(pq)\n        for _ in range(k):\n            _, i = heappop(pq)\n            nums[i] *= multiplier\n            heappush(pq, (nums[i], i))\n        return nums\n", "class Solution:\n  def getFinalState(\n      self,\n      nums: list[int],\n      k: int,\n      multiplier: int\n  ) -> list[int]:\n    ans = [0] * len(nums)\n    minHeap = [(num, i) for i, num in enumerate(nums)]\n    heapq.heapify(minHeap)\n\n    for _ in range(k):\n      num, i = heapq.heappop(minHeap)\n      heapq.heappush(minHeap, (num * multiplier, i))\n\n    for num, i in minHeap:\n      ans[i] = num\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3212, "slug": "count-submatrices-with-equal-frequency-of-x-and-y", "solutions": ["class Solution:\n    def numberOfSubmatrices(self, grid: List[List[str]]) -> int:\n        m, n = len(grid), len(grid[0])\n        s = [[[0] * 2 for _ in range(n + 1)] for _ in range(m + 1)]\n        ans = 0\n        for i, row in enumerate(grid, 1):\n            for j, x in enumerate(row, 1):\n                s[i][j][0] = s[i - 1][j][0] + s[i][j - 1][0] - s[i - 1][j - 1][0]\n                s[i][j][1] = s[i - 1][j][1] + s[i][j - 1][1] - s[i - 1][j - 1][1]\n                if x != \".\":\n                    s[i][j][ord(x) & 1] += 1\n                if s[i][j][0] > 0 and s[i][j][0] == s[i][j][1]:\n                    ans += 1\n        return ans\n", "class Solution:\n  def numberOfSubmatrices(self, grid: list[list[str]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    # x[i][j] := the number of 'X' in grid[0..i)[0..j)\n    x = [[0] * (n + 1) for _ in range(m + 1)]\n    # y[i][j] := the number of 'Y' in grid[0..i)[0..j)\n    y = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i, row in enumerate(grid):\n      for j, cell in enumerate(row):\n        x[i + 1][j + 1] = (cell == 'X') + x[i][j + 1] + x[i + 1][j] - x[i][j]\n        y[i + 1][j + 1] = (cell == 'Y') + y[i][j + 1] + y[i + 1][j] - y[i][j]\n        if x[i + 1][j + 1] > 0 and x[i + 1][j + 1] == y[i + 1][j + 1]:\n          ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3201, "slug": "find-the-maximum-length-of-valid-subsequence-i", "solutions": ["class Solution:\n    def maximumLength(self, nums: List[int]) -> int:\n        k = 2\n        f = [[0] * k for _ in range(k)]\n        ans = 0\n        for x in nums:\n            x %= k\n            for j in range(k):\n                y = (j - x + k) % k\n                f[x][y] = f[y][x] + 1\n                ans = max(ans, f[x][y])\n        return ans\n", "class Solution:\n  def maximumLength(self, nums: list[int]) -> int:\n    # dp[i][j] := the maximum length of a valid subsequence, where the last\n    # number mod k equal to i and the next desired number mod k equal to j\n    dp = [[0] * 2 for _ in range(2)]\n\n    # Extend the pattern xyxyxy...xy.\n    for x in nums:\n      for y in range(2):\n        dp[x % 2][y] = dp[y][x % 2] + 1\n\n    return max(map(max, dp))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3272, "slug": "find-the-count-of-good-integers", "solutions": ["class Solution:\n    def countGoodIntegers(self, n: int, k: int) -> int:\n        fac = [factorial(i) for i in range(n + 1)]\n        ans = 0\n        vis = set()\n        base = 10 ** ((n - 1) // 2)\n        for i in range(base, base * 10):\n            s = str(i)\n            s += s[::-1][n % 2 :]\n            if int(s) % k:\n                continue\n            t = \"\".join(sorted(s))\n            if t in vis:\n                continue\n            vis.add(t)\n            cnt = Counter(t)\n            res = (n - cnt[\"0\"]) * fac[n - 1]\n            for x in cnt.values():\n                res //= fac[x]\n            ans += res\n        return ans\n", "class Solution:\n  def countGoodIntegers(self, n: int, k: int) -> int:\n    halfLength = (n + 1) // 2\n    minHalf = 10**(halfLength - 1)\n    maxHalf = 10**halfLength\n    ans = 0\n    seen = set()\n\n    for num in range(minHalf, maxHalf):\n      palindrome = str(num) + str(num)[::-1][n % 2:]\n      sortedDigits = ''.join(sorted(palindrome))\n      if int(palindrome) % k != 0 or sortedDigits in seen:\n        continue\n      seen.add(sortedDigits)\n      digitCount = collections.Counter(palindrome)\n      # Leading zeros are not allowed, so the first digit is special.\n      firstDigitChoices = n - digitCount['0']\n      permutations = firstDigitChoices * math.factorial(n - 1)\n      # For each repeated digit, divide by the factorial of the frequency since\n      # permutations that swap identical digits don't create a new number.\n      for freq in digitCount.values():\n        permutations //= math.factorial(freq)\n      ans += permutations\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3290, "slug": "maximum-multiplication-score", "solutions": ["class Solution:\n    def maxScore(self, a: List[int], b: List[int]) -> int:\n        @cache\n        def dfs(i: int, j: int) -> int:\n            if j >= len(b):\n                return 0 if i >= len(a) else -inf\n            if i >= len(a):\n                return 0\n            return max(dfs(i, j + 1), a[i] * b[j] + dfs(i + 1, j + 1))\n\n        return dfs(0, 0)\n", "class Solution:\n  def maxScore(self, a: list[int], b: list[int]) -> int:\n    n = len(b)\n    # dp[i][j] := the maximum score by selecting 4 - i numbers from b[j..n - 1]\n    # using the corresponding numbers from a[i..3]\n    dp = [[0] * (n + 1) for _ in range(5)]\n\n    # Run out of numbers in b but still need to select numbers from a.\n    for i in range(4):\n      dp[i][n] = -math.inf\n\n    for i in reversed(range(4)):\n      for j in reversed(range(n)):\n        # Skip b[j] or pair a[i] with b[j].\n        dp[i][j] = max(dp[i][j + 1], a[i] * b[j] + dp[i + 1][j + 1])\n\n    return -1 if dp[0][0] == -math.inf else dp[0][0]\n", "class Solution:\n  def maxScore(self, a: list[int], b: list[int]) -> int:\n    # dp[i] := the maximum score of a[0..i]\n    dp = [-math.inf] * 4\n\n    for num in b:\n      for i in reversed(range(4)):\n        # Skip `num` or pair a[i] with `num`.\n        dp[i] = max(dp[i], (dp[i - 1] if i > 0 else 0) + a[i] * num)\n\n    return dp[3]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3207, "slug": "maximum-points-after-enemy-battles", "solutions": ["class Solution:\n    def maximumPoints(self, enemyEnergies: List[int], currentEnergy: int) -> int:\n        enemyEnergies.sort()\n        if currentEnergy < enemyEnergies[0]:\n            return 0\n        ans = 0\n        for i in range(len(enemyEnergies) - 1, -1, -1):\n            ans += currentEnergy // enemyEnergies[0]\n            currentEnergy %= enemyEnergies[0]\n            currentEnergy += enemyEnergies[i]\n        return ans\n", "class Solution:\n  def maximumPoints(self, enemyEnergies: list[int], currentEnergy: int) -> int:\n    minEnergy = min(enemyEnergies)\n    return (0 if currentEnergy < minEnergy\n            else (currentEnergy + sum(enemyEnergies) - minEnergy) // minEnergy)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3213, "slug": "construct-string-with-minimum-cost", "solutions": ["class Solution:\n    def minimumCost(self, target: str, words: List[str], costs: List[int]) -> int:\n        base, mod = 13331, 998244353\n        n = len(target)\n        h = [0] * (n + 1)\n        p = [1] * (n + 1)\n        for i, c in enumerate(target, 1):\n            h[i] = (h[i - 1] * base + ord(c)) % mod\n            p[i] = (p[i - 1] * base) % mod\n        f = [0] + [inf] * n\n        ss = sorted(set(map(len, words)))\n        d = defaultdict(lambda: inf)\n        min = lambda a, b: a if a < b else b\n        for w, c in zip(words, costs):\n            x = 0\n            for ch in w:\n                x = (x * base + ord(ch)) % mod\n            d[x] = min(d[x], c)\n        for i in range(1, n + 1):\n            for j in ss:\n                if j > i:\n                    break\n                x = (h[i] - h[i - j] * p[j]) % mod\n                f[i] = min(f[i], f[i - j] + d[x])\n        return f[n] if f[n] < inf else -1\n", "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.cost = math.inf\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, word: str, cost: int) -> None:\n    \"\"\"Inserts a word with a cost.\"\"\"\n    node: TrieNode = self.root\n    for c in word:\n      node = node.children.setdefault(c, TrieNode())\n    node.cost = min(node.cost, cost)\n\n  @functools.lru_cache(None)\n  def search(self, word: str, i: int) -> int:\n    \"\"\"Returns the minimum cost to construct s[i:].\"\"\"\n    if i == len(word):\n      return 0\n    cost = math.inf\n    node = self.root\n    for i in range(i, len(word)):\n      if word[i] not in node.children:\n        break\n      node = node.children[word[i]]\n      if node.cost != math.inf:\n        childCost = self.search(word, i + 1)\n        if childCost != math.inf:\n          cost = min(cost, node.cost + childCost)\n    return cost\n\n\nclass Solution:\n  def minimumCost(self, target: str, words: list[str], costs: list[int]) -> int:\n    trie = Trie()\n\n    for word, cost in zip(words, costs):\n      trie.insert(word, cost)\n\n    ans = trie.search(target, 0)\n    return -1 if ans == math.inf else ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3298, "slug": "count-substrings-that-can-be-rearranged-to-contain-a-string-ii", "solutions": ["class Solution:\n    def validSubstringCount(self, word1: str, word2: str) -> int:\n        if len(word1) < len(word2):\n            return 0\n        cnt = Counter(word2)\n        need = len(cnt)\n        ans = l = 0\n        win = Counter()\n        for c in word1:\n            win[c] += 1\n            if win[c] == cnt[c]:\n                need -= 1\n            while need == 0:\n                if win[word1[l]] == cnt[word1[l]]:\n                    need += 1\n                win[word1[l]] -= 1\n                l += 1\n            ans += l\n        return ans\n", "class Solution:\n  # Same as 3297. Count Substrings That Can Be Rearranged to Contain a String I\n  def validSubstringCount(self, word1: str, word2: str) -> int:\n    ans = 0\n    count = collections.Counter(word2)\n    required = len(word2)\n\n    l = 0\n    for r, c in enumerate(word1):\n      count[c] -= 1\n      if count[c] >= 0:\n        required -= 1\n      while required == 0:\n        # Add valid substrings containing word1[l..r] to the answer. They are\n        # word1[l..r], word1[l..r + 1], ..., word1[l..n - 1].\n        ans += len(word1) - r\n        count[word1[l]] += 1\n        if count[word1[l]] > 0:\n          required += 1\n        l += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3296, "slug": "minimum-number-of-seconds-to-make-mountain-height-zero", "solutions": ["class Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        def check(t: int) -> bool:\n            h = 0\n            for wt in workerTimes:\n                h += int(sqrt(2 * t / wt + 1 / 4) - 1 / 2)\n            return h >= mountainHeight\n\n        return bisect_left(range(10**16), True, key=check)\n", "class Solution:\n  def minNumberOfSeconds(\n      self,\n      mountainHeight: int,\n      workerTimes: list[int]\n  ) -> int:\n    def getReducedHeight(m: int) -> int:\n      \"\"\"Returns the total height reduced by all workers in `m` seconds.\"\"\"\n      # The height `x` that a worker with working time `w` reduces in `m`\n      # seconds.\n      # w * (1 + 2 + ... + x) <= m\n      #       (1 + x) * x / 2 <= m / w\n      #   x^2 + x - 2 * m / w <= 0\n      #                     x <= (-1 + sqrt(1 + 8 * m / w)) / 2\n      return sum((-1 + math.sqrt(1 + 8 * m // workerTime)) // 2\n                 for workerTime in workerTimes)\n\n    l = 1\n    r = min(workerTimes) * mountainHeight * (mountainHeight + 1) // 2\n    return bisect.bisect_left(range(l, r), mountainHeight,\n                              key=getReducedHeight) + l\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3231, "slug": "minimum-number-of-increasing-subsequence-to-be-removed", "solutions": ["class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        g = []\n        for x in nums:\n            l, r = 0, len(g)\n            while l < r:\n                mid = (l + r) >> 1\n                if g[mid] < x:\n                    r = mid\n                else:\n                    l = mid + 1\n            if l == len(g):\n                g.append(x)\n            else:\n                g[l] = x\n        return len(g)\n", "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    return self._lengthOfLIS(nums[::-1])\n\n  def _lengthOfLIS(self, nums: list[int]) -> int:\n    # tails[i] := the minimum tail of all the increasing subsequences having\n    # length i + 1\n    tails = []\n    for num in nums:\n      if not tails or num >= tails[-1]:\n        tails.append(num)\n      else:\n        tails[bisect.bisect_right(tails, num)] = num\n    return len(tails)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3204, "slug": "bitwise-user-permissions-analysis", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3283, "slug": "maximum-number-of-moves-to-kill-all-pawns", "solutions": ["class Solution:\n    def maxMoves(self, kx: int, ky: int, positions: List[List[int]]) -> int:\n        @cache\n        def dfs(last: int, state: int, k: int) -> int:\n            if state == 0:\n                return 0\n            if k:\n                res = 0\n                for i, (x, y) in enumerate(positions):\n                    if state >> i & 1:\n                        t = dfs(i, state ^ (1 << i), k ^ 1) + dist[last][x][y]\n                        if res < t:\n                            res = t\n                return res\n            else:\n                res = inf\n                for i, (x, y) in enumerate(positions):\n                    if state >> i & 1:\n                        t = dfs(i, state ^ (1 << i), k ^ 1) + dist[last][x][y]\n                        if res > t:\n                            res = t\n                return res\n\n        n = len(positions)\n        m = 50\n        dist = [[[-1] * m for _ in range(m)] for _ in range(n + 1)]\n        dx = [1, 1, 2, 2, -1, -1, -2, -2]\n        dy = [2, -2, 1, -1, 2, -2, 1, -1]\n        positions.append([kx, ky])\n        for i, (x, y) in enumerate(positions):\n            dist[i][x][y] = 0\n            q = deque([(x, y)])\n            step = 0\n            while q:\n                step += 1\n                for _ in range(len(q)):\n                    x1, y1 = q.popleft()\n                    for j in range(8):\n                        x2, y2 = x1 + dx[j], y1 + dy[j]\n                        if 0 <= x2 < m and 0 <= y2 < m and dist[i][x2][y2] == -1:\n                            dist[i][x2][y2] = step\n                            q.append((x2, y2))\n\n        ans = dfs(n, (1 << n) - 1, 1)\n        dfs.cache_clear()\n        return ans\n", "class Solution:\n  def __init__(self):\n    self.SIZE = 50\n    self.MAX = 1_000_000\n    self.DIRS = ((1, 2), (2, 1), (2, -1), (1, -2),\n                 (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n\n  def maxMoves(self, kx: int, ky: int, positions: list[list[int]]) -> int:\n    n = len(positions)\n    positions.append([kx, ky])\n    hashedPositionToIndex = {}\n    # dist[i][j] := the minimum distance from positions[i] to positions[j]\n    dist = [[0] * (n + 1) for _ in range(n + 1)]\n\n    for i, (x, y) in enumerate(positions):\n      hashedPositionToIndex[self._hash(x, y)] = i\n\n    for sourceIndex in range(n + 1):\n      self._bfs(positions, sourceIndex, hashedPositionToIndex, dist)\n\n    MAX_MASK = 1 << (n + 1)\n    # dp[i][mask][turn] := the maximum (Alice) or the minimum (Bob) cost to\n    # kill all pawns, where i is the current pawn, mask is the set of pawns\n    # that have been killed, and turn is the current player's turn (0 for Alice\n    # and 1 for Bob)\n    dp = [[[0, 0]\n          for _ in range(1 << (n + 1))]\n          for _ in range(n + 1)]\n\n    for i in range(n + 1):\n      for mask in range(MAX_MASK - 1):\n        dp[i][mask] = [-self.MAX, self.MAX]\n\n    for mask in range(MAX_MASK - 2, -1, -1):\n      for i in range(n + 1):\n        for turn in range(2):\n          for j in range(n):\n            if mask >> j & 1:\n              continue\n            moves = dist[i][j] + dp[j][mask | 1 << j][1 - turn]\n            dp[i][mask][turn] = (max(dp[i][mask][turn], moves) if turn == 0 else\n                                 min(dp[i][mask][turn], moves))\n\n    # Returns the maximum cost to kill all pawns, i.e., the original positions\n    # array without the knight (kx, ky).\n    return dp[n][1 << n][0]\n\n  def _hash(self, x: int, y: int) -> int:\n    return x * self.SIZE + y\n\n  def _bfs(\n      self,\n      positions: list[list[int]],\n      sourceIndex: int,\n      hashedPositionToIndex: dict[int, int],\n      dist: list[list[int]]\n  ) -> None:\n    \"\"\"\n    Computes the distance between positions[sourceIndex] and other positions.\n    \"\"\"\n    sx, sy = positions[sourceIndex]\n    q = collections.deque([(sx, sy)])\n    seen = {(sx, sy)}\n    seenPositions = 0\n\n    step = 0\n    while q and seenPositions < len(positions):\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        hashedPosition = self._hash(i, j)\n        if hashedPosition in hashedPositionToIndex:\n          dist[sourceIndex][hashedPositionToIndex[hashedPosition]] = step\n          seenPositions += 1\n        for dx, dy in self.DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x >= self.SIZE or y < 0 or y >= self.SIZE:\n            continue\n          if (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n      step += 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3256, "slug": "maximum-value-sum-by-placing-three-rooks-i", "solutions": ["class Solution:\n  def maximumValueSum(self, board: list[list[int]]) -> int:\n    rows = [heapq.nlargest(3, [(val, i, j)\n            for j, val in enumerate(row)])\n            for i, row in enumerate(board)]\n    cols = [heapq.nlargest(3, [(val, i, j)\n            for i, val in enumerate(col)])\n            for j, col in enumerate(zip(*board))]\n    topNine = heapq.nlargest(9,\n                             set(itertools.chain(*rows)) &\n                             set(itertools.chain(*cols)))\n    return max(\n        (val1 + val2 + val3 for\n         (val1, i1, j1),\n         (val2, i2, j2),\n         (val3, i3, j3) in (itertools.combinations(topNine, 3))\n         if len({i1, i2, i3}) == 3 and len({j1, j2, j3}) == 3))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3271, "slug": "hash-divided-string", "solutions": ["class Solution:\n    def stringHash(self, s: str, k: int) -> str:\n        ans = []\n        for i in range(0, len(s), k):\n            t = 0\n            for j in range(i, i + k):\n                t += ord(s[j]) - ord(\"a\")\n            hashedChar = t % 26\n            ans.append(chr(ord(\"a\") + hashedChar))\n        return \"\".join(ans)\n", "class Solution:\n  def stringHash(self, s: str, k: int) -> str:\n    ans = []\n\n    for i in range(0, len(s), k):\n      sumHash = sum(string.ascii_lowercase.index(s[j])\n                    for j in range(i, i + k))\n      ans.append(string.ascii_lowercase[sumHash % 26])\n\n    return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3214, "slug": "year-on-year-growth-rate", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3255, "slug": "find-the-power-of-k-size-subarrays-ii", "solutions": ["class Solution:\n    def resultsArray(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        f = [1] * n\n        for i in range(1, n):\n            if nums[i] == nums[i - 1] + 1:\n                f[i] = f[i - 1] + 1\n        return [nums[i] if f[i] >= k else -1 for i in range(k - 1, n)]\n", "class Solution:\n  # Same as 3254. Find the Power of K-Size Subarrays I\n  def resultsArray(self, nums: list[int], k: int) -> list[int]:\n    ans = []\n    start = 0\n\n    for i, num in enumerate(nums):\n      if i > 0 and num != nums[i - 1] + 1:\n        start = i\n      if i >= k - 1:\n        ans.append(num if i - start + 1 >= k else -1)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3247, "slug": "number-of-subsequences-with-odd-sum", "solutions": ["class Solution:\n    def subsequenceCount(self, nums: List[int]) -> int:\n        mod = 10**9 + 7\n        f = [0] * 2\n        for x in nums:\n            if x % 2:\n                f[0], f[1] = (f[0] + f[1]) % mod, (f[0] + f[1] + 1) % mod\n            else:\n                f[0], f[1] = (f[0] + f[0] + 1) % mod, (f[1] + f[1]) % mod\n        return f[1]\n", "class Solution:\n  def subsequenceCount(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    even = 0  # the number of subsequences with even sum\n    odd = 0  # the number of subsequences with odd sum\n\n    for num in nums:\n      if num % 2 == 0:\n        # Appending an even number to a subsequence doesn't change the parity.\n        # The even number itself is also a valid subsequence.\n        even, odd = even + even + 1, odd + odd\n      else:\n        # Appending an odd number to a subsequence changes the parity.\n        # The odd number itself is also a valid subsequence.\n        even, odd = even + odd, odd + even + 1\n\n    return odd % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3219, "slug": "minimum-cost-for-cutting-cake-ii", "solutions": ["class Solution:\n    def minimumCost(\n        self, m: int, n: int, horizontalCut: List[int], verticalCut: List[int]\n    ) -> int:\n        horizontalCut.sort(reverse=True)\n        verticalCut.sort(reverse=True)\n        ans = i = j = 0\n        h = v = 1\n        while i < m - 1 or j < n - 1:\n            if j == n - 1 or (i < m - 1 and horizontalCut[i] > verticalCut[j]):\n                ans += horizontalCut[i] * v\n                h, i = h + 1, i + 1\n            else:\n                ans += verticalCut[j] * h\n                v, j = v + 1, j + 1\n        return ans\n", "class Solution:\n  # Same as 3218. Minimum Cost for Cutting Cake I\n  def minimumCost(\n      self,\n      m: int,\n      n: int,\n      horizontalCut: list[int],\n      verticalCut: list[int],\n  ) -> int:\n    ans = 0\n    sumH = sum(horizontalCut)\n    sumV = sum(verticalCut)\n\n    horizontalCut.sort()\n    verticalCut.sort()\n\n    while horizontalCut and verticalCut:\n      if horizontalCut[-1] > verticalCut[-1]:\n        ans += horizontalCut[-1] + sumV\n        sumH -= horizontalCut.pop()\n      else:\n        ans += verticalCut[-1] + sumH\n        sumV -= verticalCut.pop()\n\n    return ans + sumH + sumV\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3216, "slug": "lexicographically-smallest-string-after-a-swap", "solutions": ["class Solution:\n    def getSmallestString(self, s: str) -> str:\n        for i, (a, b) in enumerate(pairwise(map(ord, s))):\n            if (a + b) % 2 == 0 and a > b:\n                return s[:i] + s[i + 1] + s[i] + s[i + 2 :]\n        return s\n", "class Solution:\n  def getSmallestString(self, s: str) -> str:\n    chars = list(s)\n    for i, (a, b) in enumerate(itertools.pairwise(chars)):\n      if ord(a) % 2 == ord(b) % 2 and a > b:\n        chars[i], chars[i + 1] = chars[i + 1], chars[i]\n        return ''.join(chars)\n    return s\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3265, "slug": "count-almost-equal-pairs-i", "solutions": ["class Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        nums.sort()\n        ans = 0\n        cnt = defaultdict(int)\n        for x in nums:\n            vis = {x}\n            s = list(str(x))\n            for j in range(len(s)):\n                for i in range(j):\n                    s[i], s[j] = s[j], s[i]\n                    vis.add(int(\"\".join(s)))\n                    s[i], s[j] = s[j], s[i]\n            ans += sum(cnt[x] for x in vis)\n            cnt[x] += 1\n        return ans\n", "class Solution:\n  def countPairs(self, nums: list[int]) -> int:\n    ans = 0\n    count = collections.Counter()\n    maxLen = len(str(max(nums)))\n\n    for num in nums:\n      digits = list(str(num).zfill(maxLen))\n      for swap in self._getSwaps(digits):\n        ans += count[swap]\n      count[num] += 1\n\n    return ans\n\n  def _getSwaps(self, digits: str) -> set[int]:\n    \"\"\"Returns all possible numbers after 1 swap.\"\"\"\n    n = len(digits)\n    swaps = set([int(''.join(digits))])\n\n    for i, j in itertools.combinations(range(n), 2):\n      newDigits = digits[:]\n      newDigits[i], newDigits[j] = newDigits[j], newDigits[i]\n      swaps.add(int(''.join(newDigits)))\n\n    return swaps\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3286, "slug": "find-a-safe-walk-through-a-grid", "solutions": ["class Solution:\n    def findSafeWalk(self, grid: List[List[int]], health: int) -> bool:\n        m, n = len(grid), len(grid[0])\n        dist = [[inf] * n for _ in range(m)]\n        dist[0][0] = grid[0][0]\n        q = deque([(0, 0)])\n        dirs = (-1, 0, 1, 0, -1)\n        while q:\n            x, y = q.popleft()\n            for a, b in pairwise(dirs):\n                nx, ny = x + a, y + b\n                if (\n                    0 <= nx < m\n                    and 0 <= ny < n\n                    and dist[nx][ny] > dist[x][y] + grid[nx][ny]\n                ):\n                    dist[nx][ny] = dist[x][y] + grid[nx][ny]\n                    q.append((nx, ny))\n        return dist[-1][-1] < health\n", "class Solution:\n  def findSafeWalk(self, grid: list[list[int]], health: int) -> bool:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    initialHealth = health - grid[0][0]\n    q = collections.deque([(0, 0, initialHealth)])\n    seen = {(0, 0, initialHealth)}\n\n    while q:\n      for _ in range(len(q)):\n        i, j, h = q.popleft()\n        if i == m - 1 and j == n - 1 and h > 0:\n          return True\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          nextHealth = h - grid[x][y]\n          if nextHealth <= 0 or (x, y, nextHealth) in seen:\n            continue\n          q.append((x, y, nextHealth))\n          seen.add((x, y, nextHealth))\n\n    return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3237, "slug": "alt-and-tab-simulation", "solutions": ["class Solution:\n    def simulationResult(self, windows: List[int], queries: List[int]) -> List[int]:\n        s = set()\n        ans = []\n        for q in queries[::-1]:\n            if q not in s:\n                ans.append(q)\n                s.add(q)\n        for w in windows:\n            if w not in s:\n                ans.append(w)\n        return ans\n", "class Solution:\n  def simulationResult(\n      self,\n      windows: list[int],\n      queries: list[int],\n  ) -> list[int]:\n    ans = []\n    seen = set()\n\n    for query in reversed(queries):\n      if query not in seen:\n        ans.append(query)\n        seen.add(query)\n\n    for window in windows:\n      if window not in seen:\n        ans.append(window)\n        seen.add(window)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3274, "slug": "check-if-two-chessboard-squares-have-the-same-color", "solutions": ["class Solution:\n    def checkTwoChessboards(self, coordinate1: str, coordinate2: str) -> bool:\n        x = ord(coordinate1[0]) - ord(coordinate2[0])\n        y = int(coordinate1[1]) - int(coordinate2[1])\n        return (x + y) % 2 == 0\n", "class Solution:\n  def checkTwoChessboards(self, coordinate1: str, coordinate2: str) -> bool:\n    # Same as 1812. Determine Color of a Chessboard Square\n    def squareIsWhite(coordinate: str) -> bool:\n      letter, digit = coordinate\n      return ord(letter) % 2 != int(digit) % 2\n\n    return squareIsWhite(coordinate1) == squareIsWhite(coordinate2)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3295, "slug": "report-spam-message", "solutions": ["class Solution:\n    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:\n        s = set(bannedWords)\n        return sum(w in s for w in message) >= 2\n", "class Solution:\n  def reportSpam(self, message: list[str], bannedWords: list[str]) -> bool:\n    bannedWordsSet = set(bannedWords)\n    return sum(word in bannedWordsSet for word in message) > 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3239, "slug": "minimum-number-of-flips-to-make-binary-grid-palindromic-i", "solutions": ["class Solution:\n    def minFlips(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        cnt1 = cnt2 = 0\n        for row in grid:\n            for j in range(n // 2):\n                if row[j] != row[n - j - 1]:\n                    cnt1 += 1\n        for j in range(n):\n            for i in range(m // 2):\n                if grid[i][j] != grid[m - i - 1][j]:\n                    cnt2 += 1\n        return min(cnt1, cnt2)\n", "class Solution:\n  def minFlips(self, grid: list[list[int]]) -> int:\n    rowFlips = sum(row[i] != row[-1 - i]\n                   for row in grid for i in range(len(row) // 2))\n    colFlips = sum(col[i] != col[-1 - i] for col in zip(*grid)\n                   for i in range(len(col) // 2))\n    return min(rowFlips, colFlips)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3284, "slug": "sum-of-consecutive-subarrays", "solutions": ["class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        mod = 10**9 + 7\n        f = g = 1\n        s = t = nums[0]\n        ans = nums[0]\n        for x, y in pairwise(nums):\n            if y - x == 1:\n                f += 1\n                s += f * y\n                ans = (ans + s) % mod\n            else:\n                f = 1\n                s = y\n            if y - x == -1:\n                g += 1\n                t += g * y\n                ans = (ans + t) % mod\n            else:\n                g = 1\n                t = y\n            if abs(y - x) != 1:\n                ans = (ans + y) % mod\n        return ans\n", "class Solution:\n  def getSum(self, nums: list[int]) -> int:\n    def getSum(diff: int) -> int:\n      \"\"\"Returns the sum of all subarrays with a difference of `diff`.\"\"\"\n      res = nums[0]\n      summ = nums[0]\n      count = 1\n      for prev, num in itertools.pairwise(nums):\n        if num == prev + diff:\n          count += 1\n          summ += count * num\n        else:\n          count = 1\n          summ = num\n        res += summ\n      return res\n\n    return (getSum(1) + getSum(-1) - sum(nums)) % 1_000_000_007\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3299, "slug": "sum-of-consecutive-subsequences", "solutions": ["class Solution:\n    def getSum(self, nums: List[int]) -> int:\n        def calc(nums: List[int]) -> int:\n            n = len(nums)\n            left = [0] * n\n            right = [0] * n\n            cnt = Counter()\n            for i in range(1, n):\n                cnt[nums[i - 1]] += 1 + cnt[nums[i - 1] - 1]\n                left[i] = cnt[nums[i] - 1]\n            cnt = Counter()\n            for i in range(n - 2, -1, -1):\n                cnt[nums[i + 1]] += 1 + cnt[nums[i + 1] + 1]\n                right[i] = cnt[nums[i] + 1]\n            return sum((l + r + l * r) * x for l, r, x in zip(left, right, nums)) % mod\n\n        mod = 10**9 + 7\n        x = calc(nums)\n        nums.reverse()\n        y = calc(nums)\n        return (x + y + sum(nums)) % mod\n", "class Solution:\n  def getSum(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(nums)\n\n    def getSequenceSum(nums: list[int], direction: int) -> int:\n      \"\"\"\n      Returns the sum of all sequences in the array that are in consecutive\n      increasing order if `direction` is 1, or in consecutive decreasing order\n      if `direction` is -1.\"\"\"\n      sequenceSum = 0\n      # {num: the number of subsequences ending in `num` so far}\n      prefixCount = collections.Counter()\n      # {num: the number of subsequences starting from `num` so far}\n      suffixCount = collections.Counter()\n      # prefixSubseqs[i] := the number of subsequences ending in nums[i]\n      prefixSubseqs = [0] * n\n      # suffixSubseqs[i] := the number of subsequences starting from nums[i]\n      suffixSubseqs = [0] * n\n\n      for i, num in enumerate(nums):\n        prevNum = num - direction\n        freq = prefixCount[prevNum] + 1\n        prefixSubseqs[i] = freq\n        prefixCount[num] += freq\n        prefixCount[num] %= MOD\n\n      for i, num in reversed(list(enumerate(nums))):\n        nextNum = num + direction\n        freq = suffixCount[nextNum] + 1\n        suffixSubseqs[i] = freq\n        suffixCount[num] += freq\n        suffixCount[num] %= MOD\n\n      for num, prefixSubseq, suffixSubseq in zip(\n              nums, prefixSubseqs, suffixSubseqs):\n        sequenceSum += num * prefixSubseq * suffixSubseq\n        sequenceSum %= MOD\n\n      return sequenceSum\n\n    increasingSequenceSum = getSequenceSum(nums, 1)\n    decreasingSequenceSum = getSequenceSum(nums, -1)\n    return (increasingSequenceSum + decreasingSequenceSum - sum(nums) + MOD) % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3242, "slug": "design-neighbor-sum-service", "solutions": ["class NeighborSum:\n\n    def __init__(self, grid: List[List[int]]):\n        self.grid = grid\n        self.d = {}\n        self.dirs = ((-1, 0, 1, 0, -1), (-1, 1, 1, -1, -1))\n        for i, row in enumerate(grid):\n            for j, x in enumerate(row):\n                self.d[x] = (i, j)\n\n    def adjacentSum(self, value: int) -> int:\n        return self.cal(value, 0)\n\n    def cal(self, value: int, k: int):\n        i, j = self.d[value]\n        s = 0\n        for a, b in pairwise(self.dirs[k]):\n            x, y = i + a, j + b\n            if 0 <= x < len(self.grid) and 0 <= y < len(self.grid[0]):\n                s += self.grid[x][y]\n        return s\n\n    def diagonalSum(self, value: int) -> int:\n        return self.cal(value, 1)\n\n\n# Your NeighborSum object will be instantiated and called as such:\n# obj = NeighborSum(grid)\n# param_1 = obj.adjacentSum(value)\n# param_2 = obj.diagonalSum(value)\n", "class neighborSum:\n  def __init__(self, grid: list[list[int]]):\n    self.grid = grid\n    self.n = len(grid)\n    self.numToPos = {num: (i, j)\n                     for i, row in enumerate(grid)\n                     for j, num in enumerate(row)}\n\n  def adjacentSum(self, value: int) -> int:\n    i, j = self.numToPos[value]\n    return sum(self.grid[x][y]\n               for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1))\n               if 0 <= x < self.n and 0 <= y < self.n)\n\n  def diagonalSum(self, value: int) -> int:\n    i, j = self.numToPos[value]\n    return sum(self.grid[x][y]\n               for x, y in ((i - 1, j - 1), (i - 1, j + 1),\n                            (i + 1, j - 1), (i + 1, j + 1))\n               if 0 <= x < self.n and 0 <= y < self.n)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3225, "slug": "maximum-score-from-grid-operations", "solutions": ["class Solution:\n  def maximumScore(self, grid: list[list[int]]) -> int:\n    n = len(grid)\n    # prefix[j][i] := the sum of the first i elements in the j-th column\n    prefix = [[0] * (n + 1) for _ in range(n)]\n    # prevPick[i] := the maximum score up to the previous column, where the\n    # bottommost selected element in the previous column is in row (i - 1)\n    prevPick = [0] * (n + 1)\n    # prevSkip[i] := the maximum score up to the previous column, where the\n    # bottommost selected element in the column before the previous one is in\n    # row (i - 1)\n    prevSkip = [0] * (n + 1)\n\n    for j in range(n):\n      for i in range(n):\n        prefix[j][i + 1] = prefix[j][i] + grid[i][j]\n\n    for j in range(1, n):\n      currPick = [0] * (n + 1)\n      currSkip = [0] * (n + 1)\n      # Consider all possible combinations of the number of current and\n      # previous selected elements.\n      for curr in range(n + 1):  # the number of current selected elements\n        for prev in range(n + 1):  # the number of previous selected elements\n          if curr > prev:\n            # 1. The current bottom is deeper than the previous bottom.\n            # Get the score of grid[prev..curr)[j - 1] for both pick and skip.\n            score = prefix[j - 1][curr] - prefix[j - 1][prev]\n            currPick[curr] = max(currPick[curr], prevSkip[prev] + score)\n            currSkip[curr] = max(currSkip[curr], prevSkip[prev] + score)\n          else:\n            # 2. The previous bottom is deeper than the current bottom.\n            # Get the score of grid[curr..prev)[j] for pick only.\n            score = prefix[j][prev] - prefix[j][curr]\n            currPick[curr] = max(currPick[curr], prevPick[prev] + score)\n            currSkip[curr] = max(currSkip[curr], prevPick[prev])\n      prevPick = currPick\n      prevSkip = currSkip\n\n    return max(prevPick)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3233, "slug": "find-the-count-of-numbers-which-are-not-special", "solutions": ["m = 31623\nprimes = [True] * (m + 1)\nprimes[0] = primes[1] = False\nfor i in range(2, m + 1):\n    if primes[i]:\n        for j in range(i + i, m + 1, i):\n            primes[j] = False\n\n\nclass Solution:\n    def nonSpecialCount(self, l: int, r: int) -> int:\n        lo = ceil(sqrt(l))\n        hi = floor(sqrt(r))\n        cnt = sum(primes[i] for i in range(lo, hi + 1))\n        return r - l + 1 - cnt\n", "class Solution:\n  def nonSpecialCount(self, l: int, r: int) -> int:\n    maxRoot = math.isqrt(r)\n    isPrime = self._sieveEratosthenes(maxRoot + 1)\n    specialCount = 0\n\n    for num in range(2, math.isqrt(r) + 1):\n      if isPrime[num] and l <= num**2 <= r:\n        specialCount += 1\n\n    return r - l + 1 - specialCount\n\n  def _sieveEratosthenes(self, n: int) -> list[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3205, "slug": "maximum-array-hopping-score-i", "solutions": ["class Solution:\n    def maxScore(self, nums: List[int]) -> int:\n        @cache\n        def dfs(i: int) -> int:\n            return max(\n                [(j - i) * nums[j] + dfs(j) for j in range(i + 1, len(nums))] or [0]\n            )\n\n        return dfs(0)\n", "class Solution:\n  def maxScore(self, nums: list[int]) -> int:\n    n = len(nums)\n    # dp[i] := the maximum score to jump from index i to n - 1\n    dp = [0] * n\n\n    for i in reversed(range(n)):\n      for j in range(i + 1, n):\n        # Jump from i to j, and then jump from j to n - 1.\n        dp[i] = max(dp[i], (j - i) * nums[j] + dp[j])\n\n    return dp[0]\n", "class Solution:\n  def maxScore(self, nums: list[int]) -> int:\n    # The optimal jump is the maximum number in the remaining suffix.\n    return sum(itertools.accumulate(nums[:0:-1], max))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3254, "slug": "find-the-power-of-k-size-subarrays-i", "solutions": ["class Solution:\n    def resultsArray(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        f = [1] * n\n        for i in range(1, n):\n            if nums[i] == nums[i - 1] + 1:\n                f[i] = f[i - 1] + 1\n        return [nums[i] if f[i] >= k else -1 for i in range(k - 1, n)]\n", "class Solution:\n  def resultsArray(self, nums: list[int], k: int) -> list[int]:\n    ans = []\n    start = 0\n\n    for i, num in enumerate(nums):\n      if i > 0 and num != nums[i - 1] + 1:\n        start = i\n      if i >= k - 1:\n        ans.append(num if i - start + 1 >= k else -1)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3261, "slug": "count-substrings-that-satisfy-k-constraint-ii", "solutions": ["class Solution:\n    def countKConstraintSubstrings(\n        self, s: str, k: int, queries: List[List[int]]\n    ) -> List[int]:\n        cnt = [0, 0]\n        i, n = 0, len(s)\n        d = [n] * n\n        pre = [0] * (n + 1)\n        for j, x in enumerate(map(int, s)):\n            cnt[x] += 1\n            while cnt[0] > k and cnt[1] > k:\n                d[i] = j\n                cnt[int(s[i])] -= 1\n                i += 1\n            pre[j + 1] = pre[j] + j - i + 1\n        ans = []\n        for l, r in queries:\n            p = min(r + 1, d[l])\n            a = (1 + p - l) * (p - l) // 2\n            b = pre[r + 1] - pre[p]\n            ans.append(a + b)\n        return ans\n", "class Solution:\n  def countKConstraintSubstrings(\n      self,\n      s: str,\n      k: int,\n      queries: list[list[int]]\n  ) -> list[int]:\n    n = len(s)\n    ans = []\n    count = [0, 0]\n    # leftToRight[l] := the maximum right index r s.t. s[l..r] is valid\n    leftToRight = [0] * n\n    # rightToLeft[r] := the minimum left index l s.t. s[l..r] is valid\n    rightToLeft = [0] * n\n\n    l = 0\n    for r in range(n):\n      count[int(s[r])] += 1\n      while min(count) > k:\n        count[int(s[l])] -= 1\n        l += 1\n      rightToLeft[r] = l\n\n    count = [0, 0]\n    r = n - 1\n    for l in reversed(range(n)):\n      count[int(s[l])] += 1\n      while min(count) > k:\n        count[int(s[r])] -= 1\n        r -= 1\n      leftToRight[l] = r\n\n    # prefix[i] := the number of valid substrings ending in [0..i - 1].\n    prefix = list(itertools.accumulate((r - l + 1\n                                       for r, l in enumerate(rightToLeft)),\n                                       initial=0))\n\n    for l, r in queries:\n      if r > leftToRight[l]:\n        # If r is beyond leftToRight[l], compute the number of valid substrings\n        # from l to leftToRight[l] and add the number of valid substrings\n        # ending in [leftToRight[l] + 1..r].\n        #\n        # prefix[r + 1] := the number of valid substrings ending in [0..r].\n        # prefix[leftToRight[l] + 1] := the number of valid substrings ending\n        # in [0..leftToRight].\n        # => prefix[r + 1] - prefix[leftToRight[l] + 1] := the number of valid\n        # substrings ending in [leftToRight[l] + 1..r].\n        sz = leftToRight[l] - l + 1\n        numValidSubstrings = sz * (sz + 1) // 2 + (\n            prefix[r + 1] - prefix[leftToRight[l] + 1])\n      else:\n        # If r is within the range of leftToRight[l], compute the number of\n        # valid substrings directly from l to r.\n        sz = r - l + 1\n        numValidSubstrings = sz * (sz + 1) // 2\n      ans.append(numValidSubstrings)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3211, "slug": "generate-binary-strings-without-adjacent-zeros", "solutions": ["class Solution:\n    def validStrings(self, n: int) -> List[str]:\n        def dfs(i: int):\n            if i >= n:\n                ans.append(\"\".join(t))\n                return\n            for j in range(2):\n                if (j == 0 and (i == 0 or t[i - 1] == \"1\")) or j == 1:\n                    t.append(str(j))\n                    dfs(i + 1)\n                    t.pop()\n\n        ans = []\n        t = []\n        dfs(0)\n        return ans\n", "class Solution:\n  def validStrings(self, n: int) -> list[str]:\n    ans = []\n\n    def dfs(n: int, s: list[str]) -> None:\n      if n == 0:\n        ans.append(''.join(s))\n        return\n      if not s or s[-1] == '1':\n        s.append('0')\n        dfs(n - 1, s)\n        s.pop()\n      s.append('1')\n      dfs(n - 1, s)\n      s.pop()\n\n    dfs(n, [])\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3250, "slug": "find-the-count-of-monotonic-pairs-i", "solutions": ["class Solution:\n    def countOfPairs(self, nums: List[int]) -> int:\n        mod = 10**9 + 7\n        n, m = len(nums), max(nums)\n        f = [[0] * (m + 1) for _ in range(n)]\n        for j in range(nums[0] + 1):\n            f[0][j] = 1\n        for i in range(1, n):\n            s = list(accumulate(f[i - 1]))\n            for j in range(nums[i] + 1):\n                k = min(j, j + nums[i - 1] - nums[i])\n                if k >= 0:\n                    f[i][j] = s[k] % mod\n        return sum(f[-1][: nums[-1] + 1]) % mod\n", "class Solution:\n  def countOfPairs(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    MAX = 1000\n    n = len(nums)\n    # dp[i][num] := the number of valid ways to fill the arrays up to index i\n    # with arr1[i] = num\n    dp = [[0] * (MAX + 1) for _ in range(n)]\n\n    for num in range(nums[0] + 1):\n      dp[0][num] = 1\n\n    for i in range(1, n):\n      ways = 0\n      prevNum = 0\n      # To satisfy arr1, prevNum <= num.\n      # To satisfy arr2, nums[i - 1] - prevNum >= nums[i] - num.\n      #               => prevNum <= min(num, num - (nums[i] - nums[i - 1])).\n      # As we move from `num` to `num + 1`, the range of valid `prevNum` values\n      # becomes prevNum <= min(num + 1, num + 1 - (nums[i] - nums[i - 1])).\n      # Since the range of `prevNum` can only increase by at most 1, there's\n      # no need to iterate through all possible values of `prevNum`. We can\n      # simply increment `prevNum` by 1 if it meets the condition.\n      for num in range(nums[i] + 1):\n        if prevNum <= min(num, num - (nums[i] - nums[i - 1])):\n          ways = (ways + dp[i - 1][prevNum]) % MOD\n          prevNum += 1\n        dp[i][num] = ways\n\n    return sum(dp[n - 1]) % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3215, "slug": "count-triplets-with-even-xor-set-bits-ii", "solutions": ["class Solution:\n    def tripletCount(self, a: List[int], b: List[int], c: List[int]) -> int:\n        cnt1 = Counter(x.bit_count() & 1 for x in a)\n        cnt2 = Counter(x.bit_count() & 1 for x in b)\n        cnt3 = Counter(x.bit_count() & 1 for x in c)\n        ans = 0\n        for i in range(2):\n            for j in range(2):\n                for k in range(2):\n                    if (i + j + k) & 1 ^ 1:\n                        ans += cnt1[i] * cnt2[j] * cnt3[k]\n        return ans\n", "class Solution:\n  # Same as 3199. Count Triplets with Even XOR Set Bits I\n  def tripletCount(self, a: list[int], b: list[int], c: list[int]) -> int:\n    evenA, oddA = self._getEvenOddBitCount(a)\n    evenB, oddB = self._getEvenOddBitCount(b)\n    evenC, oddC = self._getEvenOddBitCount(c)\n    return evenA * oddB * oddC + oddA * evenB * oddC + oddA * oddB * evenC + evenA * evenB * evenC\n\n  def _getEvenOddBitCount(self, nums: list[int]) -> tuple[int, int]:\n    \"\"\"\n    Returns the count of numbers in the `nums` arrays that have even number of\n    ones and odd number of ones in their binary representation.\n    \"\"\"\n    even = sum(num.bit_count() % 2 == 0 for num in nums)\n    return (even, len(nums) - even)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3251, "slug": "find-the-count-of-monotonic-pairs-ii", "solutions": ["class Solution:\n    def countOfPairs(self, nums: List[int]) -> int:\n        mod = 10**9 + 7\n        n, m = len(nums), max(nums)\n        f = [[0] * (m + 1) for _ in range(n)]\n        for j in range(nums[0] + 1):\n            f[0][j] = 1\n        for i in range(1, n):\n            s = list(accumulate(f[i - 1]))\n            for j in range(nums[i] + 1):\n                k = min(j, j + nums[i - 1] - nums[i])\n                if k >= 0:\n                    f[i][j] = s[k] % mod\n        return sum(f[-1][: nums[-1] + 1]) % mod\n", "class Solution:\n  # Same as 3250. Find the Count of Monotonic Pairs I\n  def countOfPairs(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    MAX = 1000\n    n = len(nums)\n    # dp[i][num] := the number of valid ways to fill the arrays up to index i\n    # with arr1[i] = num\n    dp = [[0] * (MAX + 1) for _ in range(n)]\n\n    for num in range(nums[0] + 1):\n      dp[0][num] = 1\n\n    for i in range(1, n):\n      ways = 0\n      prevNum = 0\n      # To satisfy arr1, prevNum <= num.\n      # To satisfy arr2, nums[i - 1] - prevNum >= nums[i] - num.\n      #               => prevNum <= min(num, num - (nums[i] - nums[i - 1])).\n      # As we move from `num` to `num + 1`, the range of valid `prevNum` values\n      # becomes prevNum <= min(num + 1, num + 1 - (nums[i] - nums[i - 1])).\n      # Since the range of `prevNum` can only increase by at most 1, there's\n      # no need to iterate through all possible values of `prevNum`. We can\n      # simply increment `prevNum` by 1 if it meets the condition.\n      for num in range(nums[i] + 1):\n        if prevNum <= min(num, num - (nums[i] - nums[i - 1])):\n          ways = (ways + dp[i - 1][prevNum]) % MOD\n          prevNum += 1\n        dp[i][num] = ways\n\n    return sum(dp[n - 1]) % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3257, "slug": "maximum-value-sum-by-placing-three-rooks-ii", "solutions": ["class Solution:\n  # Same as 3256. Maximum Value Sum by Placing Three Rooks I\n  def maximumValueSum(self, board: list[list[int]]) -> int:\n    rows = [heapq.nlargest(3, [(val, i, j)\n            for j, val in enumerate(row)])\n            for i, row in enumerate(board)]\n    cols = [heapq.nlargest(3, [(val, i, j)\n            for i, val in enumerate(col)])\n            for j, col in enumerate(zip(*board))]\n    topNine = heapq.nlargest(9,\n                             set(itertools.chain(*rows)) &\n                             set(itertools.chain(*cols)))\n    return max(\n        (val1 + val2 + val3 for\n         (val1, i1, j1),\n         (val2, i2, j2),\n         (val3, i3, j3) in (itertools.combinations(topNine, 3))\n         if len({i1, i2, i3}) == 3 and len({j1, j2, j3}) == 3))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3260, "slug": "find-the-largest-palindrome-divisible-by-k", "solutions": ["class Solution:\n  def largestPalindrome(self, n: int, k: int) -> str:\n    match k:\n      case 1:\n        return '9' * n\n      case 2:\n        return '8' * n if n <= 2 else '8' + '9' * (n - 2) + '8'\n      case 3 | 9:\n        return '9' * n\n      case 4:\n        return '8' * n if n <= 4 else '88' + '9' * (n - 4) + '88'\n      case 5:\n        return '5' * n if n <= 2 else '5' + '9' * (n - 2) + '5'\n      case 6:\n        if n <= 2:\n          return '6' * n\n        elif n % 2 == 1:\n          l = n // 2 - 1\n          return '8' + '9' * l + '8' + '9' * l + '8'\n        else:\n          l = n // 2 - 2\n          return '8' + '9' * l + '77' + '9' * l + '8'\n      case 8:\n        return '8' * n if n <= 6 else '888' + '9' * (n - 6) + '888'\n      case _:\n        middle = {\n            0: '', 1: '7', 2: '77', 3: '959', 4: '9779', 5: '99799',\n            6: '999999', 7: '9994999', 8: '99944999', 9: '999969999',\n            10: '9999449999', 11: '99999499999'\n        }\n        q, r = divmod(n, 12)\n        return '999999' * q + middle[r] + '999999' * q\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3232, "slug": "find-if-digit-game-can-be-won", "solutions": ["class Solution:\n    def canAliceWin(self, nums: List[int]) -> bool:\n        a = sum(x for x in nums if x < 10)\n        b = sum(x for x in nums if x > 9)\n        return a != b\n", "class Solution:\n  def canAliceWin(self, nums: list[int]) -> bool:\n    return sum(num if num < 10 else -num for num in nums) != 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3217, "slug": "delete-nodes-from-linked-list-present-in-array", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def modifiedList(\n        self, nums: List[int], head: Optional[ListNode]\n    ) -> Optional[ListNode]:\n        s = set(nums)\n        pre = dummy = ListNode(next=head)\n        while pre.next:\n            if pre.next.val in s:\n                pre.next = pre.next.next\n            else:\n                pre = pre.next\n        return dummy.next\n", "class Solution:\n  def modifiedList(\n      self,\n      nums: list[int],\n      head: ListNode | None,\n  ) -> ListNode | None:\n    dummy = ListNode(0, head)\n    numsSet = set(nums)\n\n    curr = dummy\n    while curr.next:\n      if curr.next.val in numsSet:\n        curr.next = curr.next.next\n      else:\n        curr = curr.next\n\n    return dummy.next\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3249, "slug": "count-the-number-of-good-nodes", "solutions": ["class Solution:\n    def countGoodNodes(self, edges: List[List[int]]) -> int:\n        def dfs(a: int, fa: int) -> int:\n            pre = -1\n            cnt = ok = 1\n            for b in g[a]:\n                if b != fa:\n                    cur = dfs(b, a)\n                    cnt += cur\n                    if pre < 0:\n                        pre = cur\n                    elif pre != cur:\n                        ok = 0\n            nonlocal ans\n            ans += ok\n            return cnt\n\n        g = defaultdict(list)\n        for a, b in edges:\n            g[a].append(b)\n            g[b].append(a)\n        ans = 0\n        dfs(0, -1)\n        return ans\n", "class Solution:\n  def countGoodNodes(self, edges: list[list[int]]) -> int:\n    n = len(edges) + 1\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    ans = 0\n\n    def dfs(u: int, prev: int) -> int:\n      \"\"\"Returns the size of the subtree rooted at u.\"\"\"\n      nonlocal ans\n      size = 1\n      childrenSizes = []\n      for v in graph[u]:\n        if v == prev:\n          continue\n        child_size = dfs(v, u)\n        size += child_size\n        childrenSizes.append(child_size)\n\n      if not childrenSizes or all(s == childrenSizes[0]\n                                  for s in childrenSizes):\n        ans += 1\n\n      return size\n\n    dfs(0, -1)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3294, "slug": "convert-doubly-linked-list-to-array-ii", "solutions": ["\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val, prev=None, next=None):\n        self.val = val\n        self.prev = prev\n        self.next = next\n\"\"\"\n\n\nclass Solution:\n    def toArray(self, node: \"Optional[Node]\") -> List[int]:\n        while node.prev:\n            node = node.prev\n        ans = []\n        while node:\n            ans.append(node.val)\n            node = node.next\n        return ans\n", "class Solution:\n  def toArray(self, node: 'Optional[Node]') -> list[int]:\n    ans = []\n    curr = node\n\n    while curr.prev:\n      curr = curr.prev\n\n    while curr:\n      ans.append(curr.val)\n      curr = curr.next\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3222, "slug": "find-the-winning-player-in-coin-game", "solutions": ["class Solution:\n    def losingPlayer(self, x: int, y: int) -> str:\n        k = min(x // 2, y // 8)\n        x -= k * 2\n        y -= k * 8\n        return \"Alice\" if x and y >= 4 else \"Bob\"\n", "class Solution:\n  def losingPlayer(self, x: int, y: int) -> str:\n    return 'Bob' if min(x, y // 4) % 2 == 0 else 'Alice'\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3291, "slug": "minimum-number-of-valid-strings-to-form-target-i", "solutions": ["def min(a: int, b: int) -> int:\n    return a if a < b else b\n\n\nclass Trie:\n    def __init__(self):\n        self.children: List[Optional[Trie]] = [None] * 26\n\n    def insert(self, w: str):\n        node = self\n        for i in map(lambda c: ord(c) - 97, w):\n            if node.children[i] is None:\n                node.children[i] = Trie()\n            node = node.children[i]\n\n\nclass Solution:\n    def minValidStrings(self, words: List[str], target: str) -> int:\n        @cache\n        def dfs(i: int) -> int:\n            if i >= n:\n                return 0\n            node = trie\n            ans = inf\n            for j in range(i, n):\n                k = ord(target[j]) - 97\n                if node.children[k] is None:\n                    break\n                node = node.children[k]\n                ans = min(ans, 1 + dfs(j + 1))\n            return ans\n\n        trie = Trie()\n        for w in words:\n            trie.insert(w)\n        n = len(target)\n        ans = dfs(0)\n        return ans if ans < inf else -1\n", "class Solution:\n  def minValidStrings(self, words: list[str], target: str) -> int:\n    ans = 0\n    unmatchedPrefix = len(target)\n    lpsList = [self._getLPS(word + '#' + target) for word in words]\n\n    while unmatchedPrefix > 0:\n      # Greedily choose the word that has the longest suffix match with the\n      # remaining unmatched prefix.\n      maxMatchSuffix = 0\n      for lps, word in zip(lpsList, words):\n        maxMatchSuffix = max(maxMatchSuffix, lps[len(word) + unmatchedPrefix])\n      if maxMatchSuffix == 0:\n        return -1\n      ans += 1\n      unmatchedPrefix -= maxMatchSuffix\n\n    return ans\n\n  def _getLPS(self, pattern: str) -> list[int]:\n    \"\"\"\n    Returns the lps array, where lps[i] is the length of the longest prefix of\n    pattern[0..i] which is also a suffix of this substring.\n    \"\"\"\n    lps = [0] * len(pattern)\n    j = 0\n    for i in range(1, len(pattern)):\n      while j > 0 and pattern[j] != pattern[i]:\n        j = lps[j - 1]\n      if pattern[i] == pattern[j]:\n        lps[i] = j + 1\n        j += 1\n    return lps\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3293, "slug": "calculate-product-final-price", "solutions": ["import pandas as pd\n\n\ndef calculate_final_prices(\n    products: pd.DataFrame, discounts: pd.DataFrame\n) -> pd.DataFrame:\n    # Perform a left join on the 'category' column\n    merged_df = pd.merge(products, discounts, on=\"category\", how=\"left\")\n\n    # Calculate the final price\n    merged_df[\"final_price\"] = (\n        merged_df[\"price\"] * (100 - merged_df[\"discount\"].fillna(0)) / 100\n    )\n\n    # Select the necessary columns and sort by 'product_id'\n    result_df = merged_df[[\"product_id\", \"final_price\", \"category\"]].sort_values(\n        \"product_id\"\n    )\n\n    return result_df\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3227, "slug": "vowels-game-in-a-string", "solutions": ["class Solution:\n    def doesAliceWin(self, s: str) -> bool:\n        vowels = set(\"aeiou\")\n        return any(c in vowels for c in s)\n", "class Solution:\n  def doesAliceWin(self, s: str) -> bool:\n    # Let k be the number of vowels in s.\n    # 1. If k == 0, Bob wins since Alice has no vowels to pick.\n    # 2. If k % 2 == 1, Alice wins since Alice can pick the entire string.\n    # 3. If k % 2 == 0, Alice wins since Alice can pick (k - 1) vowels,\n    # then Bob will either pick a substring containing 0 vowels, resulting in\n    # Alice picking the remaining entire string, or Bob couldn't pick at all\n    # (the last vowel).\n    VOWELS = 'aeiou'\n    return any(c in VOWELS for c in s)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3285, "slug": "find-indices-of-stable-mountains", "solutions": ["class Solution:\n    def stableMountains(self, height: List[int], threshold: int) -> List[int]:\n        return [i for i in range(1, len(height)) if height[i - 1] > threshold]\n", "class Solution:\n  def stableMountains(self, height: list[int], threshold: int) -> list[int]:\n    return [i for i in range(1, len(height))\n            if height[i - 1] > threshold]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3280, "slug": "convert-date-to-binary", "solutions": ["class Solution:\n    def convertDateToBinary(self, date: str) -> str:\n        return \"-\".join(f\"{int(s):b}\" for s in date.split(\"-\"))\n", "class Solution:\n  def convertDateToBinary(self, date: str) -> str:\n    year, month, day = map(int, date.split('-'))\n\n    def toBinary(value: int) -> str:\n      \"\"\"Converts an integer to binary without leading zeros.\"\"\"\n      return bin(value)[2:]\n\n    return '-'.join([toBinary(year), toBinary(month), toBinary(day)])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3234, "slug": "count-the-number-of-substrings-with-dominant-ones", "solutions": ["class Solution:\n  def numberOfSubstrings(self, s: str) -> int:\n    ans = 0\n    #    z^2 + z = n.\n    # => z^2 + z - n = 0.\n    # => z = (-1 + sqrt(1 + 4n)) / 2.\n    maxZero = (-1 + math.sqrt(1 + 4 * len(s))) // 2\n\n    # Iterate through all possible number of 0s.\n    for zero in range(int(maxZero) + 1):\n      lastInvalidPos = -1\n      count = [0, 0]\n      l = 0\n      for r, c in enumerate(s):\n        count[int(c)] += 1\n        # Try to shrink the window to maintain the \"minimum\" length of the\n        # valid substring.\n        while l < r:\n          if s[l] == '0' and count[0] > zero:\n            count[0] -= 1  # Remove an extra '0'.\n            lastInvalidPos = l\n            l += 1\n          elif s[l] == '1' and count[1] - 1 >= zero * zero:\n            count[1] -= 1  # Remove an extra '1'.\n            l += 1\n          else:\n            break  # Cannot remove more characters.\n        if count[0] == zero and count[1] >= zero * zero:\n          # Add valid substrings ending in s[r] to the answer. They are\n          # s[lastInvalidPos + 1..r], s[lastInvalidPos + 2..r], ..., s[l..r].\n          ans += l - lastInvalidPos\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3266, "slug": "final-array-state-after-k-multiplication-operations-ii", "solutions": ["class Solution:\n    def getFinalState(self, nums: List[int], k: int, multiplier: int) -> List[int]:\n        if multiplier == 1:\n            return nums\n        pq = [(x, i) for i, x in enumerate(nums)]\n        heapify(pq)\n        m = max(nums)\n        while k and pq[0][0] < m:\n            x, i = heappop(pq)\n            heappush(pq, (x * multiplier, i))\n            k -= 1\n        n = len(nums)\n        mod = 10**9 + 7\n        pq.sort()\n        for i, (x, j) in enumerate(pq):\n            nums[j] = x * pow(multiplier, k // n + int(i < k % n), mod) % mod\n        return nums\n", "class Solution:\n  def getFinalState(\n      self,\n      nums: list[int],\n      k: int,\n      multiplier: int\n  ) -> list[int]:\n    if multiplier == 1:\n      return nums\n\n    MOD = 1_000_000_007\n    n = len(nums)\n    maxNum = max(nums)\n    ans = [0] * n\n    minHeap = [(num, i) for i, num in enumerate(nums)]\n\n    heapq.heapify(minHeap)\n\n    # Keep multiplying the minimum number as close as possible to the maximum\n    # number in the array. After that, stop multiplying the minimum number\n    # because it will be greater than the maximum number in the array and break\n    # the circularity.\n    while k > 0 and minHeap[0][0] * multiplier <= maxNum:\n      num, i = heapq.heappop(minHeap)\n      heapq.heappush(minHeap, (num * multiplier, i))\n      k -= 1\n\n    sortedIndexedNums = sorted(minHeap)\n    multipliesPerNum, remainingK = divmod(k, n)\n\n    # Evenly distribute the remaining multiplications to each number by using\n    # fast exponentiation.\n    for index, (num, i) in enumerate(sortedIndexedNums):\n      sortedIndexedNums[index] = (\n          sortedIndexedNums[index][0] *\n          pow(multiplier, multipliesPerNum, MOD) % MOD, i)\n\n    # Distribute the remaining multiplications to the minimum `remainingK`\n    # numbers.\n    for index in range(remainingK):\n      sortedIndexedNums[index] = (\n          sortedIndexedNums[index][0] * multiplier % MOD,\n          sortedIndexedNums[index][1])\n\n    for num, i in sortedIndexedNums:\n      ans[i] = num\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3245, "slug": "alternating-groups-iii", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3287, "slug": "find-the-maximum-sequence-value-of-array", "solutions": ["class Solution:\n    def maxValue(self, nums: List[int], k: int) -> int:\n        m = 1 << 7\n        n = len(nums)\n        f = [[[False] * m for _ in range(k + 2)] for _ in range(n + 1)]\n        f[0][0][0] = True\n        for i in range(n):\n            for j in range(k + 1):\n                for x in range(m):\n                    f[i + 1][j][x] |= f[i][j][x]\n                    f[i + 1][j + 1][x | nums[i]] |= f[i][j][x]\n\n        g = [[[False] * m for _ in range(k + 2)] for _ in range(n + 1)]\n        g[n][0][0] = True\n        for i in range(n, 0, -1):\n            for j in range(k + 1):\n                for y in range(m):\n                    g[i - 1][j][y] |= g[i][j][y]\n                    g[i - 1][j + 1][y | nums[i - 1]] |= g[i][j][y]\n\n        ans = 0\n        for i in range(k, n - k + 1):\n            for x in range(m):\n                if f[i][k][x]:\n                    for y in range(m):\n                        if g[i][k][y]:\n                            ans = max(ans, x ^ y)\n        return ans\n", "class Solution:\n  def maxValue(self, nums: list[int], k: int) -> int:\n    left = self._getPossibleORs(nums, k)\n    right = self._getPossibleORs(nums[::-1], k)[::-1]\n    return max(a ^ b\n               for i in range(k - 1, len(nums) - k)\n               for a in range(128 + 1)\n               for b in range(128 + 1)\n               if left[i][k][a] and right[i + 1][k][b])\n\n  def _getPossibleORs(self, nums: list[int], k: int) -> list[list[list[bool]]]:\n    dp = [[[False] * (128 + 1)\n          for _ in range(k + 1)]\n          for _ in range(len(nums))]\n\n    dp[0][1][nums[0]] = True\n\n    for i in range(len(nums)):\n      dp[i][0][0] = True\n\n    for i in range(1, len(nums)):\n      for j in range(1, k + 1):\n        for x in range(128 + 1):\n          if dp[i - 1][j][x]:\n            dp[i][j][x] = True\n          if dp[i - 1][j - 1][x]:\n            dp[i][j][nums[i] | x] = True\n\n    return dp\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3273, "slug": "minimum-amount-of-damage-dealt-to-bob", "solutions": ["from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass Enemy:\n  damage: int\n  timeTakenDown: int\n\n\nclass Solution:\n  def minDamage(self, power: int, damage: list[int], health: list[int]) -> int:\n    ans = 0\n    sumDamage = sum(damage)\n    enemies = [Enemy(d, (h + power - 1) // power)\n               for d, h in zip(damage, health)]\n\n    # It's better to take down the enemy i first if the damage dealt of taking\n    # down i first is less than the damage dealt of taking down j first. So,\n    #    damage[i] * t[i] + (t[i] + t[j]) * damage[j] <\n    #    damage[j] * t[j] + (t[i] + t[j]) * damage[i]\n    # => damage[i] * t[i] + damage[j] * t[i] + damage[j] * t[j] <\n    #    damage[j] * t[j] + damage[i] * t[j] + damage[i] * t[i]\n    # => damage[j] * t[i] < damage[i] * t[j]\n    # => damage[j] / t[j] < damage[i] / t[i]\n    enemies.sort(key=lambda x: -x.damage / x.timeTakenDown)\n\n    for enemy in enemies:\n      ans += sumDamage * enemy.timeTakenDown\n      sumDamage -= enemy.damage\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3218, "slug": "minimum-cost-for-cutting-cake-i", "solutions": ["class Solution:\n    def minimumCost(\n        self, m: int, n: int, horizontalCut: List[int], verticalCut: List[int]\n    ) -> int:\n        horizontalCut.sort(reverse=True)\n        verticalCut.sort(reverse=True)\n        ans = i = j = 0\n        h = v = 1\n        while i < m - 1 or j < n - 1:\n            if j == n - 1 or (i < m - 1 and horizontalCut[i] > verticalCut[j]):\n                ans += horizontalCut[i] * v\n                h, i = h + 1, i + 1\n            else:\n                ans += verticalCut[j] * h\n                v, j = v + 1, j + 1\n        return ans\n", "class Solution:\n  def minimumCost(\n      self,\n      m: int,\n      n: int,\n      horizontalCut: list[int],\n      verticalCut: list[int],\n  ) -> int:\n    ans = 0\n    sumH = sum(horizontalCut)\n    sumV = sum(verticalCut)\n\n    horizontalCut.sort()\n    verticalCut.sort()\n\n    while horizontalCut and verticalCut:\n      if horizontalCut[-1] > verticalCut[-1]:\n        ans += horizontalCut[-1] + sumV\n        sumH -= horizontalCut.pop()\n      else:\n        ans += verticalCut[-1] + sumH\n        sumV -= verticalCut.pop()\n\n    return ans + sumH + sumV\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3259, "slug": "maximum-energy-boost-from-two-drinks", "solutions": ["class Solution:\n    def maxEnergyBoost(self, energyDrinkA: List[int], energyDrinkB: List[int]) -> int:\n        n = len(energyDrinkA)\n        f = [[0] * 2 for _ in range(n)]\n        f[0][0] = energyDrinkA[0]\n        f[0][1] = energyDrinkB[0]\n        for i in range(1, n):\n            f[i][0] = max(f[i - 1][0] + energyDrinkA[i], f[i - 1][1])\n            f[i][1] = max(f[i - 1][1] + energyDrinkB[i], f[i - 1][0])\n        return max(f[n - 1])\n", "class Solution:\n  def maxEnergyBoost(\n      self,\n      energyDrinkA: list[int],\n      energyDrinkB: list[int]\n  ) -> int:\n    dpA = 0  # the maximum energy boost if the last drink is A\n    dpB = 0  # the maximum energy boost if the last drink is B\n\n    for a, b in zip(energyDrinkA, energyDrinkB):\n      dpA, dpB = max(dpB, dpA + a), max(dpA, dpB + b)\n\n    return max(dpA, dpB)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3202, "slug": "find-the-maximum-length-of-valid-subsequence-ii", "solutions": ["class Solution:\n    def maximumLength(self, nums: List[int], k: int) -> int:\n        f = [[0] * k for _ in range(k)]\n        ans = 0\n        for x in nums:\n            x %= k\n            for j in range(k):\n                y = (j - x + k) % k\n                f[x][y] = f[y][x] + 1\n                ans = max(ans, f[x][y])\n        return ans\n", "class Solution:\n  # Similar to 3201. Find the Maximum Length of Valid Subsequence I\n  def maximumLength(self, nums: list[int], k: int) -> int:\n    # dp[i][j] := the maximum length of a valid subsequence, where the last\n    # number mod k equal to i and the next desired number mod k equal to j\n    dp = [[0] * k for _ in range(k)]\n\n    # Extend the pattern xyxyxy...xy.\n    for x in nums:\n      for y in range(k):\n        dp[x % k][y] = dp[y][x % k] + 1\n\n    return max(map(max, dp))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3236, "slug": "ceo-subordinate-hierarchy", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3226, "slug": "number-of-bit-changes-to-make-two-integers-equal", "solutions": ["class Solution:\n    def minChanges(self, n: int, k: int) -> int:\n        return -1 if n & k != k else (n ^ k).bit_count()\n", "class Solution:\n  def minChanges(self, n: int, k: int) -> int:\n    # n needs to be a superset of k.\n    return (n ^ k).bit_count() if (n & k) == k else -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3282, "slug": "reach-end-of-array-with-max-score", "solutions": ["class Solution:\n    def findMaximumScore(self, nums: List[int]) -> int:\n        ans = mx = 0\n        for x in nums[:-1]:\n            mx = max(mx, x)\n            ans += mx\n        return ans\n", "class Solution:\n  # Similar to 3205. Maximum Array Hopping Score I\n  def findMaximumScore(self, nums: list[int]) -> int:\n    return sum(itertools.accumulate(nums[:-1], max))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3269, "slug": "constructing-two-increasing-arrays", "solutions": ["class Solution:\n    def minLargest(self, nums1: List[int], nums2: List[int]) -> int:\n        def nxt(x: int, y: int) -> int:\n            return x + 1 if (x & 1 ^ y) == 1 else x + 2\n\n        m, n = len(nums1), len(nums2)\n        f = [[0] * (n + 1) for _ in range(m + 1)]\n        for i, x in enumerate(nums1, 1):\n            f[i][0] = nxt(f[i - 1][0], x)\n        for j, y in enumerate(nums2, 1):\n            f[0][j] = nxt(f[0][j - 1], y)\n        for i, x in enumerate(nums1, 1):\n            for j, y in enumerate(nums2, 1):\n                f[i][j] = min(nxt(f[i - 1][j], x), nxt(f[i][j - 1], y))\n        return f[m][n]\n", "class Solution:\n  def minLargest(self, nums1: list[int], nums2: list[int]) -> int:\n    m = len(nums1)\n    n = len(nums2)\n    # dp[i][j] := the minimum largest number for the first i nums1 and the\n    # first j nums2\n    dp = [[math.inf] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = 0\n\n    def f(prev: int, num: int) -> int:\n      \"\"\"\n      Returns the next number to fill in the array based on the previous number\n      and the current number.\n      \"\"\"\n      return prev + (2 if prev % 2 == num else 1)\n\n    for i in range(m + 1):\n      for j in range(n + 1):\n        if i > 0:\n          dp[i][j] = min(dp[i][j], f(dp[i - 1][j], nums1[i - 1]))\n        if j > 0:\n          dp[i][j] = min(dp[i][j], f(dp[i][j - 1], nums2[j - 1]))\n\n    return dp[m][n]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3292, "slug": "minimum-number-of-valid-strings-to-form-target-ii", "solutions": ["class Hashing:\n    __slots__ = [\"mod\", \"h\", \"p\"]\n\n    def __init__(self, s: List[str], base: int, mod: int):\n        self.mod = mod\n        self.h = [0] * (len(s) + 1)\n        self.p = [1] * (len(s) + 1)\n        for i in range(1, len(s) + 1):\n            self.h[i] = (self.h[i - 1] * base + ord(s[i - 1])) % mod\n            self.p[i] = (self.p[i - 1] * base) % mod\n\n    def query(self, l: int, r: int) -> int:\n        return (self.h[r] - self.h[l - 1] * self.p[r - l + 1]) % self.mod\n\n\nclass Solution:\n    def minValidStrings(self, words: List[str], target: str) -> int:\n        def f(i: int) -> int:\n            l, r = 0, min(n - i, m)\n            while l < r:\n                mid = (l + r + 1) >> 1\n                sub = hashing.query(i + 1, i + mid)\n                if sub in s[mid]:\n                    l = mid\n                else:\n                    r = mid - 1\n            return l\n\n        base, mod = 13331, 998244353\n        hashing = Hashing(target, base, mod)\n        m = max(len(w) for w in words)\n        s = [set() for _ in range(m + 1)]\n        for w in words:\n            h = 0\n            for j, c in enumerate(w, 1):\n                h = (h * base + ord(c)) % mod\n                s[j].add(h)\n        ans = last = mx = 0\n        n = len(target)\n        for i in range(n):\n            dist = f(i)\n            mx = max(mx, i + dist)\n            if i == last:\n                if i == mx:\n                    return -1\n                last = mx\n                ans += 1\n        return ans\n", "class Solution:\n  # 3291. Minimum Number of Valid Strings to Form Target I\n  def minValidStrings(self, words: list[str], target: str) -> int:\n    ans = 0\n    unmatchedPrefix = len(target)\n    lpsList = [self._getLPS(word + '#' + target) for word in words]\n\n    while unmatchedPrefix > 0:\n      # Greedily choose the word that has the longest suffix match with the\n      # remaining unmatched prefix.\n      maxMatchSuffix = 0\n      for lps, word in zip(lpsList, words):\n        maxMatchSuffix = max(maxMatchSuffix, lps[len(word) + unmatchedPrefix])\n      if maxMatchSuffix == 0:\n        return -1\n      ans += 1\n      unmatchedPrefix -= maxMatchSuffix\n\n    return ans\n\n  def _getLPS(self, pattern: str) -> list[int]:\n    \"\"\"\n    Returns the lps array, where lps[i] is the length of the longest prefix of\n    pattern[0..i] which is also a suffix of this substring.\n    \"\"\"\n    lps = [0] * len(pattern)\n    j = 0\n    for i in range(1, len(pattern)):\n      while j > 0 and pattern[j] != pattern[i]:\n        j = lps[j - 1]\n      if pattern[i] == pattern[j]:\n        lps[i] = j + 1\n        j += 1\n    return lps\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3244, "slug": "shortest-distance-after-road-addition-queries-ii", "solutions": ["class Solution:\n    def shortestDistanceAfterQueries(\n        self, n: int, queries: List[List[int]]\n    ) -> List[int]:\n        nxt = list(range(1, n))\n        ans = []\n        cnt = n - 1\n        for u, v in queries:\n            if 0 < nxt[u] < v:\n                i = nxt[u]\n                while i < v:\n                    cnt -= 1\n                    nxt[i], i = 0, nxt[i]\n                nxt[u] = v\n            ans.append(cnt)\n        return ans\n", "class Solution:\n  def shortestDistanceAfterQueries(\n      self,\n      n: int,\n      queries: list[list[int]],\n  ) -> list[int]:\n    ans = []\n    nodeToFarthestNode = {i: i + 1 for i in range(n - 1)}\n\n    for u, v in queries:\n      # If `u` exists in the map and `v` is farther than the current farthest\n      # node for `u`, we need to update the map and remove intermediate nodes.\n      if u in nodeToFarthestNode and nodeToFarthestNode[u] < v:\n        node = nodeToFarthestNode[u]\n        while node < v:\n          node = nodeToFarthestNode.pop(node)\n        nodeToFarthestNode[u] = v\n      ans.append(len(nodeToFarthestNode))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3206, "slug": "alternating-groups-i", "solutions": ["class Solution:\n    def numberOfAlternatingGroups(self, colors: List[int]) -> int:\n        k = 3\n        n = len(colors)\n        ans = cnt = 0\n        for i in range(n << 1):\n            if i and colors[i % n] == colors[(i - 1) % n]:\n                cnt = 1\n            else:\n                cnt += 1\n            ans += i >= n and cnt >= k\n        return ans\n", "class Solution:\n  def numberOfAlternatingGroups(self, colors: list[int]) -> int:\n    n = len(colors)\n    return sum(colors[i] != colors[i - 1] and\n               colors[i] != colors[(i + 1) % n]\n               for i in range(n))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3224, "slug": "minimum-array-changes-to-make-differences-equal", "solutions": ["class Solution:\n    def minChanges(self, nums: List[int], k: int) -> int:\n        d = [0] * (k + 2)\n        n = len(nums)\n        for i in range(n // 2):\n            x, y = nums[i], nums[-i - 1]\n            if x > y:\n                x, y = y, x\n            d[0] += 1\n            d[y - x] -= 1\n            d[y - x + 1] += 1\n            d[max(y, k - x) + 1] -= 1\n            d[max(y, k - x) + 1] += 2\n        return min(accumulate(d))\n", "class Solution:\n  def minChanges(self, nums: list[int], k: int) -> int:\n    pairSize = len(nums) // 2\n    diffCount = collections.Counter()  # {nums[-1 - i] - nums[i]: freq}\n    # oneChangeCount[i] := the number of pairs that need only one change to\n    # to achieve a difference of `i`\n    oneChangeCount = [0] * (k + 1)\n\n    for i in range(pairSize):\n      a = nums[i]\n      b = nums[-1 - i]\n      diffCount[abs(a - b)] += 1\n      oneChangeCount[max(a, b, k - a, k - b)] += 1\n\n    # prefixOneChangeCount[i] := the number of pairs that need only one change\n    # to achieve a difference >= `i`\n    # prefixOneChangeCount[i] = sum(oneChangeCount[i..k])\n    prefixOneChangeCount = list(\n        itertools.accumulate(reversed(oneChangeCount)))[::-1]\n\n    return min(prefixOneChangeCount[diff] - freq +  # one change\n               (pairSize - prefixOneChangeCount[diff]) * 2  # two changes\n               for diff, freq in diffCount.items())\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3275, "slug": "k-th-nearest-obstacle-queries", "solutions": ["class Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        ans = []\n        pq = []\n        for i, (x, y) in enumerate(queries):\n            heappush(pq, -(abs(x) + abs(y)))\n            if i >= k:\n                heappop(pq)\n            ans.append(-pq[0] if i >= k - 1 else -1)\n        return ans\n", "class Solution:\n  def resultsArray(self, queries: list[list[int]], k: int) -> list[int]:\n    ans = []\n    maxHeap = []\n\n    for x, y in queries:\n      heapq.heappush(maxHeap, -(abs(x) + abs(y)))\n      if len(maxHeap) > k:\n        heapq.heappop(maxHeap)\n      ans.append(-maxHeap[0] if len(maxHeap) == k else -1)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3209, "slug": "number-of-subarrays-with-and-value-of-k", "solutions": ["class Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        ans = 0\n        pre = Counter()\n        for x in nums:\n            cur = Counter()\n            for y, v in pre.items():\n                cur[x & y] += v\n            cur[x] += 1\n            ans += cur[k]\n            pre = cur\n        return ans\n", "class Solution:\n  # Similar to 1521. Find a Value of a Mysterious Function Closest to Target\n  def countSubarrays(self, nums: list[int], k: int) -> int:\n    ans = 0\n    # the counter of all the values of subarrays that end in the previous\n    # number\n    prev = collections.Counter()\n\n    for num in nums:\n      # Extend each subarray that ends in the previous number. Due to\n      # monotonicity of the AND operation, the size of `curr` will be at most\n      # num.bit_count() + 1.\n      curr = collections.Counter({num: 1})\n      for val, freq in prev.items():\n        curr[val & num] += freq\n      ans += curr[k]\n      prev = curr\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3262, "slug": "find-overlapping-shifts", "solutions": ["import pandas as pd\n\n\ndef find_overlapping_shifts(employee_shifts: pd.DataFrame) -> pd.DataFrame:\n    merged_shifts = employee_shifts.merge(\n        employee_shifts, on=\"employee_id\", suffixes=(\"_t1\", \"_t2\")\n    )\n    overlapping_shifts = merged_shifts[\n        (merged_shifts[\"start_time_t1\"] < merged_shifts[\"start_time_t2\"])\n        & (merged_shifts[\"end_time_t1\"] > merged_shifts[\"start_time_t2\"])\n    ]\n    result = (\n        overlapping_shifts.groupby(\"employee_id\")\n        .size()\n        .reset_index(name=\"overlapping_shifts\")\n    )\n    result = result[result[\"overlapping_shifts\"] > 0]\n    result = result.sort_values(\"employee_id\").reset_index(drop=True)\n    return result\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3230, "slug": "customer-purchasing-behavior-analysis", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3221, "slug": "maximum-array-hopping-score-ii", "solutions": ["class Solution:\n    def maxScore(self, nums: List[int]) -> int:\n        stk = []\n        for i, x in enumerate(nums):\n            while stk and nums[stk[-1]] <= x:\n                stk.pop()\n            stk.append(i)\n        ans = i = 0\n        for j in stk:\n            ans += nums[j] * (j - i)\n            i = j\n        return ans\n", "class Solution:\n  # Same as 3205. Maximum Array Hopping Score I\n  def maxScore(self, nums: list[int]) -> int:\n    # The optimal jump is the maximum number in the remaining suffix.\n    return sum(itertools.accumulate(nums[:0:-1], max))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3270, "slug": "find-the-key-of-the-numbers", "solutions": ["class Solution:\n    def generateKey(self, num1: int, num2: int, num3: int) -> int:\n        ans, k = 0, 1\n        for _ in range(4):\n            x = min(num1 // k % 10, num2 // k % 10, num3 // k % 10)\n            ans += x * k\n            k *= 10\n        return ans\n", "class Solution:\n  def generateKey(self, num1: int, num2: int, num3: int) -> int:\n    return int(''.join(min(a, b, c)\n                       for a, b, c in zip(str(num1).zfill(4),\n                                          str(num2).zfill(4),\n                                          str(num3).zfill(4))))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3248, "slug": "snake-in-matrix", "solutions": ["class Solution:\n    def finalPositionOfSnake(self, n: int, commands: List[str]) -> int:\n        x = y = 0\n        for c in commands:\n            match c[0]:\n                case \"U\":\n                    x -= 1\n                case \"D\":\n                    x += 1\n                case \"L\":\n                    y -= 1\n                case \"R\":\n                    y += 1\n        return x * n + y\n", "class Solution:\n  def finalPositionOfSnake(self, n: int, commands: list[str]) -> int:\n    directions = {\n        \"UP\": (-1, 0),\n        \"RIGHT\": (0, 1),\n        \"DOWN\": (1, 0),\n        \"LEFT\": (0, -1),\n    }\n    i = 0\n    j = 0\n\n    for command in commands:\n      dx, dy = directions[command]\n      i += dx\n      j += dy\n\n    return i * n + j\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3220, "slug": "odd-and-even-transactions", "solutions": ["import pandas as pd\n\n\ndef sum_daily_odd_even(transactions: pd.DataFrame) -> pd.DataFrame:\n    transactions[\"odd_sum\"] = transactions[\"amount\"].where(\n        transactions[\"amount\"] % 2 == 1, 0\n    )\n    transactions[\"even_sum\"] = transactions[\"amount\"].where(\n        transactions[\"amount\"] % 2 == 0, 0\n    )\n\n    result = (\n        transactions.groupby(\"transaction_date\")\n        .agg(odd_sum=(\"odd_sum\", \"sum\"), even_sum=(\"even_sum\", \"sum\"))\n        .reset_index()\n    )\n\n    result = result.sort_values(\"transaction_date\")\n\n    return result\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3238, "slug": "find-the-number-of-winning-players", "solutions": ["class Solution:\n    def winningPlayerCount(self, n: int, pick: List[List[int]]) -> int:\n        cnt = [[0] * 11 for _ in range(n)]\n        s = set()\n        for x, y in pick:\n            cnt[x][y] += 1\n            if cnt[x][y] > x:\n                s.add(x)\n        return len(s)\n", "class Solution:\n  def winningPlayerCount(self, n: int, pick: list[list[int]]) -> int:\n    counts = [collections.Counter() for _ in range(n)]\n    for player, color in pick:\n      counts[player][color] += 1\n    return sum(max(count.values(), default=0) > i\n               for i, count in enumerate(counts))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3241, "slug": "time-taken-to-mark-all-nodes", "solutions": ["from dataclasses import dataclass\n\n\n@dataclass\nclass Node:\n  node: int = 0  # the node number\n  time: int = 0  # the time taken to mark the entire subtree rooted at the node\n\n\nclass Top2:\n  def __init__(self, top1: Node = Node(), top2: Node = Node()):\n    # the direct child node, where the time taken to mark the entire subtree\n    # rooted at the node is the maximum\n    self.top1 = top1\n    # the direct child node, where the time taken to mark the entire subtree\n    # rooted at the node is the second maximum\n    self.top2 = top2\n\n\nclass Solution:\n  def timeTaken(self, edges: list[list[int]]) -> list[int]:\n    n = len(edges) + 1\n    ans = [0] * n\n    tree = [[] for _ in range(n)]\n    # dp[i] := the top two direct child nodes for subtree rooted at node i,\n    # where each node contains the time taken to mark the entire subtree rooted\n    # at the node itself\n    dp = [Top2()] * n\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    self._dfs(tree, 0, -1, dp)\n    self._reroot(tree, 0, -1, 0, dp, ans)\n    return ans\n\n  def _getTime(self, u: int) -> int:\n    \"\"\"Returns the time taken to mark node u.\"\"\"\n    return 2 if u % 2 == 0 else 1\n\n  def _dfs(\n      self,\n      tree: list[list[int]],\n      u: int,\n      prev: int,\n      dp: list[Top2]\n  ) -> int:\n    \"\"\"\n    Performs a DFS traversal of the subtree rooted at node `u`, computes the\n    time taken to mark all nodes in the subtree, records the top two direct\n    child nodes, where the time taken to mark the subtree rooted at each of the\n    child nodes is maximized, and returns the top child node.\n\n    These values are used later in the rerooting process.\n    \"\"\"\n    top1 = Node()\n    top2 = Node()\n    for v in tree[u]:\n      if v == prev:\n        continue\n      time = self._dfs(tree, v, u, dp) + self._getTime(v)\n      if time >= top1.time:\n        top2 = top1\n        top1 = Node(v, time)\n      elif time > top2.time:\n        top2 = Node(v, time)\n    dp[u] = Top2(top1, top2)\n    return top1.time\n\n  def _reroot(\n      self,\n      tree: list[list[int]],\n      u: int,\n      prev: int,\n      maxTime: int,\n      dp: list[Top2],\n      ans: list[int]\n  ) -> None:\n    \"\"\"\n    Reroots the tree at node `u` and updates the answer array, where `maxTime`\n    is the longest path that doesn't go through `u`'s subtree.\n    \"\"\"\n    ans[u] = max(maxTime, dp[u].top1.time)\n\n    for v in tree[u]:\n      if v == prev:\n        continue\n      newMaxTime = self._getTime(u) + max(\n          maxTime,\n          dp[u].top2.time if dp[u].top1.node == v else dp[u].top1.time\n      )\n      self._reroot(tree, v, u, newMaxTime, dp, ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 64, "slug": "minimum-path-sum", "solutions": ["class Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        f = [[0] * n for _ in range(m)]\n        f[0][0] = grid[0][0]\n        for i in range(1, m):\n            f[i][0] = f[i - 1][0] + grid[i][0]\n        for j in range(1, n):\n            f[0][j] = f[0][j - 1] + grid[0][j]\n        for i in range(1, m):\n            for j in range(1, n):\n                f[i][j] = min(f[i - 1][j], f[i][j - 1]) + grid[i][j]\n        return f[-1][-1]\n", "class Solution:\n  def minPathSum(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    for i in range(m):\n      for j in range(n):\n        if i > 0 and j > 0:\n          grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\n        elif i > 0:\n          grid[i][0] += grid[i - 1][0]\n        elif j > 0:\n          grid[0][j] += grid[0][j - 1]\n\n    return grid[m - 1][n - 1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 98, "slug": "validate-binary-search-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\n        def dfs(root: Optional[TreeNode]) -> bool:\n            if root is None:\n                return True\n            if not dfs(root.left):\n                return False\n            nonlocal prev\n            if prev >= root.val:\n                return False\n            prev = root.val\n            return dfs(root.right)\n\n        prev = -inf\n        return dfs(root)\n", "class Solution:\n  def isValidBST(self, root: TreeNode | None) -> bool:\n    def isValidBST(root: TreeNode | None,\n                   minNode: TreeNode | None, maxNode: TreeNode | None) -> bool:\n      if not root:\n        return True\n      if minNode and root.val <= minNode.val:\n        return False\n      if maxNode and root.val >= maxNode.val:\n        return False\n\n      return (isValidBST(root.left, minNode, root) and\n              isValidBST(root.right, root, maxNode))\n\n    return isValidBST(root, None, None)\n", "class Solution:\n  def isValidBST(self, root: TreeNode | None) -> bool:\n    stack = []\n    pred = None\n\n    while root or stack:\n      while root:\n        stack.append(root)\n        root = root.left\n      root = stack.pop()\n      if pred and pred.val >= root.val:\n        return False\n      pred = root\n      root = root.right\n\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 38, "slug": "count-and-say", "solutions": ["class Solution:\n    def countAndSay(self, n: int) -> str:\n        s = '1'\n        for _ in range(n - 1):\n            i = 0\n            t = []\n            while i < len(s):\n                j = i\n                while j < len(s) and s[j] == s[i]:\n                    j += 1\n                t.append(str(j - i))\n                t.append(str(s[i]))\n                i = j\n            s = ''.join(t)\n        return s\n", "class Solution:\n  def countAndSay(self, n: int) -> str:\n    ans = '1'\n\n    for _ in range(n - 1):\n      nxt = ''\n      i = 0\n      while i < len(ans):\n        count = 1\n        while i + 1 < len(ans) and ans[i] == ans[i + 1]:\n          count += 1\n          i += 1\n        nxt += str(count) + ans[i]\n        i += 1\n      ans = nxt\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 49, "slug": "group-anagrams", "solutions": ["class Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        d = defaultdict(list)\n        for s in strs:\n            k = ''.join(sorted(s))\n            d[k].append(s)\n        return list(d.values())\n", "class Solution:\n  def groupAnagrams(self, strs: list[str]) -> list[list[str]]:\n    dict = collections.defaultdict(list)\n\n    for str in strs:\n      key = ''.join(sorted(str))\n      dict[key].append(str)\n\n    return dict.values()\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 48, "slug": "rotate-image", "solutions": ["class Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        n = len(matrix)\n        for i in range(n >> 1):\n            for j in range(n):\n                matrix[i][j], matrix[n - i - 1][j] = matrix[n - i - 1][j], matrix[i][j]\n        for i in range(n):\n            for j in range(i):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n", "class Solution:\n  def rotate(self, matrix: list[list[int]]) -> None:\n    for mn in range(len(matrix) // 2):\n      mx = len(matrix) - mn - 1\n      for i in range(mn, mx):\n        offset = i - mn\n        top = matrix[mn][i]\n        matrix[mn][i] = matrix[mx - offset][mn]\n        matrix[mx - offset][mn] = matrix[mx][mx - offset]\n        matrix[mx][mx - offset] = matrix[i][mx]\n        matrix[i][mx] = top\n", "class Solution:\n  def rotate(self, matrix: list[list[int]]) -> None:\n    matrix.reverse()\n\n    for i in range(len(matrix)):\n      for j in range(i + 1, len(matrix)):\n        matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 45, "slug": "jump-game-ii", "solutions": ["class Solution:\n    def jump(self, nums: List[int]) -> int:\n        ans = mx = last = 0\n        for i, x in enumerate(nums[:-1]):\n            mx = max(mx, i + x)\n            if last == i:\n                ans += 1\n                last = mx\n        return ans\n", "class Solution:\n  def jump(self, nums: list[int]) -> int:\n    ans = 0\n    end = 0\n    farthest = 0\n\n    # Start an implicit BFS.\n    for i in range(len(nums) - 1):\n      farthest = max(farthest, i + nums[i])\n      if farthest >= len(nums) - 1:\n        ans += 1\n        break\n      if i == end:      # Visited all the items on the current level.\n        ans += 1        # Increment the level.\n        end = farthest  # Make the queue size for the next level.\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 55, "slug": "jump-game", "solutions": ["class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        mx = 0\n        for i, x in enumerate(nums):\n            if mx < i:\n                return False\n            mx = max(mx, i + x)\n        return True\n", "class Solution:\n  def canJump(self, nums: list[int]) -> bool:\n    i = 0\n    reach = 0\n\n    while i < len(nums) and i <= reach:\n      reach = max(reach, i + nums[i])\n      i += 1\n\n    return i == len(nums)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 89, "slug": "gray-code", "solutions": ["class Solution:\n    def grayCode(self, n: int) -> List[int]:\n        return [i ^ (i >> 1) for i in range(1 << n)]\n", "class Solution:\n  def grayCode(self, n: int) -> list[int]:\n    ans = [0]\n\n    for i in range(n):\n      for j in reversed(range(len(ans))):\n        ans.append(ans[j] | 1 << i)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 68, "slug": "text-justification", "solutions": ["class Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        ans = []\n        i, n = 0, len(words)\n        while i < n:\n            t = []\n            cnt = len(words[i])\n            t.append(words[i])\n            i += 1\n            while i < n and cnt + 1 + len(words[i]) <= maxWidth:\n                cnt += 1 + len(words[i])\n                t.append(words[i])\n                i += 1\n            if i == n or len(t) == 1:\n                left = ' '.join(t)\n                right = ' ' * (maxWidth - len(left))\n                ans.append(left + right)\n                continue\n            space_width = maxWidth - (cnt - len(t) + 1)\n            w, m = divmod(space_width, len(t) - 1)\n            row = []\n            for j, s in enumerate(t[:-1]):\n                row.append(s)\n                row.append(' ' * (w + (1 if j < m else 0)))\n            row.append(t[-1])\n            ans.append(''.join(row))\n        return ans\n", "class Solution:\n  def fullJustify(self, words: list[str], maxWidth: int) -> list[str]:\n    ans = []\n    row = []\n    rowLetters = 0\n\n    for word in words:\n      # If we place the word in this row, it will exceed the maximum width.\n      # Therefore, we cannot put the word in this row and have to pad spaces\n      # for each word in this row.\n      if rowLetters + len(word) + len(row) > maxWidth:\n        for i in range(maxWidth - rowLetters):\n          row[i % (len(row) - 1 or 1)] += ' '\n        ans.append(''.join(row))\n        row = []\n        rowLetters = 0\n      row.append(word)\n      rowLetters += len(word)\n\n    return ans + [' '.join(row).ljust(maxWidth)]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 87, "slug": "scramble-string", "solutions": ["class Solution:\n    def isScramble(self, s1: str, s2: str) -> bool:\n        @cache\n        def dfs(i: int, j: int, k: int) -> bool:\n            if k == 1:\n                return s1[i] == s2[j]\n            for h in range(1, k):\n                if dfs(i, j, h) and dfs(i + h, j + h, k - h):\n                    return True\n                if dfs(i + h, j, k - h) and dfs(i, j + k - h, h):\n                    return True\n            return False\n\n        return dfs(0, 0, len(s1))\n", "class Solution:\n  @functools.lru_cache(None)\n  def isScramble(self, s1: str, s2: str) -> bool:\n    if s1 == s2:\n      return True\n    if collections.Counter(s1) != collections.Counter(s2):\n      return False\n\n    for i in range(1, len(s1)):\n      if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n        return True\n      if (self.isScramble(s1[:i], s2[len(s2) - i:]) and\n              self.isScramble(s1[i:], s2[: len(s2) - i])):\n        return True\n\n    return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 9, "slug": "palindrome-number", "solutions": ["class Solution:\n    def isPalindrome(self, x: int) -> bool:\n        if x < 0 or (x and x % 10 == 0):\n            return False\n        y = 0\n        while y < x:\n            y = y * 10 + x % 10\n            x //= 10\n        return x in (y, y // 10)\n", "class Solution:\n  def isPalindrome(self, x: int) -> bool:\n    if x < 0:\n      return False\n\n    rev = 0\n    y = x\n\n    while y:\n      rev = rev * 10 + y % 10\n      y //= 10\n\n    return rev == x\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 86, "slug": "partition-list", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\n        l = ListNode()\n        r = ListNode()\n        tl, tr = l, r\n        while head:\n            if head.val < x:\n                tl.next = head\n                tl = tl.next\n            else:\n                tr.next = head\n                tr = tr.next\n            head = head.next\n        tr.next = None\n        tl.next = r.next\n        return l.next\n", "class Solution:\n  def partition(self, head: ListNode, x: int) -> ListNode:\n    beforeHead = ListNode(0)\n    afterHead = ListNode(0)\n    before = beforeHead\n    after = afterHead\n\n    while head:\n      if head.val < x:\n        before.next = head\n        before = head\n      else:\n        after.next = head\n        after = head\n      head = head.next\n\n    after.next = None\n    before.next = afterHead.next\n\n    return beforeHead.next\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 80, "slug": "remove-duplicates-from-sorted-array-ii", "solutions": ["class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        k = 0\n        for x in nums:\n            if k < 2 or x != nums[k - 2]:\n                nums[k] = x\n                k += 1\n        return k\n", "class Solution:\n  def removeDuplicates(self, nums: list[int]) -> int:\n    i = 0\n\n    for num in nums:\n      if i < 2 or num != nums[i - 2]:\n        nums[i] = num\n        i += 1\n\n    return i\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2, "slug": "add-two-numbers", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def addTwoNumbers(\n        self, l1: Optional[ListNode], l2: Optional[ListNode]\n    ) -> Optional[ListNode]:\n        dummy = ListNode()\n        carry, curr = 0, dummy\n        while l1 or l2 or carry:\n            s = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry\n            carry, val = divmod(s, 10)\n            curr.next = ListNode(val)\n            curr = curr.next\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n        return dummy.next\n", "class Solution:\n  def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n    dummy = ListNode(0)\n    curr = dummy\n    carry = 0\n\n    while carry or l1 or l2:\n      if l1:\n        carry += l1.val\n        l1 = l1.next\n      if l2:\n        carry += l2.val\n        l2 = l2.next\n      curr.next = ListNode(carry % 10)\n      carry //= 10\n      curr = curr.next\n\n    return dummy.next\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 84, "slug": "largest-rectangle-in-histogram", "solutions": ["class Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        n = len(heights)\n        stk = []\n        left = [-1] * n\n        right = [n] * n\n        for i, h in enumerate(heights):\n            while stk and heights[stk[-1]] >= h:\n                right[stk[-1]] = i\n                stk.pop()\n            if stk:\n                left[i] = stk[-1]\n            stk.append(i)\n        return max(h * (right[i] - left[i] - 1) for i, h in enumerate(heights))\n", "class Solution:\n  def largestRectangleArea(self, heights: list[int]) -> int:\n    ans = 0\n    stack = []\n\n    for i in range(len(heights) + 1):\n      while stack and (i == len(heights) or heights[stack[-1]] > heights[i]):\n        h = heights[stack.pop()]\n        w = i - stack[-1] - 1 if stack else i\n        ans = max(ans, h * w)\n      stack.append(i)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 72, "slug": "edit-distance", "solutions": ["class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        m, n = len(word1), len(word2)\n        f = [[0] * (n + 1) for _ in range(m + 1)]\n        for j in range(1, n + 1):\n            f[0][j] = j\n        for i, a in enumerate(word1, 1):\n            f[i][0] = i\n            for j, b in enumerate(word2, 1):\n                if a == b:\n                    f[i][j] = f[i - 1][j - 1]\n                else:\n                    f[i][j] = min(f[i - 1][j], f[i][j - 1], f[i - 1][j - 1]) + 1\n        return f[m][n]\n", "class Solution:\n  def minDistance(self, word1: str, word2: str) -> int:\n    m = len(word1)\n    n = len(word2)\n    # dp[i][j] := the minimum number of operations to convert word1[0..i) to\n    # word2[0..j)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n      dp[i][0] = i\n\n    for j in range(1, n + 1):\n      dp[0][j] = j\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        if word1[i - 1] == word2[j - 1]:\n          dp[i][j] = dp[i - 1][j - 1]\n        else:\n          dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1\n\n    return dp[m][n]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 42, "slug": "trapping-rain-water", "solutions": ["class Solution:\n    def trap(self, height: List[int]) -> int:\n        n = len(height)\n        left = [height[0]] * n\n        right = [height[-1]] * n\n        for i in range(1, n):\n            left[i] = max(left[i - 1], height[i])\n            right[n - i - 1] = max(right[n - i], height[n - i - 1])\n        return sum(min(l, r) - h for l, r, h in zip(left, right, height))\n", "class Solution:\n  def trap(self, height: list[int]) -> int:\n    if not height:\n      return 0\n\n    ans = 0\n    l = 0\n    r = len(height) - 1\n    maxL = height[l]\n    maxR = height[r]\n\n    while l < r:\n      if maxL < maxR:\n        ans += maxL - height[l]\n        l += 1\n        maxL = max(maxL, height[l])\n      else:\n        ans += maxR - height[r]\n        r -= 1\n        maxR = max(maxR, height[r])\n\n    return ans\n", "class Solution:\n  def trap(self, height: list[int]) -> int:\n    n = len(height)\n    l = [0] * n  # l[i] := max(height[0..i])\n    r = [0] * n  # r[i] := max(height[i..n))\n\n    for i, h in enumerate(height):\n      l[i] = h if i == 0 else max(h, l[i - 1])\n\n    for i, h in reversed(list(enumerate(height))):\n      r[i] = h if i == n - 1 else max(h, r[i + 1])\n\n    return sum(min(l[i], r[i]) - h\n               for i, h in enumerate(height))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 61, "slug": "rotate-list", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if head is None or head.next is None:\n            return head\n        cur, n = head, 0\n        while cur:\n            n += 1\n            cur = cur.next\n        k %= n\n        if k == 0:\n            return head\n        fast = slow = head\n        for _ in range(k):\n            fast = fast.next\n        while fast.next:\n            fast, slow = fast.next, slow.next\n\n        ans = slow.next\n        slow.next = None\n        fast.next = head\n        return ans\n", "class Solution:\n  def rotateRight(self, head: ListNode, k: int) -> ListNode:\n    if not head or not head.next or k == 0:\n      return head\n\n    tail = head\n    length = 1\n    while tail.next:\n      tail = tail.next\n      length += 1\n    tail.next = head  # Circle the list.\n\n    t = length - k % length\n    for _ in range(t):\n      tail = tail.next\n    newHead = tail.next\n    tail.next = None\n\n    return newHead\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 77, "slug": "combinations", "solutions": ["class Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        def dfs(i: int):\n            if len(t) == k:\n                ans.append(t[:])\n                return\n            if i > n:\n                return\n            t.append(i)\n            dfs(i + 1)\n            t.pop()\n            dfs(i + 1)\n\n        ans = []\n        t = []\n        dfs(1)\n        return ans\n", "class Solution:\n  def combine(self, n: int, k: int) -> list[list[int]]:\n    ans = []\n\n    def dfs(s: int, path: list[int]) -> None:\n      if len(path) == k:\n        ans.append(path.copy())\n        return\n\n      for i in range(s, n + 1):\n        path.append(i)\n        dfs(i + 1, path)\n        path.pop()\n\n    dfs(1, [])\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 99, "slug": "recover-binary-search-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def recoverTree(self, root: Optional[TreeNode]) -> None:\n        \"\"\"\n        Do not return anything, modify root in-place instead.\n        \"\"\"\n\n        def dfs(root):\n            if root is None:\n                return\n            nonlocal prev, first, second\n            dfs(root.left)\n            if prev and prev.val > root.val:\n                if first is None:\n                    first = prev\n                second = root\n            prev = root\n            dfs(root.right)\n\n        prev = first = second = None\n        dfs(root)\n        first.val, second.val = second.val, first.val\n", "class Solution:\n  def recoverTree(self, root: TreeNode | None) -> None:\n    def swap(x: TreeNode | None, y: TreeNode | None) -> None:\n      temp = x.val\n      x.val = y.val\n      y.val = temp\n\n    def inorder(root: TreeNode | None) -> None:\n      if not root:\n        return\n\n      inorder(root.left)\n\n      if self.pred and root.val < self.pred.val:\n        self.y = root\n        if not self.x:\n          self.x = self.pred\n        else:\n          return\n      self.pred = root\n\n      inorder(root.right)\n\n    inorder(root)\n    swap(self.x, self.y)\n\n  pred = None\n  x = None  # the first wrong node\n  y = None  # the second wrong node\n", "class Solution:\n  def recoverTree(self, root: TreeNode | None) -> None:\n    pred = None\n    x = None  # the first wrong node\n    y = None  # the second wrong node\n\n    def findPredecessor(root: TreeNode | None) -> TreeNode | None:\n      pred = root.left\n      while pred.right and pred.right != root:\n        pred = pred.right\n      return pred\n\n    while root:\n      if root.left:\n        morrisPred = findPredecessor(root)\n        if morrisPred.right:\n          # The node has already been connected before.\n          # Start the main logic.\n          if pred and root.val < pred.val:\n            y = root\n            if not x:\n              x = pred\n          pred = root\n          # End of the main logic\n          morrisPred.right = None  # Break the connection.\n          root = root.right\n        else:\n          morrisPred.right = root  # Connect it.\n          root = root.left\n      else:\n        # Start the main logic.\n        if pred and root.val < pred.val:\n          y = root\n          if not x:\n            x = pred\n        pred = root\n        # End of the main logic.\n        root = root.right\n\n    def swap(x: TreeNode | None, y: TreeNode | None) -> None:\n      temp = x.val\n      x.val = y.val\n      y.val = temp\n\n    swap(x, y)\n", "class Solution:\n  def recoverTree(self, root: TreeNode | None) -> None:\n    pred = None\n    x = None  # the first wrong node\n    y = None  # the second wrong node\n    stack = []\n\n    while root or stack:\n      while root:\n        stack.append(root)\n        root = root.left\n      root = stack.pop()\n      if pred and root.val < pred.val:\n        y = root\n        if not x:\n          x = pred\n      pred = root\n      root = root.right\n\n    def swap(x: TreeNode | None, y: TreeNode | None) -> None:\n      temp = x.val\n      x.val = y.val\n      y.val = temp\n\n    swap(x, y)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 39, "slug": "combination-sum", "solutions": ["class Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        def dfs(i: int, s: int):\n            if s == 0:\n                ans.append(t[:])\n                return\n            if s < candidates[i]:\n                return\n            for j in range(i, len(candidates)):\n                t.append(candidates[j])\n                dfs(j, s - candidates[j])\n                t.pop()\n\n        candidates.sort()\n        t = []\n        ans = []\n        dfs(0, target)\n        return ans\n", "class Solution:\n  def combinationSum(self, candidates: list[int],\n                     target: int) -> list[list[int]]:\n    ans = []\n\n    def dfs(s: int, target: int, path: list[int]) -> None:\n      if target < 0:\n        return\n      if target == 0:\n        ans.append(path.clone())\n        return\n\n      for i in range(s, len(candidates)):\n        path.append(candidates[i])\n        dfs(i, target - candidates[i], path)\n        path.pop()\n\n    candidates.sort()\n    dfs(0, target, [])\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 15, "slug": "3sum", "solutions": ["class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        nums.sort()\n        n = len(nums)\n        ans = []\n        for i in range(n - 2):\n            if nums[i] > 0:\n                break\n            if i and nums[i] == nums[i - 1]:\n                continue\n            j, k = i + 1, n - 1\n            while j < k:\n                x = nums[i] + nums[j] + nums[k]\n                if x < 0:\n                    j += 1\n                elif x > 0:\n                    k -= 1\n                else:\n                    ans.append([nums[i], nums[j], nums[k]])\n                    j, k = j + 1, k - 1\n                    while j < k and nums[j] == nums[j - 1]:\n                        j += 1\n                    while j < k and nums[k] == nums[k + 1]:\n                        k -= 1\n        return ans\n", "class Solution:\n  def threeSum(self, nums: list[int]) -> list[list[int]]:\n    if len(nums) < 3:\n      return []\n\n    ans = []\n\n    nums.sort()\n\n    for i in range(len(nums) - 2):\n      if i > 0 and nums[i] == nums[i - 1]:\n        continue\n      # Choose nums[i] as the first number in the triplet, then search the\n      # remaining numbers in [i + 1, n - 1].\n      l = i + 1\n      r = len(nums) - 1\n      while l < r:\n        summ = nums[i] + nums[l] + nums[r]\n        if summ == 0:\n          ans.append((nums[i], nums[l], nums[r]))\n          l += 1\n          r -= 1\n          while nums[l] == nums[l - 1] and l < r:\n            l += 1\n          while nums[r] == nums[r + 1] and l < r:\n            r -= 1\n        elif summ < 0:\n          l += 1\n        else:\n          r -= 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 95, "slug": "unique-binary-search-trees-ii", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:\n        def dfs(i: int, j: int) -> List[Optional[TreeNode]]:\n            if i > j:\n                return [None]\n            ans = []\n            for v in range(i, j + 1):\n                left = dfs(i, v - 1)\n                right = dfs(v + 1, j)\n                for l in left:\n                    for r in right:\n                        ans.append(TreeNode(v, l, r))\n            return ans\n\n        return dfs(1, n)\n", "class Solution:\n  def generateTrees(self, n: int) -> list[TreeNode]:\n    if n == 0:\n      return []\n\n    def generateTrees(mn: int, mx: int) -> list[int | None]:\n      if mn > mx:\n        return [None]\n\n      ans = []\n\n      for i in range(mn, mx + 1):\n        for left in generateTrees(mn, i - 1):\n          for right in generateTrees(i + 1, mx):\n            ans.append(TreeNode(i))\n            ans[-1].left = left\n            ans[-1].right = right\n\n      return ans\n\n    return generateTrees(1, n)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 79, "slug": "word-search", "solutions": ["class Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        def dfs(i: int, j: int, k: int) -> bool:\n            if k == len(word) - 1:\n                return board[i][j] == word[k]\n            if board[i][j] != word[k]:\n                return False\n            c = board[i][j]\n            board[i][j] = \"0\"\n            for a, b in pairwise((-1, 0, 1, 0, -1)):\n                x, y = i + a, j + b\n                ok = 0 <= x < m and 0 <= y < n and board[x][y] != \"0\"\n                if ok and dfs(x, y, k + 1):\n                    return True\n            board[i][j] = c\n            return False\n\n        m, n = len(board), len(board[0])\n        return any(dfs(i, j, 0) for i in range(m) for j in range(n))\n", "class Solution:\n  def exist(self, board: list[list[str]], word: str) -> bool:\n    m = len(board)\n    n = len(board[0])\n\n    def dfs(i: int, j: int, s: int) -> bool:\n      if i < 0 or i == m or j < 0 or j == n:\n        return False\n      if board[i][j] != word[s] or board[i][j] == '*':\n        return False\n      if s == len(word) - 1:\n        return True\n\n      cache = board[i][j]\n      board[i][j] = '*'\n      isExist = (dfs(i + 1, j, s + 1) or\n                 dfs(i - 1, j, s + 1) or\n                 dfs(i, j + 1, s + 1) or\n                 dfs(i, j - 1, s + 1))\n      board[i][j] = cache\n\n      return isExist\n\n    return any(dfs(i, j, 0)\n               for i in range(m)\n               for j in range(n))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 31, "slug": "next-permutation", "solutions": ["class Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        n = len(nums)\n        i = next((i for i in range(n - 2, -1, -1) if nums[i] < nums[i + 1]), -1)\n        if ~i:\n            j = next((j for j in range(n - 1, i, -1) if nums[j] > nums[i]))\n            nums[i], nums[j] = nums[j], nums[i]\n        nums[i + 1 :] = nums[i + 1 :][::-1]\n", "class Solution:\n  def nextPermutation(self, nums: list[int]) -> None:\n    n = len(nums)\n\n    # From back to front, find the first number < nums[i + 1].\n    i = n - 2\n    while i >= 0:\n      if nums[i] < nums[i + 1]:\n        break\n      i -= 1\n\n    # From back to front, find the first number > nums[i], swap it with nums[i].\n    if i >= 0:\n      for j in range(n - 1, i, -1):\n        if nums[j] > nums[i]:\n          nums[i], nums[j] = nums[j], nums[i]\n          break\n\n    def reverse(nums: list[int], l: int, r: int) -> None:\n      while l < r:\n        nums[l], nums[r] = nums[r], nums[l]\n        l += 1\n        r -= 1\n\n    # Reverse nums[i + 1..n - 1].\n    reverse(nums, i + 1, len(nums) - 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 74, "slug": "search-a-2d-matrix", "solutions": ["class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        m, n = len(matrix), len(matrix[0])\n        left, right = 0, m * n - 1\n        while left < right:\n            mid = (left + right) >> 1\n            x, y = divmod(mid, n)\n            if matrix[x][y] >= target:\n                right = mid\n            else:\n                left = mid + 1\n        return matrix[left // n][left % n] == target\n", "class Solution:\n  def searchMatrix(self, matrix: list[list[int]], target: int) -> bool:\n    if not matrix:\n      return False\n\n    m = len(matrix)\n    n = len(matrix[0])\n    l = 0\n    r = m * n\n\n    while l < r:\n      mid = (l + r) // 2\n      i = mid // n\n      j = mid % n\n      if matrix[i][j] == target:\n        return True\n      if matrix[i][j] < target:\n        l = mid + 1\n      else:\n        r = mid\n\n    return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 83, "slug": "remove-duplicates-from-sorted-list", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        cur = head\n        while cur and cur.next:\n            if cur.val == cur.next.val:\n                cur.next = cur.next.next\n            else:\n                cur = cur.next\n        return head\n", "class Solution:\n  def deleteDuplicates(self, head: ListNode) -> ListNode:\n    curr = head\n\n    while curr:\n      while curr.next and curr.val == curr.next.val:\n        curr.next = curr.next.next\n      curr = curr.next\n\n    return head\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 32, "slug": "longest-valid-parentheses", "solutions": ["class Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        n = len(s)\n        f = [0] * (n + 1)\n        for i, c in enumerate(s, 1):\n            if c == \")\":\n                if i > 1 and s[i - 2] == \"(\":\n                    f[i] = f[i - 2] + 2\n                else:\n                    j = i - f[i - 1] - 1\n                    if j and s[j - 1] == \"(\":\n                        f[i] = f[i - 1] + 2 + f[j - 1]\n        return max(f)\n", "class Solution:\n  def longestValidParentheses(self, s: str) -> int:\n    s2 = ')' + s\n    # dp[i] := the length of the longest valid parentheses in the substring\n    # s2[1..i]\n    dp = [0] * len(s2)\n\n    for i in range(1, len(s2)):\n      if s2[i] == ')' and s2[i - dp[i - 1] - 1] == '(':\n        dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2\n\n    return max(dp)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 69, "slug": "sqrtx", "solutions": ["class Solution:\n    def mySqrt(self, x: int) -> int:\n        l, r = 0, x\n        while l < r:\n            mid = (l + r + 1) >> 1\n            if mid > x // mid:\n                r = mid - 1\n            else:\n                l = mid\n        return l\n", "class Solution:\n  def mySqrt(self, x: int) -> int:\n    return bisect.bisect_right(range(x + 1), x,\n                               key=lambda m: m * m) - 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 57, "slug": "insert-interval", "solutions": ["class Solution:\n    def insert(\n        self, intervals: List[List[int]], newInterval: List[int]\n    ) -> List[List[int]]:\n        def merge(intervals: List[List[int]]) -> List[List[int]]:\n            intervals.sort()\n            ans = [intervals[0]]\n            for s, e in intervals[1:]:\n                if ans[-1][1] < s:\n                    ans.append([s, e])\n                else:\n                    ans[-1][1] = max(ans[-1][1], e)\n            return ans\n\n        intervals.append(newInterval)\n        return merge(intervals)\n", "class Solution:\n  def insert(self, intervals: list[list[int]],\n             newInterval: list[int]) -> list[list[int]]:\n    n = len(intervals)\n    ans = []\n    i = 0\n\n    while i < n and intervals[i][1] < newInterval[0]:\n      ans.append(intervals[i])\n      i += 1\n\n    # Merge overlapping intervals.\n    while i < n and intervals[i][0] <= newInterval[1]:\n      newInterval[0] = min(newInterval[0], intervals[i][0])\n      newInterval[1] = max(newInterval[1], intervals[i][1])\n      i += 1\n\n    ans.append(newInterval)\n\n    while i < n:\n      ans.append(intervals[i])\n      i += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 96, "slug": "unique-binary-search-trees", "solutions": ["class Solution:\n    def numTrees(self, n: int) -> int:\n        f = [1] + [0] * n\n        for i in range(n + 1):\n            for j in range(i):\n                f[i] += f[j] * f[i - j - 1]\n        return f[n]\n", "class Solution:\n  def numTrees(self, n: int) -> int:\n    # dp[i] := the number of unique BST's that store values 1..i\n    dp = [1, 1] + [0] * (n - 1)\n\n    for i in range(2, n + 1):\n      for j in range(i):\n        dp[i] += dp[j] * dp[i - j - 1]\n\n    return dp[n]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 29, "slug": "divide-two-integers", "solutions": ["class Solution:\n    def divide(self, a: int, b: int) -> int:\n        if b == 1:\n            return a\n        if a == -(2**31) and b == -1:\n            return 2**31 - 1\n        sign = (a > 0 and b > 0) or (a < 0 and b < 0)\n        a = -a if a > 0 else a\n        b = -b if b > 0 else b\n        ans = 0\n        while a <= b:\n            x = b\n            cnt = 1\n            while x >= (-(2**30)) and a <= (x << 1):\n                x <<= 1\n                cnt <<= 1\n            a -= x\n            ans += cnt\n        return ans if sign else -ans\n", "class Solution:\n  def divide(self, dividend: int, divisor: int) -> int:\n    # -2^{31} / -1 = 2^31 will overflow, so return 2^31 - 1.\n    if dividend == -2**31 and divisor == -1:\n      return 2**31 - 1\n\n    sign = -1 if (dividend > 0) ^ (divisor > 0) else 1\n    ans = 0\n    dvd = abs(dividend)\n    dvs = abs(divisor)\n\n    while dvd >= dvs:\n      k = 1\n      while k * 2 * dvs <= dvd:\n        k <<= 1\n      dvd -= k * dvs\n      ans += k\n\n    return sign * ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 71, "slug": "simplify-path", "solutions": ["class Solution:\n    def simplifyPath(self, path: str) -> str:\n        stk = []\n        for s in path.split('/'):\n            if not s or s == '.':\n                continue\n            if s == '..':\n                if stk:\n                    stk.pop()\n            else:\n                stk.append(s)\n        return '/' + '/'.join(stk)\n", "class Solution:\n  def simplifyPath(self, path: str) -> str:\n    stack = []\n\n    for str in path.split('/'):\n      if str in ('', '.'):\n        continue\n      if str == '..':\n        if stack:\n          stack.pop()\n      else:\n        stack.append(str)\n\n    return '/' + '/'.join(stack)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 14, "slug": "longest-common-prefix", "solutions": ["class Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        for i in range(len(strs[0])):\n            for s in strs[1:]:\n                if len(s) <= i or s[i] != strs[0][i]:\n                    return s[:i]\n        return strs[0]\n", "class Solution:\n  def longestCommonPrefix(self, strs: list[str]) -> str:\n    if not strs:\n      return ''\n\n    for i in range(len(strs[0])):\n      for j in range(1, len(strs)):\n        if i == len(strs[j]) or strs[j][i] != strs[0][i]:\n          return strs[0][:i]\n\n    return strs[0]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 76, "slug": "minimum-window-substring", "solutions": ["class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        need = Counter(t)\n        window = Counter()\n        cnt = l = 0\n        k, mi = -1, inf\n        for r, c in enumerate(s):\n            window[c] += 1\n            if need[c] >= window[c]:\n                cnt += 1\n            while cnt == len(t):\n                if r - l + 1 < mi:\n                    mi = r - l + 1\n                    k = l\n                if need[s[l]] >= window[s[l]]:\n                    cnt -= 1\n                window[s[l]] -= 1\n                l += 1\n        return \"\" if k < 0 else s[k : k + mi]\n", "class Solution:\n  def minWindow(self, s: str, t: str) -> str:\n    count = collections.Counter(t)\n    required = len(t)\n    bestLeft = -1\n    minLength = len(s) + 1\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] -= 1\n      if count[c] >= 0:\n        required -= 1\n      while required == 0:\n        if r - l + 1 < minLength:\n          bestLeft = l\n          minLength = r - l + 1\n        count[s[l]] += 1\n        if count[s[l]] > 0:\n          required += 1\n        l += 1\n\n    return '' if bestLeft == -1 else s[bestLeft: bestLeft + minLength]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 65, "slug": "valid-number", "solutions": ["class Solution:\n    def isNumber(self, s: str) -> bool:\n        n = len(s)\n        i = 0\n        if s[i] in '+-':\n            i += 1\n        if i == n:\n            return False\n        if s[i] == '.' and (i + 1 == n or s[i + 1] in 'eE'):\n            return False\n        dot = e = 0\n        j = i\n        while j < n:\n            if s[j] == '.':\n                if e or dot:\n                    return False\n                dot += 1\n            elif s[j] in 'eE':\n                if e or j == i or j == n - 1:\n                    return False\n                e += 1\n                if s[j + 1] in '+-':\n                    j += 1\n                    if j == n - 1:\n                        return False\n            elif not s[j].isnumeric():\n                return False\n            j += 1\n        return True\n", "class Solution:\n  def isNumber(self, s: str) -> bool:\n    s = s.strip()\n    if not s:\n      return False\n\n    seenNum = False\n    seenDot = False\n    seenE = False\n\n    for i, c in enumerate(s):\n      if c == '.':\n        if seenDot or seenE:\n          return False\n        seenDot = True\n      elif c == 'e' or c == 'E':\n        if seenE or not seenNum:\n          return False\n        seenE = True\n        seenNum = False\n      elif c in '+-':\n        if i > 0 and s[i - 1] not in 'eE':\n          return False\n        seenNum = False\n      else:\n        if not c.isdigit():\n          return False\n        seenNum = True\n\n    return seenNum\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 10, "slug": "regular-expression-matching", "solutions": ["class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        @cache\n        def dfs(i, j):\n            if j >= n:\n                return i == m\n            if j + 1 < n and p[j + 1] == '*':\n                return dfs(i, j + 2) or (\n                    i < m and (s[i] == p[j] or p[j] == '.') and dfs(i + 1, j)\n                )\n            return i < m and (s[i] == p[j] or p[j] == '.') and dfs(i + 1, j + 1)\n\n        m, n = len(s), len(p)\n        return dfs(0, 0)\n", "class Solution:\n  def isMatch(self, s: str, p: str) -> bool:\n    m = len(s)\n    n = len(p)\n    # dp[i][j] := True if s[0..i) matches p[0..j)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    def isMatch(i: int, j: int) -> bool:\n      return j >= 0 and p[j] == '.' or s[i] == p[j]\n\n    for j, c in enumerate(p):\n      if c == '*' and dp[0][j - 1]:\n        dp[0][j + 1] = True\n\n    for i in range(m):\n      for j in range(n):\n        if p[j] == '*':\n          # The minimum index of '*' is 1.\n          noRepeat = dp[i + 1][j - 1]\n          doRepeat = isMatch(i, j - 1) and dp[i][j + 1]\n          dp[i + 1][j + 1] = noRepeat or doRepeat\n        elif isMatch(i, j):\n          dp[i + 1][j + 1] = dp[i][j]\n\n    return dp[m][n]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 93, "slug": "restore-ip-addresses", "solutions": ["class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        def check(i: int, j: int) -> int:\n            if s[i] == \"0\" and i != j:\n                return False\n            return 0 <= int(s[i : j + 1]) <= 255\n\n        def dfs(i: int):\n            if i >= n and len(t) == 4:\n                ans.append(\".\".join(t))\n                return\n            if i >= n or len(t) >= 4:\n                return\n            for j in range(i, min(i + 3, n)):\n                if check(i, j):\n                    t.append(s[i : j + 1])\n                    dfs(j + 1)\n                    t.pop()\n\n        n = len(s)\n        ans = []\n        t = []\n        dfs(0)\n        return ans\n", "class Solution:\n  def restoreIpAddresses(self, s: str) -> list[str]:\n    ans = []\n\n    def dfs(start: int, path: list[int]) -> None:\n      if len(path) == 4 and start == len(s):\n        ans.append(path[0] + '.' + path[1] + '.' + path[2] + '.' + path[3])\n        return\n      if len(path) == 4 or start == len(s):\n        return\n\n      for length in range(1, 4):\n        if start + length > len(s):\n          return  # out-of-bounds\n        if length > 1 and s[start] == '0':\n          return  # leading '0'\n        num = s[start: start + length]\n        if int(num) > 255:\n          return\n        dfs(start + length, path + [num])\n\n    dfs(0, [])\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 26, "slug": "remove-duplicates-from-sorted-array", "solutions": ["class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        k = 0\n        for x in nums:\n            if k == 0 or x != nums[k - 1]:\n                nums[k] = x\n                k += 1\n        return k\n", "class Solution:\n  def removeDuplicates(self, nums: list[int]) -> int:\n    i = 0\n\n    for num in nums:\n      if i < 1 or num > nums[i - 1]:\n        nums[i] = num\n        i += 1\n\n    return i\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 60, "slug": "permutation-sequence", "solutions": ["class Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        ans = []\n        vis = [False] * (n + 1)\n        for i in range(n):\n            fact = 1\n            for j in range(1, n - i):\n                fact *= j\n            for j in range(1, n + 1):\n                if not vis[j]:\n                    if k > fact:\n                        k -= fact\n                    else:\n                        ans.append(str(j))\n                        vis[j] = True\n                        break\n        return ''.join(ans)\n", "class Solution:\n  def getPermutation(self, n: int, k: int) -> str:\n    ans = ''\n    nums = [i + 1 for i in range(n)]\n    fact = [1] * (n + 1)  # fact[i] := i!\n\n    for i in range(2, n + 1):\n      fact[i] = fact[i - 1] * i\n\n    k -= 1  # 0-indexed\n\n    for i in reversed(range(n)):\n      j = k // fact[i]\n      k %= fact[i]\n      ans += str(nums[j])\n      nums.pop(j)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 82, "slug": "remove-duplicates-from-sorted-list-ii", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = pre = ListNode(next=head)\n        cur = head\n        while cur:\n            while cur.next and cur.next.val == cur.val:\n                cur = cur.next\n            if pre.next == cur:\n                pre = cur\n            else:\n                pre.next = cur.next\n            cur = cur.next\n        return dummy.next\n", "class Solution:\n  def deleteDuplicates(self, head: ListNode) -> ListNode:\n    dummy = ListNode(0, head)\n    prev = dummy\n\n    while head:\n      while head.next and head.val == head.next.val:\n        head = head.next\n      if prev.next == head:\n        prev = prev.next\n      else:\n        prev.next = head.next\n      head = head.next\n\n    return dummy.next\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 35, "slug": "search-insert-position", "solutions": ["class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums)\n        while l < r:\n            mid = (l + r) >> 1\n            if nums[mid] >= target:\n                r = mid\n            else:\n                l = mid + 1\n        return l\n", "class Solution:\n  def searchInsert(self, nums: list[int], target: int) -> int:\n    l = 0\n    r = len(nums)\n\n    while l < r:\n      m = (l + r) // 2\n      if nums[m] == target:\n        return m\n      if nums[m] < target:\n        l = m + 1\n      else:\n        r = m\n\n    return l\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 43, "slug": "multiply-strings", "solutions": ["class Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        m, n = len(num1), len(num2)\n        arr = [0] * (m + n)\n        for i in range(m - 1, -1, -1):\n            a = int(num1[i])\n            for j in range(n - 1, -1, -1):\n                b = int(num2[j])\n                arr[i + j + 1] += a * b\n        for i in range(m + n - 1, 0, -1):\n            arr[i - 1] += arr[i] // 10\n            arr[i] %= 10\n        i = 0 if arr[0] else 1\n        return \"\".join(str(x) for x in arr[i:])\n", "class Solution:\n  def multiply(self, num1: str, num2: str) -> str:\n    s = [0] * (len(num1) + len(num2))\n\n    for i in reversed(range(len(num1))):\n      for j in reversed(range(len(num2))):\n        mult = int(num1[i]) * int(num2[j])\n        summ = mult + s[i + j + 1]\n        s[i + j] += summ // 10\n        s[i + j + 1] = summ % 10\n\n    for i, c in enumerate(s):\n      if c != 0:\n        break\n\n    return ''.join(map(str, s[i:]))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 17, "slug": "letter-combinations-of-a-phone-number", "solutions": ["class Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        if not digits:\n            return []\n        d = [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"]\n        ans = [\"\"]\n        for i in digits:\n            s = d[int(i) - 2]\n            ans = [a + b for a in ans for b in s]\n        return ans\n", "class Solution:\n  def letterCombinations(self, digits: str) -> list[str]:\n    if not digits:\n      return []\n\n    digitToLetters = ['', '', 'abc', 'def', 'ghi',\n                      'jkl', 'mno', 'pqrs', 'tuv', 'wxyz']\n    ans = []\n\n    def dfs(i: int, path: list[str]) -> None:\n      if i == len(digits):\n        ans.append(''.join(path))\n        return\n\n      for letter in digitToLetters[int(digits[i])]:\n        path.append(letter)\n        dfs(i + 1, path)\n        path.pop()\n\n    dfs(0, [])\n    return ans\n", "class Solution:\n  def letterCombinations(self, digits: str) -> list[str]:\n    if not digits:\n      return []\n\n    ans = ['']\n    digitToLetters = ['', '', 'abc', 'def', 'ghi',\n                      'jkl', 'mno', 'pqrs', 'tuv', 'wxyz']\n\n    for d in digits:\n      temp = []\n      for s in ans:\n        for c in digitToLetters[int(d)]:\n          temp.append(s + c)\n      ans = temp\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 44, "slug": "wildcard-matching", "solutions": ["class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        @cache\n        def dfs(i: int, j: int) -> bool:\n            if i >= len(s):\n                return j >= len(p) or (p[j] == \"*\" and dfs(i, j + 1))\n            if j >= len(p):\n                return False\n            if p[j] == \"*\":\n                return dfs(i + 1, j) or dfs(i + 1, j + 1) or dfs(i, j + 1)\n            return (p[j] == \"?\" or s[i] == p[j]) and dfs(i + 1, j + 1)\n\n        return dfs(0, 0)\n", "class Solution:\n  def isMatch(self, s: str, p: str) -> bool:\n    m = len(s)\n    n = len(p)\n    # dp[i][j] := True if s[0..i) matches p[0..j)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    def isMatch(i: int, j: int) -> bool:\n      return i >= 0 and p[j] == '?' or s[i] == p[j]\n\n    for j, c in enumerate(p):\n      if c == '*':\n        dp[0][j + 1] = dp[0][j]\n\n    for i in range(m):\n      for j in range(n):\n        if p[j] == '*':\n          matchEmpty = dp[i + 1][j]\n          matchSome = dp[i][j + 1]\n          dp[i + 1][j + 1] = matchEmpty or matchSome\n        elif isMatch(i, j):\n          dp[i + 1][j + 1] = dp[i][j]\n\n    return dp[m][n]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 51, "slug": "n-queens", "solutions": ["class Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        def dfs(i: int):\n            if i == n:\n                ans.append([\"\".join(row) for row in g])\n                return\n            for j in range(n):\n                if col[j] + dg[i + j] + udg[n - i + j] == 0:\n                    g[i][j] = \"Q\"\n                    col[j] = dg[i + j] = udg[n - i + j] = 1\n                    dfs(i + 1)\n                    col[j] = dg[i + j] = udg[n - i + j] = 0\n                    g[i][j] = \".\"\n\n        ans = []\n        g = [[\".\"] * n for _ in range(n)]\n        col = [0] * n\n        dg = [0] * (n << 1)\n        udg = [0] * (n << 1)\n        dfs(0)\n        return ans\n", "class Solution:\n  def solveNQueens(self, n: int) -> list[list[str]]:\n    ans = []\n    cols = [False] * n\n    diag1 = [False] * (2 * n - 1)\n    diag2 = [False] * (2 * n - 1)\n\n    def dfs(i: int, board: list[int]) -> None:\n      if i == n:\n        ans.append(board)\n        return\n\n      for j in range(n):\n        if cols[j] or diag1[i + j] or diag2[j - i + n - 1]:\n          continue\n        cols[j] = diag1[i + j] = diag2[j - i + n - 1] = True\n        dfs(i + 1, board + ['.' * j + 'Q' + '.' * (n - j - 1)])\n        cols[j] = diag1[i + j] = diag2[j - i + n - 1] = False\n\n    dfs(0, [])\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 50, "slug": "powx-n", "solutions": ["class Solution:\n    def myPow(self, x: float, n: int) -> float:\n        def qpow(a: float, n: int) -> float:\n            ans = 1\n            while n:\n                if n & 1:\n                    ans *= a\n                a *= a\n                n >>= 1\n            return ans\n\n        return qpow(x, n) if n >= 0 else 1 / qpow(x, -n)\n", "class Solution:\n  def myPow(self, x: float, n: int) -> float:\n    if n == 0:\n      return 1\n    if n < 0:\n      return 1 / self.myPow(x, -n)\n    if n % 2 == 1:\n      return x * self.myPow(x, n - 1)\n    return self.myPow(x * x, n // 2)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 30, "slug": "substring-with-concatenation-of-all-words", "solutions": ["class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        cnt = Counter(words)\n        m, n = len(s), len(words)\n        k = len(words[0])\n        ans = []\n        for i in range(k):\n            l = r = i\n            cnt1 = Counter()\n            while r + k <= m:\n                t = s[r : r + k]\n                r += k\n                if cnt[t] == 0:\n                    l = r\n                    cnt1.clear()\n                    continue\n                cnt1[t] += 1\n                while cnt1[t] > cnt[t]:\n                    rem = s[l : l + k]\n                    l += k\n                    cnt1[rem] -= 1\n                if r - l == n * k:\n                    ans.append(l)\n        return ans\n", "class Solution:\n  def findSubstring(self, s: str, words: list[str]) -> list[int]:\n    if len(s) == 0 or words == []:\n      return []\n\n    k = len(words)\n    n = len(words[0])\n    ans = []\n    count = collections.Counter(words)\n\n    for i in range(len(s) - k * n + 1):\n      seen = collections.defaultdict(int)\n      j = 0\n      while j < k:\n        word = s[i + j * n: i + j * n + n]\n        seen[word] += 1\n        if seen[word] > count[word]:\n          break\n        j += 1\n      if j == k:\n        ans.append(i)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 59, "slug": "spiral-matrix-ii", "solutions": ["class Solution:\n    def generateMatrix(self, n: int) -> List[List[int]]:\n        ans = [[0] * n for _ in range(n)]\n        dirs = (0, 1, 0, -1, 0)\n        i = j = k = 0\n        for v in range(1, n * n + 1):\n            ans[i][j] = v\n            x, y = i + dirs[k], j + dirs[k + 1]\n            if x < 0 or x >= n or y < 0 or y >= n or ans[x][y]:\n                k = (k + 1) % 4\n            i, j = i + dirs[k], j + dirs[k + 1]\n        return ans\n", "class Solution:\n  def generateMatrix(self, n: int) -> list[list[int]]:\n    ans = [[0] * n for _ in range(n)]\n    count = 1\n\n    for mn in range(n // 2):\n      mx = n - mn - 1\n      for i in range(mn, mx):\n        ans[mn][i] = count\n        count += 1\n      for i in range(mn, mx):\n        ans[i][mx] = count\n        count += 1\n      for i in range(mx, mn, -1):\n        ans[mx][i] = count\n        count += 1\n      for i in range(mx, mn, -1):\n        ans[i][mn] = count\n        count += 1\n\n    if n % 2 == 1:\n      ans[n // 2][n // 2] = count\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 81, "slug": "search-in-rotated-sorted-array-ii", "solutions": ["class Solution:\n    def search(self, nums: List[int], target: int) -> bool:\n        n = len(nums)\n        l, r = 0, n - 1\n        while l < r:\n            mid = (l + r) >> 1\n            if nums[mid] > nums[r]:\n                if nums[l] <= target <= nums[mid]:\n                    r = mid\n                else:\n                    l = mid + 1\n            elif nums[mid] < nums[r]:\n                if nums[mid] < target <= nums[r]:\n                    l = mid + 1\n                else:\n                    r = mid\n            else:\n                r -= 1\n        return nums[l] == target\n", "class Solution:\n  def search(self, nums: list[int], target: int) -> bool:\n    l = 0\n    r = len(nums) - 1\n\n    while l <= r:\n      m = (l + r) // 2\n      if nums[m] == target:\n        return True\n      if nums[l] == nums[m] == nums[r]:\n        l += 1\n        r -= 1\n      elif nums[l] <= nums[m]:  # nums[l..m] are sorted\n        if nums[l] <= target < nums[m]:\n          r = m - 1\n        else:\n          l = m + 1\n      else:  # nums[m..n - 1] are sorted\n        if nums[m] < target <= nums[r]:\n          l = m + 1\n        else:\n          r = m - 1\n\n    return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 40, "slug": "combination-sum-ii", "solutions": ["class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        def dfs(i: int, s: int):\n            if s == 0:\n                ans.append(t[:])\n                return\n            if i >= len(candidates) or s < candidates[i]:\n                return\n            for j in range(i, len(candidates)):\n                if j > i and candidates[j] == candidates[j - 1]:\n                    continue\n                t.append(candidates[j])\n                dfs(j + 1, s - candidates[j])\n                t.pop()\n\n        candidates.sort()\n        ans = []\n        t = []\n        dfs(0, target)\n        return ans\n", "class Solution:\n  def combinationSum2(self, candidates: list[int],\n                      target: int) -> list[list[int]]:\n    ans = []\n\n    def dfs(s: int, target: int, path: list[int]) -> None:\n      if target < 0:\n        return\n      if target == 0:\n        ans.append(path.copy())\n        return\n\n      for i in range(s, len(candidates)):\n        if i > s and candidates[i] == candidates[i - 1]:\n          continue\n        path.append(candidates[i])\n        dfs(i + 1, target - candidates[i], path)\n        path.pop()\n\n    candidates.sort()\n    dfs(0, target, [])\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 62, "slug": "unique-paths", "solutions": ["class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        f = [[0] * n for _ in range(m)]\n        f[0][0] = 1\n        for i in range(m):\n            for j in range(n):\n                if i:\n                    f[i][j] += f[i - 1][j]\n                if j:\n                    f[i][j] += f[i][j - 1]\n        return f[-1][-1]\n", "class Solution:\n  def uniquePaths(self, m: int, n: int) -> int:\n    dp = [1] * n\n\n    for _ in range(1, m):\n      for j in range(1, n):\n        dp[j] += dp[j - 1]\n\n    return dp[n - 1]\n", "class Solution:\n  def uniquePaths(self, m: int, n: int) -> int:\n    # dp[i][j] := the number of unique paths from (0, 0) to (i, j)\n    dp = [[1] * n for _ in range(m)]\n\n    for i in range(1, m):\n      for j in range(1, n):\n        dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 36, "slug": "valid-sudoku", "solutions": ["class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        row = [[False] * 9 for _ in range(9)]\n        col = [[False] * 9 for _ in range(9)]\n        sub = [[False] * 9 for _ in range(9)]\n        for i in range(9):\n            for j in range(9):\n                c = board[i][j]\n                if c == '.':\n                    continue\n                num = int(c) - 1\n                k = i // 3 * 3 + j // 3\n                if row[i][num] or col[j][num] or sub[k][num]:\n                    return False\n                row[i][num] = True\n                col[j][num] = True\n                sub[k][num] = True\n        return True\n", "class Solution:\n  def isValidSudoku(self, board: list[list[str]]) -> bool:\n    seen = set()\n\n    for i in range(9):\n      for j in range(9):\n        c = board[i][j]\n        if c == '.':\n          continue\n        if (c + '@row ' + str(i) in seen or\n            c + '@col ' + str(j) in seen or\n                c + '@box ' + str(i // 3) + str(j // 3) in seen):\n          return False\n        seen.add(c + '@row ' + str(i))\n        seen.add(c + '@col ' + str(j))\n        seen.add(c + '@box ' + str(i // 3) + str(j // 3))\n\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 54, "slug": "spiral-matrix", "solutions": ["class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        m, n = len(matrix), len(matrix[0])\n        dirs = (0, 1, 0, -1, 0)\n        vis = [[False] * n for _ in range(m)]\n        i = j = k = 0\n        ans = []\n        for _ in range(m * n):\n            ans.append(matrix[i][j])\n            vis[i][j] = True\n            x, y = i + dirs[k], j + dirs[k + 1]\n            if x < 0 or x >= m or y < 0 or y >= n or vis[x][y]:\n                k = (k + 1) % 4\n            i += dirs[k]\n            j += dirs[k + 1]\n        return ans\n", "class Solution:\n  def spiralOrder(self, matrix: list[list[int]]) -> list[int]:\n    if not matrix:\n      return []\n\n    m = len(matrix)\n    n = len(matrix[0])\n    ans = []\n    r1 = 0\n    c1 = 0\n    r2 = m - 1\n    c2 = n - 1\n\n    # Repeatedly add matrix[r1..r2][c1..c2] to `ans`.\n    while len(ans) < m * n:\n      j = c1\n      while j <= c2 and len(ans) < m * n:\n        ans.append(matrix[r1][j])\n        j += 1\n      i = r1 + 1\n      while i <= r2 - 1 and len(ans) < m * n:\n        ans.append(matrix[i][c2])\n        i += 1\n      j = c2\n      while j >= c1 and len(ans) < m * n:\n        ans.append(matrix[r2][j])\n        j -= 1\n      i = r2 - 1\n      while i >= r1 + 1 and len(ans) < m * n:\n        ans.append(matrix[i][c1])\n        i -= 1\n      r1 += 1\n      c1 += 1\n      r2 -= 1\n      c2 -= 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 13, "slug": "roman-to-integer", "solutions": ["class Solution:\n    def romanToInt(self, s: str) -> int:\n        d = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n        return sum((-1 if d[a] < d[b] else 1) * d[a] for a, b in pairwise(s)) + d[s[-1]]\n", "class Solution:\n  def romanToInt(self, s: str) -> int:\n    ans = 0\n    roman = {'I': 1, 'V': 5, 'X': 10, 'L': 50,\n             'C': 100, 'D': 500, 'M': 1000}\n\n    for a, b in zip(s, s[1:]):\n      if roman[a] < roman[b]:\n        ans -= roman[a]\n      else:\n        ans += roman[a]\n\n    return ans + roman[s[-1]]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 52, "slug": "n-queens-ii", "solutions": ["class Solution:\n    def totalNQueens(self, n: int) -> int:\n        def dfs(i: int):\n            if i == n:\n                nonlocal ans\n                ans += 1\n                return\n            for j in range(n):\n                a, b = i + j, i - j + n\n                if cols[j] or dg[a] or udg[b]:\n                    continue\n                cols[j] = dg[a] = udg[b] = True\n                dfs(i + 1)\n                cols[j] = dg[a] = udg[b] = False\n\n        cols = [False] * 10\n        dg = [False] * 20\n        udg = [False] * 20\n        ans = 0\n        dfs(0)\n        return ans\n", "class Solution:\n  def totalNQueens(self, n: int) -> int:\n    ans = 0\n    cols = [False] * n\n    diag1 = [False] * (2 * n - 1)\n    diag2 = [False] * (2 * n - 1)\n\n    def dfs(i: int) -> None:\n      nonlocal ans\n      if i == n:\n        ans += 1\n        return\n\n      for j in range(n):\n        if cols[j] or diag1[i + j] or diag2[j - i + n - 1]:\n          continue\n        cols[j] = diag1[i + j] = diag2[j - i + n - 1] = True\n        dfs(i + 1)\n        cols[j] = diag1[i + j] = diag2[j - i + n - 1] = False\n\n    dfs(0)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 37, "slug": "sudoku-solver", "solutions": ["class Solution:\n    def solveSudoku(self, board: List[List[str]]) -> None:\n        def dfs(k):\n            nonlocal ok\n            if k == len(t):\n                ok = True\n                return\n            i, j = t[k]\n            for v in range(9):\n                if row[i][v] == col[j][v] == block[i // 3][j // 3][v] == False:\n                    row[i][v] = col[j][v] = block[i // 3][j // 3][v] = True\n                    board[i][j] = str(v + 1)\n                    dfs(k + 1)\n                    row[i][v] = col[j][v] = block[i // 3][j // 3][v] = False\n                if ok:\n                    return\n\n        row = [[False] * 9 for _ in range(9)]\n        col = [[False] * 9 for _ in range(9)]\n        block = [[[False] * 9 for _ in range(3)] for _ in range(3)]\n        t = []\n        ok = False\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == '.':\n                    t.append((i, j))\n                else:\n                    v = int(board[i][j]) - 1\n                    row[i][v] = col[j][v] = block[i // 3][j // 3][v] = True\n        dfs(0)\n", "class Solution:\n  def solveSudoku(self, board: list[list[str]]) -> None:\n    def isValid(row: int, col: int, c: str) -> bool:\n      for i in range(9):\n        if (board[i][col] == c or\n            board[row][i] == c or\n                board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == c):\n          return False\n      return True\n\n    def solve(s: int) -> bool:\n      if s == 81:\n        return True\n\n      i = s // 9\n      j = s % 9\n\n      if board[i][j] != '.':\n        return solve(s + 1)\n\n      for c in string.digits[1:]:\n        if isValid(i, j, c):\n          board[i][j] = c\n          if solve(s + 1):\n            return True\n          board[i][j] = '.'\n\n      return False\n\n    solve(0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 66, "slug": "plus-one", "solutions": ["class Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        n = len(digits)\n        for i in range(n - 1, -1, -1):\n            digits[i] += 1\n            digits[i] %= 10\n            if digits[i] != 0:\n                return digits\n        return [1] + digits\n", "class Solution:\n  def plusOne(self, digits: list[int]) -> list[int]:\n    for i, d in reversed(list(enumerate(digits))):\n      if d < 9:\n        digits[i] += 1\n        return digits\n      digits[i] = 0\n\n    return [1] + digits\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 5, "slug": "longest-palindromic-substring", "solutions": ["class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        n = len(s)\n        f = [[True] * n for _ in range(n)]\n        k, mx = 0, 1\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 1, n):\n                f[i][j] = False\n                if s[i] == s[j]:\n                    f[i][j] = f[i + 1][j - 1]\n                    if f[i][j] and mx < j - i + 1:\n                        k, mx = i, j - i + 1\n        return s[k : k + mx]\n", "class Solution:\n  def longestPalindrome(self, s: str) -> str:\n    t = '#'.join('@' + s + '$')\n    p = self._manacher(t)\n    maxPalindromeLength, bestCenter = max((extend, i)\n                                          for i, extend in enumerate(p))\n    l = (bestCenter - maxPalindromeLength) // 2\n    r = (bestCenter + maxPalindromeLength) // 2\n    return s[l:r]\n\n  def _manacher(self, t: str) -> list[int]:\n    \"\"\"\n    Returns an array `p` s.t. `p[i]` is the length of the longest palindrome\n    centered at `t[i]`, where `t` is a string with delimiters and sentinels.\n    \"\"\"\n    p = [0] * len(t)\n    center = 0\n    for i in range(1, len(t) - 1):\n      rightBoundary = center + p[center]\n      mirrorIndex = center - (i - center)\n      if rightBoundary > i:\n        p[i] = min(rightBoundary - i, p[mirrorIndex])\n      # Try to expand the palindrome centered at i.\n      while t[i + 1 + p[i]] == t[i - 1 - p[i]]:\n        p[i] += 1\n      # If a palindrome centered at i expands past `rightBoundary`, adjust\n      # the center based on the expanded palindrome.\n      if i + p[i] > rightBoundary:\n        center = i\n    return p\n", "class Solution:\n  def longestPalindrome(self, s: str) -> str:\n    if not s:\n      return ''\n\n    # (start, end) indices of the longest palindrome in s\n    indices = [0, 0]\n\n    def extend(s: str, i: int, j: int) -> tuple[int, int]:\n      \"\"\"\n      Returns the (start, end) indices of the longest palindrome extended from\n      the substring s[i..j].\n      \"\"\"\n      while i >= 0 and j < len(s):\n        if s[i] != s[j]:\n          break\n        i -= 1\n        j += 1\n      return i + 1, j - 1\n\n    for i in range(len(s)):\n      l1, r1 = extend(s, i, i)\n      if r1 - l1 > indices[1] - indices[0]:\n        indices = l1, r1\n      if i + 1 < len(s) and s[i] == s[i + 1]:\n        l2, r2 = extend(s, i, i + 1)\n        if r2 - l2 > indices[1] - indices[0]:\n          indices = l2, r2\n\n    return s[indices[0]:indices[1] + 1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 21, "slug": "merge-two-sorted-lists", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeTwoLists(\n        self, list1: Optional[ListNode], list2: Optional[ListNode]\n    ) -> Optional[ListNode]:\n        if list1 is None or list2 is None:\n            return list1 or list2\n        if list1.val <= list2.val:\n            list1.next = self.mergeTwoLists(list1.next, list2)\n            return list1\n        else:\n            list2.next = self.mergeTwoLists(list1, list2.next)\n            return list2\n", "class Solution:\n  def mergeTwoLists(\n      self,\n      list1: ListNode | None,\n      list2: ListNode | None,\n  ) -> ListNode | None:\n    if not list1 or not list2:\n      return list1 if list1 else list2\n    if list1.val > list2.val:\n      list1, list2 = list2, list1\n    list1.next = self.mergeTwoLists(list1.next, list2)\n    return list1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 34, "slug": "find-first-and-last-position-of-element-in-sorted-array", "solutions": ["class Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        l = bisect_left(nums, target)\n        r = bisect_left(nums, target + 1)\n        return [-1, -1] if l == r else [l, r - 1]\n", "class Solution:\n  def searchRange(self, nums: list[int], target: int) -> list[int]:\n    l = bisect_left(nums, target)\n    if l == len(nums) or nums[l] != target:\n      return -1, -1\n    r = bisect_right(nums, target) - 1\n    return l, r\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1, "slug": "two-sum", "solutions": ["class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        d = {}\n        for i, x in enumerate(nums):\n            if (y := target - x) in d:\n                return [d[y], i]\n            d[x] = i\n", "class Solution:\n  def twoSum(self, nums: list[int], target: int) -> list[int]:\n    numToIndex = {}\n\n    for i, num in enumerate(nums):\n      if target - num in numToIndex:\n        return numToIndex[target - num], i\n      numToIndex[num] = i\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 23, "slug": "merge-k-sorted-lists", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        setattr(ListNode, \"__lt__\", lambda a, b: a.val < b.val)\n        pq = [head for head in lists if head]\n        heapify(pq)\n        dummy = cur = ListNode()\n        while pq:\n            node = heappop(pq)\n            if node.next:\n                heappush(pq, node.next)\n            cur.next = node\n            cur = cur.next\n        return dummy.next\n", "from queue import PriorityQueue\n\n\nclass Solution:\n  def mergeKLists(self, lists: list[ListNode]) -> ListNode:\n    dummy = ListNode(0)\n    curr = dummy\n    pq = PriorityQueue()\n\n    for i, lst in enumerate(lists):\n      if lst:\n        pq.put((lst.val, i, lst))\n\n    while not pq.empty():\n      _, i, minNode = pq.get()\n      if minNode.next:\n        pq.put((minNode.next.val, i, minNode.next))\n      curr.next = minNode\n      curr = curr.next\n\n    return dummy.next\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 27, "slug": "remove-element", "solutions": ["class Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        k = 0\n        for x in nums:\n            if x != val:\n                nums[k] = x\n                k += 1\n        return k\n", "class Solution:\n  def removeElement(self, nums: list[int], val: int) -> int:\n    i = 0\n\n    for num in nums:\n      if num != val:\n        nums[i] = num\n        i += 1\n\n    return i\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 4, "slug": "median-of-two-sorted-arrays", "solutions": ["class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        def f(i: int, j: int, k: int) -> int:\n            if i >= m:\n                return nums2[j + k - 1]\n            if j >= n:\n                return nums1[i + k - 1]\n            if k == 1:\n                return min(nums1[i], nums2[j])\n            p = k // 2\n            x = nums1[i + p - 1] if i + p - 1 < m else inf\n            y = nums2[j + p - 1] if j + p - 1 < n else inf\n            return f(i + p, j, k - p) if x < y else f(i, j + p, k - p)\n\n        m, n = len(nums1), len(nums2)\n        a = f(0, 0, (m + n + 1) // 2)\n        b = f(0, 0, (m + n + 2) // 2)\n        return (a + b) / 2\n", "class Solution:\n  def findMedianSortedArrays(self, nums1: list[int], nums2: list[int]) -> float:\n    n1 = len(nums1)\n    n2 = len(nums2)\n    if n1 > n2:\n      return self.findMedianSortedArrays(nums2, nums1)\n\n    l = 0\n    r = n1\n\n    while l <= r:\n      partition1 = (l + r) // 2\n      partition2 = (n1 + n2 + 1) // 2 - partition1\n      maxLeft1 = -2**31 if partition1 == 0 else nums1[partition1 - 1]\n      maxLeft2 = -2**31 if partition2 == 0 else nums2[partition2 - 1]\n      minRight1 = 2**31 - 1 if partition1 == n1 else nums1[partition1]\n      minRight2 = 2**31 - 1 if partition2 == n2 else nums2[partition2]\n      if maxLeft1 <= minRight2 and maxLeft2 <= minRight1:\n        return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) * 0.5 if (n1 + n2) % 2 == 0 else max(maxLeft1, maxLeft2)\n      elif maxLeft1 > minRight2:\n        r = partition1 - 1\n      else:\n        l = partition1 + 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 70, "slug": "climbing-stairs", "solutions": ["class Solution:\n    def climbStairs(self, n: int) -> int:\n        a, b = 0, 1\n        for _ in range(n):\n            a, b = b, a + b\n        return b\n", "class Solution:\n  def climbStairs(self, n: int) -> int:\n    # dp[i] := the number of ways to climb to the i-th stair\n    dp = [1, 1] + [0] * (n - 1)\n\n    for i in range(2, n + 1):\n      dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n", "class Solution:\n  def climbStairs(self, n: int) -> int:\n    prev1 = 1  # dp[i - 1]\n    prev2 = 1  # dp[i - 2]\n\n    for _ in range(2, n + 1):\n      dp = prev1 + prev2\n      prev2 = prev1\n      prev1 = dp\n\n    return prev1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 92, "slug": "reverse-linked-list-ii", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseBetween(\n        self, head: Optional[ListNode], left: int, right: int\n    ) -> Optional[ListNode]:\n        if head.next is None or left == right:\n            return head\n        dummy = ListNode(0, head)\n        pre = dummy\n        for _ in range(left - 1):\n            pre = pre.next\n        p, q = pre, pre.next\n        cur = q\n        for _ in range(right - left + 1):\n            t = cur.next\n            cur.next = pre\n            pre, cur = cur, t\n        p.next = pre\n        q.next = cur\n        return dummy.next\n", "class Solution:\n  def reverseBetween(\n      self,\n      head: ListNode | None,\n      left: int,\n      right: int,\n  ) -> ListNode | None:\n    if left == 1:\n      return self.reverseN(head, right)\n\n    head.next = self.reverseBetween(head.next, left - 1, right - 1)\n    return head\n\n  def reverseN(self, head: ListNode | None, n: int) -> ListNode | None:\n    if n == 1:\n      return head\n\n    newHead = self.reverseN(head.next, n - 1)\n    headNext = head.next\n    head.next = headNext.next\n    headNext.next = head\n    return newHead\n", "class Solution:\n  def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:\n    if not head and m == n:\n      return head\n\n    dummy = ListNode(0, head)\n    prev = dummy\n\n    for _ in range(m - 1):\n      prev = prev.next  # Point to the node before the sublist [m, n].\n\n    tail = prev.next  # Be the tail of the sublist [m, n].\n\n    # Reverse the sublist [m, n] one by one.\n    for _ in range(n - m):\n      cache = tail.next\n      tail.next = cache.next\n      cache.next = prev.next\n      prev.next = cache\n\n    return dummy.next\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 18, "slug": "4sum", "solutions": ["class Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        n = len(nums)\n        ans = []\n        if n < 4:\n            return ans\n        nums.sort()\n        for i in range(n - 3):\n            if i and nums[i] == nums[i - 1]:\n                continue\n            for j in range(i + 1, n - 2):\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                k, l = j + 1, n - 1\n                while k < l:\n                    x = nums[i] + nums[j] + nums[k] + nums[l]\n                    if x < target:\n                        k += 1\n                    elif x > target:\n                        l -= 1\n                    else:\n                        ans.append([nums[i], nums[j], nums[k], nums[l]])\n                        k, l = k + 1, l - 1\n                        while k < l and nums[k] == nums[k - 1]:\n                            k += 1\n                        while k < l and nums[l] == nums[l + 1]:\n                            l -= 1\n        return ans\n", "class Solution:\n  def fourSum(self, nums: list[int], target: int):\n    ans = []\n\n    def nSum(\n            l: int, r: int, target: int, n: int, path: list[int],\n            ans: list[list[int]]) -> None:\n      \"\"\"Finds n numbers that add up to the target in [l, r].\"\"\"\n      if r - l + 1 < n or n < 2 or target < nums[l] * n or target > nums[r] * n:\n        return\n      if n == 2:\n        while l < r:\n          summ = nums[l] + nums[r]\n          if summ == target:\n            ans.append(path + [nums[l], nums[r]])\n            l += 1\n            while nums[l] == nums[l - 1] and l < r:\n              l += 1\n          elif summ < target:\n            l += 1\n          else:\n            r -= 1\n        return\n\n      for i in range(l, r + 1):\n        if i > l and nums[i] == nums[i - 1]:\n          continue\n\n        nSum(i + 1, r, target - nums[i], n - 1, path + [nums[i]], ans)\n\n    nums.sort()\n    nSum(0, len(nums) - 1, target, 4, [], ans)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 94, "slug": "binary-tree-inorder-traversal", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        def dfs(root):\n            if root is None:\n                return\n            dfs(root.left)\n            ans.append(root.val)\n            dfs(root.right)\n\n        ans = []\n        dfs(root)\n        return ans\n", "class Solution:\n  def inorderTraversal(self, root: TreeNode | None) -> list[int]:\n    ans = []\n    stack = []\n\n    while root or stack:\n      while root:\n        stack.append(root)\n        root = root.left\n      root = stack.pop()\n      ans.append(root.val)\n      root = root.right\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 63, "slug": "unique-paths-ii", "solutions": ["class Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\n        @cache\n        def dfs(i: int, j: int) -> int:\n            if i >= m or j >= n or obstacleGrid[i][j]:\n                return 0\n            if i == m - 1 and j == n - 1:\n                return 1\n            return dfs(i + 1, j) + dfs(i, j + 1)\n\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\n        return dfs(0, 0)\n", "class Solution:\n  def uniquePathsWithObstacles(self, obstacleGrid: list[list[int]]) -> int:\n    m = len(obstacleGrid)\n    n = len(obstacleGrid[0])\n    dp = [0] * n\n    dp[0] = 1\n\n    for i in range(m):\n      for j in range(n):\n        if obstacleGrid[i][j]:\n          dp[j] = 0\n        elif j > 0:\n          dp[j] += dp[j - 1]\n\n    return dp[n - 1]\n", "class Solution:\n  def uniquePathsWithObstacles(self, obstacleGrid: list[list[int]]) -> int:\n    m = len(obstacleGrid)\n    n = len(obstacleGrid[0])\n    # dp[i][j] := the number of unique paths from (0, 0) to (i, j)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    dp[0][1] = 1  # Can also set dp[1][0] = 1.\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        if obstacleGrid[i - 1][j - 1] == 0:\n          dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[m][n]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 20, "slug": "valid-parentheses", "solutions": ["class Solution:\n    def isValid(self, s: str) -> bool:\n        stk = []\n        d = {'()', '[]', '{}'}\n        for c in s:\n            if c in '({[':\n                stk.append(c)\n            elif not stk or stk.pop() + c not in d:\n                return False\n        return not stk\n", "class Solution:\n  def isValid(self, s: str) -> bool:\n    stack = []\n\n    for c in s:\n      if c == '(':\n        stack.append(')')\n      elif c == '{':\n        stack.append('}')\n      elif c == '[':\n        stack.append(']')\n      elif not stack or stack.pop() != c:\n        return False\n\n    return not stack\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 67, "slug": "add-binary", "solutions": ["class Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        return bin(int(a, 2) + int(b, 2))[2:]\n", "class Solution:\n  def addBinary(self, a: str, b: str) -> str:\n    ans = []\n    carry = 0\n    i = len(a) - 1\n    j = len(b) - 1\n\n    while i >= 0 or j >= 0 or carry:\n      if i >= 0:\n        carry += int(a[i])\n        i -= 1\n      if j >= 0:\n        carry += int(b[j])\n        j -= 1\n      ans.append(str(carry % 2))\n      carry //= 2\n\n    return ''.join(reversed(ans))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 19, "slug": "remove-nth-node-from-end-of-list", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        dummy = ListNode(next=head)\n        fast = slow = dummy\n        for _ in range(n):\n            fast = fast.next\n        while fast.next:\n            slow, fast = slow.next, fast.next\n        slow.next = slow.next.next\n        return dummy.next\n", "class Solution:\n  def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\n    slow = head\n    fast = head\n\n    for _ in range(n):\n      fast = fast.next\n    if not fast:\n      return head.next\n\n    while fast.next:\n      slow = slow.next\n      fast = fast.next\n    slow.next = slow.next.next\n\n    return head\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 7, "slug": "reverse-integer", "solutions": ["class Solution:\n    def reverse(self, x: int) -> int:\n        ans = 0\n        mi, mx = -(2**31), 2**31 - 1\n        while x:\n            if ans < mi // 10 + 1 or ans > mx // 10:\n                return 0\n            y = x % 10\n            if x < 0 and y > 0:\n                y -= 10\n            ans = ans * 10 + y\n            x = (x - y) // 10\n        return ans\n", "class Solution:\n  def reverse(self, x: int) -> int:\n    ans = 0\n    sign = -1 if x < 0 else 1\n    x *= sign\n\n    while x:\n      ans = ans * 10 + x % 10\n      x //= 10\n\n    return 0 if ans < -2**31 or ans > 2**31 - 1 else sign * ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 85, "slug": "maximal-rectangle", "solutions": ["class Solution:\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\n        heights = [0] * len(matrix[0])\n        ans = 0\n        for row in matrix:\n            for j, v in enumerate(row):\n                if v == \"1\":\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n            ans = max(ans, self.largestRectangleArea(heights))\n        return ans\n\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        n = len(heights)\n        stk = []\n        left = [-1] * n\n        right = [n] * n\n        for i, h in enumerate(heights):\n            while stk and heights[stk[-1]] >= h:\n                stk.pop()\n            if stk:\n                left[i] = stk[-1]\n            stk.append(i)\n        stk = []\n        for i in range(n - 1, -1, -1):\n            h = heights[i]\n            while stk and heights[stk[-1]] >= h:\n                stk.pop()\n            if stk:\n                right[i] = stk[-1]\n            stk.append(i)\n        return max(h * (right[i] - left[i] - 1) for i, h in enumerate(heights))\n", "class Solution:\n  def maximalRectangle(self, matrix: list[list[str]]) -> int:\n    if not matrix:\n      return 0\n\n    ans = 0\n    hist = [0] * len(matrix[0])\n\n    def largestRectangleArea(heights: list[int]) -> int:\n      ans = 0\n      stack = []\n\n      for i in range(len(heights) + 1):\n        while stack and (i == len(heights) or heights[stack[-1]] > heights[i]):\n          h = heights[stack.pop()]\n          w = i - stack[-1] - 1 if stack else i\n          ans = max(ans, h * w)\n        stack.append(i)\n\n      return ans\n\n    for row in matrix:\n      for i, num in enumerate(row):\n        hist[i] = 0 if num == '0' else hist[i] + 1\n      ans = max(ans, largestRectangleArea(hist))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 8, "slug": "string-to-integer-atoi", "solutions": ["class Solution:\n    def myAtoi(self, s: str) -> int:\n        if not s:\n            return 0\n        n = len(s)\n        if n == 0:\n            return 0\n        i = 0\n        while s[i] == ' ':\n            i += 1\n            # \n            if i == n:\n                return 0\n        sign = -1 if s[i] == '-' else 1\n        if s[i] in ['-', '+']:\n            i += 1\n        res, flag = 0, (2**31 - 1) // 10\n        while i < n:\n            # \n            if not s[i].isdigit():\n                break\n            c = int(s[i])\n            # \n            if res > flag or (res == flag and c > 7):\n                return 2**31 - 1 if sign > 0 else -(2**31)\n            res = res * 10 + c\n            i += 1\n        return sign * res\n", "class Solution:\n  def myAtoi(self, s: str) -> int:\n    s = s.strip()\n    if not s:\n      return 0\n\n    sign = -1 if s[0] == '-' else 1\n    if s[0] in {'-', '+'}:\n      s = s[1:]\n\n    num = 0\n\n    for c in s:\n      if not c.isdigit():\n        break\n      num = num * 10 + int(c)\n      if sign * num <= -2**31:\n        return -2**31\n      if sign * num >= 2**31 - 1:\n        return 2**31 - 1\n\n    return sign * num\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 73, "slug": "set-matrix-zeroes", "solutions": ["class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        m, n = len(matrix), len(matrix[0])\n        row = [False] * m\n        col = [False] * n\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    row[i] = col[j] = True\n        for i in range(m):\n            for j in range(n):\n                if row[i] or col[j]:\n                    matrix[i][j] = 0\n", "class Solution:\n  def setZeroes(self, matrix: list[list[int]]) -> None:\n    m = len(matrix)\n    n = len(matrix[0])\n    shouldFillFirstRow = 0 in matrix[0]\n    shouldFillFirstCol = 0 in list(zip(*matrix))[0]\n\n    # Store the information in the first row and the first column.\n    for i in range(1, m):\n      for j in range(1, n):\n        if matrix[i][j] == 0:\n          matrix[i][0] = 0\n          matrix[0][j] = 0\n\n    # Fill 0s for the matrix except the first row and the first column.\n    for i in range(1, m):\n      for j in range(1, n):\n        if matrix[i][0] == 0 or matrix[0][j] == 0:\n          matrix[i][j] = 0\n\n    # Fill 0s for the first row if needed.\n    if shouldFillFirstRow:\n      matrix[0] = [0] * n\n\n    # Fill 0s for the first column if needed.\n    if shouldFillFirstCol:\n      for row in matrix:\n        row[0] = 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 58, "slug": "length-of-last-word", "solutions": ["class Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        i = len(s) - 1\n        while i >= 0 and s[i] == ' ':\n            i -= 1\n        j = i\n        while j >= 0 and s[j] != ' ':\n            j -= 1\n        return i - j\n", "class Solution:\n  def lengthOfLastWord(self, s: str) -> int:\n    i = len(s) - 1\n\n    while i >= 0 and s[i] == ' ':\n      i -= 1\n    lastIndex = i\n    while i >= 0 and s[i] != ' ':\n      i -= 1\n\n    return lastIndex - i\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 75, "slug": "sort-colors", "solutions": ["class Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        i, j, k = -1, len(nums), 0\n        while k < j:\n            if nums[k] == 0:\n                i += 1\n                nums[i], nums[k] = nums[k], nums[i]\n                k += 1\n            elif nums[k] == 2:\n                j -= 1\n                nums[j], nums[k] = nums[k], nums[j]\n            else:\n                k += 1\n", "class Solution:\n  def sortColors(self, nums: list[int]) -> None:\n    l = 0  # The next 0 should be placed in l.\n    r = len(nums) - 1  # THe next 2 should be placed in r.\n\n    i = 0\n    while i <= r:\n      if nums[i] == 0:\n        nums[i], nums[l] = nums[l], nums[i]\n        i += 1\n        l += 1\n      elif nums[i] == 1:\n        i += 1\n      else:\n        # We may swap a 0 to index i, but we're still not sure whether this 0\n        # is placed in the correct index, so we can't move pointer i.\n        nums[i], nums[r] = nums[r], nums[i]\n        r -= 1\n", "class Solution:\n  def sortColors(self, nums: list[int]) -> None:\n    zero = -1\n    one = -1\n    two = -1\n\n    for num in nums:\n      if num == 0:\n        two += 1\n        one += 1\n        zero += 1\n        nums[two] = 2\n        nums[one] = 1\n        nums[zero] = 0\n      elif num == 1:\n        two += 1\n        one += 1\n        nums[two] = 2\n        nums[one] = 1\n      else:\n        two += 1\n        nums[two] = 2\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 22, "slug": "generate-parentheses", "solutions": ["class Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        def dfs(l, r, t):\n            if l > n or r > n or l < r:\n                return\n            if l == n and r == n:\n                ans.append(t)\n                return\n            dfs(l + 1, r, t + '(')\n            dfs(l, r + 1, t + ')')\n\n        ans = []\n        dfs(0, 0, '')\n        return ans\n", "class Solution:\n  def generateParenthesis(self, n):\n    ans = []\n\n    def dfs(l: int, r: int, s: list[str]) -> None:\n      if l == 0 and r == 0:\n        ans.append(''.join(s))\n      if l > 0:\n        s.append('(')\n        dfs(l - 1, r, s)\n        s.pop()\n      if l < r:\n        s.append(')')\n        dfs(l, r - 1, s)\n        s.pop()\n\n    dfs(n, n, [])\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 47, "slug": "permutations-ii", "solutions": ["class Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        def dfs(i: int):\n            if i == n:\n                ans.append(t[:])\n                return\n            for j in range(n):\n                if vis[j] or (j and nums[j] == nums[j - 1] and not vis[j - 1]):\n                    continue\n                t[i] = nums[j]\n                vis[j] = True\n                dfs(i + 1)\n                vis[j] = False\n\n        n = len(nums)\n        nums.sort()\n        ans = []\n        t = [0] * n\n        vis = [False] * n\n        dfs(0)\n        return ans\n", "class Solution:\n  def permuteUnique(self, nums: list[int]) -> list[list[int]]:\n    ans = []\n    used = [False] * len(nums)\n\n    def dfs(path: list[int]) -> None:\n      if len(path) == len(nums):\n        ans.append(path.copy())\n        return\n\n      for i, num in enumerate(nums):\n        if used[i]:\n          continue\n        if i > 0 and nums[i] == nums[i - 1] and not used[i - 1]:\n          continue\n        used[i] = True\n        path.append(num)\n        dfs(path)\n        path.pop()\n        used[i] = False\n\n    nums.sort()\n    dfs([])\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 88, "slug": "merge-sorted-array", "solutions": ["class Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        k = m + n - 1\n        i, j = m - 1, n - 1\n        while j >= 0:\n            if i >= 0 and nums1[i] > nums2[j]:\n                nums1[k] = nums1[i]\n                i -= 1\n            else:\n                nums1[k] = nums2[j]\n                j -= 1\n            k -= 1\n", "class Solution:\n  def merge(self, nums1: list[int], m: int, nums2: list[int], n: int) -> None:\n    i = m - 1  # nums1's index (the actual nums)\n    j = n - 1  # nums2's index\n    k = m + n - 1  # nums1's index (the next filled position)\n\n    while j >= 0:\n      if i >= 0 and nums1[i] > nums2[j]:\n        nums1[k] = nums1[i]\n        k -= 1\n        i -= 1\n      else:\n        nums1[k] = nums2[j]\n        k -= 1\n        j -= 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 28, "slug": "find-the-index-of-the-first-occurrence-in-a-string", "solutions": ["class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        n, m = len(haystack), len(needle)\n        for i in range(n - m + 1):\n            if haystack[i : i + m] == needle:\n                return i\n        return -1\n", "class Solution:\n  def strStr(self, haystack: str, needle: str) -> int:\n    m = len(haystack)\n    n = len(needle)\n\n    for i in range(m - n + 1):\n      if haystack[i:i + n] == needle:\n        return i\n\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 16, "slug": "3sum-closest", "solutions": ["class Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        n = len(nums)\n        ans = inf\n        for i, v in enumerate(nums):\n            j, k = i + 1, n - 1\n            while j < k:\n                t = v + nums[j] + nums[k]\n                if t == target:\n                    return t\n                if abs(t - target) < abs(ans - target):\n                    ans = t\n                if t > target:\n                    k -= 1\n                else:\n                    j += 1\n        return ans\n", "class Solution:\n  def threeSumClosest(self, nums: list[int], target: int) -> int:\n    ans = nums[0] + nums[1] + nums[2]\n\n    nums.sort()\n\n    for i in range(len(nums) - 2):\n      if i > 0 and nums[i] == nums[i - 1]:\n        continue\n      # Choose nums[i] as the first number in the triplet, then search the\n      # remaining numbers in [i + 1, n - 1].\n      l = i + 1\n      r = len(nums) - 1\n      while l < r:\n        summ = nums[i] + nums[l] + nums[r]\n        if summ == target:\n          return summ\n        if abs(summ - target) < abs(ans - target):\n          ans = summ\n        if summ < target:\n          l += 1\n        else:\n          r -= 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 91, "slug": "decode-ways", "solutions": ["class Solution:\n    def numDecodings(self, s: str) -> int:\n        n = len(s)\n        f = [1] + [0] * n\n        for i, c in enumerate(s, 1):\n            if c != \"0\":\n                f[i] = f[i - 1]\n            if i > 1 and s[i - 2] != \"0\" and int(s[i - 2 : i]) <= 26:\n                f[i] += f[i - 2]\n        return f[n]\n", "class Solution:\n  def numDecodings(self, s: str) -> int:\n    n = len(s)\n    # dp[i] := the number of ways to decode s[i..n)\n    dp = [0] * n + [1]\n\n    def isValid(a: str, b=None) -> bool:\n      if b:\n        return a == '1' or a == '2' and b < '7'\n      return a != '0'\n\n    if isValid(s[-1]):\n      dp[n - 1] = 1\n\n    for i in reversed(range(n - 1)):\n      if isValid(s[i]):\n        dp[i] += dp[i + 1]\n      if isValid(s[i], s[i + 1]):\n        dp[i] += dp[i + 2]\n\n    return dp[0]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 90, "slug": "subsets-ii", "solutions": ["class Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        def dfs(i: int):\n            if i == len(nums):\n                ans.append(t[:])\n                return\n            t.append(nums[i])\n            dfs(i + 1)\n            x = t.pop()\n            while i + 1 < len(nums) and nums[i + 1] == x:\n                i += 1\n            dfs(i + 1)\n\n        nums.sort()\n        ans = []\n        t = []\n        dfs(0)\n        return ans\n", "class Solution:\n  def subsetsWithDup(self, nums: list[int]) -> list[list[int]]:\n    ans = []\n\n    def dfs(s: int, path: list[int]) -> None:\n      ans.append(path)\n      if s == len(nums):\n        return\n\n      for i in range(s, len(nums)):\n        if i > s and nums[i] == nums[i - 1]:\n          continue\n        dfs(i + 1, path + [nums[i]])\n\n    nums.sort()\n    dfs(0, [])\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 24, "slug": "swap-nodes-in-pairs", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head is None or head.next is None:\n            return head\n        t = self.swapPairs(head.next.next)\n        p = head.next\n        p.next = head\n        head.next = t\n        return p\n", "class Solution:\n  def swapPairs(self, head: ListNode) -> ListNode:\n    def getLength(head: ListNode) -> int:\n      length = 0\n      while head:\n        length += 1\n        head = head.next\n      return length\n\n    length = getLength(head)\n    dummy = ListNode(0, head)\n    prev = dummy\n    curr = head\n\n    for _ in range(length // 2):\n      next = curr.next\n      curr.next = next.next\n      next.next = prev.next\n      prev.next = next\n      prev = curr\n      curr = curr.next\n\n    return dummy.next\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 97, "slug": "interleaving-string", "solutions": ["class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        @cache\n        def dfs(i: int, j: int) -> bool:\n            if i >= m and j >= n:\n                return True\n            k = i + j\n            if i < m and s1[i] == s3[k] and dfs(i + 1, j):\n                return True\n            if j < n and s2[j] == s3[k] and dfs(i, j + 1):\n                return True\n            return False\n\n        m, n = len(s1), len(s2)\n        if m + n != len(s3):\n            return False\n        return dfs(0, 0)\n", "class Solution:\n  def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n    m = len(s1)\n    n = len(s2)\n    if m + n != len(s3):\n      return False\n\n    # dp[i][j] := true if s3[0..i + j) is formed by the interleaving of\n    # s1[0..i) and s2[0..j)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    for i in range(1, m + 1):\n      dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n\n    for j in range(1, n + 1):\n      dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1] or\n                    dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n\n    return dp[m][n]\n", "class Solution:\n  def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n    m = len(s1)\n    n = len(s2)\n    if m + n != len(s3):\n      return False\n\n    dp = [False] * (n + 1)\n\n    for i in range(m + 1):\n      for j in range(n + 1):\n        if i == 0 and j == 0:\n          dp[j] = True\n        elif i == 0:\n          dp[j] = dp[j - 1] and s2[j - 1] == s3[j - 1]\n        elif j == 0:\n          dp[j] = dp[j] and s1[i - 1] == s3[i - 1]\n        else:\n          dp[j] = (dp[j] and s1[i - 1] == s3[i + j - 1] or\n                   dp[j - 1] and s2[j - 1] == s3[i + j - 1])\n\n    return dp[n]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3, "slug": "longest-substring-without-repeating-characters", "solutions": ["class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        cnt = Counter()\n        ans = l = 0\n        for r, c in enumerate(s):\n            cnt[c] += 1\n            while cnt[c] > 1:\n                cnt[s[l]] -= 1\n                l += 1\n            ans = max(ans, r - l + 1)\n        return ans\n", "class Solution:\n  def lengthOfLongestSubstring(self, s: str) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] += 1\n      while count[c] > 1:\n        count[s[l]] -= 1\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans\n", "class Solution:\n  def lengthOfLongestSubstring(self, s: str) -> int:\n    ans = 0\n    # The substring s[j + 1..i] has no repeating characters.\n    j = -1\n    # lastSeen[c] := the index of the last time c appeared\n    lastSeen = {}\n\n    for i, c in enumerate(s):\n      # Update j to lastSeen[c], so the window must start from j + 1.\n      j = max(j, lastSeen.get(c, -1))\n      ans = max(ans, i - j)\n      lastSeen[c] = i\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 41, "slug": "first-missing-positive", "solutions": ["class Solution:\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        n = len(nums)\n        for i in range(n):\n            while 1 <= nums[i] <= n and nums[i] != nums[nums[i] - 1]:\n                j = nums[i] - 1\n                nums[i], nums[j] = nums[j], nums[i]\n        for i in range(n):\n            if nums[i] != i + 1:\n                return i + 1\n        return n + 1\n", "class Solution:\n  def firstMissingPositive(self, nums: list[int]) -> int:\n    n = len(nums)\n\n    # Correct slot:\n    # nums[i] = i + 1\n    # nums[i] - 1 = i\n    # nums[nums[i] - 1] = nums[i]\n    for i in range(n):\n      while nums[i] > 0 and nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n        nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n\n    for i, num in enumerate(nums):\n      if num != i + 1:\n        return i + 1\n\n    return n + 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 56, "slug": "merge-intervals", "solutions": ["class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        intervals.sort()\n        ans = []\n        st, ed = intervals[0]\n        for s, e in intervals[1:]:\n            if ed < s:\n                ans.append([st, ed])\n                st, ed = s, e\n            else:\n                ed = max(ed, e)\n        ans.append([st, ed])\n        return ans\n", "class Solution:\n  def merge(self, intervals: list[list[int]]) -> list[list[int]]:\n    ans = []\n\n    for interval in sorted(intervals):\n      if not ans or ans[-1][1] < interval[0]:\n        ans.append(interval)\n      else:\n        ans[-1][1] = max(ans[-1][1], interval[1])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 33, "slug": "search-in-rotated-sorted-array", "solutions": ["class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        left, right = 0, n - 1\n        while left < right:\n            mid = (left + right) >> 1\n            if nums[0] <= nums[mid]:\n                if nums[0] <= target <= nums[mid]:\n                    right = mid\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[n - 1]:\n                    left = mid + 1\n                else:\n                    right = mid\n        return left if nums[left] == target else -1\n", "class Solution:\n  def search(self, nums: list[int], target: int) -> int:\n    l = 0\n    r = len(nums) - 1\n\n    while l <= r:\n      m = (l + r) // 2\n      if nums[m] == target:\n        return m\n      if nums[l] <= nums[m]:  # nums[l..m] are sorted.\n        if nums[l] <= target < nums[m]:\n          r = m - 1\n        else:\n          l = m + 1\n      else:  # nums[m..n - 1] are sorted.\n        if nums[m] < target <= nums[r]:\n          l = m + 1\n        else:\n          r = m - 1\n\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 6, "slug": "zigzag-conversion", "solutions": ["class Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        if numRows == 1:\n            return s\n        g = [[] for _ in range(numRows)]\n        i, k = 0, -1\n        for c in s:\n            g[i].append(c)\n            if i == 0 or i == numRows - 1:\n                k = -k\n            i += k\n        return ''.join(chain(*g))\n", "class Solution:\n  def convert(self, s: str, numRows: int) -> str:\n    rows = [''] * numRows\n    k = 0\n    direction = (numRows == 1) - 1\n\n    for c in s:\n      rows[k] += c\n      if k == 0 or k == numRows - 1:\n        direction *= -1\n      k += direction\n\n    return ''.join(rows)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 11, "slug": "container-with-most-water", "solutions": ["class Solution:\n    def maxArea(self, height: List[int]) -> int:\n        l, r = 0, len(height) - 1\n        ans = 0\n        while l < r:\n            t = min(height[l], height[r]) * (r - l)\n            ans = max(ans, t)\n            if height[l] < height[r]:\n                l += 1\n            else:\n                r -= 1\n        return ans\n", "class Solution:\n  def maxArea(self, height: list[int]) -> int:\n    ans = 0\n    l = 0\n    r = len(height) - 1\n\n    while l < r:\n      minHeight = min(height[l], height[r])\n      ans = max(ans, minHeight * (r - l))\n      if height[l] < height[r]:\n        l += 1\n      else:\n        r -= 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 78, "slug": "subsets", "solutions": ["class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        def dfs(i: int):\n            if i == len(nums):\n                ans.append(t[:])\n                return\n            dfs(i + 1)\n            t.append(nums[i])\n            dfs(i + 1)\n            t.pop()\n\n        ans = []\n        t = []\n        dfs(0)\n        return ans\n", "class Solution:\n  def subsets(self, nums: list[int]) -> list[list[int]]:\n    ans = []\n\n    def dfs(s: int, path: list[int]) -> None:\n      ans.append(path)\n\n      for i in range(s, len(nums)):\n        dfs(i + 1, path + [nums[i]])\n\n    dfs(0, [])\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 53, "slug": "maximum-subarray", "solutions": ["class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        ans = f = nums[0]\n        for x in nums[1:]:\n            f = max(f, 0) + x\n            ans = max(ans, f)\n        return ans\n", "class Solution:\n  def maxSubArray(self, nums: list[int]) -> int:\n    ans = -math.inf\n    summ = 0\n\n    for num in nums:\n      summ = max(num, summ + num)\n      ans = max(ans, summ)\n\n    return ans\n", "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass T:\n  summ: int\n  # the sum of the subarray starting from the first number\n  maxSubarraySumLeft: int\n  # the sum of the subarray ending in the last number\n  maxSubarraySumRight: int\n  maxSubarraySum: int\n\n\nclass Solution:\n  def maxSubArray(self, nums: list[int]) -> int:\n    def divideAndConquer(l: int, r: int) -> T:\n      if l == r:\n        return T(nums[l], nums[l], nums[l], nums[l])\n      m = (l + r) // 2\n      left = divideAndConquer(l, m)\n      right = divideAndConquer(m + 1, r)\n      maxSubarraySumLeft = max(left.maxSubarraySumLeft,\n                               left.summ + right.maxSubarraySumLeft)\n      maxSubarraySumRight = max(\n          left.maxSubarraySumRight + right.summ, right.maxSubarraySumRight)\n      maxSubarraySum = max(left.maxSubarraySumRight + right.maxSubarraySumLeft,\n                           left.maxSubarraySum, right.maxSubarraySum)\n      summ = left.summ + right.summ\n      return T(summ, maxSubarraySumLeft, maxSubarraySumRight, maxSubarraySum)\n\n    return divideAndConquer(0, len(nums) - 1).maxSubarraySum\n", "class Solution:\n  def maxSubArray(self, nums: list[int]) -> int:\n    # dp[i] := the maximum sum subarray ending in i\n    dp = [0] * len(nums)\n\n    dp[0] = nums[0]\n    for i in range(1, len(nums)):\n      dp[i] = max(nums[i], dp[i - 1] + nums[i])\n\n    return max(dp)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 46, "slug": "permutations", "solutions": ["class Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        def dfs(i: int):\n            if i >= n:\n                ans.append(t[:])\n                return\n            for j, x in enumerate(nums):\n                if not vis[j]:\n                    vis[j] = True\n                    t[i] = x\n                    dfs(i + 1)\n                    vis[j] = False\n\n        n = len(nums)\n        vis = [False] * n\n        t = [0] * n\n        ans = []\n        dfs(0)\n        return ans\n", "class Solution:\n  def permute(self, nums: list[int]) -> list[list[int]]:\n    ans = []\n    used = [False] * len(nums)\n\n    def dfs(path: list[int]) -> None:\n      if len(path) == len(nums):\n        ans.append(path.copy())\n        return\n\n      for i, num in enumerate(nums):\n        if used[i]:\n          continue\n        used[i] = True\n        path.append(num)\n        dfs(path)\n        path.pop()\n        used[i] = False\n\n    dfs([])\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 12, "slug": "integer-to-roman", "solutions": ["class Solution:\n    def intToRoman(self, num: int) -> str:\n        cs = ('M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I')\n        vs = (1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)\n        ans = []\n        for c, v in zip(cs, vs):\n            while num >= v:\n                num -= v\n                ans.append(c)\n        return ''.join(ans)\n", "class Solution:\n  def intToRoman(self, num: int) -> str:\n    M = ['', 'M', 'MM', 'MMM']\n    C = ['', 'C', 'CC', 'CCC', 'CD', 'D', 'DC', 'DCC', 'DCCC', 'CM']\n    X = ['', 'X', 'XX', 'XXX', 'XL', 'L', 'LX', 'LXX', 'LXXX', 'XC']\n    I = ['', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX']\n    return M[num // 1000] + C[num % 1000 // 100] + X[num % 100 // 10] + I[num % 10]\n", "class Solution:\n  def intToRoman(self, num: int) -> str:\n    valueSymbols = [(1000, 'M'), (900, 'CM'),\n                    (500, 'D'), (400, 'CD'),\n                    (100, 'C'), (90, 'XC'),\n                    (50, 'L'), (40, 'XL'),\n                    (10, 'X'), (9, 'IX'),\n                    (5, 'V'), (4, 'IV'),\n                    (1, 'I')]\n    ans = []\n\n    for value, symbol in valueSymbols:\n      if num == 0:\n        break\n      count, num = divmod(num, value)\n      ans.append(symbol * count)\n\n    return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 25, "slug": "reverse-nodes-in-k-group", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        def reverse(head: Optional[ListNode]) -> Optional[ListNode]:\n            dummy = ListNode()\n            cur = head\n            while cur:\n                nxt = cur.next\n                cur.next = dummy.next\n                dummy.next = cur\n                cur = nxt\n            return dummy.next\n\n        dummy = pre = ListNode(next=head)\n        while pre:\n            cur = pre\n            for _ in range(k):\n                cur = cur.next\n                if cur is None:\n                    return dummy.next\n            node = pre.next\n            nxt = cur.next\n            cur.next = None\n            pre.next = reverse(node)\n            node.next = nxt\n            pre = node\n        return dummy.next\n", "class Solution:\n  def reverseKGroup(self, head: ListNode | None, k: int) -> ListNode | None:\n    if not head:\n      return None\n\n    tail = head\n\n    for _ in range(k):\n      # There are less than k nodes in the list, do nothing.\n      if not tail:\n        return head\n      tail = tail.next\n\n    newHead = self._reverse(head, tail)\n    head.next = self.reverseKGroup(tail, k)\n    return newHead\n\n  def _reverse(\n      self,\n      head: ListNode | None,\n      tail: ListNode | None,\n  ) -> ListNode | None:\n    \"\"\"Reverses [head, tail).\"\"\"\n    prev = None\n    curr = head\n    while curr != tail:\n      next = curr.next\n      curr.next = prev\n      prev = curr\n      curr = next\n    return prev\n", "class Solution:\n  def reverseKGroup(self, head: ListNode, k: int) -> ListNode:\n    if not head or k == 1:\n      return head\n\n    def getLength(head: ListNode) -> int:\n      length = 0\n      while head:\n        length += 1\n        head = head.next\n      return length\n\n    length = getLength(head)\n    dummy = ListNode(0, head)\n    prev = dummy\n    curr = head\n\n    for _ in range(length // k):\n      for _ in range(k - 1):\n        next = curr.next\n        curr.next = next.next\n        next.next = prev.next\n        prev.next = next\n      prev = curr\n      curr = curr.next\n\n    return dummy.next\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1039, "slug": "minimum-score-triangulation-of-polygon", "solutions": ["class Solution:\n    def minScoreTriangulation(self, values: List[int]) -> int:\n        @cache\n        def dfs(i: int, j: int) -> int:\n            if i + 1 == j:\n                return 0\n            return min(\n                dfs(i, k) + dfs(k, j) + values[i] * values[k] * values[j]\n                for k in range(i + 1, j)\n            )\n\n        return dfs(0, len(values) - 1)\n", "class Solution:\n  def minScoreTriangulation(self, values: list[int]) -> int:\n    n = len(values)\n    dp = [[0] * n for _ in range(n)]\n\n    for j in range(2, n):\n      for i in range(j - 2, -1, -1):\n        dp[i][j] = math.inf\n        for k in range(i + 1, j):\n          dp[i][j] = min(dp[i][j], dp[i][k] + values[i]\n                         * values[k] * values[j] + dp[k][j])\n\n    return dp[0][n - 1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1074, "slug": "number-of-submatrices-that-sum-to-target", "solutions": ["class Solution:\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\n        def f(nums: List[int]) -> int:\n            d = defaultdict(int)\n            d[0] = 1\n            cnt = s = 0\n            for x in nums:\n                s += x\n                cnt += d[s - target]\n                d[s] += 1\n            return cnt\n\n        m, n = len(matrix), len(matrix[0])\n        ans = 0\n        for i in range(m):\n            col = [0] * n\n            for j in range(i, m):\n                for k in range(n):\n                    col[k] += matrix[j][k]\n                ans += f(col)\n        return ans\n", "class Solution:\n  def numSubmatrixSumTarget(self, matrix: list[list[int]], target: int) -> int:\n    m = len(matrix)\n    n = len(matrix[0])\n    ans = 0\n\n    # Transfer each row in the matrix to the prefix sum.\n    for row in matrix:\n      for i in range(1, n):\n        row[i] += row[i - 1]\n\n    for baseCol in range(n):\n      for j in range(baseCol, n):\n        prefixCount = collections.Counter({0: 1})\n        summ = 0\n        for i in range(m):\n          if baseCol > 0:\n            summ -= matrix[i][baseCol - 1]\n          summ += matrix[i][j]\n          ans += prefixCount[summ - target]\n          prefixCount[summ] += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1012, "slug": "numbers-with-repeated-digits", "solutions": ["class Solution:\n    def numDupDigitsAtMostN(self, n: int) -> int:\n        @cache\n        def dfs(i: int, mask: int, lead: bool, limit: bool) -> int:\n            if i >= len(s):\n                return lead ^ 1\n            up = int(s[i]) if limit else 9\n            ans = 0\n            for j in range(up + 1):\n                if lead and j == 0:\n                    ans += dfs(i + 1, mask, True, False)\n                elif mask >> j & 1 ^ 1:\n                    ans += dfs(i + 1, mask | 1 << j, False, limit and j == up)\n            return ans\n\n        s = str(n)\n        return n - dfs(0, 0, True, True)\n", "class Solution:\n  def numDupDigitsAtMostN(self, n: int) -> int:\n    return n - self._countSpecialNumbers(n)\n\n  # Same as 2376. Count Special Integers\n  def _countSpecialNumbers(self, n: int) -> int:\n    s = str(n)\n\n    @functools.lru_cache(None)\n    def dp(i: int, used: int, isTight: bool) -> int:\n      \"\"\"\n      Returns the number of special integers, considering the i-th digit, where\n      `used` is the bitmask of the used digits, and `isTight` indicates if the\n      current digit is tightly bound.\n      \"\"\"\n      if i == len(s):\n        return 1\n\n      res = 0\n      maxDigit = int(s[i]) if isTight else 9\n\n      for d in range(maxDigit + 1):\n        # `d` is used.\n        if used >> d & 1:\n          continue\n        # Use `d` now.\n        nextIsTight = isTight and (d == maxDigit)\n        if used == 0 and d == 0:  # Don't count leading 0s as used.\n          res += dp(i + 1, used, nextIsTight)\n        else:\n          res += dp(i + 1, used | 1 << d, nextIsTight)\n\n      return res\n\n    return dp(0, 0, True) - 1  # - 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1075, "slug": "project-employees-i", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1000, "slug": "minimum-cost-to-merge-stones", "solutions": ["class Solution:\n    def mergeStones(self, stones: List[int], K: int) -> int:\n        n = len(stones)\n        if (n - 1) % (K - 1):\n            return -1\n        s = list(accumulate(stones, initial=0))\n        f = [[[inf] * (K + 1) for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            f[i][i][1] = 0\n        for l in range(2, n + 1):\n            for i in range(1, n - l + 2):\n                j = i + l - 1\n                for k in range(1, K + 1):\n                    for h in range(i, j):\n                        f[i][j][k] = min(f[i][j][k], f[i][h][1] + f[h + 1][j][k - 1])\n                f[i][j][1] = f[i][j][K] + s[j] - s[i - 1]\n        return f[1][n][1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1083, "slug": "sales-analysis-ii", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1098, "slug": "unpopular-books", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1081, "slug": "smallest-subsequence-of-distinct-characters", "solutions": ["class Solution:\n    def smallestSubsequence(self, s: str) -> str:\n        last = {c: i for i, c in enumerate(s)}\n        stk = []\n        vis = set()\n        for i, c in enumerate(s):\n            if c in vis:\n                continue\n            while stk and stk[-1] > c and last[stk[-1]] > i:\n                vis.remove(stk.pop())\n            stk.append(c)\n            vis.add(c)\n        return \"\".join(stk)\n", "class Solution:\n  def smallestSubsequence(self, text: str) -> str:\n    ans = []\n    count = collections.Counter(text)\n    used = [False] * 26\n\n    for c in text:\n      count[c] -= 1\n      if used[ord(c) - ord('a')]:\n        continue\n      while ans and ans[-1] > c and count[ans[-1]] > 0:\n        used[ord(ans[-1]) - ord('a')] = False\n        ans.pop()\n      ans.append(c)\n      used[ord(ans[-1]) - ord('a')] = True\n\n    return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1017, "slug": "convert-to-base-2", "solutions": ["class Solution:\n    def baseNeg2(self, n: int) -> str:\n        k = 1\n        ans = []\n        while n:\n            if n % 2:\n                ans.append('1')\n                n -= k\n            else:\n                ans.append('0')\n            n //= 2\n            k *= -1\n        return ''.join(ans[::-1]) or '0'\n", "class Solution:\n  def baseNeg2(self, n: int) -> str:\n    ans = []\n\n    while n != 0:\n      ans.append(str(n % 2))\n      n = -(n >> 1)\n\n    return ''.join(reversed(ans)) if ans else '0'\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1056, "slug": "confusing-number", "solutions": ["class Solution:\n    def confusingNumber(self, n: int) -> bool:\n        x, y = n, 0\n        d = [0, 1, -1, -1, -1, -1, 9, -1, 8, 6]\n        while x:\n            x, v = divmod(x, 10)\n            if d[v] < 0:\n                return False\n            y = y * 10 + d[v]\n        return y != n\n", "class Solution:\n  def confusingNumber(self, n: int) -> bool:\n    s = str(n)\n    rotated = {'0': '0', '1': '1', '6': '9', '8': '8', '9': '6'}\n    rotatedNum = []\n\n    for c in s[::-1]:\n      if c not in rotated:\n        return False\n      rotatedNum.append(rotated[c])\n\n    return ''.join(rotatedNum) != s\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1013, "slug": "partition-array-into-three-parts-with-equal-sum", "solutions": ["class Solution:\n    def canThreePartsEqualSum(self, arr: List[int]) -> bool:\n        s, mod = divmod(sum(arr), 3)\n        if mod:\n            return False\n        cnt = t = 0\n        for x in arr:\n            t += x\n            if t == s:\n                cnt += 1\n                t = 0\n        return cnt >= 3\n", "class Solution:\n  def canThreePartsEqualSum(self, arr: list[int]) -> bool:\n    summ = sum(arr)\n    if summ % 3 != 0:\n      return False\n\n    average = summ // 3\n    partCount = 0\n    partSum = 0\n\n    for a in arr:\n      partSum += a\n      if partSum == average:\n        partCount += 1\n        partSum = 0\n\n    # edge case: arr = [0, 0, 0, 0] . partCount = 4.\n    return partCount >= 3\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1004, "slug": "max-consecutive-ones-iii", "solutions": ["class Solution:\n    def longestOnes(self, nums: List[int], k: int) -> int:\n        l = cnt = 0\n        for x in nums:\n            cnt += x ^ 1\n            if cnt > k:\n                cnt -= nums[l] ^ 1\n                l += 1\n        return len(nums) - l\n", "class Solution:\n  def longestOnes(self, nums: list[int], k: int) -> int:\n    ans = 0\n\n    l = 0\n    for r, num in enumerate(nums):\n      if num == 0:\n        k -= 1\n      while k < 0:\n        if nums[l] == 0:\n          k += 1\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1097, "slug": "game-play-analysis-v", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1041, "slug": "robot-bounded-in-circle", "solutions": ["class Solution:\n    def isRobotBounded(self, instructions: str) -> bool:\n        k = 0\n        dist = [0] * 4\n        for c in instructions:\n            if c == 'L':\n                k = (k + 1) % 4\n            elif c == 'R':\n                k = (k + 3) % 4\n            else:\n                dist[k] += 1\n        return (dist[0] == dist[2] and dist[1] == dist[3]) or k != 0\n", "class Solution:\n  def isRobotBounded(self, instructions: str) -> bool:\n    x = 0\n    y = 0\n    d = 0\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    for instruction in instructions:\n      if instruction == 'G':\n        x += directions[d][0]\n        y += directions[d][1]\n      elif instruction == 'L':\n        d = (d + 3) % 4\n      else:\n        d = (d + 1) % 4\n\n    return (x, y) == (0, 0) or d > 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1048, "slug": "longest-string-chain", "solutions": ["class Solution:\n    def longestStrChain(self, words: List[str]) -> int:\n        def check(w1, w2):\n            if len(w2) - len(w1) != 1:\n                return False\n            i = j = cnt = 0\n            while i < len(w1) and j < len(w2):\n                if w1[i] != w2[j]:\n                    cnt += 1\n                else:\n                    i += 1\n                j += 1\n            return cnt < 2 and i == len(w1)\n\n        n = len(words)\n        dp = [1] * (n + 1)\n        words.sort(key=lambda x: len(x))\n        res = 1\n        for i in range(1, n):\n            for j in range(i):\n                if check(words[j], words[i]):\n                    dp[i] = max(dp[i], dp[j] + 1)\n            res = max(res, dp[i])\n        return res\n", "class Solution:\n  def longestStrChain(self, words: list[str]) -> int:\n    wordsSet = set(words)\n\n    @functools.lru_cache(None)\n    def dp(s: str) -> int:\n      \"\"\"Returns the longest chain where s is the last word.\"\"\"\n      ans = 1\n      for i in range(len(s)):\n        pred = s[:i] + s[i + 1:]\n        if pred in wordsSet:\n          ans = max(ans, dp(pred) + 1)\n      return ans\n\n    return max(dp(word) for word in words)\n", "class Solution:\n  def longestStrChain(self, words: list[str]) -> int:\n    dp = {}\n\n    for word in sorted(words, key=len):\n      dp[word] = max(dp.get(word[:i] + word[i + 1:], 0) +\n                     1 for i in range(len(word)))\n\n    return max(dp.values())\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1032, "slug": "stream-of-characters", "solutions": ["class Trie:\n    def __init__(self):\n        self.children = [None] * 26\n        self.is_end = False\n\n    def insert(self, w: str):\n        node = self\n        for c in w[::-1]:\n            idx = ord(c) - ord('a')\n            if node.children[idx] is None:\n                node.children[idx] = Trie()\n            node = node.children[idx]\n        node.is_end = True\n\n    def search(self, w: List[str]) -> bool:\n        node = self\n        for c in w[::-1]:\n            idx = ord(c) - ord('a')\n            if node.children[idx] is None:\n                return False\n            node = node.children[idx]\n            if node.is_end:\n                return True\n        return False\n\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.cs = []\n        self.limit = 201\n        for w in words:\n            self.trie.insert(w)\n\n    def query(self, letter: str) -> bool:\n        self.cs.append(letter)\n        return self.trie.search(self.cs[-self.limit :])\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "from dataclasses import dataclass\n\n\n@dataclass\nclass TrieNode:\n  children: dict[str, TrieNode]\n  isWord: bool\n\n\nclass StreamChecker:\n  def __init__(self, words: list[str]):\n    self.root = TrieNode()\n    self.letters = []\n\n    for word in words:\n      self._insert(word)\n\n  def query(self, letter: str) -> bool:\n    self.letters.append(letter)\n    node = self.root\n    for c in reversed(self.letters):\n      if c not in node.children:\n        return False\n      node = node.children[c]\n      if node.isWord:\n        return True\n    return False\n\n  def _insert(self, word: str) -> None:\n    node = self.root\n    for c in reversed(word):\n      node = node.children.setdefault(c, TrieNode())\n    node.isWord = True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1022, "slug": "sum-of-root-to-leaf-binary-numbers", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumRootToLeaf(self, root: TreeNode) -> int:\n        def dfs(root, t):\n            if root is None:\n                return 0\n            t = (t << 1) | root.val\n            if root.left is None and root.right is None:\n                return t\n            return dfs(root.left, t) + dfs(root.right, t)\n\n        return dfs(root, 0)\n", "class Solution:\n  def sumRootToLeaf(self, root: TreeNode | None) -> int:\n    ans = 0\n\n    def dfs(root: TreeNode | None, val: int) -> None:\n      nonlocal ans\n      if not root:\n        return\n      val = val * 2 + root.val\n      if not root.left and not root.right:\n        ans += val\n      dfs(root.left, val)\n      dfs(root.right, val)\n\n    dfs(root, 0)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1064, "slug": "fixed-point", "solutions": ["class Solution:\n    def fixedPoint(self, arr: List[int]) -> int:\n        left, right = 0, len(arr) - 1\n        while left < right:\n            mid = (left + right) >> 1\n            if arr[mid] >= mid:\n                right = mid\n            else:\n                left = mid + 1\n        return left if arr[left] == left else -1\n", "class Solution:\n  def fixedPoint(self, arr: list[int]) -> int:\n    l = 0\n    r = len(arr) - 1\n\n    # Since arr[i] is strictly increasing, arr[i] - i will also be increasing.\n    # Therefore, binary search `arr` for the first arr[i] - i = 0.\n    while l < r:\n      m = (l + r) // 2\n      if arr[m] - m >= 0:\n        r = m\n      else:\n        l = m + 1\n\n    return l if arr[l] == l else -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1090, "slug": "largest-values-from-labels", "solutions": ["class Solution:\n    def largestValsFromLabels(\n        self, values: List[int], labels: List[int], numWanted: int, useLimit: int\n    ) -> int:\n        ans = num = 0\n        cnt = Counter()\n        for v, l in sorted(zip(values, labels), reverse=True):\n            if cnt[l] < useLimit:\n                cnt[l] += 1\n                num += 1\n                ans += v\n                if num == numWanted:\n                    break\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1018, "slug": "binary-prefix-divisible-by-5", "solutions": ["class Solution:\n    def prefixesDivBy5(self, nums: List[int]) -> List[bool]:\n        ans = []\n        x = 0\n        for v in nums:\n            x = (x << 1 | v) % 5\n            ans.append(x == 0)\n        return ans\n", "class Solution:\n  def prefixesDivBy5(self, nums: list[int]) -> list[bool]:\n    ans = []\n    curr = 0\n\n    for num in nums:\n      curr = (curr * 2 + num) % 5\n      ans.append(curr % 5 == 0)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1077, "slug": "project-employees-iii", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1063, "slug": "number-of-valid-subarrays", "solutions": ["class Solution:\n    def validSubarrays(self, nums: List[int]) -> int:\n        n = len(nums)\n        right = [n] * n\n        stk = []\n        for i in range(n - 1, -1, -1):\n            while stk and nums[stk[-1]] >= nums[i]:\n                stk.pop()\n            if stk:\n                right[i] = stk[-1]\n            stk.append(i)\n        return sum(j - i for i, j in enumerate(right))\n", "class Solution:\n  def validSubarrays(self, nums: list[int]) -> int:\n    # For each `num` in `nums`, each element x in the stack can be the leftmost\n    # element s.t. [x, num] forms a valid subarray, so the size of the stack is\n    # the number of valid subarrays ending in the current number.\n    #\n    # e.g. nums = [1, 3, 2]\n    # num = 1, stack = [1] -> valid subarray is [1]\n    # num = 3, stack = [1, 3] -> valid subarrays are [1, 3], [3]\n    # num = 2, stack = [1, 2] -> valid subarrays are [1, 3, 2], [2]\n    ans = 0\n    stack = []\n\n    for num in nums:\n      while stack and stack[-1] > num:\n        stack.pop()\n      stack.append(num)\n      ans += len(stack)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1029, "slug": "two-city-scheduling", "solutions": ["class Solution:\n    def twoCitySchedCost(self, costs: List[List[int]]) -> int:\n        costs.sort(key=lambda x: x[0] - x[1])\n        n = len(costs) >> 1\n        return sum(costs[i][0] + costs[i + n][1] for i in range(n))\n", "class Solution:\n  def twoCitySchedCost(self, costs: list[list[int]]) -> int:\n    n = len(costs) // 2\n\n    # How much money can we save if we fly a person to A instead of B?\n    # To save money, we should\n    #   1. Fly the person with the maximum saving to A.\n    #   2. Fly the person with the minimum saving to B.\n\n    # Sort `costs` in ascending order by the money saved if we fly a person to\n    # B instead of A.\n    costs.sort(key=lambda x: x[0] - x[1])\n    return sum(costs[i][0] + costs[i + n][1] for i in range(n))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1054, "slug": "distant-barcodes", "solutions": ["class Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        cnt = Counter(barcodes)\n        barcodes.sort(key=lambda x: (-cnt[x], x))\n        n = len(barcodes)\n        ans = [0] * len(barcodes)\n        ans[::2] = barcodes[: (n + 1) // 2]\n        ans[1::2] = barcodes[(n + 1) // 2 :]\n        return ans\n", "class Solution:\n  def rearrangeBarcodes(self, barcodes: list[int]) -> list[int]:\n    ans = [0] * len(barcodes)\n    count = collections.Counter(barcodes)\n    i = 0  # ans' index\n    maxNum = max(count, key=count.get)\n\n    def fillAns(num: int) -> None:\n      nonlocal i\n      while count[num]:\n        ans[i] = num\n        i = i + 2 if i + 2 < len(barcodes) else 1\n        count[num] -= 1\n\n    fillAns(maxNum)\n    for num in count.keys():\n      fillAns(num)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1092, "slug": "shortest-common-supersequence", "solutions": ["class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        m, n = len(str1), len(str2)\n        f = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if str1[i - 1] == str2[j - 1]:\n                    f[i][j] = f[i - 1][j - 1] + 1\n                else:\n                    f[i][j] = max(f[i - 1][j], f[i][j - 1])\n        ans = []\n        i, j = m, n\n        while i or j:\n            if i == 0:\n                j -= 1\n                ans.append(str2[j])\n            elif j == 0:\n                i -= 1\n                ans.append(str1[i])\n            else:\n                if f[i][j] == f[i - 1][j]:\n                    i -= 1\n                    ans.append(str1[i])\n                elif f[i][j] == f[i][j - 1]:\n                    j -= 1\n                    ans.append(str2[j])\n                else:\n                    i, j = i - 1, j - 1\n                    ans.append(str1[i])\n        return ''.join(ans[::-1])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1072, "slug": "flip-columns-for-maximum-number-of-equal-rows", "solutions": ["class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        cnt = Counter()\n        for row in matrix:\n            t = tuple(row) if row[0] == 0 else tuple(x ^ 1 for x in row)\n            cnt[t] += 1\n        return max(cnt.values())\n", "class Solution:\n  def maxEqualRowsAfterFlips(self, matrix: list[list[int]]) -> int:\n    patterns = [tuple(a ^ row[0] for a in row) for row in matrix]\n    return max(Counter(patterns).values())\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1078, "slug": "occurrences-after-bigram", "solutions": ["class Solution:\n    def findOcurrences(self, text: str, first: str, second: str) -> List[str]:\n        words = text.split()\n        ans = []\n        for i in range(len(words) - 2):\n            a, b, c = words[i : i + 3]\n            if a == first and b == second:\n                ans.append(c)\n        return ans\n", "class Solution:\n  def findOcurrences(self, text: str, first: str, second: str) -> list[str]:\n    words = text.split()\n    return [c for a, b, c in zip(words, words[1:], words[2:]) if a == first and b == second]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1069, "slug": "product-sales-analysis-ii", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1010, "slug": "pairs-of-songs-with-total-durations-divisible-by-60", "solutions": ["class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        cnt = Counter(t % 60 for t in time)\n        ans = sum(cnt[x] * cnt[60 - x] for x in range(1, 30))\n        ans += cnt[0] * (cnt[0] - 1) // 2\n        ans += cnt[30] * (cnt[30] - 1) // 2\n        return ans\n", "class Solution:\n  def numPairsDivisibleBy60(self, time: list[int]) -> int:\n    ans = 0\n    count = [0] * 60\n\n    for t in time:\n      t %= 60\n      ans += count[(60 - t) % 60]\n      count[t] += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1030, "slug": "matrix-cells-in-distance-order", "solutions": ["class Solution:\n    def allCellsDistOrder(\n        self, rows: int, cols: int, rCenter: int, cCenter: int\n    ) -> List[List[int]]:\n        q = deque([[rCenter, cCenter]])\n        vis = [[False] * cols for _ in range(rows)]\n        vis[rCenter][cCenter] = True\n        ans = []\n        while q:\n            for _ in range(len(q)):\n                p = q.popleft()\n                ans.append(p)\n                for a, b in pairwise((-1, 0, 1, 0, -1)):\n                    x, y = p[0] + a, p[1] + b\n                    if 0 <= x < rows and 0 <= y < cols and not vis[x][y]:\n                        vis[x][y] = True\n                        q.append([x, y])\n        return ans\n", "class Solution:\n  def allCellsDistOrder(self, rows: int, cols: int, rCenter: int, cCenter: int) -> list[list[int]]:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    ans = []\n    q = collections.deque([(rCenter, cCenter)])\n    seen = {(rCenter, cCenter)}\n\n    while q:\n      i, j = q.popleft()\n      ans.append([i, j])\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == rows or y < 0 or y == cols:\n          continue\n        if (x, y) in seen:\n          continue\n        seen.add((x, y))\n        q.append((x, y))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1035, "slug": "uncrossed-lines", "solutions": ["class Solution:\n    def maxUncrossedLines(self, nums1: List[int], nums2: List[int]) -> int:\n        m, n = len(nums1), len(nums2)\n        f = [[0] * (n + 1) for _ in range(m + 1)]\n        for i, x in enumerate(nums1, 1):\n            for j, y in enumerate(nums2, 1):\n                if x == y:\n                    f[i][j] = f[i - 1][j - 1] + 1\n                else:\n                    f[i][j] = max(f[i - 1][j], f[i][j - 1])\n        return f[m][n]\n", "class Solution:\n  def maxUncrossedLines(self, nums1: list[int], nums2: list[int]) -> int:\n    m = len(nums1)\n    n = len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        dp[i][j] = (dp[i - 1][j - 1] + 1\n                    if nums1[i - 1] == nums2[j - 1]\n                    else max(dp[i - 1][j], dp[i][j - 1]))\n\n    return dp[m][n]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1020, "slug": "number-of-enclaves", "solutions": ["class Solution:\n    def numEnclaves(self, grid: List[List[int]]) -> int:\n        def dfs(i: int, j: int):\n            grid[i][j] = 0\n            for a, b in pairwise(dirs):\n                x, y = i + a, j + b\n                if 0 <= x < m and 0 <= y < n and grid[x][y]:\n                    dfs(x, y)\n\n        m, n = len(grid), len(grid[0])\n        dirs = (-1, 0, 1, 0, -1)\n        for j in range(n):\n            for i in (0, m - 1):\n                if grid[i][j]:\n                    dfs(i, j)\n        for i in range(m):\n            for j in (0, n - 1):\n                if grid[i][j]:\n                    dfs(i, j)\n        return sum(sum(row) for row in grid)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1089, "slug": "duplicate-zeros", "solutions": ["class Solution:\n    def duplicateZeros(self, arr: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify arr in-place instead.\n        \"\"\"\n        n = len(arr)\n        i, k = -1, 0\n        while k < n:\n            i += 1\n            k += 1 if arr[i] else 2\n        j = n - 1\n        if k == n + 1:\n            arr[j] = 0\n            i, j = i - 1, j - 1\n        while ~j:\n            if arr[i] == 0:\n                arr[j] = arr[j - 1] = arr[i]\n                j -= 1\n            else:\n                arr[j] = arr[i]\n            i, j = i - 1, j - 1\n", "class Solution:\n  def duplicateZeros(self, arr: list[int]) -> None:\n    zeros = arr.count(0)\n    i = len(arr) - 1\n    j = len(arr) + zeros - 1\n\n    while i < j:\n      if j < len(arr):\n        arr[j] = arr[i]\n      if arr[i] == 0:\n        j -= 1\n        if j < len(arr):\n          arr[j] = arr[i]\n      i -= 1\n      j -= 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1021, "slug": "remove-outermost-parentheses", "solutions": ["class Solution:\n    def removeOuterParentheses(self, s: str) -> str:\n        ans = []\n        cnt = 0\n        for c in s:\n            if c == '(':\n                cnt += 1\n                if cnt > 1:\n                    ans.append(c)\n            else:\n                cnt -= 1\n                if cnt > 0:\n                    ans.append(c)\n        return ''.join(ans)\n", "class Solution:\n  def removeOuterParentheses(self, s: str) -> str:\n    ans = []\n    opened = 0\n\n    for c in s:\n      if c == '(':\n        opened += 1\n        if opened > 1:\n          ans.append(c)\n      else:  # c == ')'\n        opened -= 1\n        if opened > 0:\n          ans.append(c)\n\n    return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1055, "slug": "shortest-way-to-form-string", "solutions": ["class Solution:\n    def shortestWay(self, source: str, target: str) -> int:\n        def f(i, j):\n            while i < m and j < n:\n                if source[i] == target[j]:\n                    j += 1\n                i += 1\n            return j\n\n        m, n = len(source), len(target)\n        ans = j = 0\n        while j < n:\n            k = f(0, j)\n            if k == j:\n                return -1\n            j = k\n            ans += 1\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1015, "slug": "smallest-integer-divisible-by-k", "solutions": ["class Solution:\n    def smallestRepunitDivByK(self, k: int) -> int:\n        n = 1 % k\n        for i in range(1, k + 1):\n            if n == 0:\n                return i\n            n = (n * 10 + 1) % k\n        return -1\n", "class Solution:\n  def smallestRepunitDivByK(self, k: int) -> int:\n    if k % 10 not in {1, 3, 7, 9}:\n      return -1\n\n    seen = set()\n    n = 0\n\n    for length in range(1, k + 1):\n      n = (n * 10 + 1) % k\n      if n == 0:\n        return length\n      if n in seen:\n        return -1\n      seen.add(n)\n\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1007, "slug": "minimum-domino-rotations-for-equal-row", "solutions": ["class Solution:\n    def minDominoRotations(self, tops: List[int], bottoms: List[int]) -> int:\n        def f(x: int) -> int:\n            cnt1 = cnt2 = 0\n            for a, b in zip(tops, bottoms):\n                if x not in (a, b):\n                    return inf\n                cnt1 += a == x\n                cnt2 += b == x\n            return len(tops) - max(cnt1, cnt2)\n\n        ans = min(f(tops[0]), f(bottoms[0]))\n        return -1 if ans == inf else ans\n", "class Solution:\n  def minDominoRotations(self, tops: list[int], bottoms: list[int]) -> int:\n    for num in range(1, 7):\n      if all(num in pair for pair in zip(tops, bottoms)):\n        return len(tops) - max(tops.count(num), bottoms.count(num))\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1045, "slug": "customers-who-bought-all-products", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1031, "slug": "maximum-sum-of-two-non-overlapping-subarrays", "solutions": ["class Solution:\n    def maxSumTwoNoOverlap(self, nums: List[int], firstLen: int, secondLen: int) -> int:\n        n = len(nums)\n        s = list(accumulate(nums, initial=0))\n        ans = t = 0\n        i = firstLen\n        while i + secondLen - 1 < n:\n            t = max(t, s[i] - s[i - firstLen])\n            ans = max(ans, t + s[i + secondLen] - s[i])\n            i += 1\n        t = 0\n        i = secondLen\n        while i + firstLen - 1 < n:\n            t = max(t, s[i] - s[i - secondLen])\n            ans = max(ans, t + s[i + firstLen] - s[i])\n            i += 1\n        return ans\n", "class Solution:\n  def maxSumTwoNoOverlap(\n      self,\n      nums: list[int],\n      firstLen: int,\n      secondLen: int,\n  ) -> int:\n    def helper(l: int, r: int) -> int:\n      n = len(nums)\n      left = [0] * n\n      summ = 0\n\n      for i in range(n):\n        summ += nums[i]\n        if i >= l:\n          summ -= nums[i - l]\n        if i >= l - 1:\n          left[i] = max(left[i - 1], summ) if i > 0 else summ\n\n      right = [0] * n\n      summ = 0\n\n      for i in reversed(range(n)):\n        summ += nums[i]\n        if i <= n - r - 1:\n          summ -= nums[i + r]\n        if i <= n - r:\n          right[i] = max(right[i + 1], summ) if i < n - 1 else summ\n\n      return max(left[i] + right[i + 1] for i in range(n - 1))\n\n    return max(helper(firstLen, secondLen), helper(secondLen, firstLen))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1047, "slug": "remove-all-adjacent-duplicates-in-string", "solutions": ["class Solution:\n    def removeDuplicates(self, s: str) -> str:\n        stk = []\n        for c in s:\n            if stk and stk[-1] == c:\n                stk.pop()\n            else:\n                stk.append(c)\n        return ''.join(stk)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1096, "slug": "brace-expansion-ii", "solutions": ["class Solution:\n    def braceExpansionII(self, expression: str) -> List[str]:\n        def dfs(exp):\n            j = exp.find('}')\n            if j == -1:\n                s.add(exp)\n                return\n            i = exp.rfind('{', 0, j - 1)\n            a, c = exp[:i], exp[j + 1 :]\n            for b in exp[i + 1 : j].split(','):\n                dfs(a + b + c)\n\n        s = set()\n        dfs(expression)\n        return sorted(s)\n", "class Solution:\n  def braceExpansionII(self, expression: str) -> list[str]:\n    def merge(groups: list[list[str]], group: list[str]) -> None:\n      if not groups[-1]:\n        groups[-1] = group\n        return\n\n      groups[-1] = [word1 + word2 for word1 in groups[-1]\n                    for word2 in group]\n\n    def dfs(s: int, e: int) -> list[str]:\n      groups = [[]]\n      layer = 0\n\n      for i in range(s, e + 1):\n        c = expression[i]\n        if c == '{':\n          layer += 1\n          if layer == 1:\n            left = i + 1\n        elif c == '}':\n          layer -= 1\n          if layer == 0:\n            group = dfs(left, i - 1)\n            merge(groups, group)\n        elif c == ',' and layer == 0:\n          groups.append([])\n        elif layer == 0:\n          merge(groups, [c])\n\n      return sorted(list({word for group in groups for word in group}))\n\n    return dfs(0, len(expression) - 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1025, "slug": "divisor-game", "solutions": ["class Solution:\n    def divisorGame(self, n: int) -> bool:\n        return n % 2 == 0\n", "class Solution:\n  def divisorGame(self, n: int) -> bool:\n    return n % 2 == 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1033, "slug": "moving-stones-until-consecutive", "solutions": ["class Solution:\n    def numMovesStones(self, a: int, b: int, c: int) -> List[int]:\n        x, z = min(a, b, c), max(a, b, c)\n        y = a + b + c - x - z\n        mi = mx = 0\n        if z - x > 2:\n            mi = 1 if y - x < 3 or z - y < 3 else 2\n            mx = z - x - 2\n        return [mi, mx]\n", "class Solution:\n  def numMovesStones(self, a: int, b: int, c: int) -> list[int]:\n    nums = sorted([a, b, c])\n\n    if nums[2] - nums[0] == 2:\n      return [0, 0]\n    return [1 if min(nums[1] - nums[0], nums[2] - nums[1]) <= 2 else 2,\n            nums[2] - nums[0] - 2]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1084, "slug": "sales-analysis-iii", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1001, "slug": "grid-illumination", "solutions": ["class Solution:\n    def gridIllumination(\n        self, n: int, lamps: List[List[int]], queries: List[List[int]]\n    ) -> List[int]:\n        s = {(i, j) for i, j in lamps}\n        row, col, diag1, diag2 = Counter(), Counter(), Counter(), Counter()\n        for i, j in s:\n            row[i] += 1\n            col[j] += 1\n            diag1[i - j] += 1\n            diag2[i + j] += 1\n        ans = [0] * len(queries)\n        for k, (i, j) in enumerate(queries):\n            if row[i] or col[j] or diag1[i - j] or diag2[i + j]:\n                ans[k] = 1\n            for x in range(i - 1, i + 2):\n                for y in range(j - 1, j + 2):\n                    if (x, y) in s:\n                        s.remove((x, y))\n                        row[x] -= 1\n                        col[y] -= 1\n                        diag1[x - y] -= 1\n                        diag2[x + y] -= 1\n        return ans\n", "class Solution:\n  def gridIllumination(\n      self,\n      n: int,\n      lamps: list[list[int]],\n      queries: list[list[int]],\n  ) -> list[int]:\n    ans = []\n    rows = collections.Counter()\n    cols = collections.Counter()\n    diag1 = collections.Counter()\n    diag2 = collections.Counter()\n    lampsSet = set()\n\n    for i, j in lamps:\n      if (i, j) not in lampsSet:\n        lampsSet.add((i, j))\n        rows[i] += 1\n        cols[j] += 1\n        diag1[i + j] += 1\n        diag2[i - j] += 1\n\n    for i, j in queries:\n      if rows[i] or cols[j] or diag1[i + j] or diag2[i - j]:\n        ans.append(1)\n        for y in range(max(0, i - 1), min(n, i + 2)):\n          for x in range(max(0, j - 1), min(n, j + 2)):\n            if (y, x) in lampsSet:\n              lampsSet.remove((y, x))\n              rows[y] -= 1\n              cols[x] -= 1\n              diag1[y + x] -= 1\n              diag2[y - x] -= 1\n      else:\n        ans.append(0)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1099, "slug": "two-sum-less-than-k", "solutions": ["class Solution:\n    def twoSumLessThanK(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        ans = -1\n        for i, x in enumerate(nums):\n            j = bisect_left(nums, k - x, lo=i + 1) - 1\n            if i < j:\n                ans = max(ans, x + nums[j])\n        return ans\n", "class Solution:\n  def twoSumLessThanK(self, nums: list[int], k: int) -> int:\n    if len(nums) < 2:\n      return -1\n\n    ans = -1  # Note the constrathat nums[i] > 0.\n    l = 0\n    r = len(nums) - 1\n\n    nums.sort()\n\n    while l < r:\n      if nums[l] + nums[r] < k:\n        ans = max(ans, nums[l] + nums[r])\n        l += 1\n      else:\n        r -= 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1040, "slug": "moving-stones-until-consecutive-ii", "solutions": ["class Solution:\n    def numMovesStonesII(self, stones: List[int]) -> List[int]:\n        stones.sort()\n        mi = n = len(stones)\n        mx = max(stones[-1] - stones[1] + 1, stones[-2] - stones[0] + 1) - (n - 1)\n        i = 0\n        for j, x in enumerate(stones):\n            while x - stones[i] + 1 > n:\n                i += 1\n            if j - i + 1 == n - 1 and x - stones[i] == n - 2:\n                mi = min(mi, 2)\n            else:\n                mi = min(mi, n - (j - i + 1))\n        return [mi, mx]\n", "class Solution:\n  def numMovesStonesII(self, stones: list[int]) -> list[int]:\n    n = len(stones)\n    minMoves = n\n\n    stones.sort()\n\n    l = 0\n    for r, stone in enumerate(stones):\n      while stone - stones[l] + 1 > n:\n        l += 1\n      alreadyStored = r - l + 1\n      if alreadyStored == n - 1 and stone - stones[l] + 1 == n - 1:\n        minMoves = 2\n      else:\n        minMoves = min(minMoves, n - alreadyStored)\n\n    return [minMoves, max(stones[n - 1] - stones[1] - n + 2, stones[n - 2] - stones[0] - n + 2)]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1034, "slug": "coloring-a-border", "solutions": ["class Solution:\n    def colorBorder(\n        self, grid: List[List[int]], row: int, col: int, color: int\n    ) -> List[List[int]]:\n        def dfs(i: int, j: int, c: int) -> None:\n            vis[i][j] = True\n            for a, b in pairwise((-1, 0, 1, 0, -1)):\n                x, y = i + a, j + b\n                if 0 <= x < m and 0 <= y < n:\n                    if not vis[x][y]:\n                        if grid[x][y] == c:\n                            dfs(x, y, c)\n                        else:\n                            grid[i][j] = color\n                else:\n                    grid[i][j] = color\n\n        m, n = len(grid), len(grid[0])\n        vis = [[False] * n for _ in range(m)]\n        dfs(row, col, grid[row][col])\n        return grid\n", "class Solution:\n  def colorBorder(\n      self,\n      grid: list[list[int]],\n      r0: int,\n      c0: int,\n      color: int\n  ) -> list[list[int]]:\n    def dfs(i: int, j: int, startColor: int) -> None:\n      if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]):\n        return\n      if grid[i][j] != startColor:\n        return\n\n      grid[i][j] = -startColor\n      dfs(i + 1, j, startColor)\n      dfs(i - 1, j, startColor)\n      dfs(i, j + 1, startColor)\n      dfs(i, j - 1, startColor)\n\n      # If this cell is already on the boarder, it must be painted later.\n      if i == 0 or i == len(grid) - 1 or j == 0 or j == len(grid[0]) - 1:\n        return\n\n      if (abs(grid[i + 1][j]) == startColor and\n          abs(grid[i - 1][j]) == startColor and\n          abs(grid[i][j + 1]) == startColor and\n              abs(grid[i][j - 1]) == startColor):\n        grid[i][j] = startColor\n\n    dfs(r0, c0, grid[r0][c0])\n\n    for i, row in enumerate(grid):\n      for j, num in enumerate(row):\n        if num < 0:\n          grid[i][j] = color\n\n    return grid\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1027, "slug": "longest-arithmetic-subsequence", "solutions": ["class Solution:\n    def longestArithSeqLength(self, nums: List[int]) -> int:\n        n = len(nums)\n        f = [[1] * 1001 for _ in range(n)]\n        ans = 0\n        for i in range(1, n):\n            for k in range(i):\n                j = nums[i] - nums[k] + 500\n                f[i][j] = max(f[i][j], f[k][j] + 1)\n                ans = max(ans, f[i][j])\n        return ans\n", "class Solution:\n  def longestArithSeqLength(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = 0\n    # dp[i][k] := the length of the longest arithmetic subsequence of nums[0..i]\n    # with k = diff + 500\n    dp = [[0] * 1001 for _ in range(n)]\n\n    for i in range(n):\n      for j in range(i):\n        k = nums[i] - nums[j] + 500\n        dp[i][k] = max(2, dp[j][k] + 1)\n        ans = max(ans, dp[i][k])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1009, "slug": "complement-of-base-10-integer", "solutions": ["class Solution:\n    def bitwiseComplement(self, n: int) -> int:\n        if n == 0:\n            return 1\n        ans = i = 0\n        while n:\n            ans |= (n & 1 ^ 1) << i\n            i += 1\n            n >>= 1\n        return ans\n", "class Solution:\n  def bitwiseComplement(self, n: int) -> int:\n    mask = 1\n    while mask < n:\n      mask = (mask << 1) + 1\n    return mask ^ n\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1071, "slug": "greatest-common-divisor-of-strings", "solutions": ["class Solution:\n    def gcdOfStrings(self, str1: str, str2: str) -> str:\n        def check(a, b):\n            c = \"\"\n            while len(c) < len(b):\n                c += a\n            return c == b\n\n        for i in range(min(len(str1), len(str2)), 0, -1):\n            t = str1[:i]\n            if check(t, str1) and check(t, str2):\n                return t\n        return ''\n", "class Solution:\n  def gcdOfStrings(self, str1: str, str2: str) -> str:\n    def mod(s1: str, s2: str) -> str:\n      while s1.startswith(s2):\n        s1 = s1[len(s2):]\n      return s1\n\n    if len(str1) < len(str2):\n      return self.gcdOfStrings(str2, str1)\n    if not str1.startswith(str2):\n      return ''\n    if not str2:\n      return str1\n    return self.gcdOfStrings(str2, mod(str1, str2))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1085, "slug": "sum-of-digits-in-the-minimum-number", "solutions": ["class Solution:\n    def sumOfDigits(self, nums: List[int]) -> int:\n        x = min(nums)\n        s = 0\n        while x:\n            s += x % 10\n            x //= 10\n        return s & 1 ^ 1\n", "class Solution:\n  def sumOfDigits(self, nums: list[int]) -> int:\n    return sum(int(d) for d in str(min(nums))) & 1 ^ 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1014, "slug": "best-sightseeing-pair", "solutions": ["class Solution:\n    def maxScoreSightseeingPair(self, values: List[int]) -> int:\n        ans = mx = 0\n        for j, x in enumerate(values):\n            ans = max(ans, mx + x - j)\n            mx = max(mx, x + j)\n        return ans\n", "class Solution:\n  def maxScoreSightseeingPair(self, values: list[int]) -> int:\n    ans = 0\n    bestPrev = 0\n\n    for value in values:\n      ans = max(ans, value + bestPrev)\n      bestPrev = max(bestPrev, value) - 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1050, "slug": "actors-and-directors-who-cooperated-at-least-three-times", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1068, "slug": "product-sales-analysis-i", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1087, "slug": "brace-expansion", "solutions": ["class Solution:\n    def expand(self, s: str) -> List[str]:\n        def convert(s):\n            if not s:\n                return\n            if s[0] == '{':\n                j = s.find('}')\n                items.append(s[1:j].split(','))\n                convert(s[j + 1 :])\n            else:\n                j = s.find('{')\n                if j != -1:\n                    items.append(s[:j].split(','))\n                    convert(s[j:])\n                else:\n                    items.append(s.split(','))\n\n        def dfs(i, t):\n            if i == len(items):\n                ans.append(''.join(t))\n                return\n            for c in items[i]:\n                t.append(c)\n                dfs(i + 1, t)\n                t.pop()\n\n        items = []\n        convert(s)\n        ans = []\n        dfs(0, [])\n        ans.sort()\n        return ans\n", "class Solution:\n  def expand(self, s: str) -> list[str]:\n    ans = []\n\n    def dfs(i: int, path: list[str]) -> None:\n      if i == len(s):\n        ans.append(''.join(path))\n        return\n      if s[i] == '{':\n        nextRightBraceIndex = s.find('}', i)\n        for c in s[i + 1:nextRightBraceIndex].split(','):\n          path.append(c)\n          dfs(nextRightBraceIndex + 1, path)\n          path.pop()\n      else:  # s[i] != '{'\n        path.append(s[i])\n        dfs(i + 1, path)\n        path.pop()\n\n    dfs(0, [])\n    return sorted(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1008, "slug": "construct-binary-search-tree-from-preorder-traversal", "solutions": ["class Solution:\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\n        def dfs(i: int, j: int) -> Optional[TreeNode]:\n            if i > j:\n                return None\n            root = TreeNode(preorder[i])\n            l, r = i + 1, j + 1\n            while l < r:\n                mid = (l + r) >> 1\n                if preorder[mid] > preorder[i]:\n                    r = mid\n                else:\n                    l = mid + 1\n            root.left = dfs(i + 1, l - 1)\n            root.right = dfs(l, j)\n            return root\n\n        return dfs(0, len(preorder) - 1)\n", "class Solution:\n  def bstFromPreorder(self, preorder: list[int]) -> TreeNode | None:\n    root = TreeNode(preorder[0])\n    stack = [root]\n\n    for i in range(1, len(preorder)):\n      parent = stack[-1]\n      child = TreeNode(preorder[i])\n      # Adjust the parent.\n      while stack and stack[-1].val < child.val:\n        parent = stack.pop()\n      # Create parent-child link according to BST property.\n      if parent.val > child.val:\n        parent.left = child\n      else:\n        parent.right = child\n      stack.append(child)\n\n    return root\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1026, "slug": "maximum-difference-between-node-and-ancestor", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:\n        def dfs(root: Optional[TreeNode], mi: int, mx: int):\n            if root is None:\n                return\n            nonlocal ans\n            ans = max(ans, abs(mi - root.val), abs(mx - root.val))\n            mi = min(mi, root.val)\n            mx = max(mx, root.val)\n            dfs(root.left, mi, mx)\n            dfs(root.right, mi, mx)\n\n        ans = 0\n        dfs(root, root.val, root.val)\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1057, "slug": "campus-bikes", "solutions": ["class Solution:\n    def assignBikes(\n        self, workers: List[List[int]], bikes: List[List[int]]\n    ) -> List[int]:\n        n, m = len(workers), len(bikes)\n        arr = []\n        for i, j in product(range(n), range(m)):\n            dist = abs(workers[i][0] - bikes[j][0]) + abs(workers[i][1] - bikes[j][1])\n            arr.append((dist, i, j))\n        arr.sort()\n        vis1 = [False] * n\n        vis2 = [False] * m\n        ans = [0] * n\n        for _, i, j in arr:\n            if not vis1[i] and not vis2[j]:\n                vis1[i] = vis2[j] = True\n                ans[i] = j\n        return ans\n", "class Solution:\n  def assignBikes(\n      self,\n      workers: list[list[int]],\n      bikes: list[list[int]],\n  ) -> list[int]:\n    ans = [-1] * len(workers)\n    usedBikes = [False] * len(bikes)\n    # buckets[k] := (i, j), where k = dist(workers[i], bikes[j])\n    buckets = [[] for _ in range(2001)]\n\n    def dist(p1: list[int], p2: list[int]) -> int:\n      return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    for i, worker in enumerate(workers):\n      for j, bike in enumerate(bikes):\n        buckets[dist(worker, bike)].append((i, j))\n\n    for k in range(2001):\n      for i, j in buckets[k]:\n        if ans[i] == -1 and not usedBikes[j]:\n          ans[i] = j\n          usedBikes[j] = True\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1070, "slug": "product-sales-analysis-iii", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1086, "slug": "high-five", "solutions": ["class Solution:\n    def highFive(self, items: List[List[int]]) -> List[List[int]]:\n        d = defaultdict(list)\n        m = 0\n        for i, x in items:\n            d[i].append(x)\n            m = max(m, i)\n        ans = []\n        for i in range(1, m + 1):\n            if xs := d[i]:\n                avg = sum(nlargest(5, xs)) // 5\n                ans.append([i, avg])\n        return ans\n", "class Solution:\n  def highFive(self, items: list[list[int]]) -> list[list[int]]:\n    idToScores = collections.defaultdict(list)\n\n    for id, score in items:\n      heapq.heappush(idToScores[id], score)\n      if len(idToScores[id]) > 5:\n        heapq.heappop(idToScores[id])\n\n    return [[id, sum(scores) // 5] for id, scores in sorted(idToScores.items())]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1036, "slug": "escape-a-large-maze", "solutions": ["class Solution:\n    def isEscapePossible(\n        self, blocked: List[List[int]], source: List[int], target: List[int]\n    ) -> bool:\n        def dfs(source, target, seen):\n            x, y = source\n            if (\n                not (0 <= x < 10**6 and 0 <= y < 10**6)\n                or (x, y) in blocked\n                or (x, y) in seen\n            ):\n                return False\n            seen.add((x, y))\n            if len(seen) > 20000 or source == target:\n                return True\n            for a, b in [[0, -1], [0, 1], [1, 0], [-1, 0]]:\n                next = [x + a, y + b]\n                if dfs(next, target, seen):\n                    return True\n            return False\n\n        blocked = set((x, y) for x, y in blocked)\n        return dfs(source, target, set()) and dfs(target, source, set())\n", "class Solution:\n  def isEscapePossible(\n      self,\n      blocked: list[list[int]],\n      source: list[int],\n      target: list[int]\n  ) -> bool:\n    def dfs(i: int, j: int, target: list[int], seen: set) -> bool:\n      if i < 0 or i >= 10**6 or j < 0 or j >= 10**6:\n        return False\n      if (i, j) in blocked or (i, j) in seen:\n        return False\n      seen.add((i, j))\n      return (len(seen) > (1 + 199) * 199 // 2 or [i, j] == target or\n              dfs(i + 1, j, target, seen) or\n              dfs(i - 1, j, target, seen) or\n              dfs(i, j + 1, target, seen) or\n              dfs(i, j - 1, target, seen))\n\n    blocked = set(tuple(b) for b in blocked)\n    return (dfs(source[0], source[1], target, set()) and\n            dfs(target[0], target[1], source, set()))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1094, "slug": "car-pooling", "solutions": ["class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        mx = max(e[2] for e in trips)\n        d = [0] * (mx + 1)\n        for x, f, t in trips:\n            d[f] += x\n            d[t] -= x\n        return all(s <= capacity for s in accumulate(d))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1044, "slug": "longest-duplicate-substring", "solutions": ["class Solution:\n    def longestDupSubstring(self, s: str) -> str:\n        def check(l):\n            vis = set()\n            for i in range(n - l + 1):\n                t = s[i : i + l]\n                if t in vis:\n                    return t\n                vis.add(t)\n            return ''\n\n        n = len(s)\n        left, right = 0, n\n        ans = ''\n        while left < right:\n            mid = (left + right + 1) >> 1\n            t = check(mid)\n            ans = t or ans\n            if t:\n                left = mid\n            else:\n                right = mid - 1\n        return ans\n", "class Solution:\n  def longestDupSubstring(self, s: str) -> str:\n    BASE = 26\n    HASH = 1_000_000_007\n    bestStart = -1\n    l = 1\n    r = len(s)\n\n    def val(c: str) -> int:\n      return ord(c) - ord('a')\n\n    # k := the length of the substring to be hashed\n    def getStart(k: int) -> int | None:\n      maxPow = pow(BASE, k - 1, HASH)\n      hashToStart = collections.defaultdict(list)\n      h = 0\n\n      # Compute the hash value of s[:k].\n      for i in range(k):\n        h = (h * BASE + val(s[i])) % HASH\n      hashToStart[h].append(0)\n\n      # Compute the rolling hash by Rabin Karp.\n      for i in range(k, len(s)):\n        startIndex = i - k + 1\n        h = (h - maxPow * val(s[i - k])) % HASH\n        h = (h * BASE + val(s[i])) % HASH\n        if h in hashToStart:\n          currSub = s[startIndex:startIndex + k]\n          for start in hashToStart[h]:\n            if s[start:start + k] == currSub:\n              return startIndex\n        hashToStart[h].append(startIndex)\n\n    while l < r:\n      m = (l + r) // 2\n      start: int | None = getStart(m)\n      if start:\n        bestStart = start\n        l = m + 1\n      else:\n        r = m\n\n    if bestStart == -1:\n      return ''\n    if getStart(l):\n      return s[bestStart:bestStart + l]\n    return s[bestStart:bestStart + l - 1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1091, "slug": "shortest-path-in-binary-matrix", "solutions": ["class Solution:\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\n        if grid[0][0]:\n            return -1\n        n = len(grid)\n        grid[0][0] = 1\n        q = deque([(0, 0)])\n        ans = 1\n        while q:\n            for _ in range(len(q)):\n                i, j = q.popleft()\n                if i == j == n - 1:\n                    return ans\n                for x in range(i - 1, i + 2):\n                    for y in range(j - 1, j + 2):\n                        if 0 <= x < n and 0 <= y < n and grid[x][y] == 0:\n                            grid[x][y] = 1\n                            q.append((x, y))\n            ans += 1\n        return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1016, "slug": "binary-string-with-substrings-representing-1-to-n", "solutions": ["class Solution:\n    def queryString(self, s: str, n: int) -> bool:\n        if n > 1000:\n            return False\n        return all(bin(i)[2:] in s for i in range(n, n // 2, -1))\n", "class Solution:\n  def queryString(self, s: str, n: int) -> bool:\n    if n > 1511:\n      return False\n\n    for i in range(n, n // 2, -1):\n      if format(i, 'b') not in s:\n        return False\n\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1024, "slug": "video-stitching", "solutions": ["class Solution:\n    def videoStitching(self, clips: List[List[int]], time: int) -> int:\n        last = [0] * time\n        for a, b in clips:\n            if a < time:\n                last[a] = max(last[a], b)\n        ans = mx = pre = 0\n        for i, v in enumerate(last):\n            mx = max(mx, v)\n            if mx <= i:\n                return -1\n            if pre == i:\n                ans += 1\n                pre = mx\n        return ans\n", "class Solution:\n  def videoStitching(self, clips: list[list[int]], time: int) -> int:\n    ans = 0\n    end = 0\n    farthest = 0\n\n    clips.sort()\n\n    i = 0\n    while farthest < time:\n      while i < len(clips) and clips[i][0] <= end:\n        farthest = max(farthest, clips[i][1])\n        i += 1\n      if end == farthest:\n        return -1\n      ans += 1\n      end = farthest\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1019, "slug": "next-greater-node-in-linked-list", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def nextLargerNodes(self, head: Optional[ListNode]) -> List[int]:\n        nums = []\n        while head:\n            nums.append(head.val)\n            head = head.next\n        stk = []\n        n = len(nums)\n        ans = [0] * n\n        for i in range(n - 1, -1, -1):\n            while stk and stk[-1] <= nums[i]:\n                stk.pop()\n            if stk:\n                ans[i] = stk[-1]\n            stk.append(nums[i])\n        return ans\n", "class Solution:\n  def nextLargerNodes(self, head: ListNode) -> list[int]:\n    ans = []\n    stack = []\n\n    while head:\n      while stack and head.val > ans[stack[-1]]:\n        index = stack.pop()\n        ans[index] = head.val\n      stack.append(len(ans))\n      ans.append(head.val)\n      head = head.next\n\n    for i in stack:\n      ans[i] = 0\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1066, "slug": "campus-bikes-ii", "solutions": ["class Solution:\n    def assignBikes(self, workers: List[List[int]], bikes: List[List[int]]) -> int:\n        n, m = len(workers), len(bikes)\n        f = [[inf] * (1 << m) for _ in range(n + 1)]\n        f[0][0] = 0\n        for i, (x1, y1) in enumerate(workers, 1):\n            for j in range(1 << m):\n                for k, (x2, y2) in enumerate(bikes):\n                    if j >> k & 1:\n                        f[i][j] = min(\n                            f[i][j],\n                            f[i - 1][j ^ (1 << k)] + abs(x1 - x2) + abs(y1 - y2),\n                        )\n        return min(f[n])\n", "class Solution:\n  def assignBikes(\n      self,\n      workers: list[list[int]],\n      bikes: list[list[int]],\n  ) -> int:\n    def dist(p1: list[int], p2: list[int]) -> int:\n      return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    @functools.lru_cache(None)\n    def dp(workerIndex: int, used: int) -> int:\n      \"\"\"\n      Returns the minimum Manhattan distances to assign bikes to\n      workers[workerIndex..n), where `used` is the bitmask of the used bikes.\n      \"\"\"\n      if workerIndex == len(workers):\n        return 0\n      return min(\n          (dist(workers[workerIndex],\n                bike) + dp(workerIndex + 1, used | 1 << i) for i,\n           bike in enumerate(bikes) if not used >> i & 1),\n          default=math.inf)\n\n    return dp(0, 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1043, "slug": "partition-array-for-maximum-sum", "solutions": ["class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n        f = [0] * (n + 1)\n        for i in range(1, n + 1):\n            mx = 0\n            for j in range(i, max(0, i - k), -1):\n                mx = max(mx, arr[j - 1])\n                f[i] = max(f[i], f[j - 1] + mx * (i - j + 1))\n        return f[n]\n", "class Solution:\n  def maxSumAfterPartitioning(self, arr: list[int], k: int) -> int:\n    n = len(arr)\n    dp = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n      mx = -math.inf\n      for j in range(1, min(i, k) + 1):\n        mx = max(mx, arr[i - j])\n        dp[i] = max(dp[i], dp[i - j] + mx * j)\n\n    return dp[n]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1002, "slug": "find-common-characters", "solutions": ["class Solution:\n    def commonChars(self, words: List[str]) -> List[str]:\n        cnt = Counter(words[0])\n        for w in words:\n            t = Counter(w)\n            for c in cnt:\n                cnt[c] = min(cnt[c], t[c])\n        return list(cnt.elements())\n", "class Solution:\n  def commonChars(self, words: list[str]) -> list[str]:\n    return functools.reduce(lambda a, b: a & b,\n                            map(collections.Counter, words)).elements()\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1049, "slug": "last-stone-weight-ii", "solutions": ["class Solution:\n    def lastStoneWeightII(self, stones: List[int]) -> int:\n        s = sum(stones)\n        m, n = len(stones), s >> 1\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(n + 1):\n                dp[i][j] = dp[i - 1][j]\n                if stones[i - 1] <= j:\n                    dp[i][j] = max(\n                        dp[i][j], dp[i - 1][j - stones[i - 1]] + stones[i - 1]\n                    )\n        return s - 2 * dp[-1][-1]\n", "class Solution:\n  def lastStoneWeightII(self, stones: list[int]) -> int:\n    summ = sum(stones)\n    s = 0\n    dp = [True] + [False] * summ\n\n    for stone in stones:\n      for w in range(summ // 2 + 1)[::-1]:\n        if w >= stone:\n          dp[w] = dp[w] or dp[w - stone]\n        if dp[w]:\n          s = max(s, w)\n\n    return summ - 2 * s\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1079, "slug": "letter-tile-possibilities", "solutions": ["class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        def dfs(cnt: Counter) -> int:\n            ans = 0\n            for i, x in cnt.items():\n                if x > 0:\n                    ans += 1\n                    cnt[i] -= 1\n                    ans += dfs(cnt)\n                    cnt[i] += 1\n            return ans\n\n        cnt = Counter(tiles)\n        return dfs(cnt)\n", "class Solution:\n  def numTilePossibilities(self, tiles: str) -> int:\n    count = collections.Counter(tiles)\n\n    def dfs(count: dict[int, int]) -> int:\n      possibleSequences = 0\n\n      for k, v in count.items():\n        if v == 0:\n          continue\n        # Put c in the current position. We only care about the number of possible\n        # sequences of letters but don't care about the actual combination.\n        count[k] -= 1\n        possibleSequences += 1 + dfs(count)\n        count[k] += 1\n\n      return possibleSequences\n\n    return dfs(count)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1088, "slug": "confusing-number-ii", "solutions": ["class Solution:\n    def confusingNumberII(self, n: int) -> int:\n        def check(x: int) -> bool:\n            y, t = 0, x\n            while t:\n                t, v = divmod(t, 10)\n                y = y * 10 + d[v]\n            return x != y\n\n        def dfs(pos: int, limit: bool, x: int) -> int:\n            if pos >= len(s):\n                return int(check(x))\n            up = int(s[pos]) if limit else 9\n            ans = 0\n            for i in range(up + 1):\n                if d[i] != -1:\n                    ans += dfs(pos + 1, limit and i == up, x * 10 + i)\n            return ans\n\n        d = [0, 1, -1, -1, -1, -1, 9, -1, 8, 6]\n        s = str(n)\n        return dfs(0, True, 0)\n", "class Solution:\n  def confusingNumberII(self, n: int) -> int:\n    digitToRotated = [(0, 0), (1, 1), (6, 9), (8, 8), (9, 6)]\n\n    def dfs(num: int, rotatedNum: int, unit: int) -> int:\n      ans = 0 if num == rotatedNum else 1\n      # Add one more digit\n      for digit, rotated in digitToRotated:\n        if digit == 0 and num == 0:\n          continue\n        nextNum = num * 10 + digit\n        if nextNum > n:\n          break\n        ans += dfs(nextNum, rotated * unit + rotatedNum, unit * 10)\n      return ans\n\n    return dfs(0, 0, 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1042, "slug": "flower-planting-with-no-adjacent", "solutions": ["class Solution:\n    def gardenNoAdj(self, n: int, paths: List[List[int]]) -> List[int]:\n        g = defaultdict(list)\n        for x, y in paths:\n            x, y = x - 1, y - 1\n            g[x].append(y)\n            g[y].append(x)\n        ans = [0] * n\n        for x in range(n):\n            used = {ans[y] for y in g[x]}\n            for c in range(1, 5):\n                if c not in used:\n                    ans[x] = c\n                    break\n        return ans\n", "class Solution:\n  def gardenNoAdj(self, n: int, paths: list[list[int]]) -> list[int]:\n    ans = [0] * n  # ans[i] := 1, 2, 3, or 4\n    graph = [[] for _ in range(n)]\n\n    for x, y in paths:\n      u = x - 1\n      v = y - 1\n      graph[u].append(v)\n      graph[v].append(u)\n\n    for u in range(n):\n      used = functools.reduce(operator.or_, (1 << ans[v] for v in graph[u]), 0)\n      ans[u] = next(type_\n                    for type_ in range(1, 5)\n                    if not (used >> type_ & 1))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1093, "slug": "statistics-from-a-large-sample", "solutions": ["class Solution:\n    def sampleStats(self, count: List[int]) -> List[float]:\n        def find(i: int) -> int:\n            t = 0\n            for k, x in enumerate(count):\n                t += x\n                if t >= i:\n                    return k\n\n        mi, mx = inf, -1\n        s = cnt = 0\n        mode = 0\n        for k, x in enumerate(count):\n            if x:\n                mi = min(mi, k)\n                mx = max(mx, k)\n                s += k * x\n                cnt += x\n                if x > count[mode]:\n                    mode = k\n\n        median = (\n            find(cnt // 2 + 1) if cnt & 1 else (find(cnt // 2) + find(cnt // 2 + 1)) / 2\n        )\n        return [mi, mx, s / cnt, median, mode]\n", "class Solution:\n  def sampleStats(self, count: list[int]) -> list[float]:\n    minimum = next((i for i, num in enumerate(count) if num), None)\n    maximum = next((i for i, num in reversed(\n        list(enumerate(count))) if num), None)\n    n = sum(count)\n    mean = sum(i * c / n for i, c in enumerate(count))\n    mode = count.index(max(count))\n\n    numCount = 0\n    leftMedian = 0\n    for i, c in enumerate(count):\n      numCount += c\n      if numCount >= n / 2:\n        leftMedian = i\n        break\n\n    numCount = 0\n    rightMedian = 0\n    for i, c in reversed(list(enumerate(count))):\n      numCount += c\n      if numCount >= n / 2:\n        rightMedian = i\n        break\n\n    return [minimum, maximum, mean, (leftMedian + rightMedian) / 2, mode]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1023, "slug": "camelcase-matching", "solutions": ["class Solution:\n    def camelMatch(self, queries: List[str], pattern: str) -> List[bool]:\n        def check(s, t):\n            m, n = len(s), len(t)\n            i = j = 0\n            while j < n:\n                while i < m and s[i] != t[j] and s[i].islower():\n                    i += 1\n                if i == m or s[i] != t[j]:\n                    return False\n                i, j = i + 1, j + 1\n            while i < m and s[i].islower():\n                i += 1\n            return i == m\n\n        return [check(q, pattern) for q in queries]\n", "class Solution:\n  def camelMatch(self, queries: list[str], pattern: str) -> list[bool]:\n    def isMatch(query: str) -> bool:\n      j = 0\n      for c in query:\n        if j < len(pattern) and c == pattern[j]:\n          j += 1\n        elif c.isupper():\n          return False\n      return j == len(pattern)\n\n    return [isMatch(query) for query in queries]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1059, "slug": "all-paths-from-source-lead-to-destination", "solutions": ["class Solution:\n    def leadsToDestination(\n        self, n: int, edges: List[List[int]], source: int, destination: int\n    ) -> bool:\n        @cache\n        def dfs(i):\n            if i == destination:\n                return not g[i]\n            if i in vis or not g[i]:\n                return False\n            vis.add(i)\n            for j in g[i]:\n                if not dfs(j):\n                    return False\n            return True\n\n        g = defaultdict(list)\n        for a, b in edges:\n            g[a].append(b)\n        vis = set()\n        return dfs(source)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1058, "slug": "minimize-rounding-error-to-meet-target", "solutions": ["class Solution:\n    def minimizeError(self, prices: List[str], target: int) -> str:\n        mi = 0\n        arr = []\n        for p in prices:\n            p = float(p)\n            mi += int(p)\n            if d := p - int(p):\n                arr.append(d)\n        if not mi <= target <= mi + len(arr):\n            return \"-1\"\n        d = target - mi\n        arr.sort(reverse=True)\n        ans = d - sum(arr[:d]) + sum(arr[d:])\n        return f'{ans:.3f}'\n", "class Solution:\n  def minimizeError(self, prices: list[str], target: int) -> str:\n    # A[i] := (costCeil - costFloor, costCeil, costFloor)\n    # The lower the costCeil - costFloor is, the cheaper to ceil it.\n    A = []\n    sumFloored = 0\n    sumCeiled = 0\n\n    for price in map(float, prices):\n      floored = math.floor(price)\n      ceiled = math.ceil(price)\n      sumFloored += floored\n      sumCeiled += ceiled\n      costFloor = price - floored\n      costCeil = ceiled - price\n      A.append((costCeil - costFloor, costCeil, costFloor))\n\n    if not sumFloored <= target <= sumCeiled:\n      return '-1'\n\n    A.sort()\n    nCeiled = target - sumFloored\n    return '{:.3f}'.format(sum(a[1] for a in A[:nCeiled]) +\n                           sum(a[2] for a in A[nCeiled:]))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1076, "slug": "project-employees-ii", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1005, "slug": "maximize-sum-of-array-after-k-negations", "solutions": ["class Solution:\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\n        cnt = Counter(nums)\n        for x in range(-100, 0):\n            if cnt[x]:\n                m = min(cnt[x], k)\n                cnt[x] -= m\n                cnt[-x] += m\n                k -= m\n                if k == 0:\n                    break\n        if k & 1 and cnt[0] == 0:\n            for x in range(1, 101):\n                if cnt[x]:\n                    cnt[x] -= 1\n                    cnt[-x] += 1\n                    break\n        return sum(x * v for x, v in cnt.items())\n", "class Solution:\n  def largestSumAfterKNegations(self, nums: list[int], k: int) -> int:\n    nums.sort()\n\n    for i, num in enumerate(nums):\n      if num > 0 or k == 0:\n        break\n      nums[i] = -num\n      k -= 1\n\n    return sum(nums) - (k % 2) * min(nums) * 2\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1080, "slug": "insufficient-nodes-in-root-to-leaf-paths", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sufficientSubset(\n        self, root: Optional[TreeNode], limit: int\n    ) -> Optional[TreeNode]:\n        if root is None:\n            return None\n        limit -= root.val\n        if root.left is None and root.right is None:\n            return None if limit > 0 else root\n        root.left = self.sufficientSubset(root.left, limit)\n        root.right = self.sufficientSubset(root.right, limit)\n        return None if root.left is None and root.right is None else root\n", "class Solution:\n  def sufficientSubset(\n      self,\n      root: TreeNode | None,\n      limit: int\n  ) -> TreeNode | None:\n    if not root:\n      return None\n    if not root.left and not root.right:\n      return None if root.val < limit else root\n    root.left = self.sufficientSubset(root.left, limit - root.val)\n    root.right = self.sufficientSubset(root.right, limit - root.val)\n    return None if not root.left and not root.right else root\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1082, "slug": "sales-analysis-i", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1053, "slug": "previous-permutation-with-one-swap", "solutions": ["class Solution:\n    def prevPermOpt1(self, arr: List[int]) -> List[int]:\n        n = len(arr)\n        for i in range(n - 1, 0, -1):\n            if arr[i - 1] > arr[i]:\n                for j in range(n - 1, i - 1, -1):\n                    if arr[j] < arr[i - 1] and arr[j] != arr[j - 1]:\n                        arr[i - 1], arr[j] = arr[j], arr[i - 1]\n                        return arr\n        return arr\n", "class Solution:\n  def prevPermOpt1(self, arr: list[int]) -> list[int]:\n    n = len(arr)\n    l = n - 2\n    r = n - 1\n\n    while l >= 0 and arr[l] <= arr[l + 1]:\n      l -= 1\n    if l < 0:\n      return arr\n    while arr[r] >= arr[l] or arr[r] == arr[r - 1]:\n      r -= 1\n    arr[l], arr[r] = arr[r], arr[l]\n\n    return arr\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1073, "slug": "adding-two-negabinary-numbers", "solutions": ["class Solution:\n    def addNegabinary(self, arr1: List[int], arr2: List[int]) -> List[int]:\n        i, j = len(arr1) - 1, len(arr2) - 1\n        c = 0\n        ans = []\n        while i >= 0 or j >= 0 or c:\n            a = 0 if i < 0 else arr1[i]\n            b = 0 if j < 0 else arr2[j]\n            x = a + b + c\n            c = 0\n            if x >= 2:\n                x -= 2\n                c -= 1\n            elif x == -1:\n                x = 1\n                c += 1\n            ans.append(x)\n            i, j = i - 1, j - 1\n        while len(ans) > 1 and ans[-1] == 0:\n            ans.pop()\n        return ans[::-1]\n", "class Solution:\n  def addNegabinary(self, arr1: list[int], arr2: list[int]) -> list[int]:\n    ans = []\n    carry = 0\n\n    while carry != 0 or arr1 or arr2:\n      if arr1:\n        carry += arr1.pop()\n      if arr2:\n        carry += arr2.pop()\n      ans.append(carry & 1)\n      carry = -(carry >> 1)\n\n    while len(ans) > 1 and ans[-1] == 0:\n      ans.pop()\n\n    return ans[::-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1028, "slug": "recover-a-tree-from-preorder-traversal", "solutions": ["class Solution:\n  def recoverFromPreorder(self, traversal: str) -> TreeNode | None:\n    i = 0\n\n    def recoverFromPreorder(depth: int) -> TreeNode | None:\n      nonlocal i\n      nDashes = 0\n      while i + nDashes < len(traversal) and traversal[i + nDashes] == '-':\n        nDashes += 1\n      if nDashes != depth:\n        return None\n\n      i += depth\n      start = i\n      while i < len(traversal) and traversal[i].isdigit():\n        i += 1\n\n      return TreeNode(int(traversal[start:i]),\n                      recoverFromPreorder(depth + 1),\n                      recoverFromPreorder(depth + 1))\n\n    return recoverFromPreorder(0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1060, "slug": "missing-element-in-sorted-array", "solutions": ["class Solution:\n    def missingElement(self, nums: List[int], k: int) -> int:\n        def missing(i: int) -> int:\n            return nums[i] - nums[0] - i\n\n        n = len(nums)\n        if k > missing(n - 1):\n            return nums[n - 1] + k - missing(n - 1)\n        l, r = 0, n - 1\n        while l < r:\n            mid = (l + r) >> 1\n            if missing(mid) >= k:\n                r = mid\n            else:\n                l = mid + 1\n        return nums[l - 1] + k - missing(l - 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1052, "slug": "grumpy-bookstore-owner", "solutions": ["class Solution:\n    def maxSatisfied(\n        self, customers: List[int], grumpy: List[int], minutes: int\n    ) -> int:\n        mx = cnt = sum(c * g for c, g in zip(customers[:minutes], grumpy))\n        for i in range(minutes, len(customers)):\n            cnt += customers[i] * grumpy[i]\n            cnt -= customers[i - minutes] * grumpy[i - minutes]\n            mx = max(mx, cnt)\n        return sum(c * (g ^ 1) for c, g in zip(customers, grumpy)) + mx\n", "class Solution:\n  def maxSatisfied(\n      self,\n      customers: list[int],\n      grumpy: list[int],\n      X: int,\n  ) -> int:\n    satisfied = sum(c for i, c in enumerate(customers) if grumpy[i] == 0)\n    madeSatisfied = 0\n    windowSatisfied = 0\n\n    for i, customer in enumerate(customers):\n      if grumpy[i] == 1:\n        windowSatisfied += customer\n      if i >= X and grumpy[i - X] == 1:\n        windowSatisfied -= customers[i - X]\n      madeSatisfied = max(madeSatisfied, windowSatisfied)\n\n    return satisfied + madeSatisfied\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1006, "slug": "clumsy-factorial", "solutions": ["class Solution:\n    def clumsy(self, n: int) -> int:\n        k = 0\n        stk = [n]\n        for x in range(n - 1, 0, -1):\n            if k == 0:\n                stk.append(stk.pop() * x)\n            elif k == 1:\n                stk.append(int(stk.pop() / x))\n            elif k == 2:\n                stk.append(x)\n            else:\n                stk.append(-x)\n            k = (k + 1) % 4\n        return sum(stk)\n", "class Solution:\n  def clumsy(self, n: int) -> int:\n    if n == 1:\n      return 1\n    if n == 2:\n      return 2\n    if n == 3:\n      return 6\n    if n == 4:\n      return 7\n    if n % 4 == 1:\n      return n + 2\n    if n % 4 == 2:\n      return n + 2\n    if n % 4 == 3:\n      return n - 1\n    return n + 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1051, "slug": "height-checker", "solutions": ["class Solution:\n    def heightChecker(self, heights: List[int]) -> int:\n        expected = sorted(heights)\n        return sum(a != b for a, b in zip(heights, expected))\n", "class Solution:\n  def heightChecker(self, heights: list[int]) -> int:\n    ans = 0\n    currentHeight = 1\n    count = [0] * 101\n\n    for height in heights:\n      count[height] += 1\n\n    for height in heights:\n      while count[currentHeight] == 0:\n        currentHeight += 1\n      if height != currentHeight:\n        ans += 1\n      count[currentHeight] -= 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1046, "slug": "last-stone-weight", "solutions": ["class Solution:\n    def lastStoneWeight(self, stones: List[int]) -> int:\n        h = [-x for x in stones]\n        heapify(h)\n        while len(h) > 1:\n            y, x = -heappop(h), -heappop(h)\n            if x != y:\n                heappush(h, x - y)\n        return 0 if not h else -h[0]\n", "class Solution:\n  def lastStoneWeight(self, stones: list[int]) -> int:\n    pq = [-stone for stone in stones]\n    heapq.heapify(pq)\n\n    while len(pq) >= 2:\n      n1 = -heapq.heappop(pq)\n      n2 = -heapq.heappop(pq)\n      if n1 != n2:\n        heapq.heappush(pq, -(n1 - n2))\n\n    return 0 if not pq else -pq[0]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1003, "slug": "check-if-word-is-valid-after-substitutions", "solutions": ["class Solution:\n    def isValid(self, s: str) -> bool:\n        if len(s) % 3:\n            return False\n        t = []\n        for c in s:\n            t.append(c)\n            if ''.join(t[-3:]) == 'abc':\n                t[-3:] = []\n        return not t\n", "class Solution:\n  def isValid(self, s: str) -> bool:\n    stack = []\n\n    for c in s:\n      if c == 'c':\n        if len(stack) < 2 or stack[-2] != 'a' or stack[-1] != 'b':\n          return False\n        stack.pop()\n        stack.pop()\n      else:\n        stack.append(c)\n\n    return not stack\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1037, "slug": "valid-boomerang", "solutions": ["class Solution:\n    def isBoomerang(self, points: List[List[int]]) -> bool:\n        (x1, y1), (x2, y2), (x3, y3) = points\n        return (y2 - y1) * (x3 - x2) != (y3 - y2) * (x2 - x1)\n", "class Solution:\n  def isBoomerang(self, points: list[list[int]]) -> bool:\n    return ((points[1][0] - points[0][0]) * (points[2][1] - points[1][1]) !=\n            (points[1][1] - points[0][1]) * (points[2][0] - points[1][0]))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1038, "slug": "binary-search-tree-to-greater-sum-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def bstToGst(self, root: TreeNode) -> TreeNode:\n        def dfs(root):\n            nonlocal s\n            if root is None:\n                return\n            dfs(root.right)\n            s += root.val\n            root.val = s\n            dfs(root.left)\n\n        s = 0\n        dfs(root)\n        return root\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1062, "slug": "longest-repeating-substring", "solutions": ["class Solution:\n    def longestRepeatingSubstring(self, s: str) -> int:\n        n = len(s)\n        f = [[0] * n for _ in range(n)]\n        ans = 0\n        for i in range(1, n):\n            for j in range(i):\n                if s[i] == s[j]:\n                    f[i][j] = 1 + (f[i - 1][j - 1] if j else 0)\n                    ans = max(ans, f[i][j])\n        return ans\n", "class Solution:\n  def longestRepeatingSubstring(self, s: str) -> int:\n    n = len(s)\n    ans = 0\n    # dp[i][j] := the number of repeating characters of s[0..i) and s[0..j)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n      for j in range(i + 1, n + 1):\n        if s[i - 1] == s[j - 1]:\n          dp[i][j] = 1 + dp[i - 1][j - 1]\n          ans = max(ans, dp[i][j])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1061, "slug": "lexicographically-smallest-equivalent-string", "solutions": ["class Solution:\n    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:\n        p = list(range(26))\n\n        def find(x):\n            if p[x] != x:\n                p[x] = find(p[x])\n            return p[x]\n\n        for i in range(len(s1)):\n            a, b = ord(s1[i]) - ord('a'), ord(s2[i]) - ord('a')\n            pa, pb = find(a), find(b)\n            if pa < pb:\n                p[pb] = pa\n            else:\n                p[pa] = pb\n\n        res = []\n        for a in baseStr:\n            a = ord(a) - ord('a')\n            res.append(chr(find(a) + ord('a')))\n        return ''.join(res)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1095, "slug": "find-in-mountain-array", "solutions": ["# \"\"\"\n# This is MountainArray's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# class MountainArray:\n#    def get(self, index: int) -> int:\n#    def length(self) -> int:\n\n\nclass Solution:\n    def findInMountainArray(self, target: int, mountain_arr: 'MountainArray') -> int:\n        def search(l: int, r: int, k: int) -> int:\n            while l < r:\n                mid = (l + r) >> 1\n                if k * mountain_arr.get(mid) >= k * target:\n                    r = mid\n                else:\n                    l = mid + 1\n            return -1 if mountain_arr.get(l) != target else l\n\n        n = mountain_arr.length()\n        l, r = 0, n - 1\n        while l < r:\n            mid = (l + r) >> 1\n            if mountain_arr.get(mid) > mountain_arr.get(mid + 1):\n                r = mid\n            else:\n                l = mid + 1\n        ans = search(0, l, 1)\n        return search(l + 1, n - 1, -1) if ans == -1 else ans\n", "# \"\"\"\n# This is MountainArray's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# Class MountainArray:\n#   def get(self, index: int) -> int:\n#   def length(self) -> int:\n\nclass Solution:\n  def findInMountainArray(\n      self,\n      target: int,\n      mountain_arr: 'MountainArray',\n  ) -> int:\n    n = mountain_arr.length()\n    peakIndex = self.peakIndexInMountainArray(mountain_arr, 0, n - 1)\n\n    leftIndex = self.searchLeft(mountain_arr, target, 0, peakIndex)\n    if mountain_arr.get(leftIndex) == target:\n      return leftIndex\n\n    rightIndex = self.searchRight(mountain_arr, target, peakIndex + 1, n - 1)\n    if mountain_arr.get(rightIndex) == target:\n      return rightIndex\n\n    return -1\n\n  # 852. Peak Index in a Mountain Array\n  def peakIndexInMountainArray(self, A: 'MountainArray', l: int, r: int) -> int:\n    while l < r:\n      m = (l + r) // 2\n      if A.get(m) < A.get(m + 1):\n        l = m + 1\n      else:\n        r = m\n    return l\n\n  def searchLeft(self, A: 'MountainArray', target: int, l: int, r: int) -> int:\n    while l < r:\n      m = (l + r) // 2\n      if A.get(m) < target:\n        l = m + 1\n      else:\n        r = m\n    return l\n\n  def searchRight(self, A: 'MountainArray', target: int, l: int, r: int) -> int:\n    while l < r:\n      m = (l + r) // 2\n      if A.get(m) > target:\n        l = m + 1\n      else:\n        r = m\n    return l\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1065, "slug": "index-pairs-of-a-string", "solutions": ["class Solution:\n    def indexPairs(self, text: str, words: List[str]) -> List[List[int]]:\n        words = set(words)\n        n = len(text)\n        return [\n            [i, j] for i in range(n) for j in range(i, n) if text[i : j + 1] in words\n        ]\n", "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = collections.defaultdict(TrieNode)\n    self.isWord = False\n\n\nclass Solution:\n  def indexPairs(self, text: str, words: list[str]) -> list[list[int]]:\n    ans = []\n    root = TrieNode()\n\n    for word in words:\n      node: TrieNode = root\n      for c in word:\n        node = node.children.setdefault(c, TrieNode())\n      node.isWord = True\n\n    # Scan each text[i..j].\n    for i in range(len(text)):\n      node: TrieNode = root\n      for j in range(i, len(text)):\n        c = text[j]\n        if c not in node.children:\n          break\n        node = node.children[c]\n        if node.isWord:\n          ans.append([i, j])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1011, "slug": "capacity-to-ship-packages-within-d-days", "solutions": ["class Solution:\n    def shipWithinDays(self, weights: List[int], days: int) -> int:\n        def check(mx):\n            ws, cnt = 0, 1\n            for w in weights:\n                ws += w\n                if ws > mx:\n                    cnt += 1\n                    ws = w\n            return cnt <= days\n\n        left, right = max(weights), sum(weights) + 1\n        return left + bisect_left(range(left, right), True, key=check)\n", "class Solution:\n  def shipWithinDays(self, weights: list[int], days: int) -> int:\n    def shipDays(shipCapacity: int) -> int:\n      shipDays = 1\n      capacity = 0\n      for weight in weights:\n        if capacity + weight > shipCapacity:\n          shipDays += 1\n          capacity = weight\n        else:\n          capacity += weight\n      return shipDays\n\n    l = max(weights)\n    r = sum(weights)\n    return bisect.bisect_left(range(l, r), True,\n                              key=lambda m: shipDays(m) <= days) + l\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1067, "slug": "digit-count-in-range", "solutions": ["class Solution:\n    def digitsCount(self, d: int, low: int, high: int) -> int:\n        return self.f(high, d) - self.f(low - 1, d)\n\n    def f(self, n, d):\n        @cache\n        def dfs(pos, cnt, lead, limit):\n            if pos <= 0:\n                return cnt\n            up = a[pos] if limit else 9\n            ans = 0\n            for i in range(up + 1):\n                if i == 0 and lead:\n                    ans += dfs(pos - 1, cnt, lead, limit and i == up)\n                else:\n                    ans += dfs(pos - 1, cnt + (i == d), False, limit and i == up)\n            return ans\n\n        a = [0] * 11\n        l = 0\n        while n:\n            l += 1\n            a[l] = n % 10\n            n //= 10\n        return dfs(l, 0, True, True)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 535, "slug": "encode-and-decode-tinyurl", "solutions": ["class Codec:\n    def __init__(self):\n        self.m = defaultdict()\n        self.idx = 0\n        self.domain = 'https://tinyurl.com/'\n\n    def encode(self, longUrl: str) -> str:\n        \"\"\"Encodes a URL to a shortened URL.\"\"\"\n        self.idx += 1\n        self.m[str(self.idx)] = longUrl\n        return f'{self.domain}{self.idx}'\n\n    def decode(self, shortUrl: str) -> str:\n        \"\"\"Decodes a shortened URL to its original URL.\"\"\"\n        idx = shortUrl.split('/')[-1]\n        return self.m[idx]\n\n\n# Your Codec object will be instantiated and called as such:\n# codec = Codec()\n# codec.decode(codec.encode(url))\n", "class Codec:\n  alphabets = string.ascii_letters + '0123456789'\n  urlToCode = {}\n  codeToUrl = {}\n\n  def encode(self, longUrl: str) -> str:\n    while longUrl not in self.urlToCode:\n      code = ''.join(random.choice(self.alphabets) for _ in range(6))\n      if code not in self.codeToUrl:\n        self.codeToUrl[code] = longUrl\n        self.urlToCode[longUrl] = code\n    return 'http://tinyurl.com/' + self.urlToCode[longUrl]\n\n  def decode(self, shortUrl: str) -> str:\n    return self.codeToUrl[shortUrl[-6:]]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 504, "slug": "base-7", "solutions": ["class Solution:\n    def convertToBase7(self, num: int) -> str:\n        if num == 0:\n            return '0'\n        if num < 0:\n            return '-' + self.convertToBase7(-num)\n        ans = []\n        while num:\n            ans.append(str(num % 7))\n            num //= 7\n        return ''.join(ans[::-1])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 558, "slug": "logical-or-of-two-binary-grids-represented-as-quad-trees", "solutions": ["\"\"\"\n# Definition for a QuadTree node.\nclass Node:\n    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):\n        self.val = val\n        self.isLeaf = isLeaf\n        self.topLeft = topLeft\n        self.topRight = topRight\n        self.bottomLeft = bottomLeft\n        self.bottomRight = bottomRight\n\"\"\"\n\n\nclass Solution:\n    def intersect(self, quadTree1: \"Node\", quadTree2: \"Node\") -> \"Node\":\n        def dfs(t1, t2):\n            if t1.isLeaf and t2.isLeaf:\n                return Node(t1.val or t2.val, True)\n            if t1.isLeaf:\n                return t1 if t1.val else t2\n            if t2.isLeaf:\n                return t2 if t2.val else t1\n            res = Node()\n            res.topLeft = dfs(t1.topLeft, t2.topLeft)\n            res.topRight = dfs(t1.topRight, t2.topRight)\n            res.bottomLeft = dfs(t1.bottomLeft, t2.bottomLeft)\n            res.bottomRight = dfs(t1.bottomRight, t2.bottomRight)\n            isLeaf = (\n                res.topLeft.isLeaf\n                and res.topRight.isLeaf\n                and res.bottomLeft.isLeaf\n                and res.bottomRight.isLeaf\n            )\n            sameVal = (\n                res.topLeft.val\n                == res.topRight.val\n                == res.bottomLeft.val\n                == res.bottomRight.val\n            )\n            if isLeaf and sameVal:\n                res = res.topLeft\n            return res\n\n        return dfs(quadTree1, quadTree2)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 561, "slug": "array-partition", "solutions": ["class Solution:\n    def arrayPairSum(self, nums: List[int]) -> int:\n        nums.sort()\n        return sum(nums[::2])\n", "class Solution:\n  def arrayPairSum(self, nums: list[int]) -> int:\n    return sum(sorted(nums)[::2])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 585, "slug": "investments-in-2016", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 548, "slug": "split-array-with-equal-sum", "solutions": ["class Solution:\n    def splitArray(self, nums: List[int]) -> bool:\n        n = len(nums)\n        s = [0] * (n + 1)\n        for i, v in enumerate(nums):\n            s[i + 1] = s[i] + v\n        for j in range(3, n - 3):\n            seen = set()\n            for i in range(1, j - 1):\n                if s[i] == s[j] - s[i + 1]:\n                    seen.add(s[i])\n            for k in range(j + 2, n - 1):\n                if s[n] - s[k + 1] == s[k] - s[j + 1] and s[n] - s[k + 1] in seen:\n                    return True\n        return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 567, "slug": "permutation-in-string", "solutions": ["class Solution:\n    def checkInclusion(self, s1: str, s2: str) -> bool:\n        cnt = Counter(s1)\n        need = len(cnt)\n        m = len(s1)\n        for i, c in enumerate(s2):\n            cnt[c] -= 1\n            if cnt[c] == 0:\n                need -= 1\n            if i >= m:\n                cnt[s2[i - m]] += 1\n                if cnt[s2[i - m]] == 1:\n                    need += 1\n            if need == 0:\n                return True\n        return False\n", "class Solution:\n  def checkInclusion(self, s1: str, s2: str) -> bool:\n    count = collections.Counter(s1)\n    required = len(s1)\n\n    for r, c in enumerate(s2):\n      count[c] -= 1\n      if count[c] >= 0:\n        required -= 1\n      if r >= len(s1):  # The window is oversized.\n        count[s2[r - len(s1)]] += 1\n        if count[s2[r - len(s1)]] > 0:\n          required += 1\n      if required == 0:\n        return True\n\n    return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 523, "slug": "continuous-subarray-sum", "solutions": ["class Solution:\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\n        d = {0: -1}\n        s = 0\n        for i, x in enumerate(nums):\n            s = (s + x) % k\n            if s not in d:\n                d[s] = i\n            elif i - d[s] > 1:\n                return True\n        return False\n", "class Solution:\n  def checkSubarraySum(self, nums: list[int], k: int) -> bool:\n    prefix = 0\n    prefixToIndex = {0: -1}\n\n    for i, num in enumerate(nums):\n      prefix += num\n      if k != 0:\n        prefix %= k\n      if prefix in prefixToIndex:\n        if i - prefixToIndex[prefix] > 1:\n          return True\n      else:\n        # Set a new key if it's absent because the previous index is better.\n        prefixToIndex[prefix] = i\n\n    return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 575, "slug": "distribute-candies", "solutions": ["class Solution:\n    def distributeCandies(self, candyType: List[int]) -> int:\n        return min(len(candyType) >> 1, len(set(candyType)))\n", "class Solution:\n  def distributeCandies(self, candies: list[int]) -> int:\n    return min(len(candies) // 2, len(set(candies)))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 532, "slug": "k-diff-pairs-in-an-array", "solutions": ["class Solution:\n    def findPairs(self, nums: List[int], k: int) -> int:\n        ans = set()\n        vis = set()\n        for x in nums:\n            if x - k in vis:\n                ans.add(x - k)\n            if x + k in vis:\n                ans.add(x)\n            vis.add(x)\n        return len(ans)\n", "class Solution:\n  def findPairs(self, nums: list[int], k: int) -> int:\n    ans = 0\n    numToIndex = {num: i for i, num in enumerate(nums)}\n\n    for i, num in enumerate(nums):\n      target = num + k\n      if target in numToIndex and numToIndex[target] != i:\n        ans += 1\n        del numToIndex[target]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 565, "slug": "array-nesting", "solutions": ["class Solution:\n    def arrayNesting(self, nums: List[int]) -> int:\n        n = len(nums)\n        vis = [False] * n\n        res = 0\n        for i in range(n):\n            if vis[i]:\n                continue\n            cur, m = nums[i], 1\n            vis[cur] = True\n            while nums[cur] != nums[i]:\n                cur = nums[cur]\n                m += 1\n                vis[cur] = True\n            res = max(res, m)\n        return res\n", "class Solution:\n  def arrayNesting(self, nums: list[int]) -> int:\n    ans = 0\n\n    for num in nums:\n      if num == -1:\n        continue\n      index = num\n      count = 0\n      while nums[index] != -1:\n        cache = index\n        index = nums[index]\n        nums[cache] = -1\n        count += 1\n      ans = max(ans, count)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 557, "slug": "reverse-words-in-a-string-iii", "solutions": ["class Solution:\n    def reverseWords(self, s: str) -> str:\n        return \" \".join(t[::-1] for t in s.split())\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 552, "slug": "student-attendance-record-ii", "solutions": ["class Solution:\n    def checkRecord(self, n: int) -> int:\n        @cache\n        def dfs(i, j, k):\n            if i >= n:\n                return 1\n            ans = 0\n            if j == 0:\n                ans += dfs(i + 1, j + 1, 0)\n            if k < 2:\n                ans += dfs(i + 1, j, k + 1)\n            ans += dfs(i + 1, j, 0)\n            return ans % mod\n\n        mod = 10**9 + 7\n        ans = dfs(0, 0, 0)\n        dfs.cache_clear()\n        return ans\n", "class Solution:\n  def checkRecord(self, n: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i][j] := the length so far with i A's and the last letters are j L's\n    dp = [[0] * 3 for _ in range(2)]\n    dp[0][0] = 1\n\n    for _ in range(n):\n      prev = [A[:] for A in dp]\n\n      # Append a P.\n      dp[0][0] = (prev[0][0] + prev[0][1] + prev[0][2]) % MOD\n\n      # Append an L.\n      dp[0][1] = prev[0][0]\n\n      # Append an L.\n      dp[0][2] = prev[0][1]\n\n      # Append an A or append a P.\n      dp[1][0] = (prev[0][0] + prev[0][1] + prev[0][2] +\n                  prev[1][0] + prev[1][1] + prev[1][2]) % MOD\n\n      # Append an L.\n      dp[1][1] = prev[1][0]\n\n      # Append an L.\n      dp[1][2] = prev[1][1]\n\n    return (sum(dp[0]) + sum(dp[1])) % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 544, "slug": "output-contest-matches", "solutions": ["class Solution:\n    def findContestMatch(self, n: int) -> str:\n        s = [str(i + 1) for i in range(n)]\n        while n > 1:\n            for i in range(n >> 1):\n                s[i] = f\"({s[i]},{s[n - i - 1]})\"\n            n >>= 1\n        return s[0]\n", "class Solution:\n  def findContestMatch(self, n: int) -> str:\n    def generateMatches(matches: list[str]) -> str:\n      if len(matches) == 1:\n        return matches[0]\n\n      nextMatches = []\n\n      for i in range(len(matches) // 2):\n        nextMatches.append(\n            '(' + matches[i] + ',' + matches[len(matches) - 1 - i] + ')')\n\n      return generateMatches(nextMatches)\n\n    return generateMatches([str(i + 1) for i in range(n)])\n", "class Solution:\n  def findContestMatch(self, n: int) -> str:\n    matches = [str(i + 1) for i in range(n)]\n\n    while n > 1:\n      for i in range(n // 2):\n        matches[i] = '(' + matches[i] + ',' + matches[n - 1 - i] + ')'\n      n //= 2\n\n    return matches[0]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 514, "slug": "freedom-trail", "solutions": ["class Solution:\n    def findRotateSteps(self, ring: str, key: str) -> int:\n        m, n = len(key), len(ring)\n        pos = defaultdict(list)\n        for i, c in enumerate(ring):\n            pos[c].append(i)\n        f = [[inf] * n for _ in range(m)]\n        for j in pos[key[0]]:\n            f[0][j] = min(j, n - j) + 1\n        for i in range(1, m):\n            for j in pos[key[i]]:\n                for k in pos[key[i - 1]]:\n                    f[i][j] = min(\n                        f[i][j], f[i - 1][k] + min(abs(j - k), n - abs(j - k)) + 1\n                    )\n        return min(f[-1][j] for j in pos[key[-1]])\n", "class Solution:\n  def findRotateSteps(self, ring: str, key: str) -> int:\n    @functools.lru_cache(None)\n    def dfs(ring: str, index: int) -> int:\n      \"\"\"Returns the number of rotates of ring to match key[index..n).\"\"\"\n      if index == len(key):\n        return 0\n\n      ans = math.inf\n\n      # For each ring[i] == key[index], we rotate the ring to match the ring[i]\n      # with the key[index], then recursively match the newRing with the\n      # key[index + 1..n).\n      for i, r in enumerate(ring):\n        if r == key[index]:\n          minRotates = min(i, len(ring) - i)\n          newRing = ring[i:] + ring[:i]\n          remainingRotates = dfs(newRing, index + 1)\n          ans = min(ans, minRotates + remainingRotates)\n\n      return ans\n\n    return dfs(ring, 0) + len(key)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 526, "slug": "beautiful-arrangement", "solutions": ["class Solution:\n    def countArrangement(self, n: int) -> int:\n        def dfs(i):\n            nonlocal ans, n\n            if i == n + 1:\n                ans += 1\n                return\n            for j in match[i]:\n                if not vis[j]:\n                    vis[j] = True\n                    dfs(i + 1)\n                    vis[j] = False\n\n        ans = 0\n        vis = [False] * (n + 1)\n        match = defaultdict(list)\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                if j % i == 0 or i % j == 0:\n                    match[i].append(j)\n\n        dfs(1)\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 582, "slug": "kill-process", "solutions": ["class Solution:\n    def killProcess(self, pid: List[int], ppid: List[int], kill: int) -> List[int]:\n        def dfs(i: int):\n            ans.append(i)\n            for j in g[i]:\n                dfs(j)\n\n        g = defaultdict(list)\n        for i, p in zip(pid, ppid):\n            g[p].append(i)\n        ans = []\n        dfs(kill)\n        return ans\n", "class Solution:\n  def killProcess(\n      self,\n      pid: list[int],\n      ppid: list[int],\n      kill: int,\n  ) -> list[int]:\n    ans = []\n    tree = collections.defaultdict(list)\n\n    for v, u in zip(pid, ppid):\n      if u == 0:\n        continue\n      tree[u].append(v)\n\n    def dfs(u: int) -> None:\n      ans.append(u)\n      for v in tree.get(u, []):\n        dfs(v)\n\n    dfs(kill)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 580, "slug": "count-student-number-in-departments", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 574, "slug": "winning-candidate", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 598, "slug": "range-addition-ii", "solutions": ["class Solution:\n    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\n        for a, b in ops:\n            m = min(m, a)\n            n = min(n, b)\n        return m * n\n", "class Solution:\n  def maxCount(self, m: int, n: int, ops: list[list[int]]) -> int:\n    minY = m\n    minX = n\n\n    for y, x in ops:\n      minY = min(minY, y)\n      minX = min(minX, x)\n\n    return minX * minY\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 577, "slug": "employee-bonus", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 554, "slug": "brick-wall", "solutions": ["class Solution:\n    def leastBricks(self, wall: List[List[int]]) -> int:\n        cnt = Counter()\n        for row in wall:\n            s = 0\n            for x in row[:-1]:\n                s += x\n                cnt[s] += 1\n        return len(wall) - max(cnt.values(), default=0)\n", "class Solution:\n  def leastBricks(self, wall: list[list[int]]) -> int:\n    maxFreq = 0\n    count = collections.defaultdict(int)\n\n    for row in wall:\n      prefix = 0\n      for i in range(len(row) - 1):\n        prefix += row[i]\n        count[prefix] += 1\n        maxFreq = max(maxFreq, count[prefix])\n\n    return len(wall) - maxFreq\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 592, "slug": "fraction-addition-and-subtraction", "solutions": ["class Solution:\n    def fractionAddition(self, expression: str) -> str:\n        x, y = 0, 6 * 7 * 8 * 9 * 10\n        if expression[0].isdigit():\n            expression = '+' + expression\n        i, n = 0, len(expression)\n        while i < n:\n            sign = -1 if expression[i] == '-' else 1\n            i += 1\n            j = i\n            while j < n and expression[j] not in '+-':\n                j += 1\n            s = expression[i:j]\n            a, b = s.split('/')\n            x += sign * int(a) * y // int(b)\n            i = j\n        z = gcd(x, y)\n        x //= z\n        y //= z\n        return f'{x}/{y}'\n", "class Solution:\n  def fractionAddition(self, expression: str) -> str:\n    ints = list(map(int, re.findall('[+-]?[0-9]+', expression)))\n    A = 0\n    B = 1\n\n    for a, b in zip(ints[::2], ints[1::2]):\n      A = A * b + a * B\n      B *= b\n      g = math.gcd(A, B)\n      A //= g\n      B //= g\n\n    return str(A) + '/' + str(B)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 547, "slug": "number-of-provinces", "solutions": ["class Solution:\n    def findCircleNum(self, isConnected: List[List[int]]) -> int:\n        def dfs(i: int):\n            vis[i] = True\n            for j, x in enumerate(isConnected[i]):\n                if not vis[j] and x:\n                    dfs(j)\n\n        n = len(isConnected)\n        vis = [False] * n\n        ans = 0\n        for i in range(n):\n            if not vis[i]:\n                dfs(i)\n                ans += 1\n        return ans\n", "class UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findCircleNum(self, isConnected: list[list[int]]) -> int:\n    n = len(isConnected)\n    uf = UnionFind(n)\n\n    for i in range(n):\n      for j in range(i, n):\n        if isConnected[i][j] == 1:\n          uf.unionByRank(i, j)\n\n    return uf.count\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 509, "slug": "fibonacci-number", "solutions": ["class Solution:\n    def fib(self, n: int) -> int:\n        a, b = 0, 1\n        for _ in range(n):\n            a, b = b, a + b\n        return a\n", "class Solution:\n  def fib(self, n: int) -> int:\n    if n < 2:\n      return n\n\n    dp = [0, 0, 1]\n\n    for i in range(2, n + 1):\n      dp[0] = dp[1]\n      dp[1] = dp[2]\n      dp[2] = dp[0] + dp[1]\n\n    return dp[2]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 599, "slug": "minimum-index-sum-of-two-lists", "solutions": ["class Solution:\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\n        d = {s: i for i, s in enumerate(list2)}\n        ans = []\n        mi = inf\n        for i, s in enumerate(list1):\n            if s in d:\n                j = d[s]\n                if i + j < mi:\n                    mi = i + j\n                    ans = [s]\n                elif i + j == mi:\n                    ans.append(s)\n        return ans\n", "class Solution:\n  def findRestaurant(self, list1: list[str], list2: list[str]) -> list[str]:\n    ans = []\n    restaurantToIndex = {restaurant: i for i,\n                         restaurant in enumerate(list1)}\n    minSum = math.inf\n\n    for i, restaurant in enumerate(list2):\n      if restaurant in restaurantToIndex:\n        summ = restaurantToIndex[restaurant] + i\n        if summ < minSum:\n          ans.clear()\n        if summ <= minSum:\n          ans.append(restaurant)\n          minSum = summ\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 569, "slug": "median-employee-salary", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 568, "slug": "maximum-vacation-days", "solutions": ["class Solution:\n    def maxVacationDays(self, flights: List[List[int]], days: List[List[int]]) -> int:\n        n = len(flights)\n        K = len(days[0])\n        f = [[-inf] * n for _ in range(K + 1)]\n        f[0][0] = 0\n        for k in range(1, K + 1):\n            for j in range(n):\n                f[k][j] = f[k - 1][j]\n                for i in range(n):\n                    if flights[i][j]:\n                        f[k][j] = max(f[k][j], f[k - 1][i])\n                f[k][j] += days[j][k - 1]\n        return max(f[-1][j] for j in range(n))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 578, "slug": "get-highest-answer-rate-question", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 518, "slug": "coin-change-ii", "solutions": ["class Solution:\n    def change(self, amount: int, coins: List[int]) -> int:\n        m, n = len(coins), amount\n        f = [[0] * (n + 1) for _ in range(m + 1)]\n        f[0][0] = 1\n        for i, x in enumerate(coins, 1):\n            for j in range(n + 1):\n                f[i][j] = f[i - 1][j]\n                if j >= x:\n                    f[i][j] += f[i][j - x]\n        return f[m][n]\n", "class Solution:\n  def change(self, amount: int, coins: list[int]) -> int:\n    dp = [1] + [0] * amount\n\n    for coin in coins:\n      for i in range(coin, amount + 1):\n        dp[i] += dp[i - coin]\n\n    return dp[amount]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 588, "slug": "design-in-memory-file-system", "solutions": ["class Trie:\n    def __init__(self):\n        self.name = None\n        self.isFile = False\n        self.content = []\n        self.children = {}\n\n    def insert(self, path, isFile):\n        node = self\n        ps = path.split('/')\n        for p in ps[1:]:\n            if p not in node.children:\n                node.children[p] = Trie()\n            node = node.children[p]\n        node.isFile = isFile\n        if isFile:\n            node.name = ps[-1]\n        return node\n\n    def search(self, path):\n        node = self\n        if path == '/':\n            return node\n        ps = path.split('/')\n        for p in ps[1:]:\n            if p not in node.children:\n                return None\n            node = node.children[p]\n        return node\n\n\nclass FileSystem:\n    def __init__(self):\n        self.root = Trie()\n\n    def ls(self, path: str) -> List[str]:\n        node = self.root.search(path)\n        if node is None:\n            return []\n        if node.isFile:\n            return [node.name]\n        return sorted(node.children.keys())\n\n    def mkdir(self, path: str) -> None:\n        self.root.insert(path, False)\n\n    def addContentToFile(self, filePath: str, content: str) -> None:\n        node = self.root.insert(filePath, True)\n        node.content.append(content)\n\n    def readContentFromFile(self, filePath: str) -> str:\n        node = self.root.search(filePath)\n        return ''.join(node.content)\n\n\n# Your FileSystem object will be instantiated and called as such:\n# obj = FileSystem()\n# param_1 = obj.ls(path)\n# obj.mkdir(path)\n# obj.addContentToFile(filePath,content)\n# param_4 = obj.readContentFromFile(filePath)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 563, "slug": "binary-tree-tilt", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findTilt(self, root: Optional[TreeNode]) -> int:\n        def dfs(root: Optional[TreeNode]) -> int:\n            if root is None:\n                return 0\n            l, r = dfs(root.left), dfs(root.right)\n            nonlocal ans\n            ans += abs(l - r)\n            return l + r + root.val\n\n        ans = 0\n        dfs(root)\n        return ans\n", "class Solution:\n  def findTilt(self, root: TreeNode | None) -> int:\n    ans = 0\n\n    def summ(root: TreeNode | None) -> None:\n      nonlocal ans\n      if not root:\n        return 0\n\n      l = summ(root.left)\n      r = summ(root.right)\n      ans += abs(l - r)\n      return root.val + l + r\n\n    summ(root)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 506, "slug": "relative-ranks", "solutions": ["class Solution:\n    def findRelativeRanks(self, score: List[int]) -> List[str]:\n        n = len(score)\n        idx = list(range(n))\n        idx.sort(key=lambda x: -score[x])\n        top3 = [\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\"]\n        ans = [None] * n\n        for i, j in enumerate(idx):\n            ans[j] = top3[i] if i < 3 else str(i + 1)\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 508, "slug": "most-frequent-subtree-sum", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findFrequentTreeSum(self, root: Optional[TreeNode]) -> List[int]:\n        def dfs(root: Optional[TreeNode]) -> int:\n            if root is None:\n                return 0\n            l, r = dfs(root.left), dfs(root.right)\n            s = l + r + root.val\n            cnt[s] += 1\n            return s\n\n        cnt = Counter()\n        dfs(root)\n        mx = max(cnt.values())\n        return [k for k, v in cnt.items() if v == mx]\n", "class Solution:\n  def findFrequentTreeSum(self, root: TreeNode | None) -> list[int]:\n    if not root:\n      return []\n\n    count = collections.Counter()\n\n    def dfs(root: TreeNode | None) -> int:\n      if not root:\n        return 0\n\n      summ = root.val + dfs(root.left) + dfs(root.right)\n      count[summ] += 1\n      return summ\n\n    dfs(root)\n    maxFreq = max(count.values())\n    return [summ for summ in count if count[summ] == maxFreq]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 595, "slug": "big-countries", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 502, "slug": "ipo", "solutions": ["class Solution:\n    def findMaximizedCapital(\n        self, k: int, w: int, profits: List[int], capital: List[int]\n    ) -> int:\n        h1 = [(c, p) for c, p in zip(capital, profits)]\n        heapify(h1)\n        h2 = []\n        while k:\n            while h1 and h1[0][0] <= w:\n                heappush(h2, -heappop(h1)[1])\n            if not h2:\n                break\n            w -= heappop(h2)\n            k -= 1\n        return w\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 545, "slug": "boundary-of-binary-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def boundaryOfBinaryTree(self, root: Optional[TreeNode]) -> List[int]:\n        def dfs(nums: List[int], root: Optional[TreeNode], i: int):\n            if root is None:\n                return\n            if i == 0:\n                if root.left != root.right:\n                    nums.append(root.val)\n                    if root.left:\n                        dfs(nums, root.left, i)\n                    else:\n                        dfs(nums, root.right, i)\n            elif i == 1:\n                if root.left == root.right:\n                    nums.append(root.val)\n                else:\n                    dfs(nums, root.left, i)\n                    dfs(nums, root.right, i)\n            else:\n                if root.left != root.right:\n                    nums.append(root.val)\n                    if root.right:\n                        dfs(nums, root.right, i)\n                    else:\n                        dfs(nums, root.left, i)\n\n        ans = [root.val]\n        if root.left == root.right:\n            return ans\n        left, leaves, right = [], [], []\n        dfs(left, root.left, 0)\n        dfs(leaves, root, 1)\n        dfs(right, root.right, 2)\n        ans += left + leaves + right[::-1]\n        return ans\n", "class Solution:\n  def boundaryOfBinaryTree(self, root: TreeNode | None) -> list[int]:\n    if not root:\n      return []\n\n    ans = [root.val]\n\n    def dfs(root: TreeNode | None, lb: bool, rb: bool):\n      \"\"\"\n      1. root.left is left boundary if root is left boundary.\n         root.right if left boundary if root.left is None.\n      2. Same applys for right boundary.\n      3. If root is left boundary, add it before 2 children - preorder.\n         If root is right boundary, add it after 2 children - postorder.\n      4. A leaf that is neighter left/right boundary belongs to the bottom.\n      \"\"\"\n      if not root:\n        return\n      if lb:\n        ans.append(root.val)\n      if not lb and not rb and not root.left and not root.right:\n        ans.append(root.val)\n\n      dfs(root.left, lb, rb and not root.right)\n      dfs(root.right, lb and not root.left, rb)\n      if rb:\n        ans.append(root.val)\n\n    dfs(root.left, True, False)\n    dfs(root.right, False, True)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 510, "slug": "inorder-successor-in-bst-ii", "solutions": ["\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n        self.parent = None\n\"\"\"\n\n\nclass Solution:\n    def inorderSuccessor(self, node: \"Node\") -> \"Optional[Node]\":\n        if node.right:\n            node = node.right\n            while node.left:\n                node = node.left\n            return node\n        while node.parent and node.parent.right is node:\n            node = node.parent\n        return node.parent\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 529, "slug": "minesweeper", "solutions": ["class Solution:\n    def updateBoard(self, board: List[List[str]], click: List[int]) -> List[List[str]]:\n        def dfs(i: int, j: int):\n            cnt = 0\n            for x in range(i - 1, i + 2):\n                for y in range(j - 1, j + 2):\n                    if 0 <= x < m and 0 <= y < n and board[x][y] == \"M\":\n                        cnt += 1\n            if cnt:\n                board[i][j] = str(cnt)\n            else:\n                board[i][j] = \"B\"\n                for x in range(i - 1, i + 2):\n                    for y in range(j - 1, j + 2):\n                        if 0 <= x < m and 0 <= y < n and board[x][y] == \"E\":\n                            dfs(x, y)\n\n        m, n = len(board), len(board[0])\n        i, j = click\n        if board[i][j] == \"M\":\n            board[i][j] = \"X\"\n        else:\n            dfs(i, j)\n        return board\n", "class Solution:\n  def updateBoard(self, board: list[list[str]],\n                  click: list[int]) -> list[list[str]]:\n    i, j = click\n    if board[i][j] == 'M':\n      board[i][j] = 'X'\n      return board\n\n    DIRS = ((-1, -1), (-1, 0), (-1, 1), (0, -1),\n            (0, 1), (1, -1), (1, 0), (1, 1))\n\n    def getMinesCount(i: int, j: int) -> int:\n      minesCount = 0\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == len(board) or y < 0 or y == len(board[0]):\n          continue\n        if board[x][y] == 'M':\n          minesCount += 1\n      return minesCount\n\n    def dfs(i: int, j: int) -> None:\n      if i < 0 or i == len(board) or j < 0 or j == len(board[0]):\n        return\n      if board[i][j] != 'E':\n        return\n\n      minesCount = getMinesCount(i, j)\n      board[i][j] = 'B' if minesCount == 0 else str(minesCount)\n\n      if minesCount == 0:\n        for dx, dy in DIRS:\n          dfs(i + dx, j + dy)\n\n    dfs(i, j)\n    return board\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 549, "slug": "binary-tree-longest-consecutive-sequence-ii", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestConsecutive(self, root: TreeNode) -> int:\n        def dfs(root):\n            if root is None:\n                return [0, 0]\n            nonlocal ans\n            incr = decr = 1\n            i1, d1 = dfs(root.left)\n            i2, d2 = dfs(root.right)\n            if root.left:\n                if root.left.val + 1 == root.val:\n                    incr = i1 + 1\n                if root.left.val - 1 == root.val:\n                    decr = d1 + 1\n            if root.right:\n                if root.right.val + 1 == root.val:\n                    incr = max(incr, i2 + 1)\n                if root.right.val - 1 == root.val:\n                    decr = max(decr, d2 + 1)\n            ans = max(ans, incr + decr - 1)\n            return [incr, decr]\n\n        ans = 0\n        dfs(root)\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 564, "slug": "find-the-closest-palindrome", "solutions": ["class Solution:\n    def nearestPalindromic(self, n: str) -> str:\n        x = int(n)\n        l = len(n)\n        res = {10 ** (l - 1) - 1, 10**l + 1}\n        left = int(n[: (l + 1) >> 1])\n        for i in range(left - 1, left + 2):\n            j = i if l % 2 == 0 else i // 10\n            while j:\n                i = i * 10 + j % 10\n                j //= 10\n            res.add(i)\n        res.discard(x)\n\n        ans = -1\n        for t in res:\n            if (\n                ans == -1\n                or abs(t - x) < abs(ans - x)\n                or (abs(t - x) == abs(ans - x) and t < ans)\n            ):\n                ans = t\n        return str(ans)\n", "class Solution:\n  def nearestPalindromic(self, n: str) -> str:\n    prevPalindrome, nextPalindrome = self._getPalindromes(n)\n    return (str(prevPalindrome)\n            if abs(prevPalindrome - int(n)) <= abs(nextPalindrome - int(n))\n            else str(nextPalindrome))\n\n  def _getPalindromes(self, s: str) -> tuple[str, str]:\n    \"\"\"Returns the two closest palindromes to the given number.\"\"\"\n    num = int(s)\n    sz = len(s)\n    palindromes = []\n    half = s[0:(sz + 1) // 2]\n    reversedHalf = half[:sz // 2][::-1]\n    candidate = int(half + reversedHalf)\n\n    if candidate < num:\n      palindromes.append(candidate)\n    else:\n      prevHalf = str(int(half) - 1)\n      reversedPrevHalf = prevHalf[:sz // 2][::-1]\n      if sz % 2 == 0 and int(prevHalf) == 0:\n        palindromes.append(9)\n      elif sz % 2 == 0 and prevHalf == '9':\n        palindromes.append(int(prevHalf + '9' + reversedPrevHalf))\n      else:\n        palindromes.append(int(prevHalf + reversedPrevHalf))\n\n    if candidate > num:\n      palindromes.append(candidate)\n    else:\n      nextHalf = str(int(half) + 1)\n      reversedNextHalf = nextHalf[:sz // 2][::-1]\n      palindromes.append(int(nextHalf + reversedNextHalf))\n\n    return palindromes\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 537, "slug": "complex-number-multiplication", "solutions": ["class Solution:\n    def complexNumberMultiply(self, num1: str, num2: str) -> str:\n        a1, b1 = map(int, num1[:-1].split(\"+\"))\n        a2, b2 = map(int, num2[:-1].split(\"+\"))\n        return f\"{a1 * a2 - b1 * b2}+{a1 * b2 + a2 * b1}i\"\n", "class Solution:\n  def complexNumberMultiply(self, num1: str, num2: str) -> str:\n    a0, a1 = self._getReala0ndImag(num1)\n    b0, b1 = self._getReala0ndImag(num2)\n    return str(a0 * b0 - a1 * b1) + '+' + str(a0 * b1 + a1 * b0) + 'i'\n\n  def _getReala0ndImag(self, s: str) -> tuple:\n    return int(s[:s.index('+')]), int(s[s.index('+') + 1:-1])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 570, "slug": "managers-with-at-least-5-direct-reports", "solutions": ["import pandas as pd\n\n\ndef find_managers(employee: pd.DataFrame) -> pd.DataFrame:\n    # Group the employees by managerId and count the number of direct reports\n    manager_report_count = (\n        employee.groupby(\"managerId\").size().reset_index(name=\"directReports\")\n    )\n\n    # Filter managers with at least five direct reports\n    result = manager_report_count[manager_report_count[\"directReports\"] >= 5]\n\n    # Merge with the Employee table to get the names of these managers\n    result = result.merge(\n        employee[[\"id\", \"name\"]], left_on=\"managerId\", right_on=\"id\", how=\"inner\"\n    )\n\n    # Select only the 'name' column and drop the 'id' and 'directReports' columns\n    result = result[[\"name\"]]\n\n    return result\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 553, "slug": "optimal-division", "solutions": ["class Solution:\n    def optimalDivision(self, nums: List[int]) -> str:\n        n = len(nums)\n        if n == 1:\n            return str(nums[0])\n        if n == 2:\n            return f'{nums[0]}/{nums[1]}'\n        return f'{nums[0]}/({\"/\".join(map(str, nums[1:]))})'\n", "class Solution:\n  def optimalDivision(self, nums: list[int]) -> str:\n    ans = str(nums[0])\n\n    if len(nums) == 1:\n      return ans\n    if len(nums) == 2:\n      return ans + '/' + str(nums[1])\n\n    ans += '/(' + str(nums[1])\n    for i in range(2, len(nums)):\n      ans += '/' + str(nums[i])\n    ans += ')'\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 528, "slug": "random-pick-with-weight", "solutions": ["class Solution:\n    def __init__(self, w: List[int]):\n        self.s = [0]\n        for c in w:\n            self.s.append(self.s[-1] + c)\n\n    def pickIndex(self) -> int:\n        x = random.randint(1, self.s[-1])\n        left, right = 1, len(self.s) - 1\n        while left < right:\n            mid = (left + right) >> 1\n            if self.s[mid] >= x:\n                right = mid\n            else:\n                left = mid + 1\n        return left - 1\n\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution(w)\n# param_1 = obj.pickIndex()\n", "class Solution:\n  def __init__(self, w: list[int]):\n    self.prefix = list(itertools.accumulate(w))\n\n  def pickIndex(self) -> int:\n    target = random.randint(0, self.prefix[-1] - 1)\n    return bisect.bisect_right(range(len(self.prefix)), target,\n                               key=lambda m: self.prefix[m])\n", "class Solution:\n  def __init__(self, w: list[int]):\n    self.prefix = list(itertools.accumulate(w))\n\n  def pickIndex(self) -> int:\n    return bisect_left(self.prefix, random.random() * self.prefix[-1])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 593, "slug": "valid-square", "solutions": ["class Solution:\n    def validSquare(\n        self, p1: List[int], p2: List[int], p3: List[int], p4: List[int]\n    ) -> bool:\n        def check(a, b, c):\n            (x1, y1), (x2, y2), (x3, y3) = a, b, c\n            d1 = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)\n            d2 = (x1 - x3) * (x1 - x3) + (y1 - y3) * (y1 - y3)\n            d3 = (x2 - x3) * (x2 - x3) + (y2 - y3) * (y2 - y3)\n            return any(\n                [\n                    d1 == d2 and d1 + d2 == d3 and d1,\n                    d2 == d3 and d2 + d3 == d1 and d2,\n                    d1 == d3 and d1 + d3 == d2 and d1,\n                ]\n            )\n\n        return (\n            check(p1, p2, p3)\n            and check(p2, p3, p4)\n            and check(p1, p3, p4)\n            and check(p1, p2, p4)\n        )\n", "class Solution:\n  def validSquare(\n      self,\n      p1: list[int],\n      p2: list[int],\n      p3: list[int],\n      p4: list[int],\n  ) -> bool:\n    def dist(p1: list[int], p2: list[int]) -> int:\n      return (p1[0] - p2[0])**2 + (p1[1] - p2[1])**2\n\n    distSet = set([dist(*pair)\n                   for pair in list(\n                       itertools.combinations([p1, p2, p3, p4], 2))])\n    return 0 not in distSet and len(distSet) == 2\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 540, "slug": "single-element-in-a-sorted-array", "solutions": ["class Solution:\n    def singleNonDuplicate(self, nums: List[int]) -> int:\n        l, r = 0, len(nums) - 1\n        while l < r:\n            mid = (l + r) >> 1\n            if nums[mid] != nums[mid ^ 1]:\n                r = mid\n            else:\n                l = mid + 1\n        return nums[l]\n", "class Solution:\n  def singleNonDuplicate(self, nums: list[int]) -> int:\n    l = 0\n    r = len(nums) - 1\n\n    while l < r:\n      m = (l + r) // 2\n      if m % 2 == 1:\n        m -= 1\n      if nums[m] == nums[m + 1]:\n        l = m + 2\n      else:\n        r = m\n\n    return nums[l]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 542, "slug": "01-matrix", "solutions": ["class Solution:\n    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:\n        m, n = len(mat), len(mat[0])\n        ans = [[-1] * n for _ in range(m)]\n        q = deque()\n        for i, row in enumerate(mat):\n            for j, x in enumerate(row):\n                if x == 0:\n                    ans[i][j] = 0\n                    q.append((i, j))\n        dirs = (-1, 0, 1, 0, -1)\n        while q:\n            i, j = q.popleft()\n            for a, b in pairwise(dirs):\n                x, y = i + a, j + b\n                if 0 <= x < m and 0 <= y < n and ans[x][y] == -1:\n                    ans[x][y] = ans[i][j] + 1\n                    q.append((x, y))\n        return ans\n", "class Solution:\n  def updateMatrix(self, mat: list[list[int]]) -> list[list[int]]:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(mat)\n    n = len(mat[0])\n    q = collections.deque()\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 0:\n          q.append((i, j))\n        else:\n          mat[i][j] = math.inf\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if mat[x][y] <= mat[i][j] + 1:\n          continue\n        q.append((x, y))\n        mat[x][y] = mat[i][j] + 1\n\n    return mat\n", "class Solution:\n  def updateMatrix(self, mat: list[list[int]]) -> list[list[int]]:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(mat)\n    n = len(mat[0])\n    q = collections.deque()\n    seen = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 0:\n          q.append((i, j))\n          seen[i][j] = True\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if seen[x][y]:\n          continue\n        mat[x][y] = mat[i][j] + 1\n        q.append((x, y))\n        seen[x][y] = True\n\n    return mat\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 586, "slug": "customer-placing-the-largest-number-of-orders", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 583, "slug": "delete-operation-for-two-strings", "solutions": ["class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        m, n = len(word1), len(word2)\n        f = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            f[i][0] = i\n        for j in range(1, n + 1):\n            f[0][j] = j\n        for i, a in enumerate(word1, 1):\n            for j, b in enumerate(word2, 1):\n                if a == b:\n                    f[i][j] = f[i - 1][j - 1]\n                else:\n                    f[i][j] = min(f[i - 1][j], f[i][j - 1]) + 1\n        return f[m][n]\n", "class Solution:\n  def minDistance(self, word1: str, word2: str) -> int:\n    k = self._lcs(word1, word2)\n    return (len(word1) - k) + (len(word2) - k)\n\n  def _lcs(self, a: str, b: str) -> int:\n    m = len(a)\n    n = len(b)\n    # dp[i][j] := the length of LCS(a[0..i), b[0..j))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        if a[i - 1] == b[j - 1]:\n          dp[i][j] = 1 + dp[i - 1][j - 1]\n        else:\n          dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[m][n]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 527, "slug": "word-abbreviation", "solutions": ["class Trie:\n    __slots__ = [\"children\", \"cnt\"]\n\n    def __init__(self):\n        self.children = [None] * 26\n        self.cnt = 0\n\n    def insert(self, w: str):\n        node = self\n        for c in w:\n            idx = ord(c) - ord(\"a\")\n            if not node.children[idx]:\n                node.children[idx] = Trie()\n            node = node.children[idx]\n            node.cnt += 1\n\n    def search(self, w: str) -> int:\n        node = self\n        cnt = 0\n        for c in w:\n            cnt += 1\n            idx = ord(c) - ord(\"a\")\n            node = node.children[idx]\n            if node.cnt == 1:\n                return cnt\n        return len(w)\n\n\nclass Solution:\n    def wordsAbbreviation(self, words: List[str]) -> List[str]:\n        tries = {}\n        for w in words:\n            m = len(w)\n            if (m, w[-1]) not in tries:\n                tries[(m, w[-1])] = Trie()\n            tries[(m, w[-1])].insert(w)\n        ans = []\n        for w in words:\n            cnt = tries[(len(w), w[-1])].search(w)\n            ans.append(\n                w if cnt + 2 >= len(w) else w[:cnt] + str(len(w) - cnt - 1) + w[-1]\n            )\n        return ans\n", "from dataclasses import dataclass\n\n\n@dataclass\nclass IndexedWord:\n  word: str\n  index: int\n\n\nclass TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = collections.defaultdict(TrieNode)\n    self.count = 0\n\n\nclass Solution:\n  def wordsAbbreviation(self, words: list[str]) -> list[str]:\n    n = len(words)\n    ans = [''] * n\n\n    def getAbbrev(s: str, prefixIndex: int) -> str:\n      n = len(s)\n      num = n - (prefixIndex + 1) - 1\n      numLength = 1 if num < 10 else (2 if num < 100 else 3)\n      abbrevLength = (prefixIndex + 1) + numLength + 1\n      if abbrevLength >= n:\n        return s\n      return s[:prefixIndex + 1] + str(num) + s[-1]\n\n    abbrevToIndexedWords = collections.defaultdict(list)\n\n    for i, word in enumerate(words):\n      abbrev = getAbbrev(word, 0)\n      abbrevToIndexedWords[abbrev].append(IndexedWord(word, i))\n\n    def insertWord(root: TrieNode | None, word: str) -> None:\n      node = root\n      for c in word:\n        node = node.children.setdefault(c, TrieNode())\n        node.count += 1\n\n    def firstUniqueIndex(root: TrieNode | None, word: str) -> None:\n      node = root\n      for i, c in enumerate(word):\n        node = node.children[c]\n        if node.count == 1:\n          return i\n      return len(word)\n\n    for indexedWords in abbrevToIndexedWords.values():\n      root = TrieNode()\n      for iw in indexedWords:\n        insertWord(root, iw.word)\n      for iw in indexedWords:\n        index = firstUniqueIndex(root, iw.word)\n        ans[iw.index] = getAbbrev(iw.word, index)\n\n    return ans\n", "from dataclasses import dataclass\n\n\n@dataclass\nclass IndexedWord:\n  word: str\n  index: int\n\n\nclass Solution:\n  def wordsAbbreviation(self, words: list[str]) -> list[str]:\n    n = len(words)\n    ans = [''] * n\n\n    def getAbbrev(s: str, prefixIndex: int) -> str:\n      n = len(s)\n      num = n - (prefixIndex + 1) - 1\n      numLength = 1 if num < 10 else (2 if num < 100 else 3)\n      abbrevLength = (prefixIndex + 1) + numLength + 1\n      if abbrevLength >= n:\n        return s\n      return s[:prefixIndex + 1] + str(num) + s[-1]\n\n    abbrevToIndexedWords = collections.defaultdict(list)\n\n    for i, word in enumerate(words):\n      abbrev = getAbbrev(word, 0)\n      abbrevToIndexedWords[abbrev].append(IndexedWord(word, i))\n\n    def longestCommonPrefix(s1: str, s2: str) -> int:\n      i = 0\n      while i < len(s1) and i < len(s2) and s1[i] == s2[i]:\n        i += 1\n      return i\n\n    for indexedWords in abbrevToIndexedWords.values():\n      indexedWords.sort(key=lambda x: x.word)\n      lcp = [0] * len(indexedWords)\n      for i, (a, b) in enumerate(zip(indexedWords, indexedWords[1:])):\n        k = longestCommonPrefix(a.word, b.word)\n        lcp[i] = max(lcp[i], k)\n        lcp[i + 1] = k\n      for iw, l in zip(indexedWords, lcp):\n        ans[iw.index] = getAbbrev(iw.word, l)\n\n    return ans\n", "class Solution:\n  def wordsAbbreviation(self, words: list[str]) -> list[str]:\n    n = len(words)\n\n    def getAbbrev(s: str, prefixIndex: int) -> str:\n      n = len(s)\n      num = n - (prefixIndex + 1) - 1\n      numLength = 1 if num < 10 else (2 if num < 100 else 3)\n      abbrevLength = (prefixIndex + 1) + numLength + 1\n      if abbrevLength >= n:\n        return s\n      return s[:prefixIndex + 1] + str(num) + s[-1]\n\n    ans = [getAbbrev(word, 0) for word in words]\n    # prefix[i] := ans[i] takes words[i][0..prefix[i]]\n    prefix = [0] * n\n\n    for i in range(n):\n      while True:\n        dupeIndices = []\n        for j in range(i + 1, n):\n          if ans[i] == ans[j]:\n            dupeIndices.append(j)\n        if not dupeIndices:\n          break\n        dupeIndices.append(i)\n        for index in dupeIndices:\n          prefix[index] += 1\n          ans[index] = getAbbrev(words[index], prefix[index])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 560, "slug": "subarray-sum-equals-k", "solutions": ["class Solution:\n    def subarraySum(self, nums: List[int], k: int) -> int:\n        cnt = Counter({0: 1})\n        ans = s = 0\n        for x in nums:\n            s += x\n            ans += cnt[s - k]\n            cnt[s] += 1\n        return ans\n", "class Solution:\n  def subarraySum(self, nums: list[int], k: int) -> int:\n    ans = 0\n    prefix = 0\n    count = collections.Counter({0: 1})\n\n    for num in nums:\n      prefix += num\n      ans += count[prefix - k]\n      count[prefix] += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 507, "slug": "perfect-number", "solutions": ["class Solution:\n    def checkPerfectNumber(self, num: int) -> bool:\n        if num == 1:\n            return False\n        s, i = 1, 2\n        while i <= num // i:\n            if num % i == 0:\n                s += i\n                if i != num // i:\n                    s += num // i\n            i += 1\n        return s == num\n", "class Solution:\n  def checkPerfectNumber(self, num: int) -> bool:\n    return num in {6, 28, 496, 8128, 33550336}\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 555, "slug": "split-concatenated-strings", "solutions": ["class Solution:\n    def splitLoopedString(self, strs: List[str]) -> str:\n        strs = [s[::-1] if s[::-1] > s else s for s in strs]\n        ans = ''.join(strs)\n        for i, s in enumerate(strs):\n            t = ''.join(strs[i + 1 :]) + ''.join(strs[:i])\n            for j in range(len(s)):\n                a = s[j:]\n                b = s[:j]\n                ans = max(ans, a + t + b)\n                ans = max(ans, b[::-1] + t + a[::-1])\n        return ans\n", "class Solution:\n  def splitLoopedString(self, strs: list[str]) -> str:\n    ans = ''\n    sortedStrs = [max(s, s[::-1]) for s in strs]\n\n    for i, sortedStr in enumerate(sortedStrs):\n      for s in (sortedStr, sortedStr[::-1]):\n        for j in range(len(s) + 1):\n          ans = max(\n              ans, s[j:] + ''.join(sortedStrs[i + 1:] + sortedStrs[:i]) + s[:j])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 576, "slug": "out-of-boundary-paths", "solutions": ["class Solution:\n    def findPaths(\n        self, m: int, n: int, maxMove: int, startRow: int, startColumn: int\n    ) -> int:\n        @cache\n        def dfs(i: int, j: int, k: int) -> int:\n            if not 0 <= i < m or not 0 <= j < n:\n                return int(k >= 0)\n            if k <= 0:\n                return 0\n            ans = 0\n            for a, b in pairwise(dirs):\n                x, y = i + a, j + b\n                ans = (ans + dfs(x, y, k - 1)) % mod\n            return ans\n\n        mod = 10**9 + 7\n        dirs = (-1, 0, 1, 0, -1)\n        return dfs(startRow, startColumn, maxMove)\n", "class Solution:\n  def findPaths(\n      self,\n      m: int,\n      n: int,\n      maxMove: int,\n      startRow: int,\n      startColumn: int,\n  ) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    MOD = 1_000_000_007\n    ans = 0\n    # dp[i][j] := the number of paths to move the ball (i, j) out-of-bounds\n    dp = [[0] * n for _ in range(m)]\n    dp[startRow][startColumn] = 1\n\n    for _ in range(maxMove):\n      newDp = [[0] * n for _ in range(m)]\n      for i in range(m):\n        for j in range(n):\n          if dp[i][j] > 0:\n            for dx, dy in DIRS:\n              x = i + dx\n              y = j + dy\n              if x < 0 or x == m or y < 0 or y == n:\n                ans = (ans + dp[i][j]) % MOD\n              else:\n                newDp[x][y] = (newDp[x][y] + dp[i][j]) % MOD\n      dp = newDp\n\n    return ans\n", "class Solution:\n  def findPaths(self, m, n, maxMove, startRow, startColumn):\n    MOD = 1000000007\n\n    @functools.lru_cache(None)\n    def dp(k: int, i: int, j: int) -> int:\n      \"\"\"\n      Returns the number of paths to move the ball at (i, j) out-of-bounds with\n      k moves.\n      \"\"\"\n      if i < 0 or i == m or j < 0 or j == n:\n        return 1\n      if k == 0:\n        return 0\n      return (dp(k - 1, i + 1, j) + dp(k - 1, i - 1, j) +\n              dp(k - 1, i, j + 1) + dp(k - 1, i, j - 1)) % MOD\n\n    return dp(maxMove, startRow, startColumn)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 550, "slug": "game-play-analysis-iv", "solutions": ["import pandas as pd\n\n\ndef gameplay_analysis(activity: pd.DataFrame) -> pd.DataFrame:\n    activity[\"first\"] = activity.groupby(\"player_id\").event_date.transform(min)\n    activity_2nd_day = activity[\n        activity[\"first\"] + pd.DateOffset(1) == activity[\"event_date\"]\n    ]\n\n    return pd.DataFrame(\n        {\"fraction\": [round(len(activity_2nd_day) / activity.player_id.nunique(), 2)]}\n    )\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 566, "slug": "reshape-the-matrix", "solutions": ["class Solution:\n    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\n        m, n = len(mat), len(mat[0])\n        if m * n != r * c:\n            return mat\n        ans = [[0] * c for _ in range(r)]\n        for i in range(m * n):\n            ans[i // c][i % c] = mat[i // n][i % n]\n        return ans\n", "class Solution:\n  def matrixReshape(self, nums: list[list[int]],\n                    r: int, c: int) -> list[list[int]]:\n    if nums == [] or r * c != len(nums) * len(nums[0]):\n      return nums\n\n    ans = [[0 for j in range(c)] for i in range(r)]\n    k = 0\n\n    for row in nums:\n      for num in row:\n        ans[k // c][k % c] = num\n        k += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 539, "slug": "minimum-time-difference", "solutions": ["class Solution:\n    def findMinDifference(self, timePoints: List[str]) -> int:\n        if len(timePoints) > 1440:\n            return 0\n        nums = sorted(int(x[:2]) * 60 + int(x[3:]) for x in timePoints)\n        nums.append(nums[0] + 1440)\n        return min(b - a for a, b in pairwise(nums))\n", "class Solution:\n  def findMinDifference(self, timePoints: list[str]) -> int:\n    ans = 24 * 60\n    nums = sorted([int(timePoint[:2]) * 60 + int(timePoint[3:])\n                   for timePoint in timePoints])\n\n    for a, b in zip(nums, nums[1:]):\n      ans = min(ans, b - a)\n\n    return min(ans, 24 * 60 - nums[-1] + nums[0])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 513, "slug": "find-bottom-left-tree-value", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        q = deque([root])\n        ans = 0\n        while q:\n            ans = q[0].val\n            for _ in range(len(q)):\n                node = q.popleft()\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n        return ans\n", "class Solution:\n  def findBottomLeftValue(self, root: TreeNode | None) -> int:\n    q = collections.deque([root])\n\n    while q:\n      root = q.popleft()\n      if root.right:\n        q.append(root.right)\n      if root.left:\n        q.append(root.left)\n\n    return root.val\n", "class Solution:\n  def findBottomLeftValue(self, root: TreeNode | None) -> int:\n    ans = 0\n    maxDepth = 0\n\n    def dfs(root: TreeNode | None, depth: int) -> None:\n      nonlocal ans\n      nonlocal maxDepth\n      if not root:\n        return\n      if depth > maxDepth:\n        maxDepth = depth\n        ans = root.val\n\n      dfs(root.left, depth + 1)\n      dfs(root.right, depth + 1)\n\n    dfs(root, 1)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 524, "slug": "longest-word-in-dictionary-through-deleting", "solutions": ["class Solution:\n    def findLongestWord(self, s: str, dictionary: List[str]) -> str:\n        def check(s: str, t: str) -> bool:\n            m, n = len(s), len(t)\n            i = j = 0\n            while i < m and j < n:\n                if s[i] == t[j]:\n                    i += 1\n                j += 1\n            return i == m\n\n        ans = \"\"\n        for t in dictionary:\n            if check(t, s) and (len(ans) < len(t) or (len(ans) == len(t) and ans > t)):\n                ans = t\n        return ans\n", "class Solution:\n  def findLongestWord(self, s: str, d: list[str]) -> str:\n    ans = ''\n\n    for word in d:\n      i = 0\n      for c in s:\n        if i < len(word) and c == word[i]:\n          i += 1\n      if i == len(word):\n        if len(word) > len(ans) or len(word) == len(ans) and word < ans:\n          ans = word\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 591, "slug": "tag-validator", "solutions": ["class Solution:\n    def isValid(self, code: str) -> bool:\n        def check(tag):\n            return 1 <= len(tag) <= 9 and all(c.isupper() for c in tag)\n\n        stk = []\n        i, n = 0, len(code)\n        while i < n:\n            if i and not stk:\n                return False\n            if code[i : i + 9] == '<![CDATA[':\n                i = code.find(']]>', i + 9)\n                if i < 0:\n                    return False\n                i += 2\n            elif code[i : i + 2] == '</':\n                j = i + 2\n                i = code.find('>', j)\n                if i < 0:\n                    return False\n                t = code[j:i]\n                if not check(t) or not stk or stk.pop() != t:\n                    return False\n            elif code[i] == '<':\n                j = i + 1\n                i = code.find('>', j)\n                if i < 0:\n                    return False\n                t = code[j:i]\n                if not check(t):\n                    return False\n                stk.append(t)\n            i += 1\n        return not stk\n", "class Solution:\n  def isValid(self, code: str) -> bool:\n    if code[0] != '<' or code[-1] != '>':\n      return False\n\n    containsTag = False\n    stack = []\n\n    def isValidCdata(s: str) -> bool:\n      return s.find('[CDATA[') == 0\n\n    def isValidTagName(tagName: str, isEndTag: bool) -> bool:\n      nonlocal containsTag\n      if not tagName or len(tagName) > 9:\n        return False\n      if any(not c.isupper() for c in tagName):\n        return False\n\n      if isEndTag:\n        return stack and stack.pop() == tagName\n\n      containsTag = True\n      stack.append(tagName)\n      return True\n\n    i = 0\n    while i < len(code):\n      if not stack and containsTag:\n        return False\n      if code[i] == '<':\n        # It's inside a tag, so check if it's a cdata.\n        if stack and code[i + 1] == '!':\n          closeIndex = code.find(']]>', i + 2)\n          if closeIndex == -1 or not isValidCdata(code[i + 2:closeIndex]):\n            return False\n        elif code[i + 1] == '/':  # the end tag\n          closeIndex = code.find('>', i + 2)\n          if closeIndex == -1 or not isValidTagName(\n                  code[i + 2: closeIndex],\n                  True):\n            return False\n        else:  # the start tag\n          closeIndex = code.find('>', i + 1)\n          if closeIndex == -1 or not isValidTagName(\n                  code[i + 1: closeIndex],\n                  False):\n            return False\n        i = closeIndex\n      i += 1\n\n    return not stack and containsTag\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 516, "slug": "longest-palindromic-subsequence", "solutions": ["class Solution:\n    def longestPalindromeSubseq(self, s: str) -> int:\n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for j in range(1, n):\n            for i in range(j - 1, -1, -1):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i + 1][j - 1] + 2\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        return dp[0][-1]\n", "class Solution:\n  def longestPalindromeSubseq(self, s: str) -> int:\n    n = len(s)\n    # dp[i][j] := the length of LPS(s[i..j])\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i] = 1\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        if s[i] == s[j]:\n          dp[i][j] = 2 + dp[i + 1][j - 1]\n        else:\n          dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n\n    return dp[0][n - 1]\n", "class Solution:\n  def longestPalindromeSubseq(self, s: str) -> int:\n    @functools.lru_cache(None)\n    def dp(i: int, j: int) -> int:\n      \"\"\"Returns the length of LPS(s[i..j]).\"\"\"\n      if i > j:\n        return 0\n      if i == j:\n        return 1\n      if s[i] == s[j]:\n        return 2 + dp(i + 1, j - 1)\n      return max(dp(i + 1, j), dp(i, j - 1))\n\n    return dp(0, len(s) - 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 590, "slug": "n-ary-tree-postorder-traversal", "solutions": ["\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\"\"\"\n\n\nclass Solution:\n    def postorder(self, root: 'Node') -> List[int]:\n        def dfs(root):\n            if root is None:\n                return\n            for child in root.children:\n                dfs(child)\n            ans.append(root.val)\n\n        ans = []\n        dfs(root)\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 515, "slug": "find-largest-value-in-each-tree-row", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def largestValues(self, root: Optional[TreeNode]) -> List[int]:\n        ans = []\n        if root is None:\n            return ans\n        q = deque([root])\n        while q:\n            x = -inf\n            for _ in range(len(q)):\n                node = q.popleft()\n                x = max(x, node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            ans.append(x)\n        return ans\n", "class Solution:\n  def largestValues(self, root: TreeNode | None) -> list[int]:\n    if not root:\n      return []\n\n    ans = []\n    q = collections.deque([root])\n\n    while q:\n      mx = -math.inf\n      for _ in range(len(q)):\n        root = q.popleft()\n        mx = max(mx, root.val)\n        if root.left:\n          q.append(root.left)\n        if root.right:\n          q.append(root.right)\n      ans.append(mx)\n\n    return ans\n", "class Solution:\n  def largestValues(self, root: TreeNode | None) -> list[int]:\n    ans = []\n\n    def dfs(root: TreeNode | None, depth: int) -> None:\n      if not root:\n        return\n      if depth + 1 > len(ans):\n        ans.append(root.val)\n      else:\n        ans[depth] = max(ans[depth], root.val)\n\n      dfs(root.left, depth + 1)\n      dfs(root.right, depth + 1)\n\n    dfs(root, 0)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 511, "slug": "game-play-analysis-i", "solutions": ["import pandas as pd\n\n\ndef game_analysis(activity: pd.DataFrame) -> pd.DataFrame:\n    return (\n        activity.groupby(\"player_id\")\n        .agg(first_login=(\"event_date\", \"min\"))\n        .reset_index()\n    )\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 517, "slug": "super-washing-machines", "solutions": ["class Solution:\n    def findMinMoves(self, machines: List[int]) -> int:\n        n = len(machines)\n        k, mod = divmod(sum(machines), n)\n        if mod:\n            return -1\n        ans = s = 0\n        for x in machines:\n            x -= k\n            s += x\n            ans = max(ans, abs(s), x)\n        return ans\n", "class Solution:\n  def findMinMoves(self, machines: list[int]) -> int:\n    dresses = sum(machines)\n\n    if dresses % len(machines) != 0:\n      return -1\n\n    ans = 0\n    average = dresses // len(machines)\n    inout = 0\n\n    for dress in machines:\n      inout += dress - average\n      ans = max(ans, abs(inout), dress - average)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 521, "slug": "longest-uncommon-subsequence-i", "solutions": ["class Solution:\n    def findLUSlength(self, a: str, b: str) -> int:\n        return -1 if a == b else max(len(a), len(b))\n", "class Solution:\n  def findLUSlength(self, a: str, b: str) -> int:\n    return -1 if a == b else max(len(a), len(b))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 534, "slug": "game-play-analysis-iii", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 573, "slug": "squirrel-simulation", "solutions": ["class Solution:\n    def minDistance(\n        self,\n        height: int,\n        width: int,\n        tree: List[int],\n        squirrel: List[int],\n        nuts: List[List[int]],\n    ) -> int:\n        tr, tc = tree\n        sr, sc = squirrel\n        s = sum(abs(r - tr) + abs(c - tc) for r, c in nuts) * 2\n        ans = inf\n        for r, c in nuts:\n            a = abs(r - tr) + abs(c - tc)\n            b = abs(r - sr) + abs(c - sc)\n            ans = min(ans, s - a + b)\n        return ans\n", "class Solution:\n  def minDistance(\n      self,\n      height: int,\n      width: int,\n      tree: list[int],\n      squirrel: list[int],\n      nuts: list[list[int]],\n  ) -> int:\n    def dist(a: list[int], b: list[int]) -> int:\n      return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    totDist = sum(dist(nut, tree) for nut in nuts) * 2\n    maxSave = max(dist(nut, tree) - dist(nut, squirrel) for nut in nuts)\n    return totDist - maxSave\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 596, "slug": "classes-more-than-5-students", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 556, "slug": "next-greater-element-iii", "solutions": ["class Solution:\n    def nextGreaterElement(self, n: int) -> int:\n        cs = list(str(n))\n        n = len(cs)\n        i, j = n - 2, n - 1\n        while i >= 0 and cs[i] >= cs[i + 1]:\n            i -= 1\n        if i < 0:\n            return -1\n        while cs[i] >= cs[j]:\n            j -= 1\n        cs[i], cs[j] = cs[j], cs[i]\n        cs[i + 1 :] = cs[i + 1 :][::-1]\n        ans = int(''.join(cs))\n        return -1 if ans > 2**31 - 1 else ans\n", "class Solution:\n  def nextGreaterElement(self, n: int) -> int:\n    def nextPermutation(s: list[str]) -> str:\n      i = len(s) - 2\n      while i >= 0:\n        if s[i] < s[i + 1]:\n          break\n        i -= 1\n\n      if i >= 0:\n        for j in range(len(s) - 1, i, -1):\n          if s[j] > s[i]:\n            break\n        s[i], s[j] = s[j], s[i]\n\n      reverse(s, i + 1, len(s) - 1)\n      return ''.join(s)\n\n    def reverse(s: list[str], l: int, r: int):\n      while l < r:\n        s[l], s[r] = s[r], s[l]\n        l += 1\n        r -= 1\n\n    s = nextPermutation(list(str(n)))\n    ans = int(s)\n    return -1 if ans > 2**31 - 1 or ans <= n else ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 594, "slug": "longest-harmonious-subsequence", "solutions": ["class Solution:\n    def findLHS(self, nums: List[int]) -> int:\n        cnt = Counter(nums)\n        return max((c + cnt[x + 1] for x, c in cnt.items() if cnt[x + 1]), default=0)\n", "class Solution:\n  def findLHS(self, nums: list[int]) -> int:\n    ans = 0\n    count = collections.Counter(nums)\n\n    for num, freq in count.items():\n      if num + 1 in count:\n        ans = max(ans, freq + count[num + 1])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 503, "slug": "next-greater-element-ii", "solutions": ["class Solution:\n    def nextGreaterElements(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        ans = [-1] * n\n        stk = []\n        for i in range(n * 2 - 1, -1, -1):\n            i %= n\n            while stk and stk[-1] <= nums[i]:\n                stk.pop()\n            if stk:\n                ans[i] = stk[-1]\n            stk.append(nums[i])\n        return ans\n", "class Solution:\n  def nextGreaterElements(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n    ans = [-1] * n\n    stack = []  # a decreasing stack storing indices\n\n    for i in range(n * 2):\n      num = nums[i % n]\n      while stack and nums[stack[-1]] < num:\n        ans[stack.pop()] = num\n      if i < n:\n        stack.append(i)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 562, "slug": "longest-line-of-consecutive-one-in-matrix", "solutions": ["class Solution:\n    def longestLine(self, mat: List[List[int]]) -> int:\n        m, n = len(mat), len(mat[0])\n        a = [[0] * (n + 2) for _ in range(m + 2)]\n        b = [[0] * (n + 2) for _ in range(m + 2)]\n        c = [[0] * (n + 2) for _ in range(m + 2)]\n        d = [[0] * (n + 2) for _ in range(m + 2)]\n        ans = 0\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if mat[i - 1][j - 1]:\n                    a[i][j] = a[i - 1][j] + 1\n                    b[i][j] = b[i][j - 1] + 1\n                    c[i][j] = c[i - 1][j - 1] + 1\n                    d[i][j] = d[i - 1][j + 1] + 1\n                    ans = max(ans, a[i][j], b[i][j], c[i][j], d[i][j])\n        return ans\n", "class Solution:\n  def longestLine(self, mat: list[list[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    ans = 0\n    # dp[i][j][0] := horizontal\n    # dp[i][j][1] := vertical\n    # dp[i][j][2] := diagonal\n    # dp[i][j][3] := anti-diagonal\n    dp = [[[0] * 4 for j in range(n)] for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 1:\n          dp[i][j][0] = dp[i][j - 1][0] + 1 if j > 0 else 1\n          dp[i][j][1] = dp[i - 1][j][1] + 1 if i > 0 else 1\n          dp[i][j][2] = dp[i - 1][j - 1][2] + 1 if i > 0 and j > 0 else 1\n          dp[i][j][3] = dp[i - 1][j + 1][3] + 1 if i > 0 and j < n - 1 else 1\n          ans = max(ans, max(dp[i][j]))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 579, "slug": "find-cumulative-salary-of-an-employee", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 581, "slug": "shortest-unsorted-continuous-subarray", "solutions": ["class Solution:\n    def findUnsortedSubarray(self, nums: List[int]) -> int:\n        arr = sorted(nums)\n        l, r = 0, len(nums) - 1\n        while l <= r and nums[l] == arr[l]:\n            l += 1\n        while l <= r and nums[r] == arr[r]:\n            r -= 1\n        return r - l + 1\n", "class Solution:\n  def findUnsortedSubarray(self, nums: list[int]) -> int:\n    mn = math.inf\n    mx = -math.inf\n    flag = False\n\n    for i in range(1, len(nums)):\n      if nums[i] < nums[i - 1]:\n        flag = True\n      if flag:\n        mn = min(mn, nums[i])\n\n    flag = False\n\n    for i in reversed(range(len(nums) - 1)):\n      if nums[i] > nums[i + 1]:\n        flag = True\n      if flag:\n        mx = max(mx, nums[i])\n\n    for l in range(len(nums)):\n      if nums[l] > mn:\n        break\n\n    for r, num in reversed(list(enumerate(nums))):\n      if num < mx:\n        break\n\n    return 0 if l >= r else r - l + 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 536, "slug": "construct-binary-tree-from-string", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def str2tree(self, s: str) -> TreeNode:\n        def dfs(s):\n            if not s:\n                return None\n            p = s.find('(')\n            if p == -1:\n                return TreeNode(int(s))\n            root = TreeNode(int(s[:p]))\n            start = p\n            cnt = 0\n            for i in range(p, len(s)):\n                if s[i] == '(':\n                    cnt += 1\n                elif s[i] == ')':\n                    cnt -= 1\n                if cnt == 0:\n                    if start == p:\n                        root.left = dfs(s[start + 1 : i])\n                        start = i + 1\n                    else:\n                        root.right = dfs(s[start + 1 : i])\n            return root\n\n        return dfs(s)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 531, "slug": "lonely-pixel-i", "solutions": ["class Solution:\n    def findLonelyPixel(self, picture: List[List[str]]) -> int:\n        rows = [0] * len(picture)\n        cols = [0] * len(picture[0])\n        for i, row in enumerate(picture):\n            for j, x in enumerate(row):\n                if x == \"B\":\n                    rows[i] += 1\n                    cols[j] += 1\n        ans = 0\n        for i, row in enumerate(picture):\n            for j, x in enumerate(row):\n                if x == \"B\" and rows[i] == 1 and cols[j] == 1:\n                    ans += 1\n        return ans\n", "class Solution:\n  def findLonelyPixel(self, picture: list[list[str]]) -> int:\n    m = len(picture)\n    n = len(picture[0])\n    ans = 0\n    rows = [0] * m  # rows[i] := the number of B's in rows i\n    cols = [0] * n  # cols[i] := the number of B's in cols i\n\n    for i in range(m):\n      for j in range(n):\n        if picture[i][j] == 'B':\n          rows[i] += 1\n          cols[j] += 1\n\n    for i in range(m):\n      if rows[i] == 1:  # Only have to examine the rows if rows[i] == 1.\n        for j in range(n):\n          # After meeting a 'B' in this rows, break and search the next row.\n          if picture[i][j] == 'B':\n            if cols[j] == 1:\n              ans += 1\n            break\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 519, "slug": "random-flip-matrix", "solutions": ["class Solution:\n    def __init__(self, m: int, n: int):\n        self.m = m\n        self.n = n\n        self.total = m * n\n        self.mp = {}\n\n    def flip(self) -> List[int]:\n        self.total -= 1\n        x = random.randint(0, self.total)\n        idx = self.mp.get(x, x)\n        self.mp[x] = self.mp.get(self.total, self.total)\n        return [idx // self.n, idx % self.n]\n\n    def reset(self) -> None:\n        self.total = self.m * self.n\n        self.mp.clear()\n\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution(m, n)\n# param_1 = obj.flip()\n# obj.reset()\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 589, "slug": "n-ary-tree-preorder-traversal", "solutions": ["\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\"\"\"\n\n\nclass Solution:\n    def preorder(self, root: \"Node\") -> List[int]:\n        def dfs(root):\n            if root is None:\n                return\n            ans.append(root.val)\n            for child in root.children:\n                dfs(child)\n\n        ans = []\n        dfs(root)\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 501, "slug": "find-mode-in-binary-search-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findMode(self, root: TreeNode) -> List[int]:\n        def dfs(root):\n            if root is None:\n                return\n            nonlocal mx, prev, ans, cnt\n            dfs(root.left)\n            cnt = cnt + 1 if prev == root.val else 1\n            if cnt > mx:\n                ans = [root.val]\n                mx = cnt\n            elif cnt == mx:\n                ans.append(root.val)\n            prev = root.val\n            dfs(root.right)\n\n        prev = None\n        mx = cnt = 0\n        ans = []\n        dfs(root)\n        return ans\n", "class Solution:\n  def findMode(self, root: TreeNode | None) -> list[int]:\n    self.ans = []\n    self.pred = None\n    self.count = 0\n    self.maxCount = 0\n\n    def updateCount(root: TreeNode | None) -> None:\n      if self.pred and self.pred.val == root.val:\n        self.count += 1\n      else:\n        self.count = 1\n\n      if self.count > self.maxCount:\n        self.maxCount = self.count\n        self.ans = [root.val]\n      elif self.count == self.maxCount:\n        self.ans.append(root.val)\n\n      self.pred = root\n\n    def inorder(root: TreeNode | None) -> None:\n      if not root:\n        return\n\n      inorder(root.left)\n      updateCount(root)\n      inorder(root.right)\n\n    inorder(root)\n    return self.ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 500, "slug": "keyboard-row", "solutions": ["class Solution:\n    def findWords(self, words: List[str]) -> List[str]:\n        s1 = set('qwertyuiop')\n        s2 = set('asdfghjkl')\n        s3 = set('zxcvbnm')\n        ans = []\n        for w in words:\n            s = set(w.lower())\n            if s <= s1 or s <= s2 or s <= s3:\n                ans.append(w)\n        return ans\n", "class Solution:\n  def findWords(self, words: list[str]) -> list[str]:\n    ans = []\n    rows = [set('qwertyuiop'), set('asdfghjkl'), set('zxcvbnm')]\n\n    for word in words:\n      lowerWord = set(word.lower())\n      if any(lowerWord <= row for row in rows):\n        ans.append(word)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 572, "slug": "subtree-of-another-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:\n        def same(p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n            if p is None or q is None:\n                return p is q\n            return p.val == q.val and same(p.left, q.left) and same(p.right, q.right)\n\n        if root is None:\n            return False\n        return (\n            same(root, subRoot)\n            or self.isSubtree(root.left, subRoot)\n            or self.isSubtree(root.right, subRoot)\n        )\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 533, "slug": "lonely-pixel-ii", "solutions": ["class Solution:\n    def findBlackPixel(self, picture: List[List[str]], target: int) -> int:\n        rows = [0] * len(picture)\n        g = defaultdict(list)\n        for i, row in enumerate(picture):\n            for j, x in enumerate(row):\n                if x == \"B\":\n                    rows[i] += 1\n                    g[j].append(i)\n        ans = 0\n        for j in g:\n            i1 = g[j][0]\n            if rows[i1] != target:\n                continue\n            if len(g[j]) == rows[i1] and all(picture[i2] == picture[i1] for i2 in g[j]):\n                ans += target\n        return ans\n", "class Solution:\n  def findBlackPixel(self, picture: list[list[str]], target: int) -> int:\n    m = len(picture)\n    n = len(picture[0])\n    ans = 0\n    rows = [row.count('B') for row in picture]\n    cols = [col.count('B') for col in zip(*picture)]\n    rowStrings = [''.join(row) for row in picture]\n    countRowStrings = collections.Counter(rowStrings)\n\n    for i, (row, stringRow) in enumerate(zip(rows, rowStrings)):\n      if row == target and countRowStrings[stringRow] == target:\n        for j, col in enumerate(cols):\n          if picture[i][j] == 'B' and col == target:\n            ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 597, "slug": "friend-requests-i-overall-acceptance-rate", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 551, "slug": "student-attendance-record-i", "solutions": ["class Solution:\n    def checkRecord(self, s: str) -> bool:\n        return s.count('A') < 2 and 'LLL' not in s\n", "class Solution:\n  def checkRecord(self, s: str) -> bool:\n    return s.count('A') <= 1 and 'LLL' not in s\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 520, "slug": "detect-capital", "solutions": ["class Solution:\n    def detectCapitalUse(self, word: str) -> bool:\n        cnt = sum(c.isupper() for c in word)\n        return cnt == 0 or cnt == len(word) or (cnt == 1 and word[0].isupper())\n", "class Solution:\n  def detectCapitalUse(self, word: str) -> bool:\n    return word.isupper() or word.islower() or word.istitle()\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 541, "slug": "reverse-string-ii", "solutions": ["class Solution:\n    def reverseStr(self, s: str, k: int) -> str:\n        cs = list(s)\n        for i in range(0, len(cs), 2 * k):\n            cs[i : i + k] = reversed(cs[i : i + k])\n        return \"\".join(cs)\n", "class Solution:\n  def reverseStr(self, s: str, k: int) -> str:\n    return s[:k][::-1] + s[k:2 * k] + self.reverseStr(s[2 * k:], k) if s else \"\"\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 538, "slug": "convert-bst-to-greater-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def convertBST(self, root: TreeNode) -> TreeNode:\n        def dfs(root):\n            nonlocal s\n            if root is None:\n                return\n            dfs(root.right)\n            s += root.val\n            root.val = s\n            dfs(root.left)\n\n        s = 0\n        dfs(root)\n        return root\n", "class Solution:\n  def convertBST(self, root: TreeNode | None) -> TreeNode | None:\n    prefix = 0\n\n    def reversedInorder(root: TreeNode | None) -> None:\n      nonlocal prefix\n      if not root:\n        return\n\n      reversedInorder(root.right)\n      prefix += root.val\n      root.val = prefix\n      reversedInorder(root.left)\n\n    reversedInorder(root)\n    return root\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 546, "slug": "remove-boxes", "solutions": ["class Solution:\n    def removeBoxes(self, boxes: List[int]) -> int:\n        @cache\n        def dfs(i, j, k):\n            if i > j:\n                return 0\n            while i < j and boxes[j] == boxes[j - 1]:\n                j, k = j - 1, k + 1\n            ans = dfs(i, j - 1, 0) + (k + 1) * (k + 1)\n            for h in range(i, j):\n                if boxes[h] == boxes[j]:\n                    ans = max(ans, dfs(h + 1, j - 1, 0) + dfs(i, h, k + 1))\n            return ans\n\n        n = len(boxes)\n        ans = dfs(0, n - 1, 0)\n        dfs.cache_clear()\n        return ans\n", "class Solution:\n  def removeBoxes(self, boxes: list[int]) -> int:\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, k: int) -> int:\n      \"\"\"\n      Returns the maximum score of boxes[i..j] if k boxes equal to boxes[j].\n      \"\"\"\n      if i > j:\n        return 0\n\n      r = j\n      sameBoxes = k + 1\n      while r > 0 and boxes[r - 1] == boxes[r]:\n        r -= 1\n        sameBoxes += 1\n      res = dp(i, r - 1, 0) + sameBoxes * sameBoxes\n\n      for p in range(i, r):\n        if boxes[p] == boxes[r]:\n          res = max(res, dp(i, p, sameBoxes) + dp(p + 1, r - 1, 0))\n\n      return res\n\n    return dp(0, len(boxes) - 1, 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 543, "slug": "diameter-of-binary-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\n        def dfs(root: Optional[TreeNode]) -> int:\n            if root is None:\n                return 0\n            l, r = dfs(root.left), dfs(root.right)\n            nonlocal ans\n            ans = max(ans, l + r)\n            return 1 + max(l, r)\n\n        ans = 0\n        dfs(root)\n        return ans\n", "class Solution:\n  def diameterOfBinaryTree(self, root: TreeNode | None) -> int:\n    ans = 0\n\n    def maxDepth(root: TreeNode | None) -> int:\n      nonlocal ans\n      if not root:\n        return 0\n\n      l = maxDepth(root.left)\n      r = maxDepth(root.right)\n      ans = max(ans, l + r)\n      return 1 + max(l, r)\n\n    maxDepth(root)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 505, "slug": "the-maze-ii", "solutions": ["class Solution:\n    def shortestDistance(\n        self, maze: List[List[int]], start: List[int], destination: List[int]\n    ) -> int:\n        m, n = len(maze), len(maze[0])\n        dirs = (-1, 0, 1, 0, -1)\n        si, sj = start\n        di, dj = destination\n        q = deque([(si, sj)])\n        dist = [[inf] * n for _ in range(m)]\n        dist[si][sj] = 0\n        while q:\n            i, j = q.popleft()\n            for a, b in pairwise(dirs):\n                x, y, k = i, j, dist[i][j]\n                while 0 <= x + a < m and 0 <= y + b < n and maze[x + a][y + b] == 0:\n                    x, y, k = x + a, y + b, k + 1\n                if k < dist[x][y]:\n                    dist[x][y] = k\n                    q.append((x, y))\n        return -1 if dist[di][dj] == inf else dist[di][dj]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 530, "slug": "minimum-absolute-difference-in-bst", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def getMinimumDifference(self, root: Optional[TreeNode]) -> int:\n        def dfs(root: Optional[TreeNode]):\n            if root is None:\n                return\n            dfs(root.left)\n            nonlocal pre, ans\n            ans = min(ans, root.val - pre)\n            pre = root.val\n            dfs(root.right)\n\n        pre = -inf\n        ans = inf\n        dfs(root)\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 522, "slug": "longest-uncommon-subsequence-ii", "solutions": ["class Solution:\n    def findLUSlength(self, strs: List[str]) -> int:\n        def check(s: str, t: str):\n            i = j = 0\n            while i < len(s) and j < len(t):\n                if s[i] == t[j]:\n                    i += 1\n                j += 1\n            return i == len(s)\n\n        ans = -1\n        for i, s in enumerate(strs):\n            for j, t in enumerate(strs):\n                if i != j and check(s, t):\n                    break\n            else:\n                ans = max(ans, len(s))\n        return ans\n", "class Solution:\n  def findLUSlength(self, strs: list[str]) -> int:\n    def isSubsequence(a: str, b: str) -> bool:\n      i = 0\n      j = 0\n\n      while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n          i += 1\n        j += 1\n\n      return i == len(a)\n\n    seen = set()\n    duplicates = set()\n\n    for s in strs:\n      if s in seen:\n        duplicates.add(s)\n      seen.add(s)\n\n    strs.sort(key=lambda x: -len(x))\n\n    for i in range(len(strs)):\n      if strs[i] in duplicates:\n        continue\n      isASubsequence = False\n      for j in range(i):\n        isASubsequence |= isSubsequence(strs[i], strs[j])\n      if not isASubsequence:\n        return len(strs[i])\n\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 512, "slug": "game-play-analysis-ii", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 559, "slug": "maximum-depth-of-n-ary-tree", "solutions": ["\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val: Optional[int] = None, children: Optional[List['Node']] = None):\n        self.val = val\n        self.children = children\n\"\"\"\n\n\nclass Solution:\n    def maxDepth(self, root: \"Node\") -> int:\n        if root is None:\n            return 0\n        mx = 0\n        for child in root.children:\n            mx = max(mx, self.maxDepth(child))\n        return 1 + mx\n", "class Solution:\n  def maxDepth(self, root: 'Node') -> int:\n    if not root:\n      return 0\n    if not root.children:\n      return 1\n    return 1 + max(self.maxDepth(child) for child in root.children)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 525, "slug": "contiguous-array", "solutions": ["class Solution:\n    def findMaxLength(self, nums: List[int]) -> int:\n        d = {0: -1}\n        ans = s = 0\n        for i, x in enumerate(nums):\n            s += 1 if x else -1\n            if s in d:\n                ans = max(ans, i - d[s])\n            else:\n                d[s] = i\n        return ans\n", "class Solution:\n  def findMaxLength(self, nums: list[int]) -> int:\n    ans = 0\n    prefix = 0\n    prefixToIndex = {0: -1}\n\n    for i, num in enumerate(nums):\n      prefix += 1 if num else -1\n      ans = max(ans, i - prefixToIndex.setdefault(prefix, i))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 584, "slug": "find-customer-referee", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 571, "slug": "find-median-given-frequency-of-numbers", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 587, "slug": "erect-the-fence", "solutions": ["class Solution:\n    def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:\n        def cross(i, j, k):\n            a, b, c = trees[i], trees[j], trees[k]\n            return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\n        n = len(trees)\n        if n < 4:\n            return trees\n        trees.sort()\n        vis = [False] * n\n        stk = [0]\n        for i in range(1, n):\n            while len(stk) > 1 and cross(stk[-2], stk[-1], i) < 0:\n                vis[stk.pop()] = False\n            vis[i] = True\n            stk.append(i)\n        m = len(stk)\n        for i in range(n - 2, -1, -1):\n            if vis[i]:\n                continue\n            while len(stk) > m and cross(stk[-2], stk[-1], i) < 0:\n                stk.pop()\n            stk.append(i)\n        stk.pop()\n        return [trees[i] for i in stk]\n", "class Solution:\n  def outerTrees(self, trees: list[list[int]]) -> list[list[int]]:\n    hull = []\n\n    trees.sort(key=lambda x: (x[0], x[1]))\n\n    def cross(p: list[int], q: list[int], r: list[int]) -> int:\n      return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n\n    # Build the lower hull: left-to-right scan.\n    for tree in trees:\n      while len(hull) > 1 and cross(hull[-1], hull[-2], tree) > 0:\n        hull.pop()\n      hull.append(tuple(tree))\n    hull.pop()\n\n    # Build the upper hull: right-to-left scan.\n    for tree in reversed(trees):\n      while len(hull) > 1 and cross(hull[-1], hull[-2], tree) > 0:\n        hull.pop()\n      hull.append(tuple(tree))\n\n    # Remove the redundant elements from the stack.\n    return list(set(hull))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1563, "slug": "stone-game-v", "solutions": ["def max(a: int, b: int) -> int:\n    return a if a > b else b\n\n\nclass Solution:\n    def stoneGameV(self, stoneValue: List[int]) -> int:\n        @cache\n        def dfs(i: int, j: int) -> int:\n            if i >= j:\n                return 0\n            ans = l = 0\n            r = s[j + 1] - s[i]\n            for k in range(i, j):\n                l += stoneValue[k]\n                r -= stoneValue[k]\n                if l < r:\n                    if ans >= l * 2:\n                        continue\n                    ans = max(ans, l + dfs(i, k))\n                elif l > r:\n                    if ans >= r * 2:\n                        break\n                    ans = max(ans, r + dfs(k + 1, j))\n                else:\n                    ans = max(ans, max(l + dfs(i, k), r + dfs(k + 1, j)))\n            return ans\n\n        s = list(accumulate(stoneValue, initial=0))\n        return dfs(0, len(stoneValue) - 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1541, "slug": "minimum-insertions-to-balance-a-parentheses-string", "solutions": ["class Solution:\n    def minInsertions(self, s: str) -> int:\n        ans = x = 0\n        i, n = 0, len(s)\n        while i < n:\n            if s[i] == '(':\n                #  1\n                x += 1\n            else:\n                if i < n - 1 and s[i + 1] == ')':\n                    # i \n                    i += 1\n                else:\n                    # \n                    ans += 1\n                if x == 0:\n                    # \n                    ans += 1\n                else:\n                    #  1\n                    x -= 1\n            i += 1\n        #  x << 1 \n        ans += x << 1\n        return ans\n", "class Solution:\n  def minInsertions(self, s: str) -> int:\n    neededRight = 0   # Increment by 2 for each '('.\n    missingLeft = 0   # Increment by 1 for each missing '('.\n    missingRight = 0  # Increment by 1 for each missing ')'.\n\n    for c in s:\n      if c == '(':\n        if neededRight % 2 == 1:\n          # e.g. '()(...'\n          missingRight += 1\n          neededRight -= 1\n        neededRight += 2\n      else:  # c == ')'\n        neededRight -= 1\n        if neededRight < 0:\n          # e.g. '()))...'\n          missingLeft += 1\n          neededRight += 2\n\n    return neededRight + missingLeft + missingRight\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1553, "slug": "minimum-number-of-days-to-eat-n-oranges", "solutions": ["class Solution:\n    def minDays(self, n: int) -> int:\n        @cache\n        def dfs(n: int) -> int:\n            if n < 2:\n                return n\n            return 1 + min(n % 2 + dfs(n // 2), n % 3 + dfs(n // 3))\n\n        return dfs(n)\n", "class Solution:\n  @functools.lru_cache(None)\n  def minDays(self, n: int) -> int:\n    if n <= 1:\n      return n\n    return 1 + min(self.minDays(n // 3) + n % 3,\n                   self.minDays(n // 2) + n % 2)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1582, "slug": "special-positions-in-a-binary-matrix", "solutions": ["class Solution:\n    def numSpecial(self, mat: List[List[int]]) -> int:\n        rows = [0] * len(mat)\n        cols = [0] * len(mat[0])\n        for i, row in enumerate(mat):\n            for j, x in enumerate(row):\n                rows[i] += x\n                cols[j] += x\n        ans = 0\n        for i, row in enumerate(mat):\n            for j, x in enumerate(row):\n                ans += x == 1 and rows[i] == 1 and cols[j] == 1\n        return ans\n", "class Solution:\n  def numSpecial(self, mat: list[list[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    ans = 0\n    rowOnes = [0] * m\n    colOnes = [0] * n\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 1:\n          rowOnes[i] += 1\n          colOnes[j] += 1\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 1 and rowOnes[i] == 1 and colOnes[j] == 1:\n          ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1516, "slug": "move-sub-tree-of-n-ary-tree", "solutions": ["class Solution:\n  def moveSubTree(self, root: 'Node', p: 'Node', q: 'Node') -> 'Node':\n    if p in q.children:\n      return root\n\n    # Create a dummy Node for the case when root == p\n    dummy = Node(None, [root])\n\n    # Get each parent of p and q\n    pParent = self._getParent(dummy, p)\n    qParent = self._getParent(p, q)\n\n    # Get p's original index in p's parent\n    pIndex = pParent.children.index(p)\n    pParent.children.pop(pIndex)\n\n    q.children.append(p)\n\n    # If q is in the p's subtree, qParent != None\n    if qParent:\n      qParent.children.remove(q)\n      pParent.children.insert(pIndex, q)\n\n    return dummy.children[0]\n\n  def _getParent(self, root: 'Node', target: 'Node') -> Optional['Node']:\n    for child in root.children:\n      if child == target:\n        return root\n      res = self._getParent(child, target)\n      if res:\n        return res\n    return None\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1523, "slug": "count-odd-numbers-in-an-interval-range", "solutions": ["class Solution:\n    def countOdds(self, low: int, high: int) -> int:\n        return ((high + 1) >> 1) - (low >> 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1504, "slug": "count-submatrices-with-all-ones", "solutions": ["class Solution:\n    def numSubmat(self, mat: List[List[int]]) -> int:\n        m, n = len(mat), len(mat[0])\n        g = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if mat[i][j]:\n                    g[i][j] = 1 if j == 0 else 1 + g[i][j - 1]\n        ans = 0\n        for i in range(m):\n            for j in range(n):\n                col = inf\n                for k in range(i, -1, -1):\n                    col = min(col, g[k][j])\n                    ans += col\n        return ans\n", "class Solution:\n  def numSubmat(self, mat: list[list[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    ans = 0\n\n    for baseRow in range(m):\n      row = [1] * n\n      for i in range(baseRow, m):\n        for j in range(n):\n          row[j] &= mat[i][j]\n        ans += self._count(row)\n\n    return ans\n\n  def _count(self, row: list[int]) -> int:\n    res = 0\n    length = 0\n    for num in row:\n      length = 0 if num == 0 else length + 1\n      res += length\n    return res\n", "class Solution:\n  def numSubmat(self, mat: list[list[int]]) -> int:\n    ans = 0\n    hist = [0] * len(mat[0])\n\n    for row in mat:\n      for i, num in enumerate(row):\n        hist[i] = 0 if num == 0 else hist[i] + 1\n      ans += self._count(hist)\n\n    return ans\n\n  def _count(self, hist: list[int]) -> int:\n    # submatrices[i] := the number of submatrices, where the i-th column is the\n    # right border\n    submatrices = [0] * len(hist)\n    stack = []\n\n    for i, h in enumerate(hist):\n      while stack and hist[stack[-1]] >= h:\n        stack.pop()\n      if stack:\n        prevIndex = stack[-1]\n        submatrices[i] = submatrices[prevIndex] + h * (i - prevIndex)\n      else:\n        submatrices[i] = h * (i + 1)\n      stack.append(i)\n\n    return sum(submatrices)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1588, "slug": "sum-of-all-odd-length-subarrays", "solutions": ["class Solution:\n    def sumOddLengthSubarrays(self, arr: List[int]) -> int:\n        n = len(arr)\n        f = [0] * n\n        g = [0] * n\n        ans = f[0] = arr[0]\n        for i in range(1, n):\n            f[i] = g[i - 1] + arr[i] * (i // 2 + 1)\n            g[i] = f[i - 1] + arr[i] * ((i + 1) // 2)\n            ans += f[i]\n        return ans\n", "class Solution:\n  def sumOddLengthSubarrays(self, arr: list[int]) -> int:\n    ans = 0\n    # Maintain two sums of subarrays ending in the previous index.\n    # Each time we meet a new number, we'll consider 'how many times' it should\n    # contribute to the newly built subarrays by calculating the number of\n    # previous even/odd-length subarrays.\n    prevEvenSum = 0  # the sum of even-length subarrays\n    prevOddSum = 0  # the sum of odd-length subarrays\n\n    for i, a in enumerate(arr):\n      # (i + 1) // 2 := the number of previous odd-length subarrays.\n      currEvenSum = prevOddSum + ((i + 1) // 2) * a\n      # i // 2 + 1 := the number of previous even-length subarrays\n      # (including 0).\n      currOddSum = prevEvenSum + (i // 2 + 1) * a\n      ans += currOddSum\n      prevEvenSum = currEvenSum\n      prevOddSum = currOddSum\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1528, "slug": "shuffle-string", "solutions": ["class Solution:\n    def restoreString(self, s: str, indices: List[int]) -> str:\n        ans = [0] * len(s)\n        for i, c in enumerate(s):\n            ans[indices[i]] = c\n        return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1591, "slug": "strange-printer-ii", "solutions": ["from enum import Enum\n\n\nclass State(Enum):\n  INIT = 0\n  VISITING = 1\n  VISITED = 2\n\n\nclass Solution:\n  def isPrintable(self, targetGrid: list[list[int]]) -> bool:\n    MAX_COLOR = 60\n    m = len(targetGrid)\n    n = len(targetGrid[0])\n\n    # graph[u] := {v1, v2} means v1 and v2 cover u\n    graph = [set() for _ in range(MAX_COLOR + 1)]\n\n    for color in range(1, MAX_COLOR + 1):\n      # Get the rectangle of the current color.\n      minI = m\n      minJ = n\n      maxI = -1\n      maxJ = -1\n      for i in range(m):\n        for j in range(n):\n          if targetGrid[i][j] == color:\n            minI = min(minI, i)\n            minJ = min(minJ, j)\n            maxI = max(maxI, i)\n            maxJ = max(maxJ, j)\n\n      # Add any color covering the current as the children.\n      for i in range(minI, maxI + 1):\n        for j in range(minJ, maxJ + 1):\n          if targetGrid[i][j] != color:\n            graph[color].add(targetGrid[i][j])\n\n    states = [State.INIT] * (MAX_COLOR + 1)\n\n    def hasCycle(u: int) -> bool:\n      if states[u] == State.VISITING:\n        return True\n      if states[u] == State.VISITED:\n        return False\n      states[u] = State.VISITING\n      if any(hasCycle(v) for v in graph[u]):\n        return True\n      states[u] = State.VISITED\n      return False\n\n    return not (any(hasCycle(i) for i in range(1, MAX_COLOR + 1)))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1530, "slug": "number-of-good-leaf-nodes-pairs", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def countPairs(self, root: TreeNode, distance: int) -> int:\n        def dfs(root, cnt, i):\n            if root is None or i >= distance:\n                return\n            if root.left is None and root.right is None:\n                cnt[i] += 1\n                return\n            dfs(root.left, cnt, i + 1)\n            dfs(root.right, cnt, i + 1)\n\n        if root is None:\n            return 0\n        ans = self.countPairs(root.left, distance) + self.countPairs(\n            root.right, distance\n        )\n        cnt1 = Counter()\n        cnt2 = Counter()\n        dfs(root.left, cnt1, 1)\n        dfs(root.right, cnt2, 1)\n\n        for k1, v1 in cnt1.items():\n            for k2, v2 in cnt2.items():\n                if k1 + k2 <= distance:\n                    ans += v1 * v2\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1518, "slug": "water-bottles", "solutions": ["class Solution:\n    def numWaterBottles(self, numBottles: int, numExchange: int) -> int:\n        ans = numBottles\n        while numBottles >= numExchange:\n            numBottles -= numExchange - 1\n            ans += 1\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1581, "slug": "customer-who-visited-but-did-not-make-any-transactions", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1511, "slug": "customer-order-frequency", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1557, "slug": "minimum-number-of-vertices-to-reach-all-nodes", "solutions": ["class Solution:\n    def findSmallestSetOfVertices(self, n: int, edges: List[List[int]]) -> List[int]:\n        cnt = Counter(t for _, t in edges)\n        return [i for i in range(n) if cnt[i] == 0]\n", "class Solution:\n  def findSmallestSetOfVertices(\n      self,\n      n: int,\n      edges: list[list[int]],\n  ) -> list[int]:\n    inDegrees = [0] * n\n\n    for _, v in edges:\n      inDegrees[v] += 1\n\n    return [i for i, d in enumerate(inDegrees) if d == 0]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1513, "slug": "number-of-substrings-with-only-1s", "solutions": ["class Solution:\n    def numSub(self, s: str) -> int:\n        ans = cnt = 0\n        for c in s:\n            if c == \"1\":\n                cnt += 1\n            else:\n                cnt = 0\n            ans += cnt\n        return ans % (10**9 + 7)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1560, "slug": "most-visited-sector-in-a-circular-track", "solutions": ["class Solution:\n    def mostVisited(self, n: int, rounds: List[int]) -> List[int]:\n        if rounds[0] <= rounds[-1]:\n            return list(range(rounds[0], rounds[-1] + 1))\n        return list(range(1, rounds[-1] + 1)) + list(range(rounds[0], n + 1))\n", "class Solution:\n  def mostVisited(self, n: int, rounds: list[int]) -> list[int]:\n    # 1. if start <= end, [start, end] is the most visited.\n    #\n    #      s --------- n\n    # 1 -------------- n\n    # 1 ------ e\n    #\n    # 2. if start > end, [1, end] and [start, n] are the most visited.\n    #\n    #             s -- n\n    # 1 -------------- n\n    # 1 ------ e\n    start = rounds[0]\n    end = rounds[-1]\n    if start <= end:\n      return range(start, end + 1)\n    return list(range(1, end + 1)) + list(range(start, n + 1))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1587, "slug": "bank-account-summary-ii", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1529, "slug": "minimum-suffix-flips", "solutions": ["class Solution:\n    def minFlips(self, target: str) -> int:\n        ans = 0\n        for v in target:\n            if (ans & 1) ^ int(v):\n                ans += 1\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1597, "slug": "build-binary-expression-tree-from-infix-expression", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1502, "slug": "can-make-arithmetic-progression-from-sequence", "solutions": ["class Solution:\n    def canMakeArithmeticProgression(self, arr: List[int]) -> bool:\n        arr.sort()\n        d = arr[1] - arr[0]\n        return all(b - a == d for a, b in pairwise(arr))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1564, "slug": "put-boxes-into-the-warehouse-i", "solutions": ["class Solution:\n    def maxBoxesInWarehouse(self, boxes: List[int], warehouse: List[int]) -> int:\n        n = len(warehouse)\n        left = [warehouse[0]] * n\n        for i in range(1, n):\n            left[i] = min(left[i - 1], warehouse[i])\n        boxes.sort()\n        i, j = 0, n - 1\n        while i < len(boxes):\n            while j >= 0 and left[j] < boxes[i]:\n                j -= 1\n            if j < 0:\n                break\n            i, j = i + 1, j - 1\n        return i\n", "class Solution:\n  def maxBoxesInWarehouse(self, boxes: list[int], warehouse: list[int]) -> int:\n    realWarehouse = [warehouse[0]]\n\n    for i in range(1, len(warehouse)):\n      realWarehouse.append(min(realWarehouse[-1], warehouse[i]))\n\n    boxes.sort()\n    i = 0  # boxes' index\n    for height in reversed(realWarehouse):\n      if i < len(boxes) and boxes[i] <= height:\n        i += 1\n\n    return i\n", "class Solution:\n  def maxBoxesInWarehouse(self, boxes: list[int], warehouse: list[int]) -> int:\n    i = 0  # warehouse's index\n\n    for box in sorted(boxes, reverse=True):\n      if i < len(warehouse) and warehouse[i] >= box:\n        i += 1\n\n    return i\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1590, "slug": "make-sum-divisible-by-p", "solutions": ["class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        k = sum(nums) % p\n        if k == 0:\n            return 0\n        last = {0: -1}\n        cur = 0\n        ans = len(nums)\n        for i, x in enumerate(nums):\n            cur = (cur + x) % p\n            target = (cur - k + p) % p\n            if target in last:\n                ans = min(ans, i - last[target])\n            last[cur] = i\n        return -1 if ans == len(nums) else ans\n", "class Solution:\n  def minSubarray(self, nums: list[int], p: int) -> int:\n    summ = sum(nums)\n    remainder = summ % p\n    if remainder == 0:\n      return 0\n\n    ans = len(nums)\n    prefix = 0\n    prefixToIndex = {0: -1}\n\n    for i, num in enumerate(nums):\n      prefix += num\n      prefix %= p\n      target = (prefix - remainder + p) % p\n      if target in prefixToIndex:\n        ans = min(ans, i - prefixToIndex[target])\n      prefixToIndex[prefix] = i\n\n    return -1 if ans == len(nums) else ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1539, "slug": "kth-missing-positive-number", "solutions": ["class Solution:\n    def findKthPositive(self, arr: List[int], k: int) -> int:\n        if arr[0] > k:\n            return k\n        left, right = 0, len(arr)\n        while left < right:\n            mid = (left + right) >> 1\n            if arr[mid] - mid - 1 >= k:\n                right = mid\n            else:\n                left = mid + 1\n        return arr[left - 1] + k - (arr[left - 1] - (left - 1) - 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1556, "slug": "thousand-separator", "solutions": ["class Solution:\n    def thousandSeparator(self, n: int) -> str:\n        cnt = 0\n        ans = []\n        while 1:\n            n, v = divmod(n, 10)\n            ans.append(str(v))\n            cnt += 1\n            if n == 0:\n                break\n            if cnt == 3:\n                ans.append('.')\n                cnt = 0\n        return ''.join(ans[::-1])\n", "class Solution:\n  def thousandSeparator(self, n: int) -> str:\n    return f'{n:,}'.replace(',', '.')\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1584, "slug": "min-cost-to-connect-all-points", "solutions": ["class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        g = [[0] * n for _ in range(n)]\n        dist = [inf] * n\n        vis = [False] * n\n        for i, (x1, y1) in enumerate(points):\n            for j in range(i + 1, n):\n                x2, y2 = points[j]\n                t = abs(x1 - x2) + abs(y1 - y2)\n                g[i][j] = g[j][i] = t\n        dist[0] = 0\n        ans = 0\n        for _ in range(n):\n            i = -1\n            for j in range(n):\n                if not vis[j] and (i == -1 or dist[j] < dist[i]):\n                    i = j\n            vis[i] = True\n            ans += dist[i]\n            for j in range(n):\n                if not vis[j]:\n                    dist[j] = min(dist[j], g[i][j])\n        return ans\n", "class Solution:\n  def minCostConnectPoints(self, points: list[int]) -> int:\n    # dist[i] := the minimum distance to connect the points[i]\n    dist = [math.inf] * len(points)\n    ans = 0\n\n    for i in range(len(points) - 1):\n      for j in range(i + 1, len(points)):\n        # Try to connect the points[i] with the points[j].\n        dist[j] = min(dist[j], abs(points[i][0] - points[j][0]) +\n                      abs(points[i][1] - points[j][1]))\n        # Swap the points[j] (the point with the mnimum distance) with the\n        # points[i + 1].\n        if dist[j] < dist[i + 1]:\n          points[j], points[i + 1] = points[i + 1], points[j]\n          dist[j], dist[i + 1] = dist[i + 1], dist[j]\n      ans += dist[i + 1]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1533, "slug": "find-the-index-of-the-large-integer", "solutions": ["# \"\"\"\n# This is ArrayReader's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# class ArrayReader(object):\n# \t # Compares the sum of arr[l..r] with the sum of arr[x..y]\n# \t # return 1 if sum(arr[l..r]) > sum(arr[x..y])\n# \t # return 0 if sum(arr[l..r]) == sum(arr[x..y])\n# \t # return -1 if sum(arr[l..r]) < sum(arr[x..y])\n#    def compareSub(self, l: int, r: int, x: int, y: int) -> int:\n#\n# \t # Returns the length of the array\n#    def length(self) -> int:\n#\n\n\nclass Solution:\n    def getIndex(self, reader: 'ArrayReader') -> int:\n        left, right = 0, reader.length() - 1\n        while left < right:\n            t1, t2, t3 = (\n                left,\n                left + (right - left) // 3,\n                left + ((right - left) // 3) * 2 + 1,\n            )\n            cmp = reader.compareSub(t1, t2, t2 + 1, t3)\n            if cmp == 0:\n                left = t3 + 1\n            elif cmp == 1:\n                right = t2\n            else:\n                left, right = t2 + 1, t3\n        return left\n", "# \"\"\"\n# This is ArrayReader's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# class ArrayReader(object):\n# # Compares the sum of arr[l..r] with the sum of arr[x..y]\n# # return 1 if sum(arr[l..r]) > sum(arr[x..y])\n# # return 0 if sum(arr[l..r]) == sum(arr[x..y])\n# # return -1 if sum(arr[l..r]) < sum(arr[x..y])\n#   def compareSub(self, l: int, r: int, x: int, y: int) -> int:\n#\n# # Returns the length of the array\n#   def length(self) -> int:\n#\n\n\nclass Solution:\n  def getIndex(self, reader: 'ArrayReader') -> int:\n    l = 0\n    r = reader.length() - 1\n\n    while l < r:\n      m = (l + r) // 2\n      res = (reader.compareSub(l, m, m + 1, r) if (r - l + 1) % 2 == 0\n             else reader.compareSub(l, m, m, r))\n      if res == -1:\n        l = m + 1\n      else:  # res == 1 or res == 0\n        r = m\n\n    return l\n", "# \"\"\"\n# This is ArrayReader's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# class ArrayReader(object):\n# # Compares the sum of arr[l..r] with the sum of arr[x..y]\n# # return 1 if sum(arr[l..r]) > sum(arr[x..y])\n# # return 0 if sum(arr[l..r]) == sum(arr[x..y])\n# # return -1 if sum(arr[l..r]) < sum(arr[x..y])\n#   def compareSub(self, l: int, r: int, x: int, y: int) -> int:\n#\n# # Returns the length of the array\n#   def length(self) -> int:\n#\n\n\nclass Solution:\n  def getIndex(self, reader: 'ArrayReader') -> int:\n    l = 0\n    r = reader.length() - 1\n\n    while l < r:\n      m = (l + r) // 2\n      if (r - l) % 2 == 0:\n        res = reader.compareSub(l, m - 1, m + 1, r)\n        if res == 0:\n          return m\n        if res == 1:\n          r = m - 1\n        else:  # res == -1\n          l = m + 1\n      else:\n        res = reader.compareSub(l, m, m + 1, r)\n        # res is either 1 or -1.\n        if res == 1:\n          r = m\n        else:  # res == -1\n          l = m + 1\n\n    return l\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1576, "slug": "replace-all-s-to-avoid-consecutive-repeating-characters", "solutions": ["class Solution:\n    def modifyString(self, s: str) -> str:\n        s = list(s)\n        n = len(s)\n        for i in range(n):\n            if s[i] == \"?\":\n                for c in \"abc\":\n                    if (i and s[i - 1] == c) or (i + 1 < n and s[i + 1] == c):\n                        continue\n                    s[i] = c\n                    break\n        return \"\".join(s)\n", "class Solution:\n  def modifyString(self, s: str) -> str:\n    ans = []\n\n    def nextAvailable(ans: list[int], s: str, i: int) -> str:\n      c = 'a'\n      while ((i > 0 and ans[i - 1] == c) or\n             (i + 1 < len(s) and c == s[i + 1])):\n        c = chr(ord(c) + 1)\n      return c\n\n    for i, c in enumerate(s):\n      if c == '?':\n        ans.append(nextAvailable(ans, s, i))\n      else:\n        ans.append(c)\n\n    return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1552, "slug": "magnetic-force-between-two-balls", "solutions": ["class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def check(f: int) -> bool:\n            prev = -inf\n            cnt = 0\n            for curr in position:\n                if curr - prev >= f:\n                    prev = curr\n                    cnt += 1\n            return cnt < m\n\n        position.sort()\n        l, r = 1, position[-1]\n        return bisect_left(range(l, r + 1), True, key=check)\n", "class Solution:\n  def maxDistance(self, position: list[int], m: int) -> int:\n    position.sort()\n\n    l = 1\n    r = position[-1] - position[0]\n\n    def numBalls(force: int) -> int:\n      balls = 0\n      prevPosition = -force\n      for pos in position:\n        if pos - prevPosition >= force:\n          balls += 1\n          prevPosition = pos\n      return balls\n\n    while l < r:\n      mid = r - (r - l) // 2\n      if numBalls(mid) >= m:\n        l = mid\n      else:\n        r = mid - 1\n\n    return l\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1562, "slug": "find-latest-group-of-size-m", "solutions": ["class Solution:\n    def findLatestStep(self, arr: List[int], m: int) -> int:\n        def find(x):\n            if p[x] != x:\n                p[x] = find(p[x])\n            return p[x]\n\n        def union(a, b):\n            pa, pb = find(a), find(b)\n            if pa == pb:\n                return\n            p[pa] = pb\n            size[pb] += size[pa]\n\n        n = len(arr)\n        if m == n:\n            return n\n        vis = [False] * n\n        p = list(range(n))\n        size = [1] * n\n        ans = -1\n        for i, v in enumerate(arr):\n            v -= 1\n            if v and vis[v - 1]:\n                if size[find(v - 1)] == m:\n                    ans = i\n                union(v, v - 1)\n            if v < n - 1 and vis[v + 1]:\n                if size[find(v + 1)] == m:\n                    ans = i\n                union(v, v + 1)\n            vis[v] = True\n        return ans\n", "class Solution:\n  def findLatestStep(self, arr: list[int], m: int) -> int:\n    if len(arr) == m:\n      return len(arr)\n\n    ans = -1\n    step = 0\n    # sizes[i] := the size of the group starting from i or ending in i\n    # (1-indexed)\n    sizes = [0] * (len(arr) + 2)\n\n    for i in arr:\n      step += 1\n      # In the previous step, there exists a group with a size of m.\n      if sizes[i - 1] == m or sizes[i + 1] == m:\n        ans = step - 1\n      head = i - sizes[i - 1]\n      tail = i + sizes[i + 1]\n      sizes[head] = tail - head + 1\n      sizes[tail] = tail - head + 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1568, "slug": "minimum-number-of-days-to-disconnect-island", "solutions": ["class Solution:\n    def minDays(self, grid: List[List[int]]) -> int:\n        if self.count(grid) != 1:\n            return 0\n        m, n = len(grid), len(grid[0])\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    grid[i][j] = 0\n                    if self.count(grid) != 1:\n                        return 1\n                    grid[i][j] = 1\n        return 2\n\n    def count(self, grid):\n        def dfs(i, j):\n            grid[i][j] = 2\n            for a, b in [[0, -1], [0, 1], [1, 0], [-1, 0]]:\n                x, y = i + a, j + b\n                if 0 <= x < m and 0 <= y < n and grid[x][y] == 1:\n                    dfs(x, y)\n\n        m, n = len(grid), len(grid[0])\n        cnt = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    dfs(i, j)\n                    cnt += 1\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 2:\n                    grid[i][j] = 1\n        return cnt\n", "class Solution:\n  def minDays(self, grid: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n\n    def dfs(grid: list[list[int]], i: int, j: int, seen: set[tuple[int, int]]):\n      seen.add((i, j))\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if grid[x][y] == 0 or (x, y) in seen:\n          continue\n        dfs(grid, x, y, seen)\n\n    def disconnected(grid: list[list[int]]) -> bool:\n      islandsCount = 0\n      seen = set()\n      for i in range(m):\n        for j in range(n):\n          if grid[i][j] == 0 or (i, j) in seen:\n            continue\n          if islandsCount > 1:\n            return True\n          islandsCount += 1\n          dfs(grid, i, j, seen)\n      return islandsCount != 1\n\n    if disconnected(grid):\n      return 0\n\n    # Try to remove 1 land.\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1:\n          grid[i][j] = 0\n          if disconnected(grid):\n            return 1\n          grid[i][j] = 1\n\n    # Remove 2 lands.\n    return 2\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1526, "slug": "minimum-number-of-increments-on-subarrays-to-form-a-target-array", "solutions": ["class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        return target[0] + sum(max(0, b - a) for a, b in pairwise(target))\n", "class Solution:\n  def minNumberOperations(self, target: list[int]) -> int:\n    ans = target[0]\n\n    for a, b in zip(target, target[1:]):\n      if a < b:\n        ans += b - a\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1514, "slug": "path-with-maximum-probability", "solutions": ["class Solution:\n    def maxProbability(\n        self,\n        n: int,\n        edges: List[List[int]],\n        succProb: List[float],\n        start_node: int,\n        end_node: int,\n    ) -> float:\n        g: List[List[Tuple[int, float]]] = [[] for _ in range(n)]\n        for (a, b), p in zip(edges, succProb):\n            g[a].append((b, p))\n            g[b].append((a, p))\n        pq = [(-1, start_node)]\n        dist = [0] * n\n        dist[start_node] = 1\n        while pq:\n            w, a = heappop(pq)\n            w = -w\n            if dist[a] > w:\n                continue\n            for b, p in g[a]:\n                if (t := w * p) > dist[b]:\n                    dist[b] = t\n                    heappush(pq, (-t, b))\n        return dist[end_node]\n", "class Solution:\n  def maxProbability(\n      self,\n      n: int,\n      edges: list[list[int]],\n      succProb: list[float],\n      start: int,\n      end: int,\n  ) -> float:\n    graph = [[] for _ in range(n)]  # {a: [(b, probability_ab)]}\n    maxHeap = [(-1.0, start)]   # (the probability to reach u, u)\n    seen = [False] * n\n\n    for i, ((u, v), prob) in enumerate(zip(edges, succProb)):\n      graph[u].append((v, prob))\n      graph[v].append((u, prob))\n\n    while maxHeap:\n      prob, u = heapq.heappop(maxHeap)\n      prob *= -1\n      if u == end:\n        return prob\n      if seen[u]:\n        continue\n      seen[u] = True\n      for nextNode, edgeProb in graph[u]:\n        if seen[nextNode]:\n          continue\n        heapq.heappush(maxHeap, (-prob * edgeProb, nextNode))\n\n    return 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1570, "slug": "dot-product-of-two-sparse-vectors", "solutions": ["class SparseVector:\n    def __init__(self, nums: List[int]):\n        self.d = {i: v for i, v in enumerate(nums) if v}\n\n    # Return the dotProduct of two sparse vectors\n    def dotProduct(self, vec: \"SparseVector\") -> int:\n        a, b = self.d, vec.d\n        if len(b) < len(a):\n            a, b = b, a\n        return sum(v * b.get(i, 0) for i, v in a.items())\n\n\n# Your SparseVector object will be instantiated and called as such:\n# v1 = SparseVector(nums1)\n# v2 = SparseVector(nums2)\n# ans = v1.dotProduct(v2)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1535, "slug": "find-the-winner-of-an-array-game", "solutions": ["class Solution:\n    def getWinner(self, arr: List[int], k: int) -> int:\n        mx = arr[0]\n        cnt = 0\n        for x in arr[1:]:\n            if mx < x:\n                mx = x\n                cnt = 1\n            else:\n                cnt += 1\n            if cnt == k:\n                break\n        return mx\n", "class Solution:\n  def getWinner(self, arr: list[int], k: int) -> int:\n    ans = arr[0]\n    wins = 0\n\n    i = 1\n    while i < len(arr) and wins < k:\n      if arr[i] > ans:\n        ans = arr[i]\n        wins = 1\n      else:\n        wins += 1\n      i += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1507, "slug": "reformat-date", "solutions": ["class Solution:\n    def reformatDate(self, date: str) -> str:\n        s = date.split()\n        s.reverse()\n        months = \" JanFebMarAprMayJunJulAugSepOctNovDec\"\n        s[1] = str(months.index(s[1]) // 3 + 1).zfill(2)\n        s[2] = s[2][:-2].zfill(2)\n        return \"-\".join(s)\n", "class Solution:\n  def reformatDate(self, date: str) -> str:\n    monthToNumString = {\n        'Jan': '01', 'Feb': '02', 'Mar': '03', 'Apr': '04',\n        'May': '05', 'Jun': '06', 'Jul': '07', 'Aug': '08',\n        'Sep': '09', 'Oct': '10', 'Nov': '11', 'Dec': '12',\n    }\n    day, month, year = date.split()\n    day = day[:-2] if len(day) == 4 else '0' + day[:-2]\n    return f'{year}-{monthToNumString[month]}-{day}'\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1593, "slug": "split-a-string-into-the-max-number-of-unique-substrings", "solutions": ["class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        def dfs(i: int):\n            nonlocal ans\n            if len(st) + len(s) - i <= ans:\n                return\n            if i >= len(s):\n                ans = max(ans, len(st))\n                return\n            for j in range(i + 1, len(s) + 1):\n                if s[i:j] not in st:\n                    st.add(s[i:j])\n                    dfs(j)\n                    st.remove(s[i:j])\n\n        ans = 0\n        st = set()\n        dfs(0)\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1505, "slug": "minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits", "solutions": ["class BinaryIndexedTree:\n    def __init__(self, n):\n        self.n = n\n        self.c = [0] * (n + 1)\n\n    @staticmethod\n    def lowbit(x):\n        return x & -x\n\n    def update(self, x, delta):\n        while x <= self.n:\n            self.c[x] += delta\n            x += BinaryIndexedTree.lowbit(x)\n\n    def query(self, x):\n        s = 0\n        while x:\n            s += self.c[x]\n            x -= BinaryIndexedTree.lowbit(x)\n        return s\n\n\nclass Solution:\n    def minInteger(self, num: str, k: int) -> str:\n        pos = defaultdict(deque)\n        for i, v in enumerate(num, 1):\n            pos[int(v)].append(i)\n        ans = []\n        n = len(num)\n        tree = BinaryIndexedTree(n)\n        for i in range(1, n + 1):\n            for v in range(10):\n                q = pos[v]\n                if q:\n                    j = q[0]\n                    dist = tree.query(n) - tree.query(j) + j - i\n                    if dist <= k:\n                        k -= dist\n                        q.popleft()\n                        ans.append(str(v))\n                        tree.update(j, 1)\n                        break\n        return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1550, "slug": "three-consecutive-odds", "solutions": ["class Solution:\n    def threeConsecutiveOdds(self, arr: List[int]) -> bool:\n        cnt = 0\n        for x in arr:\n            if x & 1:\n                cnt += 1\n                if cnt == 3:\n                    return True\n            else:\n                cnt = 0\n        return False\n", "class Solution:\n  def threeConsecutiveOdds(self, arr: list[int]) -> bool:\n    count = 0\n    for a in arr:\n      count = 0 if a % 2 == 0 else count + 1\n      if count == 3:\n        return True\n    return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1586, "slug": "binary-search-tree-iterator-ii", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass BSTIterator:\n    def __init__(self, root: Optional[TreeNode]):\n        self.nums = []\n\n        def dfs(root):\n            if root is None:\n                return\n            dfs(root.left)\n            self.nums.append(root.val)\n            dfs(root.right)\n\n        dfs(root)\n        self.i = -1\n\n    def hasNext(self) -> bool:\n        return self.i < len(self.nums) - 1\n\n    def next(self) -> int:\n        self.i += 1\n        return self.nums[self.i]\n\n    def hasPrev(self) -> bool:\n        return self.i > 0\n\n    def prev(self) -> int:\n        self.i -= 1\n        return self.nums[self.i]\n\n\n# Your BSTIterator object will be instantiated and called as such:\n# obj = BSTIterator(root)\n# param_1 = obj.hasNext()\n# param_2 = obj.next()\n# param_3 = obj.hasPrev()\n# param_4 = obj.prev()\n", "class BSTIterator:\n  def __init__(self, root: TreeNode | None):\n    self.prevsAndCurr = []\n    self.nexts = []\n    self._pushLeftsUntilNull(root)\n\n  def hasNext(self) -> bool:\n    return len(self.nexts) > 0\n\n  def next(self) -> int:\n    root, fromNext = self.nexts.pop()\n    if fromNext:\n      self._pushLeftsUntilNull(root.right)\n    self.prevsAndCurr.append(root)\n    return root.val\n\n  def hasPrev(self) -> bool:\n    return len(self.prevsAndCurr) > 1\n\n  def prev(self) -> int:\n    self.nexts.append((self.prevsAndCurr.pop(), False))\n    return self.prevsAndCurr[-1].val\n\n  def _pushLeftsUntilNull(self, root):\n    while root:\n      self.nexts.append((root, True))\n      root = root.left\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1554, "slug": "strings-differ-by-one-character", "solutions": ["class Solution:\n    def differByOne(self, dict: List[str]) -> bool:\n        s = set()\n        for word in dict:\n            for i in range(len(word)):\n                t = word[:i] + \"*\" + word[i + 1 :]\n                if t in s:\n                    return True\n                s.add(t)\n        return False\n", "class Solution:\n  def differByOne(self, dict: list[str]) -> bool:\n    BASE = 26\n    HASH = 1_000_000_007\n    m = len(dict[0])\n\n    def val(c: str) -> int:\n      return ord(c) - ord('a')\n\n    def getHash(s: str) -> int:\n      \"\"\"Returns the hash of `s`. Assume the length of `s` is m.\n\n      e.g. getHash(s) = 26^(m - 1) * s[0] + 26^(m - 2) * s[1] + ... + s[m - 1].\n      \"\"\"\n      hash = 0\n      for c in s:\n        hash = (hash * BASE + val(c))\n      return hash\n\n    wordToHash = [getHash(word) for word in dict]\n\n    # Compute the hash without each letter.\n    # e.g. hash of \"abc\" = 26^2 * 'a' + 26 * 'b' + 'c'\n    #   newHash of \"a*c\" = hash - 26 * 'b'\n    coefficient = 1\n    for j in range(m - 1, -1, -1):\n      newHashToIndices = collections.defaultdict(list)\n      for i, (word, hash) in enumerate(zip(dict, wordToHash)):\n        newHash = (hash - coefficient * val(word[j]) % HASH + HASH) % HASH\n        if any(word[: j] == dict[index][: j] and word[j + 1:] ==\n               dict[index][j + 1:] for index in newHashToIndices[newHash]):\n          return True\n        newHashToIndices[newHash].append(i)\n      coefficient = coefficient * BASE % HASH\n\n    return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1579, "slug": "remove-max-number-of-edges-to-keep-graph-fully-traversable", "solutions": ["class UnionFind:\n    def __init__(self, n):\n        self.p = list(range(n))\n        self.size = [1] * n\n        self.cnt = n\n\n    def find(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n\n    def union(self, a, b):\n        pa, pb = self.find(a - 1), self.find(b - 1)\n        if pa == pb:\n            return False\n        if self.size[pa] > self.size[pb]:\n            self.p[pb] = pa\n            self.size[pa] += self.size[pb]\n        else:\n            self.p[pa] = pb\n            self.size[pb] += self.size[pa]\n        self.cnt -= 1\n        return True\n\n\nclass Solution:\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n        ufa = UnionFind(n)\n        ufb = UnionFind(n)\n        ans = 0\n        for t, u, v in edges:\n            if t == 3:\n                if ufa.union(u, v):\n                    ufb.union(u, v)\n                else:\n                    ans += 1\n        for t, u, v in edges:\n            if t == 1:\n                ans += not ufa.union(u, v)\n            if t == 2:\n                ans += not ufb.union(u, v)\n        return ans if ufa.cnt == 1 and ufb.cnt == 1 else -1\n", "class UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n    return True\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def maxNumEdgesToRemove(self, n: int, edges: list[list[int]]) -> int:\n    alice = UnionFind(n)\n    bob = UnionFind(n)\n    requiredEdges = 0\n\n    # Greedily put type 3 edges in the front.\n    for type_, u, v in sorted(edges, reverse=True):\n      u -= 1\n      v -= 1\n      if type_ == 3:  # Can be traversed by Alice and Bob.\n          # Note that we should use | instead of or because if the first\n          # expression is True, short-circuiting will skip the second\n          # expression.\n        if alice.unionByRank(u, v) | bob.unionByRank(u, v):\n          requiredEdges += 1\n      elif type_ == 2:  # Can be traversed by Bob.\n        if bob.unionByRank(u, v):\n          requiredEdges += 1\n      else:  # type == 1 Can be traversed by Alice.\n        if alice.unionByRank(u, v):\n          requiredEdges += 1\n\n    return (len(edges) - requiredEdges\n            if alice.count == 1 and bob.count == 1\n            else -1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1565, "slug": "unique-orders-and-customers-per-month", "solutions": ["import pandas as pd\n\n\ndef unique_orders_and_customers(orders: pd.DataFrame) -> pd.DataFrame:\n    filtered_orders = orders[orders[\"invoice\"] > 20]\n    filtered_orders[\"month\"] = (\n        filtered_orders[\"order_date\"].dt.to_period(\"M\").astype(str)\n    )\n    result = (\n        filtered_orders.groupby(\"month\")\n        .agg(\n            order_count=(\"order_id\", \"count\"), customer_count=(\"customer_id\", \"nunique\")\n        )\n        .reset_index()\n    )\n    return result\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1525, "slug": "number-of-good-ways-to-split-a-string", "solutions": ["class Solution:\n    def numSplits(self, s: str) -> int:\n        cnt = Counter(s)\n        vis = set()\n        ans = 0\n        for c in s:\n            vis.add(c)\n            cnt[c] -= 1\n            if cnt[c] == 0:\n                cnt.pop(c)\n            ans += len(vis) == len(cnt)\n        return ans\n", "class Solution:\n  def numSplits(self, s: str) -> int:\n    n = len(s)\n    ans = 0\n    seen = set()\n    prefix = [0] * n\n    suffix = [0] * n\n\n    for i in range(n):\n      seen.add(s[i])\n      prefix[i] = len(seen)\n\n    seen.clear()\n\n    for i in reversed(range(n)):\n      seen.add(s[i])\n      suffix[i] = len(seen)\n\n    for i in range(n - 1):\n      if prefix[i] == suffix[i + 1]:\n        ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1583, "slug": "count-unhappy-friends", "solutions": ["class Solution:\n    def unhappyFriends(\n        self, n: int, preferences: List[List[int]], pairs: List[List[int]]\n    ) -> int:\n        d = [{x: j for j, x in enumerate(p)} for p in preferences]\n        p = {}\n        for x, y in pairs:\n            p[x] = y\n            p[y] = x\n        ans = 0\n        for x in range(n):\n            y = p[x]\n            for i in range(d[x][y]):\n                u = preferences[x][i]\n                v = p[u]\n                if d[u][x] < d[u][v]:\n                    ans += 1\n                    break\n        return ans\n", "class Solution:\n  def unhappyFriends(\n      self,\n      n: int,\n      preferences: list[list[int]],\n      pairs: list[list[int]],\n  ) -> int:\n    ans = 0\n    matches = [0] * n\n    prefer = [{} for _ in range(n)]\n\n    for x, y in pairs:\n      matches[x] = y\n      matches[y] = x\n\n    for i in range(n):\n      for j in range(n - 1):\n        prefer[i][preferences[i][j]] = j\n\n    for x in range(n):\n      for u in prefer[x].keys():\n        y = matches[x]\n        v = matches[u]\n        if prefer[x][u] < prefer[x][y] and prefer[u][x] < prefer[u][v]:\n          ans += 1\n          break\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1594, "slug": "maximum-non-negative-product-in-a-matrix", "solutions": ["class Solution:\n    def maxProductPath(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        mod = 10**9 + 7\n        dp = [[[grid[0][0]] * 2 for _ in range(n)] for _ in range(m)]\n        for i in range(1, m):\n            dp[i][0] = [dp[i - 1][0][0] * grid[i][0]] * 2\n        for j in range(1, n):\n            dp[0][j] = [dp[0][j - 1][0] * grid[0][j]] * 2\n        for i in range(1, m):\n            for j in range(1, n):\n                v = grid[i][j]\n                if v >= 0:\n                    dp[i][j][0] = min(dp[i - 1][j][0], dp[i][j - 1][0]) * v\n                    dp[i][j][1] = max(dp[i - 1][j][1], dp[i][j - 1][1]) * v\n                else:\n                    dp[i][j][0] = max(dp[i - 1][j][1], dp[i][j - 1][1]) * v\n                    dp[i][j][1] = min(dp[i - 1][j][0], dp[i][j - 1][0]) * v\n        ans = dp[-1][-1][1]\n        return -1 if ans < 0 else ans % mod\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1532, "slug": "the-most-recent-three-orders", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1596, "slug": "the-most-frequently-ordered-products-for-each-customer", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1559, "slug": "detect-cycles-in-2d-grid", "solutions": ["class Solution:\n    def containsCycle(self, grid: List[List[str]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        vis = [[False] * n for _ in range(m)]\n        dirs = (-1, 0, 1, 0, -1)\n        for i, row in enumerate(grid):\n            for j, x in enumerate(row):\n                if vis[i][j]:\n                    continue\n                vis[i][j] = True\n                q = [(i, j, -1, -1)]\n                while q:\n                    x, y, px, py = q.pop()\n                    for dx, dy in pairwise(dirs):\n                        nx, ny = x + dx, y + dy\n                        if 0 <= nx < m and 0 <= ny < n:\n                            if grid[nx][ny] != grid[i][j] or (nx == px and ny == py):\n                                continue\n                            if vis[nx][ny]:\n                                return True\n                            vis[nx][ny] = True\n                            q.append((nx, ny, x, y))\n        return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1540, "slug": "can-convert-string-in-k-moves", "solutions": ["class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t):\n            return False\n        cnt = [0] * 26\n        for a, b in zip(s, t):\n            x = (ord(b) - ord(a) + 26) % 26\n            cnt[x] += 1\n        for i in range(1, 26):\n            if i + 26 * (cnt[i] - 1) > k:\n                return False\n        return True\n", "class Solution:\n  def canConvertString(self, s: str, t: str, k: int) -> bool:\n    if len(s) != len(t):\n      return False\n\n    # e.g. s = \"aab\", t = \"bbc\", so shiftCount[1] = 3\n    # 1. a -> b, need 1 move.\n    # 2. a -> b, need 1 + 26 moves.\n    # 3. b -> c, need 1 + 26 * 2 moves.\n    shiftCount = [0] * 26\n\n    for a, b in zip(s, t):\n      shiftCount[(ord(b) - ord(a) + 26) % 26] += 1\n\n    for shift in range(1, 26):\n      if shift + 26 * (shiftCount[shift] - 1) > k:\n        return False\n\n    return True\n", "class Solution:\n  def canConvertString(self, s: str, t: str, k: int) -> bool:\n    if len(s) != len(t):\n      return False\n\n    # e.g. s = \"aab\", t = \"bbc\", so shiftCount[1] = 3\n    # 1. a -> b, need 1 move.\n    # 2. a -> b, need 1 + 26 moves.\n    # 3. b -> c, need 1 + 26 * 2 moves.\n    shiftCount = [0] * 26\n\n    for a, b in zip(s, t):\n      shift = (ord(b) - ord(a) + 26) % 26\n      if shift == 0:\n        continue\n      if shift + 26 * shiftCount[shift] > k:\n        return False\n      shiftCount[shift] += 1\n\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1520, "slug": "maximum-number-of-non-overlapping-substrings", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1558, "slug": "minimum-numbers-of-function-calls-to-make-target-array", "solutions": ["class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        return sum(v.bit_count() for v in nums) + max(0, max(nums).bit_length() - 1)\n", "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    mx = max(nums)\n    return (sum(num.bit_count() for num in nums) +\n            (0 if mx == 0 else mx.bit_length() - 1))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1510, "slug": "stone-game-iv", "solutions": ["class Solution:\n    def winnerSquareGame(self, n: int) -> bool:\n        @cache\n        def dfs(i: int) -> bool:\n            if i == 0:\n                return False\n            j = 1\n            while j * j <= i:\n                if not dfs(i - j * j):\n                    return True\n                j += 1\n            return False\n\n        return dfs(n)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1508, "slug": "range-sum-of-sorted-subarray-sums", "solutions": ["class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        arr = []\n        for i in range(n):\n            s = 0\n            for j in range(i, n):\n                s += nums[j]\n                arr.append(s)\n        arr.sort()\n        mod = 10**9 + 7\n        return sum(arr[left - 1 : right]) % mod\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1598, "slug": "crawler-log-folder", "solutions": ["class Solution:\n    def minOperations(self, logs: List[str]) -> int:\n        ans = 0\n        for v in logs:\n            if v == \"../\":\n                ans = max(0, ans - 1)\n            elif v[0] != \".\":\n                ans += 1\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1589, "slug": "maximum-sum-obtained-of-any-permutation", "solutions": ["class Solution:\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\n        n = len(nums)\n        d = [0] * n\n        for l, r in requests:\n            d[l] += 1\n            if r + 1 < n:\n                d[r + 1] -= 1\n        for i in range(1, n):\n            d[i] += d[i - 1]\n        nums.sort()\n        d.sort()\n        mod = 10**9 + 7\n        return sum(a * b for a, b in zip(nums, d)) % mod\n", "class Solution:\n  def maxSumRangeQuery(self, nums: list[int], requests: list[list[int]]) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    # count[i] := the number of times nums[i] has been requested\n    count = [0] * len(nums)\n\n    for start, end in requests:\n      count[start] += 1\n      if end + 1 < len(nums):\n        count[end + 1] -= 1\n\n    for i in range(1, len(nums)):\n      count[i] += count[i - 1]\n\n    for num, c in zip(sorted(nums), sorted(count)):\n      ans += num * c\n      ans %= MOD\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1542, "slug": "find-longest-awesome-substring", "solutions": ["class Solution:\n    def longestAwesome(self, s: str) -> int:\n        st = 0\n        d = {0: -1}\n        ans = 1\n        for i, c in enumerate(s):\n            v = int(c)\n            st ^= 1 << v\n            if st in d:\n                ans = max(ans, i - d[st])\n            else:\n                d[st] = i\n            for v in range(10):\n                if st ^ (1 << v) in d:\n                    ans = max(ans, i - d[st ^ (1 << v)])\n        return ans\n", "class Solution:\n  def longestAwesome(self, s: str) -> int:\n    ans = 0\n    prefix = 0  # the binary prefix\n    prefixToIndex = [len(s)] * 1024\n    prefixToIndex[0] = -1\n\n    for i, c in enumerate(s):\n      prefix ^= 1 << int(c)\n      ans = max(ans, i - prefixToIndex[prefix])\n      for j in range(10):\n        ans = max(ans, i - prefixToIndex[prefix ^ 1 << j])\n      prefixToIndex[prefix] = min(prefixToIndex[prefix], i)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1574, "slug": "shortest-subarray-to-be-removed-to-make-array-sorted", "solutions": ["class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        n = len(arr)\n        i, j = 0, n - 1\n        while i + 1 < n and arr[i] <= arr[i + 1]:\n            i += 1\n        while j - 1 >= 0 and arr[j - 1] <= arr[j]:\n            j -= 1\n        if i >= j:\n            return 0\n        ans = min(n - i - 1, j)\n        for l in range(i + 1):\n            r = bisect_left(arr, arr[l], lo=j)\n            ans = min(ans, r - l - 1)\n        return ans\n", "class Solution:\n  def findLengthOfShortestSubarray(self, arr: list[int]) -> int:\n    n = len(arr)\n    l = 0\n    r = n - 1\n\n    # arr[0..l] is non-decreasing.\n    while l < n - 1 and arr[l + 1] >= arr[l]:\n      l += 1\n    # arr[r..n - 1] is non-decreasing.\n    while r > 0 and arr[r - 1] <= arr[r]:\n      r -= 1\n    # Remove arr[l + 1..n - 1] or arr[0..r - 1].\n    ans = min(n - 1 - l, r)\n\n    # Since arr[0..l] and arr[r..n - 1] are non-decreasing, we place pointers\n    # at the rightmost indices, l and n - 1, and greedily shrink them toward\n    # the leftmost indices, 0 and r, respectively. By removing arr[i + 1..j],\n    # we ensure that `arr` becomes non-decreasing.\n    i = l\n    j = n - 1\n    while i >= 0 and j >= r and j > i:\n      if arr[i] <= arr[j]:\n        j -= 1\n      else:\n        i -= 1\n      ans = min(ans, j - i)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1566, "slug": "detect-pattern-of-length-m-repeated-k-or-more-times", "solutions": ["class Solution:\n    def containsPattern(self, arr: List[int], m: int, k: int) -> bool:\n        if len(arr) < m * k:\n            return False\n        cnt, target = 0, (k - 1) * m\n        for i in range(m, len(arr)):\n            if arr[i] == arr[i - m]:\n                cnt += 1\n                if cnt == target:\n                    return True\n            else:\n                cnt = 0\n        return False\n", "class Solution:\n  def containsPattern(self, arr: list[int], m: int, k: int) -> bool:\n    count = 0\n    for i in range(m, len(arr)):\n      count = count + 1 if arr[i] == arr[i - m] else 0\n      if count == m * k - m:\n        return True\n    return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1592, "slug": "rearrange-spaces-between-words", "solutions": ["class Solution:\n    def reorderSpaces(self, text: str) -> str:\n        spaces = text.count(\" \")\n        words = text.split()\n        if len(words) == 1:\n            return words[0] + \" \" * spaces\n        cnt, mod = divmod(spaces, len(words) - 1)\n        return (\" \" * cnt).join(words) + \" \" * mod\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1534, "slug": "count-good-triplets", "solutions": ["class Solution:\n    def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\n        ans, n = 0, len(arr)\n        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(j + 1, n):\n                    ans += (\n                        abs(arr[i] - arr[j]) <= a\n                        and abs(arr[j] - arr[k]) <= b\n                        and abs(arr[i] - arr[k]) <= c\n                    )\n        return ans\n", "class Solution:\n  def countGoodTriplets(self, arr: list[int], a: int, b: int, c: int) -> int:\n    return sum(abs(arr[i] - arr[j]) <= a and\n               abs(arr[j] - arr[k]) <= b and\n               abs(arr[i] - arr[k]) <= c\n               for i in range(len(arr))\n               for j in range(i + 1, len(arr))\n               for k in range(j + 1, len(arr)))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1544, "slug": "make-the-string-great", "solutions": ["class Solution:\n    def makeGood(self, s: str) -> str:\n        stk = []\n        for c in s:\n            if not stk or abs(ord(stk[-1]) - ord(c)) != 32:\n                stk.append(c)\n            else:\n                stk.pop()\n        return \"\".join(stk)\n", "class Solution:\n  def makeGood(self, s: str) -> str:\n    ans = []\n    for c in s:\n      if ans and self._is_bad_pair(ans[-1], c):\n        ans.pop()\n      else:\n        ans.append(c)\n    return ''.join(ans)\n\n  def _is_bad_pair(self, a: str, b: str) -> bool:\n    return a != b and a.lower() == b.lower()\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1569, "slug": "number-of-ways-to-reorder-array-to-get-same-bst", "solutions": ["class Solution:\n    def numOfWays(self, nums: List[int]) -> int:\n        def dfs(nums):\n            if len(nums) < 2:\n                return 1\n            left = [x for x in nums if x < nums[0]]\n            right = [x for x in nums if x > nums[0]]\n            m, n = len(left), len(right)\n            a, b = dfs(left), dfs(right)\n            return (((c[m + n][m] * a) % mod) * b) % mod\n\n        n = len(nums)\n        mod = 10**9 + 7\n        c = [[0] * n for _ in range(n)]\n        c[0][0] = 1\n        for i in range(1, n):\n            c[i][0] = 1\n            for j in range(1, i + 1):\n                c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod\n        return (dfs(nums) - 1 + mod) % mod\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1545, "slug": "find-kth-bit-in-nth-binary-string", "solutions": ["class Solution:\n    def findKthBit(self, n: int, k: int) -> str:\n        def dfs(n: int, k: int) -> int:\n            if k == 1:\n                return 0\n            if (k & (k - 1)) == 0:\n                return 1\n            m = 1 << n\n            if k * 2 < m - 1:\n                return dfs(n - 1, k)\n            return dfs(n - 1, m - k) ^ 1\n\n        return str(dfs(n, k))\n", "class Solution:\n  def findKthBit(self, n: int, k: int) -> str:\n    if n == 1:\n      return '0'\n    midIndex = pow(2, n - 1)  # 1-indexed\n    if k == midIndex:\n      return '1'\n    if k < midIndex:\n      return self.findKthBit(n - 1, k)\n    return '1' if self.findKthBit(n - 1, midIndex * 2 - k) == '0' else '0'\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1503, "slug": "last-moment-before-all-ants-fall-out-of-a-plank", "solutions": ["class Solution:\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\n        ans = 0\n        for x in left:\n            ans = max(ans, x)\n        for x in right:\n            ans = max(ans, n - x)\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1531, "slug": "string-compression-ii", "solutions": ["class Solution:\n  def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n    def getLength(maxFreq: int) -> int:\n      \"\"\"Returns the length to compress `maxFreq`.\"\"\"\n      if maxFreq == 1:\n        return 1  # c\n      if maxFreq < 10:\n        return 2  # [1-9]c\n      if maxFreq < 100:\n        return 3  # [1-9][0-9]c\n      return 4    # [1-9][0-9][0-9]c\n\n    @functools.lru_cache(None)\n    def dp(i: int, k: int) -> int:\n      \"\"\"Returns the length of optimal dp of s[i..n) with at most k deletion.\"\"\"\n      if k < 0:\n        return math.inf\n      if i == len(s) or len(s) - i <= k:\n        return 0\n\n      ans = math.inf\n      maxFreq = 0  # the maximum frequency in s[i..j]\n      count = collections.Counter()\n\n      # Make letters in s[i..j] be the same.\n      # Keep the letter that has the maximum frequency in this range and remove\n      # the other letters.\n      for j in range(i, len(s)):\n        count[s[j]] += 1\n        maxFreq = max(maxFreq, count[s[j]])\n        ans = min(ans, getLength(maxFreq) +\n                  dp(j + 1, k - (j - i + 1 - maxFreq)))\n\n      return ans\n\n    return dp(0, k)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1573, "slug": "number-of-ways-to-split-a-string", "solutions": ["class Solution:\n    def numWays(self, s: str) -> int:\n        def find(x):\n            t = 0\n            for i, c in enumerate(s):\n                t += int(c == '1')\n                if t == x:\n                    return i\n\n        cnt, m = divmod(sum(c == '1' for c in s), 3)\n        if m:\n            return 0\n        n = len(s)\n        mod = 10**9 + 7\n        if cnt == 0:\n            return ((n - 1) * (n - 2) // 2) % mod\n        i1, i2 = find(cnt), find(cnt + 1)\n        j1, j2 = find(cnt * 2), find(cnt * 2 + 1)\n        return (i2 - i1) * (j2 - j1) % (10**9 + 7)\n", "class Solution:\n  def numWays(self, s: str) -> int:\n    MOD = 1_000_000_007\n    ones = s.count('1')\n    if ones % 3 != 0:\n      return 0\n    if ones == 0:\n      n = len(s)\n      return (n - 1) * (n - 2) // 2 % MOD\n\n    s1End = -1\n    s2Start = -1\n    s2End = -1\n    s3Start = -1\n    onesSoFar = 0\n\n    for i, c in enumerate(s):\n      if c == '1':\n        onesSoFar += 1\n      if s1End == -1 and onesSoFar == ones // 3:\n        s1End = i\n      elif s2Start == -1 and onesSoFar == ones // 3 + 1:\n        s2Start = i\n      if s2End == -1 and onesSoFar == ones // 3 * 2:\n        s2End = i\n      elif s3Start == -1 and onesSoFar == ones // 3 * 2 + 1:\n        s3Start = i\n\n    return (s2Start - s1End) * (s3Start - s2End) % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1561, "slug": "maximum-number-of-coins-you-can-get", "solutions": ["class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        return sum(piles[len(piles) // 3 :][::2])\n", "class Solution:\n  def maxCoins(self, piles: list[int]) -> int:\n    return sum(sorted(piles)[len(piles) // 3::2])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1575, "slug": "count-all-possible-routes", "solutions": ["class Solution:\n    def countRoutes(\n        self, locations: List[int], start: int, finish: int, fuel: int\n    ) -> int:\n        @cache\n        def dfs(i: int, k: int) -> int:\n            if k < abs(locations[i] - locations[finish]):\n                return 0\n            ans = int(i == finish)\n            for j, x in enumerate(locations):\n                if j != i:\n                    ans = (ans + dfs(j, k - abs(locations[i] - x))) % mod\n            return ans\n\n        mod = 10**9 + 7\n        return dfs(start, fuel)\n", "class Solution:\n  def countRoutes(\n      self,\n      locations: list[int],\n      start: int,\n      finish: int,\n      fuel: int,\n  ) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def dp(i: int, fuel: int) -> int:\n      \"\"\"\n      Returns the number of ways to reach the `finish` city from the i-th city\n      with `fuel` fuel.\n      \"\"\"\n      if fuel < 0:\n        return 0\n\n      res = 1 if i == finish else 0\n      for j in range(len(locations)):\n        if j == i:\n          continue\n        res += dp(j, fuel - abs(locations[i] - locations[j]))\n        res %= MOD\n\n      return res\n\n    return dp(start, fuel)\n", "class Solution:\n  def countRoutes(\n      self,\n      locations: list[int],\n      start: int,\n      finish: int,\n      fuel: int,\n  ) -> int:\n    MOD = 1_000_000_007\n    n = len(locations)\n    # dp[i][j] := the number of ways to reach the `finish` city from the i-th\n    # city with `j` fuel\n    dp = [[0] * (fuel + 1) for _ in range(n)]\n\n    for f in range(fuel + 1):\n      dp[finish][f] = 1\n\n    for f in range(fuel + 1):\n      for i in range(n):\n        for j in range(n):\n          if i == j:\n            continue\n          requiredFuel = abs(locations[i] - locations[j])\n          if requiredFuel <= f:\n            dp[i][f] += dp[j][f - requiredFuel]\n            dp[i][f] %= MOD\n\n    return dp[start][fuel]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1543, "slug": "fix-product-name-format", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1522, "slug": "diameter-of-n-ary-tree", "solutions": ["\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children if children is not None else []\n\"\"\"\n\n\nclass Solution:\n    def diameter(self, root: 'Node') -> int:\n        \"\"\"\n        :type root: 'Node'\n        :rtype: int\n        \"\"\"\n\n        def dfs(root):\n            if root is None:\n                return 0\n            nonlocal ans\n            m1 = m2 = 0\n            for child in root.children:\n                t = dfs(child)\n                if t > m1:\n                    m2, m1 = m1, t\n                elif t > m2:\n                    m2 = t\n            ans = max(ans, m1 + m2)\n            return 1 + m1\n\n        ans = 0\n        dfs(root)\n        return ans\n", "class Solution:\n  def diameter(self, root: 'Node') -> int:\n    ans = 0\n\n    def maxDepth(root: 'Node') -> int:\n      \"\"\"Returns the maximum depth of the subtree rooted at `root`.\"\"\"\n      nonlocal ans\n      maxSubDepth1 = 0\n      maxSubDepth2 = 0\n      for child in root.children:\n        maxSubDepth = maxDepth(child)\n        if maxSubDepth > maxSubDepth1:\n          maxSubDepth2 = maxSubDepth1\n          maxSubDepth1 = maxSubDepth\n        elif maxSubDepth > maxSubDepth2:\n          maxSubDepth2 = maxSubDepth\n      ans = max(ans, maxSubDepth1 + maxSubDepth2)\n      return 1 + maxSubDepth1\n\n    maxDepth(root)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1572, "slug": "matrix-diagonal-sum", "solutions": ["class Solution:\n    def diagonalSum(self, mat: List[List[int]]) -> int:\n        ans = 0\n        n = len(mat)\n        for i, row in enumerate(mat):\n            j = n - i - 1\n            ans += row[i] + (0 if j == i else row[j])\n        return ans\n", "class Solution:\n  def diagonalSum(self, mat: list[list[int]]) -> int:\n    n = len(mat)\n    ans = 0\n\n    for i in range(n):\n      ans += mat[i][i]\n      ans += mat[n - 1 - i][i]\n\n    return ans if n % 2 == 0 else ans - mat[n // 2][n // 2]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1599, "slug": "maximum-profit-of-operating-a-centennial-wheel", "solutions": ["class Solution:\n    def minOperationsMaxProfit(\n        self, customers: List[int], boardingCost: int, runningCost: int\n    ) -> int:\n        ans = -1\n        mx = t = 0\n        wait = 0\n        i = 0\n        while wait or i < len(customers):\n            wait += customers[i] if i < len(customers) else 0\n            up = wait if wait < 4 else 4\n            wait -= up\n            t += up * boardingCost - runningCost\n            i += 1\n            if t > mx:\n                mx = t\n                ans = i\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1509, "slug": "minimum-difference-between-largest-and-smallest-value-in-three-moves", "solutions": ["class Solution:\n    def minDifference(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n < 5:\n            return 0\n        nums.sort()\n        ans = inf\n        for l in range(4):\n            r = 3 - l\n            ans = min(ans, nums[n - 1 - r] - nums[l])\n        return ans\n", "class Solution:\n  def minDifference(self, nums: list[int]) -> int:\n    n = len(nums)\n    if n < 5:\n      return 0\n\n    ans = math.inf\n\n    nums.sort()\n\n    # 1. Change nums[0..i) to nums[i].\n    # 2. Change nums[n - 3 + i..n) to nums[n - 4 + i].\n    for i in range(4):\n      ans = min(ans, nums[n - 4 + i] - nums[i])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1546, "slug": "maximum-number-of-non-overlapping-subarrays-with-sum-equals-target", "solutions": ["class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        ans = 0\n        i, n = 0, len(nums)\n        while i < n:\n            s = 0\n            vis = {0}\n            while i < n:\n                s += nums[i]\n                if s - target in vis:\n                    ans += 1\n                    break\n                i += 1\n                vis.add(s)\n            i += 1\n        return ans\n", "class Solution:\n  def maxNonOverlapping(self, nums: list[int], target: int) -> int:\n    # Ending the subarray ASAP always has a better result.\n    ans = 0\n    prefix = 0\n    prefixes = {0}\n\n    # Greedily find the subarrays that equal to the target.\n    for num in nums:\n      # Check if there is a subarray ends in here and equals to the target.\n      prefix += num\n      if prefix - target in prefixes:\n        # Find one and discard all the prefixes that have been used.\n        ans += 1\n        prefix = 0\n        prefixes = {0}\n      else:\n        prefixes.add(prefix)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1538, "slug": "guess-the-majority-in-a-hidden-array", "solutions": ["# \"\"\"\n# This is the ArrayReader's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# class ArrayReader(object):\n# \t # Compares 4 different elements in the array\n# \t # return 4 if the values of the 4 elements are the same (0 or 1).\n# \t # return 2 if threeelements have a valueequal to 0and oneelement has value equal to 1or vice versa.\n# \t # return 0 :if two element have a value equal to 0 and two elements have a value equal to 1.\n#    def query(self, a: int, b: int, c: int, d: int) -> int:\n#\n# \t # Returns the length of the array\n#    def length(self) -> int:\n#\n\n\nclass Solution:\n    def guessMajority(self, reader: \"ArrayReader\") -> int:\n        n = reader.length()\n        x = reader.query(0, 1, 2, 3)\n        a, b = 1, 0\n        k = 0\n        for i in range(4, n):\n            if reader.query(0, 1, 2, i) == x:\n                a += 1\n            else:\n                b += 1\n                k = i\n\n        y = reader.query(0, 1, 2, 4)\n        if reader.query(1, 2, 3, 4) == y:\n            a += 1\n        else:\n            b += 1\n            k = 0\n        if reader.query(0, 2, 3, 4) == y:\n            a += 1\n        else:\n            b += 1\n            k = 1\n        if reader.query(0, 1, 3, 4) == y:\n            a += 1\n        else:\n            b += 1\n            k = 2\n\n        if a == b:\n            return -1\n        return 3 if a > b else k\n", "# \"\"\"\n# This is the ArrayReader's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# class ArrayReader(object):\n#   # Compares 4 different elements in the array\n#   # Returns 4 if the values of the 4 elements are the same (0 or 1).\n#   # Returns 2 if threeelements have a valueequal to 0and oneelement has\n#   #           value equal to 1or vice versa.\n#   # Returns 0 if two element have a value equal to 0 and two elements have a\n#   #           value equal to 1.\n#   def query(self, a: int, b: int, c: int, d: int) -> int:\n#\n#   # Returns the length of the array\n#   def length(self) -> int:\n#\n\nclass Solution:\n  def guessMajority(self, reader: 'ArrayReader') -> int:\n    n = reader.length()\n    query0123 = reader.query(0, 1, 2, 3)\n    query1234 = reader.query(1, 2, 3, 4)\n    zeros = 1  # the number of numbers that are same as `nums[0]`\n    nonZeros = 0  # the number of numbers that are different from `nums[0]`\n    indexNot0 = -1  # any index i s.t. nums[i] != nums[0]\n\n    # Find which group nums[1..3] belong to.\n    for i in range(1, 4):\n      abcd = [0] + [num for num in [1, 2, 3] if num != i] + [4]\n      if reader.query(*abcd) == query1234:  # nums[i] == nums[0]\n        zeros += 1\n      else:\n        nonZeros += 1\n        indexNot0 = i\n\n    # Find which group nums[4..n) belong to.\n    for i in range(4, n):\n      if reader.query(1, 2, 3, i) == query0123:  # nums[i] == nums[0]\n        zeros += 1\n      else:\n        nonZeros += 1\n        indexNot0 = i\n\n    if zeros == nonZeros:\n      return -1\n    if zeros > nonZeros:\n      return 0\n    return indexNot0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1577, "slug": "number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers", "solutions": ["class Solution:\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\n        def count(nums: List[int]) -> Counter:\n            cnt = Counter()\n            for j in range(len(nums)):\n                for k in range(j + 1, len(nums)):\n                    cnt[nums[j] * nums[k]] += 1\n            return cnt\n\n        def cal(nums: List[int], cnt: Counter) -> int:\n            return sum(cnt[x * x] for x in nums)\n\n        cnt1 = count(nums1)\n        cnt2 = count(nums2)\n        return cal(nums1, cnt2) + cal(nums2, cnt1)\n", "class Solution:\n  def numTriplets(self, nums1: list[int], nums2: list[int]) -> int:\n    def countTriplets(A: list[int], B: list[int]):\n      \"\"\"Returns the number of triplet (i, j, k) if A[i]^2 == B[j] * B[k].\"\"\"\n      res = 0\n      count = collections.Counter(B)\n\n      for a in A:\n        target = a * a\n        for b, freq in count.items():\n          if target % b > 0 or target // b not in count:\n            continue\n          if target // b == b:\n            res += freq * (freq - 1)\n          else:\n            res += freq * count[target // b]\n\n      return res // 2\n\n    return countTriplets(nums1, nums2) + countTriplets(nums2, nums1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1549, "slug": "the-most-recent-orders-for-each-product", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1555, "slug": "bank-account-summary", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1506, "slug": "find-root-of-n-ary-tree", "solutions": ["\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children if children is not None else []\n\"\"\"\n\n\nclass Solution:\n    def findRoot(self, tree: List['Node']) -> 'Node':\n        x = 0\n        for node in tree:\n            x ^= node.val\n            for child in node.children:\n                x ^= child.val\n        return next(node for node in tree if node.val == x)\n", "class Solution:\n  def findRoot(self, tree: list['Node']) -> 'Node':\n    sum = 0\n\n    for node in tree:\n      sum ^= node.val\n      for child in node.children:\n        sum ^= child.val\n\n    for node in tree:\n      if node.val == sum:\n        return node\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1500, "slug": "design-a-file-sharing-system", "solutions": ["class FileSharing:\n    def __init__(self, m: int):\n        self.cur = 0\n        self.chunks = m\n        self.reused = []\n        self.user_chunks = defaultdict(set)\n\n    def join(self, ownedChunks: List[int]) -> int:\n        if self.reused:\n            userID = heappop(self.reused)\n        else:\n            self.cur += 1\n            userID = self.cur\n        self.user_chunks[userID] = set(ownedChunks)\n        return userID\n\n    def leave(self, userID: int) -> None:\n        heappush(self.reused, userID)\n        self.user_chunks.pop(userID)\n\n    def request(self, userID: int, chunkID: int) -> List[int]:\n        if chunkID < 1 or chunkID > self.chunks:\n            return []\n        res = []\n        for k, v in self.user_chunks.items():\n            if chunkID in v:\n                res.append(k)\n        if res:\n            self.user_chunks[userID].add(chunkID)\n        return sorted(res)\n\n\n# Your FileSharing object will be instantiated and called as such:\n# obj = FileSharing(m)\n# param_1 = obj.join(ownedChunks)\n# obj.leave(userID)\n# param_3 = obj.request(userID,chunkID)\n", "from sortedcontainers import SortedSet\n\n\nclass FileSharing:\n  def __init__(self, m: int):\n    self.userToChunks: dict[int, SortedSet[int]] = {}\n    self.chunkToUsers: dict[int, SortedSet[int]] = {}\n    self.availableUserIds: list[int] = []\n\n  def join(self, ownedChunks: list[int]) -> int:\n    userId = (heapq.heappop(self.availableUserIds) if self.availableUserIds\n              else len(self.userToChunks) + 1)\n    self.userToChunks[userId] = SortedSet(ownedChunks)\n    for chunk in ownedChunks:\n      self.chunkToUsers.setdefault(chunk, SortedSet()).add(userId)\n    return userId\n\n  def leave(self, userID: int) -> None:\n    if userID not in self.userToChunks:\n      return\n    for chunk in self.userToChunks[userID]:\n      self.chunkToUsers[chunk].discard(userID)\n      if not self.chunkToUsers[chunk]:\n        del self.chunkToUsers[chunk]\n    del self.userToChunks[userID]\n    heapq.heappush(self.availableUserIds, userID)\n\n  def request(self, userID: int, chunkID: int) -> list[int]:\n    if chunkID not in self.chunkToUsers:\n      return []\n    userIds = list(self.chunkToUsers[chunkID])\n    self.userToChunks[userID].add(chunkID)\n    self.chunkToUsers[chunkID].add(userID)\n    return userIds\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1548, "slug": "the-most-similar-path-in-a-graph", "solutions": ["class Solution:\n    def mostSimilar(\n        self, n: int, roads: List[List[int]], names: List[str], targetPath: List[str]\n    ) -> List[int]:\n        g = [[] for _ in range(n)]\n        for a, b in roads:\n            g[a].append(b)\n            g[b].append(a)\n        m = len(targetPath)\n        f = [[inf] * n for _ in range(m)]\n        pre = [[-1] * n for _ in range(m)]\n        for j, s in enumerate(names):\n            f[0][j] = targetPath[0] != s\n        for i in range(1, m):\n            for j in range(n):\n                for k in g[j]:\n                    if (t := f[i - 1][k] + (targetPath[i] != names[j])) < f[i][j]:\n                        f[i][j] = t\n                        pre[i][j] = k\n        k = 0\n        mi = inf\n        for j in range(n):\n            if f[-1][j] < mi:\n                mi = f[-1][j]\n                k = j\n        ans = [0] * m\n        for i in range(m - 1, -1, -1):\n            ans[i] = k\n            k = pre[i][k]\n        return ans\n", "class Solution:\n  def mostSimilar(self, n: int, roads: list[list[int]], names: list[str],\n                  targetPath: list[str]) -> list[int]:\n    # cost[i][j] := the minimum cost to start from names[i] in path[j]\n    cost = [[-1] * len(targetPath) for _ in range(len(names))]\n    # next[i][j] := the best next of names[i] in path[j]\n    next = [[0] * len(targetPath) for _ in range(len(names))]\n    graph = [[] for _ in range(n)]\n\n    for u, v in roads:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    minDist = math.inf\n    start = 0\n\n    def dfs(nameIndex: int, pathIndex: int) -> int:\n      if cost[nameIndex][pathIndex] != -1:\n        return cost[nameIndex][pathIndex]\n\n      editDist = names[nameIndex] != targetPath[pathIndex]\n      if pathIndex == len(targetPath) - 1:\n        return editDist\n\n      minDist = math.inf\n\n      for v in graph[nameIndex]:\n        dist = dfs(v, pathIndex + 1)\n        if dist < minDist:\n          minDist = dist\n          next[nameIndex][pathIndex] = v\n\n      cost[nameIndex][pathIndex] = editDist + minDist\n      return editDist + minDist\n\n    for i in range(n):\n      dist = dfs(i, 0)\n      if dist < minDist:\n        minDist = dist\n        start = i\n\n    ans = []\n\n    while len(ans) < len(targetPath):\n      ans.append(start)\n      start = next[start][len(ans) - 1]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1595, "slug": "minimum-cost-to-connect-two-groups-of-points", "solutions": ["class Solution:\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\n        m, n = len(cost), len(cost[0])\n        f = [[inf] * (1 << n) for _ in range(m + 1)]\n        f[0][0] = 0\n        for i in range(1, m + 1):\n            for j in range(1 << n):\n                for k in range(n):\n                    if (j >> k & 1) == 0:\n                        continue\n                    c = cost[i - 1][k]\n                    x = min(f[i][j ^ (1 << k)], f[i - 1][j], f[i - 1][j ^ (1 << k)]) + c\n                    f[i][j] = min(f[i][j], x)\n        return f[m][-1]\n", "class Solution:\n  def connectTwoGroups(self, cost: list[list[int]]) -> int:\n    # minCosts[j] := the minimum cost of connecting group2's point j\n    minCosts = [min(col) for col in zip(*cost)]\n\n    @functools.lru_cache(None)\n    def dp(i: int, mask: int) -> int:\n      \"\"\"\n      Returns the minimum cost to connect group1's points[i..n) with group2's\n      points, where `mask` is the bitmask of the connected points in group2.\n      \"\"\"\n      if i == len(cost):\n        # All the points in group 1 are connected, so greedily assign the\n        # minimum cost for the unconnected points of group2.\n        return sum(minCost for j, minCost in enumerate(minCosts)\n                   if (mask >> j & 1) == 0)\n      return min(cost[i][j] + dp(i + 1, mask | 1 << j)\n                 for j in range(len(cost[0])))\n\n    return dp(0, 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1515, "slug": "best-position-for-a-service-centre", "solutions": ["class Solution:\n    def getMinDistSum(self, positions: List[List[int]]) -> float:\n        n = len(positions)\n        x = y = 0\n        for x1, y1 in positions:\n            x += x1\n            y += y1\n        x, y = x / n, y / n\n        decay = 0.999\n        eps = 1e-6\n        alpha = 0.5\n        while 1:\n            grad_x = grad_y = 0\n            dist = 0\n            for x1, y1 in positions:\n                a = x - x1\n                b = y - y1\n                c = sqrt(a * a + b * b)\n                grad_x += a / (c + 1e-8)\n                grad_y += b / (c + 1e-8)\n                dist += c\n            dx = grad_x * alpha\n            dy = grad_y * alpha\n            x -= dx\n            y -= dy\n            alpha *= decay\n            if abs(dx) <= eps and abs(dy) <= eps:\n                return dist\n", "class Solution:\n  def getMinDistSum(self, positions: list[list[int]]) -> float:\n    def distSum(a: float, b: float) -> float:\n      return sum(math.sqrt((a - x)**2 + (b - y)**2)\n                 for x, y in positions)\n\n    ERR = 1e-6\n    currX = 50\n    currY = 50\n    ans = distSum(currX, currY)\n    step = 1\n\n    while step > ERR:\n      shouldDecreaseStep = True\n      for dx, dy in [(0, step), (0, -step), (step, 0), (-step, 0)]:\n        x = currX + dx\n        y = currY + dy\n        newDistSum = distSum(x, y)\n        if newDistSum < ans:\n          ans = newDistSum\n          currX = x\n          currY = y\n          shouldDecreaseStep = False\n      if shouldDecreaseStep:\n        step /= 10\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1580, "slug": "put-boxes-into-the-warehouse-ii", "solutions": ["class Solution:\n    def maxBoxesInWarehouse(self, boxes: List[int], warehouse: List[int]) -> int:\n        n = len(warehouse)\n        left = [0] * n\n        right = [0] * n\n        left[0] = right[-1] = inf\n        for i in range(1, n):\n            left[i] = min(left[i - 1], warehouse[i - 1])\n        for i in range(n - 2, -1, -1):\n            right[i] = min(right[i + 1], warehouse[i + 1])\n        for i in range(n):\n            warehouse[i] = min(warehouse[i], max(left[i], right[i]))\n        boxes.sort()\n        warehouse.sort()\n        ans = i = 0\n        for x in boxes:\n            while i < n and warehouse[i] < x:\n                i += 1\n            if i == n:\n                break\n            ans, i = ans + 1, i + 1\n        return ans\n", "class Solution:\n  def maxBoxesInWarehouse(self, boxes: list[int], warehouse: list[int]) -> int:\n    l = 0\n    r = len(warehouse) - 1\n\n    for box in sorted(boxes, reverse=True):\n      if l > r:\n        return len(warehouse)\n      if box <= warehouse[l]:\n        l += 1\n      elif box <= warehouse[r]:\n        r -= 1\n\n    return l + (len(warehouse) - r - 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1578, "slug": "minimum-time-to-make-rope-colorful", "solutions": ["class Solution:\n    def minCost(self, colors: str, neededTime: List[int]) -> int:\n        ans = i = 0\n        n = len(colors)\n        while i < n:\n            j = i\n            s = mx = 0\n            while j < n and colors[j] == colors[i]:\n                s += neededTime[j]\n                if mx < neededTime[j]:\n                    mx = neededTime[j]\n                j += 1\n            if j - i > 1:\n                ans += s - mx\n            i = j\n        return ans\n", "class Solution:\n  def minCost(self, colors: str, neededTime: list[int]) -> int:\n    ans = 0\n    maxNeededTime = neededTime[0]\n\n    for i in range(1, len(colors)):\n      if colors[i] == colors[i - 1]:\n        ans += min(maxNeededTime, neededTime[i])\n        # For each continuous group, Bob needs to remove every balloon except\n        # the one with the maximum `neededTime`. So, he should hold the balloon\n        # with the highest `neededTime` in his hand.\n        maxNeededTime = max(maxNeededTime, neededTime[i])\n      else:\n        # If the current balloon is different from the previous one, discard\n        # the balloon from the previous group and hold the new one in hand.\n        maxNeededTime = neededTime[i]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1547, "slug": "minimum-cost-to-cut-a-stick", "solutions": ["class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        cuts.extend([0, n])\n        cuts.sort()\n        m = len(cuts)\n        f = [[0] * m for _ in range(m)]\n        for l in range(2, m):\n            for i in range(m - l):\n                j = i + l\n                f[i][j] = inf\n                for k in range(i + 1, j):\n                    f[i][j] = min(f[i][j], f[i][k] + f[k][j] + cuts[j] - cuts[i])\n        return f[0][-1]\n", "class Solution:\n  def minCost(self, n: int, cuts: list[int]) -> int:\n    arr = sorted([0] + cuts + [n])\n\n    dp = [[0] * len(arr) for _ in range(len(arr))]\n\n    for d in range(2, len(arr)):\n      for i in range(len(arr) - d):\n        j = i + d\n        dp[i][j] = math.inf\n        for k in range(i + 1, j):\n          dp[i][j] = min(dp[i][j], arr[j] - arr[i] + dp[i][k] + dp[k][j])\n\n    return dp[0][len(arr) - 1]\n", "class Solution:\n  def minCost(self, n: int, cuts: list[int]) -> int:\n    A = sorted([0] + cuts + [n])\n\n    @functools.lru_cache(None)\n    def dp(i, j):\n      if j - i <= 1:\n        return 0\n\n      return min(A[j] - A[i] + dp(i, k) + dp(k, j) for k in range(i + 1, j))\n\n    return dp(0, len(A) - 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1571, "slug": "warehouse-manager", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1527, "slug": "patients-with-a-condition", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1536, "slug": "minimum-swaps-to-arrange-a-binary-grid", "solutions": ["class Solution:\n    def minSwaps(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        pos = [-1] * n\n        for i in range(n):\n            for j in range(n - 1, -1, -1):\n                if grid[i][j] == 1:\n                    pos[i] = j\n                    break\n        ans = 0\n        for i in range(n):\n            k = -1\n            for j in range(i, n):\n                if pos[j] <= i:\n                    ans += j - i\n                    k = j\n                    break\n            if k == -1:\n                return -1\n            while k > i:\n                pos[k], pos[k - 1] = pos[k - 1], pos[k]\n                k -= 1\n        return ans\n", "class Solution:\n  def minSwaps(self, grid: list[list[int]]) -> int:\n    n = len(grid)\n    ans = 0\n    # suffixZeros[i] := the number of suffix zeros in the i-th row\n    suffixZeros = [n if 1 not in row else row[::-1].index(1) for row in grid]\n\n    for i in range(n):\n      neededZeros = n - 1 - i\n      # Get the first row with suffix zeros >= `neededZeros` in suffixZeros[i:..n).\n      j = next((j for j in range(i, n) if suffixZeros[j] >= neededZeros), -1)\n      if j == -1:\n        return -1\n      # Move the rows[j] to the rows[i].\n      for k in range(j, i, -1):\n        suffixZeros[k] = suffixZeros[k - 1]\n      ans += j - i\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1585, "slug": "check-if-string-is-transformable-with-substring-sort-operations", "solutions": ["class Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        pos = defaultdict(deque)\n        for i, c in enumerate(s):\n            pos[int(c)].append(i)\n        for c in t:\n            x = int(c)\n            if not pos[x] or any(pos[i] and pos[i][0] < pos[x][0] for i in range(x)):\n                return False\n            pos[x].popleft()\n        return True\n", "class Solution:\n  def isTransformable(self, s: str, t: str) -> bool:\n    if collections.Counter(s) != collections.Counter(t):\n      return False\n\n    positions = [collections.deque() for _ in range(10)]\n\n    for i, c in enumerate(s):\n      positions[int(c)].append(i)\n\n    # For each digit in `t`, check if we can put this digit in `s` at the same\n    # position as `t`. Ensure that all the left digits are equal to or greater\n    # than it. This is because the only operation we can perform is sorting in\n    # ascending order. If there is a digit to the left that is smaller than it,\n    # we can never move it to the same position as in `t`. However, if all the\n    # digits to its left are equal to or greater than it, we can move it one\n    # position to the left until it reaches the same position as in `t`.\n    for c in t:\n      d = int(c)\n      front = positions[d].popleft()\n      for smaller in range(d):\n        if positions[smaller] and positions[smaller][0] < front:\n          return False\n\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1524, "slug": "number-of-sub-arrays-with-odd-sum", "solutions": ["class Solution:\n    def numOfSubarrays(self, arr: List[int]) -> int:\n        mod = 10**9 + 7\n        cnt = [1, 0]\n        ans = s = 0\n        for x in arr:\n            s += x\n            ans = (ans + cnt[s & 1 ^ 1]) % mod\n            cnt[s & 1] += 1\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1567, "slug": "maximum-length-of-subarray-with-positive-product", "solutions": ["class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        n = len(nums)\n        f = [0] * n\n        g = [0] * n\n        f[0] = int(nums[0] > 0)\n        g[0] = int(nums[0] < 0)\n        ans = f[0]\n        for i in range(1, n):\n            if nums[i] > 0:\n                f[i] = f[i - 1] + 1\n                g[i] = 0 if g[i - 1] == 0 else g[i - 1] + 1\n            elif nums[i] < 0:\n                f[i] = 0 if g[i - 1] == 0 else g[i - 1] + 1\n                g[i] = f[i - 1] + 1\n            ans = max(ans, f[i])\n        return ans\n", "class Solution:\n  def getMaxLen(self, nums: list[int]) -> int:\n    ans = 0\n    # the maximum length of subarrays ending in `num` with a negative product\n    neg = 0\n    # the maximum length of subarrays ending in `num` with a positive product\n    pos = 0\n\n    for num in nums:\n      pos = 0 if num == 0 else pos + 1\n      neg = 0 if num == 0 or neg == 0 else neg + 1\n      if num < 0:\n        pos, neg = neg, pos\n      ans = max(ans, pos)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1512, "slug": "number-of-good-pairs", "solutions": ["class Solution:\n    def numIdenticalPairs(self, nums: List[int]) -> int:\n        ans = 0\n        cnt = Counter()\n        for x in nums:\n            ans += cnt[x]\n            cnt[x] += 1\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1501, "slug": "countries-you-can-safely-invest-in", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1521, "slug": "find-a-value-of-a-mysterious-function-closest-to-target", "solutions": ["class Solution:\n    def closestToTarget(self, arr: List[int], target: int) -> int:\n        ans = abs(arr[0] - target)\n        s = {arr[0]}\n        for x in arr:\n            s = {x & y for y in s} | {x}\n            ans = min(ans, min(abs(y - target) for y in s))\n        return ans\n", "class Solution:\n  def closestToTarget(self, arr: list[int], target: int) -> int:\n    ans = math.inf\n    dp = set()  # all the values of subarrays that end in the current number\n\n    for num in arr:\n      # Extend each subarray that ends in the dpious number. Due to\n      # monotonicity of the AND operation, the size of `dp` will be at most\n      # num.bit_count() + 1.\n      dp = {num} | {val & num for val in dp}\n      ans = min(ans, min(abs(target - val) for val in dp))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1517, "slug": "find-users-with-valid-e-mails", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1551, "slug": "minimum-operations-to-make-array-equal", "solutions": ["class Solution:\n    def minOperations(self, n: int) -> int:\n        return sum(n - (i << 1 | 1) for i in range(n >> 1))\n", "class Solution:\n  def minOperations(self, n: int) -> int:\n    def arr(self, i: int) -> int:\n      \"\"\"Returns the i-th element of `arr`, where 1 <= i <= n.\"\"\"\n      return (i - 1) * 2 + 1\n\n    #     median := median of arr\n    #   diffs[i] := median - arr[i] where i <= i <= n // 2\n    #        ans := sum(diffs)\n    # e.g.\n    # n = 5, arr = [1, 3, 5, 7, 9], diffs = [4, 2]\n    #        ans = (4 + 2) * 2 // 2 = 6\n    # n = 6, arr = [1, 3, 5, 7, 9, 11], diffs = [5, 3, 1]\n    #        ans = (5 + 1) * 3 // 2 = 9\n    halfSize = n // 2\n    median = (arr(n) + arr(1)) // 2\n    firstDiff = median - arr(1)\n    lastDiff = median - arr(halfSize)\n    return (firstDiff + lastDiff) * halfSize // 2\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1537, "slug": "get-the-maximum-score", "solutions": ["class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        mod = 10**9 + 7\n        m, n = len(nums1), len(nums2)\n        i = j = 0\n        f = g = 0\n        while i < m or j < n:\n            if i == m:\n                g += nums2[j]\n                j += 1\n            elif j == n:\n                f += nums1[i]\n                i += 1\n            elif nums1[i] < nums2[j]:\n                f += nums1[i]\n                i += 1\n            elif nums1[i] > nums2[j]:\n                g += nums2[j]\n                j += 1\n            else:\n                f = g = max(f, g) + nums1[i]\n                i += 1\n                j += 1\n        return max(f, g) % mod\n", "class Solution:\n  def maxSum(self, nums1: list[int], nums2: list[int]) -> int:\n    # Keep the running the sum of `nums1` and `nums2` before the next rendezvous.\n    # Since `nums1` and `nums2` are increasing, move forward on the smaller one\n    # to ensure we don't miss any rendezvous. When meet rendezvous, choose the\n    # better path.\n    ans = 0\n    sum1 = 0  # sum(nums1) in (the prevoious rendezvous, the next rendezvous)\n    sum2 = 0  # sum(nums2) in (the prevoious rendezvous, the next rendezvous)\n    i = 0  # nums1's index\n    j = 0  # nums2's index\n\n    while i < len(nums1) and j < len(nums2):\n      if nums1[i] < nums2[j]:\n        sum1 += nums1[i]\n        i += 1\n      elif nums1[i] > nums2[j]:\n        sum2 += nums2[j]\n        j += 1\n      else:  # An rendezvous happens.\n        ans += max(sum1, sum2) + nums1[i]\n        sum1 = 0\n        sum2 = 0\n        i += 1\n        j += 1\n\n    while i < len(nums1):\n      sum1 += nums1[i]\n      i += 1\n\n    while j < len(nums2):\n      sum2 += nums2[j]\n      j += 1\n\n    return (ans + max(sum1, sum2)) % (10**9 + 7)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1519, "slug": "number-of-nodes-in-the-sub-tree-with-the-same-label", "solutions": ["class Solution:\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\n        def dfs(i, fa):\n            ans[i] -= cnt[labels[i]]\n            cnt[labels[i]] += 1\n            for j in g[i]:\n                if j != fa:\n                    dfs(j, i)\n            ans[i] += cnt[labels[i]]\n\n        g = defaultdict(list)\n        for a, b in edges:\n            g[a].append(b)\n            g[b].append(a)\n        cnt = Counter()\n        ans = [0] * n\n        dfs(0, -1)\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2792, "slug": "count-nodes-that-are-great-enough", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def countGreatEnoughNodes(self, root: Optional[TreeNode], k: int) -> int:\n        def push(pq, x):\n            heappush(pq, x)\n            if len(pq) > k:\n                heappop(pq)\n\n        def dfs(root):\n            if root is None:\n                return []\n            l, r = dfs(root.left), dfs(root.right)\n            for x in r:\n                push(l, x)\n            if len(l) == k and -l[0] < root.val:\n                nonlocal ans\n                ans += 1\n            push(l, -root.val)\n            return l\n\n        ans = 0\n        dfs(root)\n        return ans\n", "class Solution:\n  def countGreatEnoughNodes(self, root: TreeNode | None, k: int) -> int:\n    ans = 0\n\n    def dfs(root: TreeNode | None) -> list[int]:\n      nonlocal ans\n      if not root:\n        return []\n\n      kSmallest = sorted(dfs(root.left) + dfs(root.right))[:k]\n      if len(kSmallest) == k and root.val > kSmallest[-1]:\n        ans += 1\n\n      return kSmallest + [root.val]\n\n    dfs(root)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2759, "slug": "convert-json-string-to-object", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2777, "slug": "date-range-generator", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2718, "slug": "sum-of-matrix-after-queries", "solutions": ["class Solution:\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\n        row = set()\n        col = set()\n        ans = 0\n        for t, i, v in queries[::-1]:\n            if t == 0:\n                if i not in row:\n                    ans += v * (n - len(col))\n                    row.add(i)\n            else:\n                if i not in col:\n                    ans += v * (n - len(row))\n                    col.add(i)\n        return ans\n", "class Solution:\n  def matrixSumQueries(self, n: int, queries: list[list[int]]) -> int:\n    ans = 0\n    # seen[0] := row, seen[1] := col\n    seen = [[False] * n for _ in range(2)]\n    # notSet[0] = row, notSet[1] := col\n    notSet = [n] * 2\n\n    # Late queries dominate.\n    for type, index, val in reversed(queries):\n      if not seen[type][index]:\n        ans += val * notSet[type ^ 1]\n        seen[type][index] = True\n        notSet[type] -= 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2711, "slug": "difference-of-number-of-distinct-values-on-diagonals", "solutions": ["class Solution:\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\n        m, n = len(grid), len(grid[0])\n        ans = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                x, y = i, j\n                s = set()\n                while x and y:\n                    x, y = x - 1, y - 1\n                    s.add(grid[x][y])\n                tl = len(s)\n                x, y = i, j\n                s = set()\n                while x + 1 < m and y + 1 < n:\n                    x, y = x + 1, y + 1\n                    s.add(grid[x][y])\n                br = len(s)\n                ans[i][j] = abs(tl - br)\n        return ans\n", "class Solution:\n  def differenceOfDistinctValues(self, grid: list[list[int]]) -> list[list[int]]:\n    m = len(grid)\n    n = len(grid[0])\n    ans = [[0] * n for _ in range(m)]\n\n    def fillInDiagonal(i: int, j: int) -> None:\n      topLeft = set()\n      bottomRight = set()\n\n      # Fill in the diagonal from the top-left to the bottom-right.\n      while i < len(grid) and j < len(grid[0]):\n        ans[i][j] = len(topLeft)\n        # Post-addition, so this information can be utilized in subsequent cells.\n        topLeft.add(grid[i][j])\n        i += 1\n        j += 1\n\n      i -= 1\n      j -= 1\n\n      # Fill in the diagonal from the bottom-right to the top-left.\n      while i >= 0 and j >= 0:\n        ans[i][j] = abs(ans[i][j] - len(bottomRight))\n        # Post-addition, so this information can be utilized in subsequent cells.\n        bottomRight.add(grid[i][j])\n        i -= 1\n        j -= 1\n\n    for i in range(m):\n      fillInDiagonal(i, 0)\n\n    for j in range(1, n):\n      fillInDiagonal(0, j)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2736, "slug": "maximum-sum-queries", "solutions": ["class BinaryIndexedTree:\n    __slots__ = [\"n\", \"c\"]\n\n    def __init__(self, n: int):\n        self.n = n\n        self.c = [-1] * (n + 1)\n\n    def update(self, x: int, v: int):\n        while x <= self.n:\n            self.c[x] = max(self.c[x], v)\n            x += x & -x\n\n    def query(self, x: int) -> int:\n        mx = -1\n        while x:\n            mx = max(mx, self.c[x])\n            x -= x & -x\n        return mx\n\n\nclass Solution:\n    def maximumSumQueries(\n        self, nums1: List[int], nums2: List[int], queries: List[List[int]]\n    ) -> List[int]:\n        nums = sorted(zip(nums1, nums2), key=lambda x: -x[0])\n        nums2.sort()\n        n, m = len(nums1), len(queries)\n        ans = [-1] * m\n        j = 0\n        tree = BinaryIndexedTree(n)\n        for i in sorted(range(m), key=lambda i: -queries[i][0]):\n            x, y = queries[i]\n            while j < n and nums[j][0] >= x:\n                k = n - bisect_left(nums2, nums[j][1])\n                tree.update(k, nums[j][0] + nums[j][1])\n                j += 1\n            k = n - bisect_left(nums2, y)\n            ans[i] = tree.query(k)\n        return ans\n", "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass Pair:\n  x: int\n  y: int\n\n  def __iter__(self):\n    yield self.x\n    yield self.y\n\n\n@dataclass(frozen=True)\nclass IndexedQuery:\n  queryIndex: int\n  minX: int\n  minY: int\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.minX\n    yield self.minY\n\n\nclass Solution:\n  def maximumSumQueries(\n      self,\n      nums1: list[int],\n      nums2: list[int],\n      queries: list[list[int]],\n  ) -> list[int]:\n    pairs = sorted([Pair(nums1[i], nums2[i])\n                   for i in range(len(nums1))], key=lambda x: x.x, reverse=True)\n    ans = [0] * len(queries)\n    stack = []  # [(y, x + y)]\n\n    pairsIndex = 0\n    for queryIndex, minX, minY in sorted([IndexedQuery(i, query[0], query[1])\n                                          for i, query in enumerate(queries)],\n                                         key=lambda x: -x.minX):\n      while pairsIndex < len(pairs) and pairs[pairsIndex].x >= minX:\n        # x + y is a better candidate. Given that x is decreasing, the\n        # condition \"x + y >= stack[-1][1]\" suggests that y is relatively\n        # larger, thereby making it a better candidate.\n        x, y = pairs[pairsIndex]\n        while stack and x + y >= stack[-1][1]:\n          stack.pop()\n        if not stack or y > stack[-1][0]:\n          stack.append((y, x + y))\n        pairsIndex += 1\n      j = self._firstGreaterEqual(stack, minY)\n      ans[queryIndex] = -1 if j == len(stack) else stack[j][1]\n\n    return ans\n\n  def _firstGreaterEqual(self, A: list[tuple[int, int]], target: int) -> int:\n    l = 0\n    r = len(A)\n    while l < r:\n      m = (l + r) // 2\n      if A[m][0] >= target:\n        r = m\n      else:\n        l = m + 1\n    return l\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2716, "slug": "minimize-string-length", "solutions": ["class Solution:\n    def minimizedStringLength(self, s: str) -> int:\n        return len(set(s))\n", "class Solution:\n  def minimizedStringLength(self, s: str) -> int:\n    return len({*s})\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2745, "slug": "construct-the-longest-new-string", "solutions": ["class Solution:\n    def longestString(self, x: int, y: int, z: int) -> int:\n        if x < y:\n            return (x * 2 + z + 1) * 2\n        if x > y:\n            return (y * 2 + z + 1) * 2\n        return (x + y + z) * 2\n", "class Solution:\n  def longestString(self, x: int, y: int, z: int) -> int:\n    # 'AB' can always be easily appended within the string.\n    # Alternating 'AA' and 'BB' can be appended, creating a pattern like 'AABB'\n    # If x == y, we repeat the pattern 'AABBAABB...AABB'.\n    # If x != y, the pattern becomes 'AABBAABB...AABBAA' or 'BBAABBAABB...AABB'\n    mn = min(x, y)\n    if x == y:\n      return (mn * 2 + z) * 2\n    return (mn * 2 + 1 + z) * 2\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2761, "slug": "prime-pairs-with-target-sum", "solutions": ["class Solution:\n    def findPrimePairs(self, n: int) -> List[List[int]]:\n        primes = [True] * n\n        for i in range(2, n):\n            if primes[i]:\n                for j in range(i + i, n, i):\n                    primes[j] = False\n        ans = []\n        for x in range(2, n // 2 + 1):\n            y = n - x\n            if primes[x] and primes[y]:\n                ans.append([x, y])\n        return ans\n", "class Solution:\n  def findPrimePairs(self, n: int) -> list[list[int]]:\n    isPrime = self._sieveEratosthenes(n + 1)\n    return [[i, n - i] for i in range(2, n // 2 + 1)\n            if isPrime[i] and isPrime[n - i]]\n\n  def _sieveEratosthenes(self, n: int) -> list[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime\n\n\nj\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2703, "slug": "return-length-of-arguments-passed", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2743, "slug": "count-substrings-without-repeating-character", "solutions": ["class Solution:\n    def numberOfSpecialSubstrings(self, s: str) -> int:\n        cnt = Counter()\n        ans = j = 0\n        for i, c in enumerate(s):\n            cnt[c] += 1\n            while cnt[c] > 1:\n                cnt[s[j]] -= 1\n                j += 1\n            ans += i - j + 1\n        return ans\n", "class Solution:\n  def numberOfSpecialSubstrings(self, s: str) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] += 1\n      while count[c] == 2:\n        count[s[l]] -= 1\n        l += 1\n      ans += r - l + 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2733, "slug": "neither-minimum-nor-maximum", "solutions": ["class Solution:\n    def findNonMinOrMax(self, nums: List[int]) -> int:\n        mi, mx = min(nums), max(nums)\n        return next((x for x in nums if x != mi and x != mx), -1)\n", "class Solution:\n  def findNonMinOrMax(self, nums: list[int]) -> int:\n    return -1 if len(nums) < 3 else sorted(nums[:3])[1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2747, "slug": "count-zero-request-servers", "solutions": ["class Solution:\n    def countServers(\n        self, n: int, logs: List[List[int]], x: int, queries: List[int]\n    ) -> List[int]:\n        cnt = Counter()\n        logs.sort(key=lambda x: x[1])\n        ans = [0] * len(queries)\n        j = k = 0\n        for r, i in sorted(zip(queries, count())):\n            l = r - x\n            while k < len(logs) and logs[k][1] <= r:\n                cnt[logs[k][0]] += 1\n                k += 1\n            while j < len(logs) and logs[j][1] < l:\n                cnt[logs[j][0]] -= 1\n                if cnt[logs[j][0]] == 0:\n                    cnt.pop(logs[j][0])\n                j += 1\n            ans[i] = n - len(cnt)\n        return ans\n", "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass IndexedQuery:\n  queryIndex: int\n  query: int\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.query\n\n\nclass Solution:\n  def countServers(\n      self,\n      n: int,\n      logs: list[list[int]],\n      x: int,\n      queries: list[int],\n  ) -> list[int]:\n    ans = [0] * len(queries)\n    count = [0] * (n + 1)\n\n    logs.sort(key=lambda x: x[1])\n\n    i = 0\n    j = 0\n    servers = 0\n\n    # For each query, we care about logs[i..j].\n    for queryIndex, query in sorted([IndexedQuery(i, query)\n                                     for i, query in enumerate(queries)],\n                                    key=lambda x: x.query):\n      while j < len(logs) and logs[j][1] <= query:\n        count[logs[j][0]] += 1\n        if count[logs[j][0]] == 1:\n          servers += 1\n        j += 1\n      while i < len(logs) and logs[i][1] < query - x:\n        count[logs[i][0]] -= 1\n        if count[logs[i][0]] == 0:\n          servers -= 1\n        i += 1\n      ans[queryIndex] = n - servers\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2737, "slug": "find-the-closest-marked-node", "solutions": ["class Solution:\n    def minimumDistance(\n        self, n: int, edges: List[List[int]], s: int, marked: List[int]\n    ) -> int:\n        g = [[inf] * n for _ in range(n)]\n        for u, v, w in edges:\n            g[u][v] = min(g[u][v], w)\n        dist = [inf] * n\n        vis = [False] * n\n        dist[s] = 0\n        for _ in range(n):\n            t = -1\n            for j in range(n):\n                if not vis[j] and (t == -1 or dist[t] > dist[j]):\n                    t = j\n            vis[t] = True\n            for j in range(n):\n                dist[j] = min(dist[j], dist[t] + g[t][j])\n        ans = min(dist[i] for i in marked)\n        return -1 if ans >= inf else ans\n", "class Solution:\n  def minimumDistance(\n      self,\n      n: int,\n      edges: list[list[int]],\n      s: int,\n      marked: list[int],\n  ) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n\n    dist = self._dijkstra(graph, s)\n    ans = min(dist[u] for u in marked)\n    return -1 if ans == math.inf else ans\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n  ) -> list[int]:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2787, "slug": "ways-to-express-an-integer-as-sum-of-powers", "solutions": ["class Solution:\n    def numberOfWays(self, n: int, x: int) -> int:\n        mod = 10**9 + 7\n        f = [[0] * (n + 1) for _ in range(n + 1)]\n        f[0][0] = 1\n        for i in range(1, n + 1):\n            k = pow(i, x)\n            for j in range(n + 1):\n                f[i][j] = f[i - 1][j]\n                if k <= j:\n                    f[i][j] = (f[i][j] + f[i - 1][j - k]) % mod\n        return f[n][n]\n", "class Solution:\n  def numberOfWays(self, n: int, x: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i] := the number of ways to express i\n    dp = [1] + [0] * n\n\n    for a in range(1, n + 1):\n      ax = a**x\n      if ax > n:\n        break\n      for i in range(n, ax - 1, -1):\n        dp[i] += dp[i - ax]\n        dp[i] %= MOD\n\n    return dp[n]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2773, "slug": "height-of-special-binary-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def heightOfTree(self, root: Optional[TreeNode]) -> int:\n        def dfs(root: Optional[TreeNode], d: int):\n            nonlocal ans\n            ans = max(ans, d)\n            if root.left and root.left.right != root:\n                dfs(root.left, d + 1)\n            if root.right and root.right.left != root:\n                dfs(root.right, d + 1)\n\n        ans = 0\n        dfs(root, 0)\n        return ans\n", "class Solution:\n  def heightOfTree(self, root: TreeNode | None) -> int:\n    if not root:\n      return 0\n    # a leaf node\n    if root.left and root.left.right == root:\n      return 0\n    return 1 + max(self.heightOfTree(root.left), self.heightOfTree(root.right))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2763, "slug": "sum-of-imbalance-numbers-of-all-subarrays", "solutions": ["class Solution:\n    def sumImbalanceNumbers(self, nums: List[int]) -> int:\n        n = len(nums)\n        ans = 0\n        for i in range(n):\n            sl = SortedList()\n            cnt = 0\n            for j in range(i, n):\n                k = sl.bisect_left(nums[j])\n                h = k - 1\n                if h >= 0 and nums[j] - sl[h] > 1:\n                    cnt += 1\n                if k < len(sl) and sl[k] - nums[j] > 1:\n                    cnt += 1\n                if h >= 0 and k < len(sl) and sl[k] - sl[h] > 1:\n                    cnt -= 1\n                sl.add(nums[j])\n                ans += cnt\n        return ans\n", "class Solution:\n  # If sorted(nums)[i + 1] - sorted(nums)[i] > 1, then there's a gap. Instead\n  # of determining the number of gaps in each subarray, let's find out how many\n  # subarrays contain each gap.\n  def sumImbalanceNumbers(self, nums: list[int]) -> int:\n    n = len(nums)\n    # Note that to avoid double counting, only `left` needs to check nums[i].\n    # This adjustment ensures that i represents the position of the leftmost\n    # element of nums[i] within the subarray.\n\n    # left[i] := the maximum index l s.t. nums[l] = nums[i] or nums[i] + 1\n    left = [0] * n\n    # right[i] := the minimum index r s.t. nums[r] = nums[i]\n    right = [0] * n\n\n    numToIndex = [-1] * (n + 2)\n    for i, num in enumerate(nums):\n      left[i] = max(numToIndex[num], numToIndex[num + 1])\n      numToIndex[num] = i\n\n    numToIndex = [n] * (n + 2)\n    for i in range(n - 1, -1, -1):\n      right[i] = numToIndex[nums[i] + 1]\n      numToIndex[nums[i]] = i\n\n    # The gap above nums[i] persists until encountering nums[i] or nums[i] + 1.\n    # Consider subarrays nums[l..r] with l <= i <= r, where l in [left[i], i]\n    # and r in [i, right[i] - 1]. There are (i - left[i]) * (right[i] - i)\n    # subarrays satisfying this condition.\n    #\n    # Subtract n * (n + 1) / 2 to account for the overcounting of elements\n    # initially assumed to have a gap. This adjustment is necessary as the\n    # maximum element of every subarray does not have a gap.\n    return sum((i - left[i]) * (right[i] - i)\n               for i in range(n)) - n * (n + 1) // 2\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2771, "slug": "longest-non-decreasing-subarray-from-two-arrays", "solutions": ["class Solution:\n    def maxNonDecreasingLength(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        f = g = 1\n        ans = 1\n        for i in range(1, n):\n            ff = gg = 1\n            if nums1[i] >= nums1[i - 1]:\n                ff = max(ff, f + 1)\n            if nums1[i] >= nums2[i - 1]:\n                ff = max(ff, g + 1)\n            if nums2[i] >= nums1[i - 1]:\n                gg = max(gg, f + 1)\n            if nums2[i] >= nums2[i - 1]:\n                gg = max(gg, g + 1)\n            f, g = ff, gg\n            ans = max(ans, f, g)\n        return ans\n", "class Solution:\n  def maxNonDecreasingLength(self, nums1: list[int], nums2: list[int]) -> int:\n    ans = 1\n    dp1 = 1  # the longest subarray that ends in nums1[i] so far\n    dp2 = 1  # the longest subarray that ends in nums2[i] so far\n\n    for i in range(1, len(nums1)):\n      dp11 = dp1 + 1 if nums1[i - 1] <= nums1[i] else 1\n      dp21 = dp2 + 1 if nums2[i - 1] <= nums1[i] else 1\n      dp12 = dp1 + 1 if nums1[i - 1] <= nums2[i] else 1\n      dp22 = dp2 + 1 if nums2[i - 1] <= nums2[i] else 1\n      dp1 = max(dp11, dp21)\n      dp2 = max(dp12, dp22)\n      ans = max(ans, dp1, dp2)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2793, "slug": "status-of-flight-tickets", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2770, "slug": "maximum-number-of-jumps-to-reach-the-last-index", "solutions": ["class Solution:\n    def maximumJumps(self, nums: List[int], target: int) -> int:\n        @cache\n        def dfs(i: int) -> int:\n            if i == n - 1:\n                return 0\n            ans = -inf\n            for j in range(i + 1, n):\n                if abs(nums[i] - nums[j]) <= target:\n                    ans = max(ans, 1 + dfs(j))\n            return ans\n\n        n = len(nums)\n        ans = dfs(0)\n        return -1 if ans < 0 else ans\n", "class Solution:\n  def maximumJumps(self, nums: list[int], target: int) -> int:\n    n = len(nums)\n    # dp[i] := the maximum number of jumps to reach i from 0\n    dp = [-1] * n\n    dp[0] = 0\n\n    for j in range(1, n):\n      for i in range(j):\n        if dp[i] != -1 and abs(nums[j] - nums[i]) <= target:\n          dp[j] = max(dp[j], dp[i] + 1)\n\n    return dp[-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2757, "slug": "generate-circular-array-values", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2709, "slug": "greatest-common-divisor-traversal", "solutions": ["class UnionFind:\n    def __init__(self, n):\n        self.p = list(range(n))\n        self.size = [1] * n\n\n    def find(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n\n    def union(self, a, b):\n        pa, pb = self.find(a), self.find(b)\n        if pa == pb:\n            return False\n        if self.size[pa] > self.size[pb]:\n            self.p[pb] = pa\n            self.size[pa] += self.size[pb]\n        else:\n            self.p[pa] = pb\n            self.size[pb] += self.size[pa]\n        return True\n\n\nmx = 100010\np = defaultdict(list)\nfor x in range(1, mx + 1):\n    v = x\n    i = 2\n    while i <= v // i:\n        if v % i == 0:\n            p[x].append(i)\n            while v % i == 0:\n                v //= i\n        i += 1\n    if v > 1:\n        p[x].append(v)\n\n\nclass Solution:\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\n        n = len(nums)\n        m = max(nums)\n        uf = UnionFind(n + m + 1)\n        for i, x in enumerate(nums):\n            for j in p[x]:\n                uf.union(i, j + n)\n        return len(set(uf.find(i) for i in range(n))) == 1\n", "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.sz = [1] * n\n\n  def unionBySize(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.sz[i] < self.sz[j]:\n      self.sz[j] += self.sz[i]\n      self.id[i] = j\n    else:\n      self.sz[i] += self.sz[j]\n      self.id[j] = i\n\n  def getSize(self, i: int) -> int:\n    return self.sz[i]\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def canTraverseAllPairs(self, nums: list[int]) -> bool:\n    n = len(nums)\n    mx = max(nums)\n    maxPrimeFactor = self._sieveEratosthenes(mx + 1)\n    primeToFirstIndex = collections.defaultdict(int)\n    uf = UnionFind(n)\n\n    for i, num in enumerate(nums):\n      for prime_factor in self._getPrimeFactors(num, maxPrimeFactor):\n        if prime_factor in primeToFirstIndex:\n          uf.unionBySize(primeToFirstIndex[prime_factor], i)\n        else:\n          primeToFirstIndex[prime_factor] = i\n\n    return any(uf.getSize(i) == n for i in range(n))\n\n  def _sieveEratosthenes(self, n: int) -> list[int]:\n    \"\"\"Gets the minimum prime factor of i, where 1 < i <= n.\"\"\"\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:  # `i` is prime.\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactors(self, num: int, minPrimeFactors: list[int]) -> list[int]:\n    primeFactors = []\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.append(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return primeFactors\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2706, "slug": "buy-two-chocolates", "solutions": ["class Solution:\n    def buyChoco(self, prices: List[int], money: int) -> int:\n        prices.sort()\n        cost = prices[0] + prices[1]\n        return money if money < cost else money - cost\n", "class Solution:\n  def buyChoco(self, prices: list[int], money: int) -> int:\n    min1 = math.inf\n    min2 = math.inf\n\n    for price in prices:\n      if price <= min1:\n        min2 = min1\n        min1 = price\n      elif price < min2:\n        min2 = price\n\n    minCost = min1 + min2\n    return money if minCost > money else money - minCost\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2723, "slug": "add-two-promises", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2774, "slug": "array-upper-bound", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2791, "slug": "count-paths-that-can-form-a-palindrome-in-a-tree", "solutions": ["class Solution:\n    def countPalindromePaths(self, parent: List[int], s: str) -> int:\n        def dfs(i: int, xor: int):\n            nonlocal ans\n            for j, v in g[i]:\n                x = xor ^ v\n                ans += cnt[x]\n                for k in range(26):\n                    ans += cnt[x ^ (1 << k)]\n                cnt[x] += 1\n                dfs(j, x)\n\n        n = len(parent)\n        g = defaultdict(list)\n        for i in range(1, n):\n            p = parent[i]\n            g[p].append((i, 1 << (ord(s[i]) - ord('a'))))\n        ans = 0\n        cnt = Counter({0: 1})\n        dfs(0, 0)\n        return ans\n", "class Solution:\n  def countPalindromePaths(self, parent: list[int], s: str) -> int:\n    # A valid (u, v) has at most 1 letter with odd frequency on its path. The\n    # frequency of a letter on the u-v path is equal to the sum of its\n    # frequencies on the root-u and root-v paths substract twice of its\n    # frequency on the root-LCA(u, v) path. Considering only the parity\n    # (even/odd), the part involving root-LCA(u, v) can be ignored, making it\n    # possible to calculate both parts easily using a simple DFS.\n    tree = [[] for _ in parent]\n    maskToCount = collections.Counter({0: 1})\n\n    for i in range(1, len(parent)):\n      tree[parent[i]].append(i)\n\n    # mask := 26 bits that represent the parity of each character in the alphabet\n    # on the path from node 0 to node u\n    def dfs(u: int, mask: int) -> int:\n      res = 0\n      if u > 0:\n        mask ^= 1 << (ord(s[u]) - ord('a'))\n        # Consider any u-v path with 1 bit set.\n        for i in range(26):\n          res += maskToCount[mask ^ (1 << i)]\n        # Consider u-v path with 0 bit set.\n        res += maskToCount[mask ^ 0]\n        maskToCount[mask] += 1\n      for v in tree[u]:\n        res += dfs(v, mask)\n      return res\n\n    return dfs(0, 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2724, "slug": "sort-by", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2729, "slug": "check-if-the-number-is-fascinating", "solutions": ["class Solution:\n    def isFascinating(self, n: int) -> bool:\n        s = str(n) + str(2 * n) + str(3 * n)\n        return \"\".join(sorted(s)) == \"123456789\"\n", "class Solution:\n  def isFascinating(self, n):\n    s = str(n) + str(2 * n) + str(3 * n)\n    return ''.join(sorted(s)) == '123456789'\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2741, "slug": "special-permutations", "solutions": ["class Solution:\n    def specialPerm(self, nums: List[int]) -> int:\n        mod = 10**9 + 7\n        n = len(nums)\n        m = 1 << n\n        f = [[0] * n for _ in range(m)]\n        for i in range(1, m):\n            for j, x in enumerate(nums):\n                if i >> j & 1:\n                    ii = i ^ (1 << j)\n                    if ii == 0:\n                        f[i][j] = 1\n                        continue\n                    for k, y in enumerate(nums):\n                        if x % y == 0 or y % x == 0:\n                            f[i][j] = (f[i][j] + f[ii][k]) % mod\n        return sum(f[-1]) % mod\n", "class Solution:\n  def specialPerm(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    maxMask = 1 << len(nums)\n\n    @functools.lru_cache(None)\n    def dp(prev: int, mask: int) -> int:\n      \"\"\"\n      Returns the number of special permutations, where the previous number is\n      nums[i] and `mask` is the bitmask of the used numbers.\n      \"\"\"\n      if mask == maxMask - 1:\n        return 1\n\n      res = 0\n\n      for i, num in enumerate(nums):\n        if mask >> i & 1:\n          continue\n        if num % nums[prev] == 0 or nums[prev] % num == 0:\n          res += dp(i, mask | 1 << i)\n          res %= MOD\n\n      return res\n\n    return sum(dp(i, 1 << i)\n               for i in range(len(nums))) % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2776, "slug": "convert-callback-based-function-to-promise-based-function", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2717, "slug": "semi-ordered-permutation", "solutions": ["class Solution:\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\n        n = len(nums)\n        i = nums.index(1)\n        j = nums.index(n)\n        k = 1 if i < j else 2\n        return i + n - j - k\n", "class Solution:\n  def semiOrderedPermutation(self, nums: list[int]) -> int:\n    n = len(nums)\n    index1 = nums.index(1)\n    indexN = nums.index(n)\n    return index1 + (n - 1 - indexN) - int(index1 > indexN)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2778, "slug": "sum-of-squares-of-special-elements", "solutions": ["class Solution:\n    def sumOfSquares(self, nums: List[int]) -> int:\n        n = len(nums)\n        return sum(x * x for i, x in enumerate(nums, 1) if n % i == 0)\n", "class Solution:\n  def sumOfSquares(self, nums: list[int]) -> int:\n    return sum(num**2 for i, num in enumerate(nums)\n               if len(nums) % (i + 1) == 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2722, "slug": "join-two-arrays-by-id", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2748, "slug": "number-of-beautiful-pairs", "solutions": ["class Solution:\n    def countBeautifulPairs(self, nums: List[int]) -> int:\n        cnt = [0] * 10\n        ans = 0\n        for x in nums:\n            for y in range(10):\n                if cnt[y] and gcd(x % 10, y) == 1:\n                    ans += cnt[y]\n            cnt[int(str(x)[0])] += 1\n        return ans\n", "class Solution:\n  def countBeautifulPairs(self, nums: list[int]) -> int:\n    def firstDigit(num: int) -> int:\n      return int(str(num)[0])\n\n    def lastDigit(num: int) -> int:\n      return num % 10\n\n    return sum(math.gcd(firstDigit(nums[i]), lastDigit(nums[j])) == 1\n               for i in range(len(nums))\n               for j in range(i + 1, len(nums)))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2794, "slug": "create-object-from-two-arrays", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2775, "slug": "undefined-to-null", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2784, "slug": "check-if-array-is-good", "solutions": ["class Solution:\n    def isGood(self, nums: List[int]) -> bool:\n        cnt = Counter(nums)\n        n = len(nums) - 1\n        return cnt[n] == 2 and all(cnt[i] for i in range(1, n))\n", "class Solution:\n  def isGood(self, nums: list[int]) -> bool:\n    n = len(nums) - 1\n    count = collections.Counter(nums)\n    return all(count[i] == 1 for i in range(1, n)) and count[n] == 2\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2756, "slug": "query-batching", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2750, "slug": "ways-to-split-array-into-good-subarrays", "solutions": ["class Solution:\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\n        mod = 10**9 + 7\n        ans, j = 1, -1\n        for i, x in enumerate(nums):\n            if x == 0:\n                continue\n            if j > -1:\n                ans = ans * (i - j) % mod\n            j = i\n        return 0 if j == -1 else ans\n", "class Solution:\n  def numberOfGoodSubarraySplits(self, nums: list[int]) -> int:\n    if 1 not in nums:\n      return 0\n\n    MOD = 1_000_000_007\n    prev = -1  # the previous index of 1\n    ans = 1\n\n    for i, num in enumerate(nums):\n      if num == 1:\n        if prev != -1:\n          ans *= i - prev\n          ans %= MOD\n        prev = i\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2705, "slug": "compact-object", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2751, "slug": "robot-collisions", "solutions": ["class Solution:\n    def survivedRobotsHealths(\n        self, positions: List[int], healths: List[int], directions: str\n    ) -> List[int]:\n        n = len(positions)\n        indices = list(range(n))\n        stack = []\n\n        indices.sort(key=lambda i: positions[i])\n\n        for currentIndex in indices:\n            if directions[currentIndex] == \"R\":\n                stack.append(currentIndex)\n            else:\n                while stack and healths[currentIndex] > 0:\n                    topIndex = stack.pop()\n\n                    if healths[topIndex] > healths[currentIndex]:\n                        healths[topIndex] -= 1\n                        healths[currentIndex] = 0\n                        stack.append(topIndex)\n                    elif healths[topIndex] < healths[currentIndex]:\n                        healths[currentIndex] -= 1\n                        healths[topIndex] = 0\n                    else:\n                        healths[currentIndex] = 0\n                        healths[topIndex] = 0\n\n        result = [health for health in healths if health > 0]\n        return result\n", "from dataclasses import dataclass\n\n\n@dataclass\nclass Robot:\n  index: int\n  position: int\n  health: int\n  direction: str\n\n\nclass Solution:\n  def survivedRobotsHealths(\n      self,\n      positions: list[int],\n      healths: list[int],\n      directions: str,\n  ) -> list[int]:\n    robots = sorted([Robot(index, position, health, direction)\n                     for index, (position, health, direction) in\n                     enumerate(zip(positions, healths, directions))],\n                    key=lambda x: x.position)\n    stack: list[Robot] = []  # running robots\n\n    for robot in robots:\n      if robot.direction == 'R':\n        stack.append(robot)\n        continue\n      # Collide with robots going right if any.\n      while stack and stack[-1].direction == 'R' and robot.health > 0:\n        if stack[-1].health == robot.health:\n          stack.pop()\n          robot.health = 0\n        elif stack[-1].health < robot.health:\n          stack.pop()\n          robot.health -= 1\n        else:  # stack[-1].health > robot.health\n          stack[-1].health -= 1\n          robot.health = 0\n      if robot.health > 0:\n        stack.append(robot)\n\n    stack.sort(key=lambda robot: robot.index)\n    return [robot.health for robot in stack]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2701, "slug": "consecutive-transactions-with-increasing-amounts", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2772, "slug": "apply-operations-to-make-all-array-elements-equal-to-zero", "solutions": ["class Solution:\n    def checkArray(self, nums: List[int], k: int) -> bool:\n        n = len(nums)\n        d = [0] * (n + 1)\n        s = 0\n        for i, x in enumerate(nums):\n            s += d[i]\n            x += s\n            if x == 0:\n                continue\n            if x < 0 or i + k > n:\n                return False\n            s -= x\n            d[i + k] += x\n        return True\n", "class Solution:\n  def checkArray(self, nums: list[int], k: int) -> bool:\n    if k == 1:\n      return True\n\n    needDecrease = 0\n    # Store nums[i - k + 1..i] with decreasing nums[i - k + 1].\n    dq = collections.deque()\n\n    for i, num in enumerate(nums):\n      if i >= k:\n        needDecrease -= dq.popleft()\n      if nums[i] < needDecrease:\n        return False\n      decreasedNum = nums[i] - needDecrease\n      dq.append(decreasedNum)\n      needDecrease += decreasedNum\n\n    return dq[-1] == 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2764, "slug": "is-array-a-preorder-of-some-binary-tree", "solutions": ["class Solution:\n    def isPreorder(self, nodes: List[List[int]]) -> bool:\n        def dfs(i: int) -> int:\n            nonlocal k\n            if i != nodes[k][0]:\n                return False\n            k += 1\n            return all(dfs(j) for j in g[i])\n\n        g = defaultdict(list)\n        for i, p in nodes:\n            g[p].append(i)\n        k = 0\n        return dfs(nodes[0][0]) and k == len(nodes)\n", "class Solution:\n  def isPreorder(self, nodes: list[list[int]]) -> bool:\n    stack = []  # Stores `id`s.\n\n    for id, parentId in nodes:\n      if parentId == -1:\n        stack.append(id)\n        continue\n      while stack and stack[-1] != parentId:\n        stack.pop()\n      if not stack:\n        return False\n      stack.append(id)\n\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2727, "slug": "is-object-empty", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2785, "slug": "sort-vowels-in-a-string", "solutions": ["class Solution:\n    def sortVowels(self, s: str) -> str:\n        vs = [c for c in s if c.lower() in \"aeiou\"]\n        vs.sort()\n        cs = list(s)\n        j = 0\n        for i, c in enumerate(cs):\n            if c.lower() in \"aeiou\":\n                cs[i] = vs[j]\n                j += 1\n        return \"\".join(cs)\n", "class Solution:\n  def sortVowels(self, s: str) -> str:\n    VOWELS = 'aeiouAEIOU'\n    ans = []\n    vowels = sorted([c for c in s if c in VOWELS])\n\n    i = 0  # vowels' index\n    for c in s:\n      if c in VOWELS:\n        ans.append(vowels[i])\n        i += 1\n      else:\n        ans.append(c)\n\n    return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2760, "slug": "longest-even-odd-subarray-with-threshold", "solutions": ["class Solution:\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\n        ans, n = 0, len(nums)\n        for l in range(n):\n            if nums[l] % 2 == 0 and nums[l] <= threshold:\n                r = l + 1\n                while r < n and nums[r] % 2 != nums[r - 1] % 2 and nums[r] <= threshold:\n                    r += 1\n                ans = max(ans, r - l)\n        return ans\n", "class Solution:\n  def longestAlternatingSubarray(self, nums: list[int], threshold: int) -> int:\n    ans = 0\n    dp = 0\n\n    def isOddEven(a: int, b: int) -> bool:\n      return a % 2 != b % 2\n\n    for i, num in enumerate(nums):\n      if num > threshold:\n        dp = 0\n      elif i > 0 and dp > 0 and isOddEven(nums[i - 1], num):\n        # Increase the size of the subarray.\n        dp += 1\n      else:\n        # Start a new subarray if the start is valid.\n        dp = 1 if num % 2 == 0 else 0\n      ans = max(ans, dp)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2769, "slug": "find-the-maximum-achievable-number", "solutions": ["class Solution:\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\n        return num + t * 2\n", "class Solution:\n  def theMaximumAchievableX(self, num: int, t: int) -> int:\n    return num + 2 * t\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2740, "slug": "find-the-value-of-the-partition", "solutions": ["class Solution:\n    def findValueOfPartition(self, nums: List[int]) -> int:\n        nums.sort()\n        return min(b - a for a, b in pairwise(nums))\n", "class Solution:\n  def findValueOfPartition(self, nums: list[int]) -> int:\n    return min(b - a for a, b in itertools.pairwise(sorted(nums)))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2788, "slug": "split-strings-by-separator", "solutions": ["class Solution:\n    def splitWordsBySeparator(self, words: List[str], separator: str) -> List[str]:\n        return [s for w in words for s in w.split(separator) if s]\n", "class Solution:\n  def splitWordsBySeparator(\n      self,\n      words: list[str],\n      separator: str,\n  ) -> list[str]:\n    return [splitWord\n            for word in words\n            for splitWord in word.split(separator)\n            if splitWord]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2768, "slug": "number-of-black-blocks", "solutions": ["class Solution:\n    def countBlackBlocks(\n        self, m: int, n: int, coordinates: List[List[int]]\n    ) -> List[int]:\n        cnt = Counter()\n        for x, y in coordinates:\n            for a, b in pairwise((0, 0, -1, -1, 0)):\n                i, j = x + a, y + b\n                if 0 <= i < m - 1 and 0 <= j < n - 1:\n                    cnt[(i, j)] += 1\n        ans = [0] * 5\n        for x in cnt.values():\n            ans[x] += 1\n        ans[0] = (m - 1) * (n - 1) - len(cnt.values())\n        return ans\n", "class Solution:\n  def countBlackBlocks(\n      self,\n      m: int,\n      n: int,\n      coordinates: list[list[int]],\n  ) -> list[int]:\n    ans = [0] * 5\n    # count[i * n + j] := the number of black cells in\n    # (i - 1, j - 1), (i - 1, j), (i, j - 1), (i, j)\n    count = collections.Counter()\n\n    for x, y in coordinates:\n      for i in range(x, x + 2):\n        for j in range(y, y + 2):\n          # 2 x 2 submatrix with right-bottom conner being (i, j) contains the\n          # current black cell (x, y).\n          if 0 < i < m and 0 < j < n:\n            count[(i, j)] += 1\n\n    for freq in count.values():\n      ans[freq] += 1\n\n    ans[0] = (m - 1) * (n - 1) - sum(ans)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2767, "slug": "partition-string-into-minimum-beautiful-substrings", "solutions": ["class Solution:\n    def minimumBeautifulSubstrings(self, s: str) -> int:\n        @cache\n        def dfs(i: int) -> int:\n            if i >= n:\n                return 0\n            if s[i] == \"0\":\n                return inf\n            x = 0\n            ans = inf\n            for j in range(i, n):\n                x = x << 1 | int(s[j])\n                if x in ss:\n                    ans = min(ans, 1 + dfs(j + 1))\n            return ans\n\n        n = len(s)\n        x = 1\n        ss = {x}\n        for i in range(n):\n            x *= 5\n            ss.add(x)\n        ans = dfs(0)\n        return -1 if ans == inf else ans\n", "class Solution:\n  def minimumBeautifulSubstrings(self, s: str) -> int:\n    n = len(s)\n    # dp[i] := the minimum number of beautiful substrings for the first i chars\n    dp = [0] + [n + 1] * n\n\n    for i in range(1, n + 1):\n      if s[i - 1] == '0':\n        continue\n      num = 0  # the number of s[i - 1..j - 1]\n      for j in range(i, n + 1):\n        num = (num << 1) + int(s[j - 1])\n        if self._isPowerOfFive(num):\n          dp[j] = min(dp[j], dp[i - 1] + 1)\n\n    return -1 if dp[n] == n + 1 else dp[n]\n\n  def _isPowerOfFive(self, num: int) -> bool:\n    while num % 5 == 0:\n      num //= 5\n    return num == 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2731, "slug": "movement-of-robots", "solutions": ["class Solution:\n    def sumDistance(self, nums: List[int], s: str, d: int) -> int:\n        mod = 10**9 + 7\n        for i, c in enumerate(s):\n            nums[i] += d if c == \"R\" else -d\n        nums.sort()\n        ans = s = 0\n        for i, x in enumerate(nums):\n            ans += i * x - s\n            s += x\n        return ans % mod\n", "class Solution:\n  def sumDistance(self, nums: list[int], s: str, d: int) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    prefix = 0\n    pos = sorted([num - d if c == 'L' else num + d\n                  for num, c in zip(nums, s)])\n\n    for i, p in enumerate(pos):\n      ans = ((ans + i * p - prefix) % MOD + MOD) % MOD\n      prefix = ((prefix + p) % MOD + MOD) % MOD\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2749, "slug": "minimum-operations-to-make-the-integer-zero", "solutions": ["class Solution:\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\n        for k in count(1):\n            x = num1 - k * num2\n            if x < 0:\n                break\n            if x.bit_count() <= k <= x:\n                return k\n        return -1\n", "class Solution:\n  def makeTheIntegerZero(self, num1: int, num2: int) -> int:\n    # If k operations are used, num1 - [(num2 + 2^{i_1}) + (num2 + 2^{i_2}) +\n    # ... + (num2 + 2^{i_k})] = 0. So, num1 - k * num2 = (2^{i_1} + 2^{i_2} +\n    # ... + 2^{i_k}), where i_1, i_2, ..., i_k are in the range [0, 60].\n    # Note that for any number x, we can use \"x's bit count\" operations to make\n    # x equal to 0. Additionally, we can also use x operations to deduct x by\n    # 2^0 (x times), which also results in 0.\n\n    for ops in range(61):\n      target = num1 - ops * num2\n      if target.bit_count() <= ops <= target:\n        return ops\n\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2795, "slug": "parallel-execution-of-promises-for-individual-results-retrieval", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2714, "slug": "find-shortest-path-with-k-hops", "solutions": ["class Solution:\n    def shortestPathWithHops(\n        self, n: int, edges: List[List[int]], s: int, d: int, k: int\n    ) -> int:\n        g = [[] for _ in range(n)]\n        for u, v, w in edges:\n            g[u].append((v, w))\n            g[v].append((u, w))\n        dist = [[inf] * (k + 1) for _ in range(n)]\n        dist[s][0] = 0\n        pq = [(0, s, 0)]\n        while pq:\n            dis, u, t = heappop(pq)\n            for v, w in g[u]:\n                if t + 1 <= k and dist[v][t + 1] > dis:\n                    dist[v][t + 1] = dis\n                    heappush(pq, (dis, v, t + 1))\n                if dist[v][t] > dis + w:\n                    dist[v][t] = dis + w\n                    heappush(pq, (dis + w, v, t))\n        return int(min(dist[d]))\n", "class Solution:\n  # Similar to 787. Cheapest Flights Within K Stops\n  def shortestPathWithHops(\n      self,\n      n: int,\n      edges: list[list[int]],\n      s: int,\n      d: int,\n      k: int,\n  ) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, s, d, k)\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n      dst: int,\n      k: int,\n  ) -> int:\n    dist = [[math.inf for _ in range(k + 1)] for _ in range(len(graph))]\n\n    dist[src][k] = 0\n    minHeap = [(dist[src][k], src, k)]  # (d, u, hops)\n\n    while minHeap:\n      d, u, hops = heapq.heappop(minHeap)\n      if u == dst:\n        return d\n      if dist[u][hops] > d:\n        continue\n      for v, w in graph[u]:\n        # Go from u -> v with w cost.\n        if d + w < dist[v][hops]:\n          dist[v][hops] = d + w\n          heapq.heappush(minHeap, (dist[v][hops], v, hops))\n        # Hop from u -> v with 0 cost.\n        if hops > 0 and d < dist[v][hops - 1]:\n          dist[v][hops - 1] = d\n          heapq.heappush(minHeap, (dist[v][hops - 1], v, hops - 1))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2753, "slug": "count-houses-in-a-circular-street-ii", "solutions": ["# Definition for a street.\n# class Street:\n#     def closeDoor(self):\n#         pass\n#     def isDoorOpen(self):\n#         pass\n#     def moveRight(self):\n#         pass\nclass Solution:\n    def houseCount(self, street: Optional[\"Street\"], k: int) -> int:\n        while not street.isDoorOpen():\n            street.moveRight()\n        for i in range(1, k + 1):\n            street.moveRight()\n            if street.isDoorOpen():\n                ans = i\n                street.closeDoor()\n        return ans\n", "# Definition for a street.\n# class Street:\n#   def closeDoor(self):\n#     pass\n#   def isDoorOpen(self):\n#     pass\n#   def moveRight(self):\n#     pass\nclass Solution:\n  def houseCount(self, street: Optional['Street'], k: int) -> int:\n    ans = 0\n\n    # Go to the first open door.\n    while not street.isDoorOpen():\n      street.moveRight()\n\n    street.moveRight()\n\n    for count in range(k):\n      # Each time we encounter an open door, there's a possibility that it's the\n      # first open door we intentionally left open.\n      if street.isDoorOpen():\n        ans = count + 1\n        street.closeDoor()\n      street.moveRight()\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2744, "slug": "find-maximum-number-of-string-pairs", "solutions": ["class Solution:\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\n        cnt = Counter()\n        ans = 0\n        for w in words:\n            ans += cnt[w[::-1]]\n            cnt[w] += 1\n        return ans\n", "class Solution:\n  def maximumNumberOfStringPairs(self, words: list[str]) -> int:\n    ans = 0\n    seen = [False] * (26 * 26)\n\n    def val(c: str) -> int:\n      return ord(c) - ord('a')\n\n    for word in words:\n      if seen[val(word[1]) * 26 + val(word[0])]:\n        ans += 1\n      seen[val(word[0]) * 26 + val(word[1])] = True\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2780, "slug": "minimum-index-of-a-valid-split", "solutions": ["class Solution:\n    def minimumIndex(self, nums: List[int]) -> int:\n        x, cnt = Counter(nums).most_common(1)[0]\n        cur = 0\n        for i, v in enumerate(nums, 1):\n            if v == x:\n                cur += 1\n                if cur * 2 > i and (cnt - cur) * 2 > len(nums) - i:\n                    return i - 1\n        return -1\n", "class Solution:\n  def minimumIndex(self, nums: list[int]) -> int:\n    count1 = collections.Counter()\n    count2 = collections.Counter(nums)\n\n    for i, num in enumerate(nums):\n      count1[num] = count1[num] + 1\n      count2[num] = count2[num] - 1\n      if count1[num] * 2 > i + 1 and count2[num] * 2 > len(nums) - i - 1:\n        return i\n\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2752, "slug": "customers-with-maximum-number-of-transactions-on-consecutive-days", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2739, "slug": "total-distance-traveled", "solutions": ["class Solution:\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\n        ans = cur = 0\n        while mainTank:\n            cur += 1\n            ans += 10\n            mainTank -= 1\n            if cur % 5 == 0 and additionalTank:\n                additionalTank -= 1\n                mainTank += 1\n        return ans\n", "class Solution:\n  def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\n    # M  M M M M  A  M M M M   A\n    # 1 [2 3 4 5] 6 [7 8 9 10] 11\n    return (mainTank + min((mainTank - 1) // 4, additionalTank)) * 10\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2721, "slug": "execute-asynchronous-functions-in-parallel", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2746, "slug": "decremental-string-concatenation", "solutions": ["class Solution:\n    def minimizeConcatenatedLength(self, words: List[str]) -> int:\n        @cache\n        def dfs(i: int, a: str, b: str) -> int:\n            if i >= len(words):\n                return 0\n            s = words[i]\n            x = dfs(i + 1, a, s[-1]) - int(s[0] == b)\n            y = dfs(i + 1, s[0], b) - int(s[-1] == a)\n            return len(s) + min(x, y)\n\n        return len(words[0]) + dfs(1, words[0][0], words[0][-1])\n", "class Solution:\n  def minimizeConcatenatedLength(self, words: list[str]) -> int:\n    @functools.lru_cache(None)\n    def dp(i: int, first: str, last: str) -> int:\n      \"\"\"\n      Returns the minimum concatenated length of the first i words starting with\n      `first` and ending in `last`.\n      \"\"\"\n      if i == len(words):\n        return 0\n      nextFirst = words[i][0]\n      nextLast = words[i][-1]\n      return len(words[i]) + min(\n          # join(words[i - 1], words[i])\n          dp(i + 1, first, nextLast) - (last == nextFirst),\n          # join(words[i], words[i - 1])\n          dp(i + 1, nextFirst, last) - (first == nextLast)\n      )\n\n    return len(words[0]) + dp(1, words[0][0], words[0][-1])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2738, "slug": "count-occurrences-in-text", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2728, "slug": "count-houses-in-a-circular-street", "solutions": ["# Definition for a street.\n# class Street:\n#     def openDoor(self):\n#         pass\n#     def closeDoor(self):\n#         pass\n#     def isDoorOpen(self):\n#         pass\n#     def moveRight(self):\n#         pass\n#     def moveLeft(self):\n#         pass\nclass Solution:\n    def houseCount(self, street: Optional[\"Street\"], k: int) -> int:\n        for _ in range(k):\n            street.openDoor()\n            street.moveLeft()\n        ans = 0\n        while street.isDoorOpen():\n            street.closeDoor()\n            street.moveLeft()\n            ans += 1\n        return ans\n", "# Definition for a street.\n# class Street:\n#   def openDoor(self):\n#     pass\n#   def closeDoor(self):\n#     pass\n#   def isDoorOpen(self):\n#     pass\n#   def moveRight(self):\n#     pass\n#   def moveLeft(self):\n#     pass\n\nclass Solution:\n  def houseCount(self, street: Optional['Street'], k: int) -> int:\n    for _ in range(k):\n      if street.isDoorOpen():\n        street.closeDoor()\n      street.moveRight()\n\n    for ans in range(k + 1):\n      if street.isDoorOpen():\n        return ans\n      street.openDoor()\n      street.moveRight()\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2713, "slug": "maximum-strictly-increasing-cells-in-a-matrix", "solutions": ["class Solution:\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\n        m, n = len(mat), len(mat[0])\n        g = defaultdict(list)\n        for i in range(m):\n            for j in range(n):\n                g[mat[i][j]].append((i, j))\n        rowMax = [0] * m\n        colMax = [0] * n\n        ans = 0\n        for _, pos in sorted(g.items()):\n            mx = []\n            for i, j in pos:\n                mx.append(1 + max(rowMax[i], colMax[j]))\n                ans = max(ans, mx[-1])\n            for k, (i, j) in enumerate(pos):\n                rowMax[i] = max(rowMax[i], mx[k])\n                colMax[j] = max(colMax[j], mx[k])\n        return ans\n", "class Solution:\n  def maxIncreasingCells(self, mat: list[list[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    rows = [0] * m  # rows[i] := the maximum path length for the i-th row\n    cols = [0] * n  # cols[j] := the maximum path length for the j-th column\n    valToIndices = collections.defaultdict(list)\n    # maxPathLength[i][j] := the maximum path length from mat[i][j]\n    maxPathLength = [[0] * n for _ in range(m)]\n    # Sort all the unique values in the matrix in non-increasing order.\n    decreasingSet = set()\n\n    for i in range(m):\n      for j in range(n):\n        val = mat[i][j]\n        valToIndices[val].append((i, j))\n        decreasingSet.add(val)\n\n    for val in sorted(decreasingSet, reverse=True):\n      for i, j in valToIndices[val]:\n        maxPathLength[i][j] = max(rows[i], cols[j]) + 1\n      for i, j in valToIndices[val]:\n        rows[i] = max(rows[i], maxPathLength[i][j])\n        cols[j] = max(cols[j], maxPathLength[i][j])\n\n    return max(max(rows), max(cols))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2702, "slug": "minimum-operations-to-make-numbers-non-positive", "solutions": ["class Solution:\n    def minOperations(self, nums: List[int], x: int, y: int) -> int:\n        def check(t: int) -> bool:\n            cnt = 0\n            for v in nums:\n                if v > t * y:\n                    cnt += ceil((v - t * y) / (x - y))\n            return cnt <= t\n\n        l, r = 0, max(nums)\n        while l < r:\n            mid = (l + r) >> 1\n            if check(mid):\n                r = mid\n            else:\n                l = mid + 1\n        return l\n", "class Solution:\n  def minOperations(self, nums: list[int], x: int, y: int) -> int:\n    def isPossible(m: int) -> bool:\n      \"\"\"\n      Returns True if it's possible to make all `nums` <= 0 using m operations.\n      \"\"\"\n      # If we want m operations, first decrease all the numbers by y * m. Then\n      # we have m operations to select indices to decrease them by x - y.\n      return sum(max(0, math.ceil((num - y * m) / (x - y)))\n                 for num in nums) <= m\n\n    return bisect.bisect_left(range(max(nums)), True, key=isPossible)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2758, "slug": "next-day", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2742, "slug": "painting-the-walls", "solutions": ["class Solution:\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\n        @cache\n        def dfs(i: int, j: int) -> int:\n            if n - i <= j:\n                return 0\n            if i >= n:\n                return inf\n            return min(dfs(i + 1, j + time[i]) + cost[i], dfs(i + 1, j - 1))\n\n        n = len(cost)\n        return dfs(0, 0)\n", "class Solution:\n  def paintWalls(self, cost: list[int], time: list[int]) -> int:\n    MAX = 500_000_000\n    n = len(cost)\n    # dp[i] := the minimum cost to paint i walls by the painters so far\n    dp = [0] + [MAX] * n\n\n    for c, t in zip(cost, time):\n      for walls in range(n, 0, -1):\n        dp[walls] = min(dp[walls], dp[max(walls - t - 1, 0)] + c)\n\n    return dp[n]\n", "class Solution:\n  def paintWalls(self, cost: list[int], time: list[int]) -> int:\n    n = len(cost)\n\n    @functools.lru_cache(None)\n    def dp(i: int, walls: int) -> int:\n      \"\"\"Returns the minimum cost to paint j walls by painters[i..n).\"\"\"\n      if walls <= 0:\n        return 0\n      if i == n:\n        return math.inf\n      pick = cost[i] + dp(i + 1, walls - time[i] - 1)\n      skip = dp(i + 1, walls)\n      return min(pick, skip)\n\n    return dp(0, n)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2779, "slug": "maximum-beauty-of-an-array-after-applying-operation", "solutions": ["class Solution:\n    def maximumBeauty(self, nums: List[int], k: int) -> int:\n        m = max(nums) + k * 2 + 2\n        d = [0] * m\n        for x in nums:\n            d[x] += 1\n            d[x + k * 2 + 1] -= 1\n        return max(accumulate(d))\n", "class Solution:\n  def maximumBeauty(self, nums: list[int], k: int) -> int:\n    nums.sort()\n\n    # l and r track the maximum window instead of the valid window.\n    l = 0\n    for r in range(len(nums)):\n      if nums[r] - nums[l] > 2 * k:\n        l += 1\n\n    return r - l + 1\n", "class Solution:\n  def maximumBeauty(self, nums: list[int], k: int) -> int:\n    ans = 0\n\n    nums.sort()\n\n    l = 0\n    for r in range(len(nums)):\n      while nums[r] - nums[l] > 2 * k:\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2715, "slug": "timeout-cancellation", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2789, "slug": "largest-element-in-an-array-after-merge-operations", "solutions": ["class Solution:\n    def maxArrayValue(self, nums: List[int]) -> int:\n        for i in range(len(nums) - 2, -1, -1):\n            if nums[i] <= nums[i + 1]:\n                nums[i] += nums[i + 1]\n        return max(nums)\n", "class Solution:\n  def maxArrayValue(self, nums: list[int]) -> int:\n    ans = nums[-1]\n\n    for i in range(len(nums) - 2, -1, -1):\n      if nums[i] > ans:\n        ans = nums[i]\n      else:\n        ans += nums[i]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2797, "slug": "partial-function-with-placeholders", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2783, "slug": "flight-occupancy-and-waitlist-analysis", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2735, "slug": "collecting-chocolates", "solutions": ["class Solution:\n    def minCost(self, nums: List[int], x: int) -> int:\n        n = len(nums)\n        f = [[0] * n for _ in range(n)]\n        for i, v in enumerate(nums):\n            f[i][0] = v\n            for j in range(1, n):\n                f[i][j] = min(f[i][j - 1], nums[(i - j) % n])\n        return min(sum(f[i][j] for i in range(n)) + x * j for j in range(n))\n", "class Solution:\n  def minCost(self, nums: list[int], x: int) -> int:\n    n = len(nums)\n    ans = math.inf\n    # minCost[i] := the minimum cost to collect the i-th type\n    minCost = [math.inf] * n\n\n    for rotate in range(n):\n      for i in range(n):\n        minCost[i] = min(minCost[i], nums[(i - rotate + n) % n])\n      ans = min(ans, sum(minCost) + rotate * x)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2708, "slug": "maximum-strength-of-a-group", "solutions": ["class Solution:\n    def maxStrength(self, nums: List[int]) -> int:\n        ans = -inf\n        for i in range(1, 1 << len(nums)):\n            t = 1\n            for j, x in enumerate(nums):\n                if i >> j & 1:\n                    t *= x\n            ans = max(ans, t)\n        return ans\n", "class Solution:\n  def maxStrength(self, nums: list[int]) -> int:\n    posProd = 1\n    negProd = 1\n    maxNeg = -math.inf\n    negCount = 0\n    hasPos = False\n    hasZero = False\n\n    for num in nums:\n      if num > 0:\n        posProd *= num\n        hasPos = True\n      elif num < 0:\n        negProd *= num\n        maxNeg = max(maxNeg, num)\n        negCount += 1\n      else:  # num == 0\n        hasZero = True\n\n    if negCount == 0 and not hasPos:\n      return 0\n    if negCount % 2 == 0:\n      return negProd * posProd\n    if negCount >= 3:\n      return negProd // maxNeg * posProd\n    if hasPos:\n      return posProd\n    if hasZero:\n      return 0\n    return maxNeg\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2799, "slug": "count-complete-subarrays-in-an-array", "solutions": ["class Solution:\n    def countCompleteSubarrays(self, nums: List[int]) -> int:\n        cnt = len(set(nums))\n        ans, n = 0, len(nums)\n        for i in range(n):\n            s = set()\n            for x in nums[i:]:\n                s.add(x)\n                if len(s) == cnt:\n                    ans += 1\n        return ans\n", "class Solution:\n  def countCompleteSubarrays(self, nums: list[int]) -> int:\n    ans = 0\n    distinct = len(set(nums))\n    count = collections.Counter()\n\n    l = 0\n    for num in nums:\n      count[num] += 1\n      while len(count) == distinct:\n        count[nums[l]] -= 1\n        if count[nums[l]] == 0:\n          del count[nums[l]]\n        l += 1\n      # Assume nums[r] = num,\n      # nums[0..r], nums[1..r], ..., nums[l - 1..r] have k different values.\n      ans += l\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2782, "slug": "number-of-unique-categories", "solutions": ["# Definition for a category handler.\n# class CategoryHandler:\n#     def haveSameCategory(self, a: int, b: int) -> bool:\n#         pass\nclass Solution:\n    def numberOfCategories(\n        self, n: int, categoryHandler: Optional['CategoryHandler']\n    ) -> int:\n        def find(x: int) -> int:\n            if p[x] != x:\n                p[x] = find(p[x])\n            return p[x]\n\n        p = list(range(n))\n        for a in range(n):\n            for b in range(a + 1, n):\n                if categoryHandler.haveSameCategory(a, b):\n                    p[find(a)] = find(b)\n        return sum(i == x for i, x in enumerate(p))\n", "# Definition for a category handler.\n# class CategoryHandler:\n#   def haveSameCategory(self, a: int, b: int) -> bool:\n#     pass\n\nclass Solution:\n  def numberOfCategories(\n      self,\n      n: int,\n      categoryHandler: Optional['CategoryHandler'],\n  ) -> int:\n    ans = 0\n\n    for i in range(n):\n      if not any(categoryHandler.haveSameCategory(i, j) for j in range(i)):\n        ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2730, "slug": "find-the-longest-semi-repetitive-substring", "solutions": ["class Solution:\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\n        ans, n = 1, len(s)\n        cnt = j = 0\n        for i in range(1, n):\n            cnt += s[i] == s[i - 1]\n            while cnt > 1:\n                cnt -= s[j] == s[j + 1]\n                j += 1\n            ans = max(ans, i - j + 1)\n        return ans\n", "class Solution:\n  def longestSemiRepetitiveSubstring(self, s: str) -> int:\n    ans = 1\n    prevStart = 0\n    start = 0\n\n    for i in range(1, len(s)):\n      if s[i] == s[i - 1]:\n        if prevStart > 0:\n          start = prevStart\n        prevStart = i\n      ans = max(ans, i - start + 1)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2755, "slug": "deep-merge-of-two-objects", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2710, "slug": "remove-trailing-zeros-from-a-string", "solutions": ["class Solution:\n    def removeTrailingZeros(self, num: str) -> str:\n        return num.rstrip(\"0\")\n", "class Solution:\n  def removeTrailingZeros(self, num: str) -> str:\n    return num.rstrip('0')\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2796, "slug": "repeat-string", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2704, "slug": "to-be-or-not-to-be", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2725, "slug": "interval-cancellation", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2762, "slug": "continuous-subarrays", "solutions": ["class Solution:\n    def continuousSubarrays(self, nums: List[int]) -> int:\n        ans = i = 0\n        sl = SortedList()\n        for x in nums:\n            sl.add(x)\n            while sl[-1] - sl[0] > 2:\n                sl.remove(nums[i])\n                i += 1\n            ans += len(sl)\n        return ans\n", "class Solution:\n  def continuousSubarrays(self, nums: list[int]) -> int:\n    ans = 1  # [nums[0]]\n    left = nums[0] - 2\n    right = nums[0] + 2\n    l = 0\n\n    # nums[l..r] is a valid window.\n    for r in range(1, len(nums)):\n      if left <= nums[r] <= right:\n        left = max(left, nums[r] - 2)\n        right = min(right, nums[r] + 2)\n      else:\n        # nums[r] is out-of-bounds, so reconstruct the window.\n        left = nums[r] - 2\n        right = nums[r] + 2\n        l = r\n        # If we consistently move leftward in each iteration, it implies that\n        # the entire left subarray satisfies the given condition. For every\n        # subarray with l in the range [0, r], the condition is met, preventing\n        # the code from reaching the final \"else\" condition. Instead, it stops\n        # at the \"if\" condition.\n        while nums[r] - 2 <= nums[l] <= nums[r] + 2:\n          left = max(left, nums[l] - 2)\n          right = min(right, nums[l] + 2)\n          l -= 1\n        l += 1\n      # nums[l..r], num[l + 1..r], ..., nums[r]\n      ans += r - l + 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2707, "slug": "extra-characters-in-a-string", "solutions": ["class Solution:\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\n        ss = set(dictionary)\n        n = len(s)\n        f = [0] * (n + 1)\n        for i in range(1, n + 1):\n            f[i] = f[i - 1] + 1\n            for j in range(i):\n                if s[j:i] in ss and f[j] < f[i]:\n                    f[i] = f[j]\n        return f[n]\n", "class Solution:\n  # Similar to 139. Word Break\n  def minExtraChar(self, s: str, dictionary: list[str]) -> int:\n    n = len(s)\n    dictionarySet = set(dictionary)\n    # dp[i] := the minimum extra letters if breaking up s[0..i) optimally\n    dp = [0] + [n] * n\n\n    for i in range(1, n + 1):\n      for j in range(i):\n        if s[j:i] in dictionarySet:\n          dp[i] = min(dp[i], dp[j])\n        else:\n          dp[i] = min(dp[i], dp[j] + i - j)\n\n    return dp[n]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2790, "slug": "maximum-number-of-groups-with-increasing-length", "solutions": ["class Solution:\n    def maxIncreasingGroups(self, usageLimits: List[int]) -> int:\n        usageLimits.sort()\n        k, n = 0, len(usageLimits)\n        for i in range(n):\n            if usageLimits[i] > k:\n                k += 1\n                usageLimits[i] -= k\n            if i + 1 < n:\n                usageLimits[i + 1] += usageLimits[i]\n        return k\n", "class Solution:\n  def maxIncreasingGroups(self, usageLimits: list[int]) -> int:\n    ans = 1  # the next target length\n    availableLimits = 0\n\n    for usageLimit in sorted(usageLimits):\n      availableLimits += usageLimit\n      # Can create groups 1, 2, ..., ans.\n      if availableLimits >= ans * (ans + 1) // 2:\n        ans += 1\n\n    return ans - 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2765, "slug": "longest-alternating-subarray", "solutions": ["class Solution:\n    def alternatingSubarray(self, nums: List[int]) -> int:\n        ans, n = -1, len(nums)\n        for i in range(n):\n            k = 1\n            j = i\n            while j + 1 < n and nums[j + 1] - nums[j] == k:\n                j += 1\n                k *= -1\n            if j - i + 1 > 1:\n                ans = max(ans, j - i + 1)\n        return ans\n", "class Solution:\n  def alternatingSubarray(self, nums: list[int]) -> int:\n    ans = 1\n    dp = 1\n\n    for i in range(1, len(nums)):\n      targetDiff = -1 if dp % 2 == 0 else 1\n      # Append nums[i] to the current alternating subarray.\n      if nums[i] - nums[i - 1] == targetDiff:\n        dp += 1\n      # Reset the alternating subarray to nums[i - 1..i].\n      elif nums[i] - nums[i - 1] == 1:\n        dp = 2\n      # Reset the alternating subarray to nums[i].\n      else:\n        dp = 1\n      ans = max(ans, dp)\n\n    return -1 if ans == 1 else ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2754, "slug": "bind-function-to-context", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2720, "slug": "popularity-percentage", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2781, "slug": "length-of-the-longest-valid-substring", "solutions": ["class Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        s = set(forbidden)\n        ans = i = 0\n        for j in range(len(word)):\n            for k in range(j, max(j - 10, i - 1), -1):\n                if word[k : j + 1] in s:\n                    i = k + 1\n                    break\n            ans = max(ans, j - i + 1)\n        return ans\n", "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.isWord = False\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, word: str) -> None:\n    node: TrieNode = self.root\n    for c in word:\n      node = node.children.setdefault(c, TrieNode())\n    node.isWord = True\n\n  def search(self, word: str, l: int, r: int) -> bool:\n    node: TrieNode = self.root\n    for i in range(l, r):\n      if word[i] not in node.children:\n        return False\n      node = node.children[word[i]]\n    return node.isWord\n\n\nclass Solution:\n  def longestValidSubstring(self, word: str, forbidden: list[str]) -> int:\n    ans = 0\n    trie = Trie()\n\n    for s in forbidden:\n      trie.insert(s)\n\n    # r is the rightmost index to make word[l..r] a valid substring.\n    r = len(word) - 1\n    for l in range(len(word) - 1, -1, -1):\n      for end in range(l, min(l + 10, r + 1)):\n        if trie.search(word, l, end + 1):\n          r = end - 1\n          break\n      ans = max(ans, r - l + 1)\n\n    return ans\n", "class Solution:\n  def longestValidSubstring(self, word: str, forbidden: list[str]) -> int:\n    forbiddenSet = set(forbidden)\n    ans = 0\n    r = len(word) - 1  # rightmost index of the valid substring\n\n    for l in range(len(word) - 1, -1, -1):\n      for end in range(l, min(l + 10, r + 1)):\n        if word[l:end + 1] in forbiddenSet:\n          r = end - 1\n          break\n      ans = max(ans, r - l + 1)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2719, "slug": "count-of-integers", "solutions": ["class Solution:\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\n        @cache\n        def dfs(pos: int, s: int, limit: bool) -> int:\n            if pos >= len(num):\n                return int(min_sum <= s <= max_sum)\n            up = int(num[pos]) if limit else 9\n            return (\n                sum(dfs(pos + 1, s + i, limit and i == up) for i in range(up + 1)) % mod\n            )\n\n        mod = 10**9 + 7\n        num = num2\n        a = dfs(0, 0, True)\n        dfs.cache_clear()\n        num = str(int(num1) - 1)\n        b = dfs(0, 0, True)\n        return (a - b) % mod\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2766, "slug": "relocate-marbles", "solutions": ["class Solution:\n    def relocateMarbles(\n        self, nums: List[int], moveFrom: List[int], moveTo: List[int]\n    ) -> List[int]:\n        pos = set(nums)\n        for f, t in zip(moveFrom, moveTo):\n            pos.remove(f)\n            pos.add(t)\n        return sorted(pos)\n", "class Solution:\n  def relocateMarbles(\n      self,\n      nums: list[int],\n      moveFrom: list[int],\n      moveTo: list[int],\n  ) -> list[int]:\n    numsSet = set(nums)\n\n    for f, t in zip(moveFrom, moveTo):\n      numsSet.remove(f)\n      numsSet.add(t)\n\n    return sorted(numsSet)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2732, "slug": "find-a-good-subset-of-the-matrix", "solutions": ["class Solution:\n    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:\n        g = {}\n        for i, row in enumerate(grid):\n            mask = 0\n            for j, x in enumerate(row):\n                mask |= x << j\n            if mask == 0:\n                return [i]\n            g[mask] = i\n        for a, i in g.items():\n            for b, j in g.items():\n                if (a & b) == 0:\n                    return sorted([i, j])\n        return []\n", "class Solution:\n  def goodSubsetofBinaryMatrix(self, grid: list[list[int]]) -> list[int]:\n    MAX_BIT = 30\n    maskToIndex = {}\n\n    def getMask(row: list[int]) -> int:\n      mask = 0\n      for i, num in enumerate(row):\n        if num == 1:\n          mask |= 1 << i\n      return mask\n\n    for i, row in enumerate(grid):\n      mask = getMask(row)\n      if mask == 0:\n        return [i]\n      for prevMask in range(1, MAX_BIT):\n        if (mask & prevMask) == 0 and prevMask in maskToIndex:\n          return [maskToIndex[prevMask], i]\n      maskToIndex[mask] = i\n\n    return []\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2700, "slug": "differences-between-two-objects", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2734, "slug": "lexicographically-smallest-string-after-substring-operation", "solutions": ["class Solution:\n    def smallestString(self, s: str) -> str:\n        n = len(s)\n        i = 0\n        while i < n and s[i] == \"a\":\n            i += 1\n        if i == n:\n            return s[:-1] + \"z\"\n        j = i\n        while j < n and s[j] != \"a\":\n            j += 1\n        return s[:i] + \"\".join(chr(ord(c) - 1) for c in s[i:j]) + s[j:]\n", "class Solution:\n  def smallestString(self, s: str) -> str:\n    chars = list(s)\n    n = len(s)\n    i = 0\n\n    while i < n and chars[i] == 'a':\n      i += 1\n    if i == n:\n      chars[-1] = 'z'\n      return ''.join(chars)\n\n    while i < n and s[i] != 'a':\n      chars[i] = chr(ord(chars[i]) - 1)\n      i += 1\n\n    return ''.join(chars)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2712, "slug": "minimum-cost-to-make-all-characters-equal", "solutions": ["class Solution:\n    def minimumCost(self, s: str) -> int:\n        ans, n = 0, len(s)\n        for i in range(1, n):\n            if s[i] != s[i - 1]:\n                ans += min(i, n - i)\n        return ans\n", "class Solution:\n  def minimumCost(self, s: str) -> int:\n    n = len(s)\n    ans = 0\n\n    for i in range(1, n):\n      if s[i] != s[i - 1]:\n        # Invert s[0..i - 1] or s[i..n - 1].\n        ans += min(i, n - i)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2798, "slug": "number-of-employees-who-met-the-target", "solutions": ["class Solution:\n    def numberOfEmployeesWhoMetTarget(self, hours: List[int], target: int) -> int:\n        return sum(x >= target for x in hours)\n", "class Solution:\n  def numberOfEmployeesWhoMetTarget(self, hours: list[int], target: int) -> int:\n    return sum(hour >= target for hour in hours)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2786, "slug": "visit-array-positions-to-maximize-score", "solutions": ["class Solution:\n    def maxScore(self, nums: List[int], x: int) -> int:\n        f = [-inf] * 2\n        f[nums[0] & 1] = nums[0]\n        for v in nums[1:]:\n            f[v & 1] = max(f[v & 1], f[v & 1 ^ 1] - x) + v\n        return max(f)\n", "class Solution:\n  def maxScore(self, nums: list[int], x: int) -> int:\n    # Note that we always need to take nums[0], so the initial definition might\n    # not hold true.\n\n    # dp0 := the maximum score so far with `nums` ending in an even number\n    dp0 = nums[0] - (x if nums[0] % 2 == 1 else 0)\n    # dp0 := the maximum score so far with `nums` ending in an odd number\n    dp1 = nums[0] - (x if nums[0] % 2 == 0 else 0)\n\n    for i in range(1, len(nums)):\n      if nums[i] % 2 == 0:\n        dp0 = nums[i] + max(dp0, dp1 - x)\n      else:\n        dp1 = nums[i] + max(dp1, dp0 - x)\n\n    return max(dp0, dp1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2726, "slug": "calculator-with-method-chaining", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 142, "slug": "linked-list-cycle-ii", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\n\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        fast = slow = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                ans = head\n                while ans != slow:\n                    ans = ans.next\n                    slow = slow.next\n                return ans\n", "class Solution:\n  def detectCycle(self, head: ListNode) -> ListNode:\n    slow = head\n    fast = head\n\n    while fast and fast.next:\n      slow = slow.next\n      fast = fast.next.next\n      if slow == fast:\n        slow = head\n        while slow != fast:\n          slow = slow.next\n          fast = fast.next\n        return slow\n\n    return None\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 118, "slug": "pascals-triangle", "solutions": ["class Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n        f = [[1]]\n        for i in range(numRows - 1):\n            g = [1] + [a + b for a, b in pairwise(f[-1])] + [1]\n            f.append(g)\n        return f\n", "class Solution:\n  def generate(self, numRows: int) -> list[list[int]]:\n    ans = []\n\n    for i in range(numRows):\n      ans.append([1] * (i + 1))\n\n    for i in range(2, numRows):\n      for j in range(1, len(ans[i]) - 1):\n        ans[i][j] = ans[i - 1][j - 1] + ans[i - 1][j]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 150, "slug": "evaluate-reverse-polish-notation", "solutions": ["import operator\n\n\nclass Solution:\n    def evalRPN(self, tokens: List[str]) -> int:\n        opt = {\n            \"+\": operator.add,\n            \"-\": operator.sub,\n            \"*\": operator.mul,\n            \"/\": operator.truediv,\n        }\n        s = []\n        for token in tokens:\n            if token in opt:\n                s.append(int(opt[token](s.pop(-2), s.pop(-1))))\n            else:\n                s.append(int(token))\n        return s[0]\n", "class Solution:\n  def evalRPN(self, tokens: list[str]) -> int:\n    stack = []\n    op = {\n        '+': lambda a, b: a + b,\n        '-': lambda a, b: a - b,\n        '*': lambda a, b: a * b,\n        '/': lambda a, b: int(a / b),\n    }\n\n    for token in tokens:\n      if token in op:\n        b = stack.pop()\n        a = stack.pop()\n        stack.append(op[token](a, b))\n      else:\n        stack.append(int(token))\n\n    return stack.pop()\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 109, "slug": "convert-sorted-list-to-binary-search-tree", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        def dfs(i: int, j: int) -> Optional[TreeNode]:\n            if i > j:\n                return None\n            mid = (i + j) >> 1\n            l, r = dfs(i, mid - 1), dfs(mid + 1, j)\n            return TreeNode(nums[mid], l, r)\n\n        nums = []\n        while head:\n            nums.append(head.val)\n            head = head.next\n        return dfs(0, len(nums) - 1)\n", "class Solution:\n  def sortedListToBST(self, head: ListNode) -> TreeNode:\n    def findMid(head: ListNode) -> ListNode:\n      prev = None\n      slow = head\n      fast = head\n\n      while fast and fast.next:\n        prev = slow\n        slow = slow.next\n        fast = fast.next.next\n      prev.next = None\n\n      return slow\n\n    if not head:\n      return None\n    if not head.next:\n      return TreeNode(head.val)\n\n    mid = findMid(head)\n    root = TreeNode(mid.val)\n    root.left = self.sortedListToBST(head)\n    root.right = self.sortedListToBST(mid.next)\n    return root\n", "class Solution:\n  def sortedListToBST(self, head: ListNode | None) -> TreeNode | None:\n    arr = []\n\n    # Construct the array.\n    curr = head\n    while curr:\n      arr.append(curr.val)\n      curr = curr.next\n\n    def helper(l: int, r: int) -> TreeNode | None:\n      if l > r:\n        return None\n      m = (l + r) // 2\n      root = TreeNode(arr[m])\n      root.left = helper(l, m - 1)\n      root.right = helper(m + 1, r)\n      return root\n\n    return helper(0, len(arr) - 1)\n", "class Solution:\n  def sortedListToBST(self, head: ListNode | None) -> TreeNode | None:\n    def helper(l: int, r: int) -> TreeNode | None:\n      nonlocal head\n      if l > r:\n        return None\n\n      m = (l + r) // 2\n\n      # Simulate inorder traversal: recursively form the left half.\n      left = helper(l, m - 1)\n\n      # Once the left half is traversed, process the current node.\n      root = TreeNode(head.val)\n      root.left = left\n\n      # Maintain the invariance.\n      head = head.next\n\n      # Simulate inorder traversal: recursively form the right half.\n      root.right = helper(m + 1, r)\n      return root\n\n    return helper(0, self._getLength(head) - 1)\n\n  def _getLength(self, head: ListNode | None) -> int:\n    length = 0\n    curr = head\n    while curr:\n      length += 1\n      curr = curr.next\n    return length\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 198, "slug": "house-robber", "solutions": ["class Solution:\n    def rob(self, nums: List[int]) -> int:\n        @cache\n        def dfs(i: int) -> int:\n            if i >= len(nums):\n                return 0\n            return max(nums[i] + dfs(i + 2), dfs(i + 1))\n\n        return dfs(0)\n", "class Solution:\n  def rob(self, nums: list[int]) -> int:\n    prev1 = 0  # dp[i - 1]\n    prev2 = 0  # dp[i - 2]\n\n    for num in nums:\n      dp = max(prev1, prev2 + num)\n      prev2 = prev1\n      prev1 = dp\n\n    return prev1\n", "class Solution:\n  def rob(self, nums: list[int]) -> int:\n    if not nums:\n      return 0\n    if len(nums) == 1:\n      return nums[0]\n\n    # dp[i]:= max money of robbing nums[0..i]\n    dp = [0] * len(nums)\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n\n    for i in range(2, len(nums)):\n      dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n    return dp[-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 188, "slug": "best-time-to-buy-and-sell-stock-iv", "solutions": ["class Solution:\n    def maxProfit(self, k: int, prices: List[int]) -> int:\n        @cache\n        def dfs(i: int, j: int, k: int) -> int:\n            if i >= len(prices):\n                return 0\n            ans = dfs(i + 1, j, k)\n            if k:\n                ans = max(ans, prices[i] + dfs(i + 1, j, 0))\n            elif j:\n                ans = max(ans, -prices[i] + dfs(i + 1, j - 1, 1))\n            return ans\n\n        return dfs(0, k, 0)\n", "class Solution:\n  def maxProfit(self, k: int, prices: list[int]) -> int:\n    if k >= len(prices) // 2:\n      sell = 0\n      hold = -math.inf\n\n      for price in prices:\n        sell = max(sell, hold + price)\n        hold = max(hold, sell - price)\n\n      return sell\n\n    sell = [0] * (k + 1)\n    hold = [-math.inf] * (k + 1)\n\n    for price in prices:\n      for i in range(k, 0, -1):\n        sell[i] = max(sell[i], hold[i] + price)\n        hold[i] = max(hold[i], sell[i - 1] - price)\n\n    return sell[k]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 161, "slug": "one-edit-distance", "solutions": ["class Solution:\n    def isOneEditDistance(self, s: str, t: str) -> bool:\n        if len(s) < len(t):\n            return self.isOneEditDistance(t, s)\n        m, n = len(s), len(t)\n        if m - n > 1:\n            return False\n        for i, c in enumerate(t):\n            if c != s[i]:\n                return s[i + 1 :] == t[i + 1 :] if m == n else s[i + 1 :] == t[i:]\n        return m == n + 1\n", "class Solution:\n  def isOneEditDistance(self, s: str, t: str) -> bool:\n    m = len(s)\n    n = len(t)\n    if m > n:  # Make sure that |s| <= |t|.\n      return self.isOneEditDistance(t, s)\n\n    for i in range(m):\n      if s[i] != t[i]:\n        if m == n:\n          return s[i + 1:] == t[i + 1:]  # Replace s[i] with t[i].\n        return s[i:] == t[i + 1:]  # Delete t[i].\n\n    return m + 1 == n  # Delete t[-1].\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 173, "slug": "binary-search-tree-iterator", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass BSTIterator:\n    def __init__(self, root: TreeNode):\n        def inorder(root):\n            if root:\n                inorder(root.left)\n                self.vals.append(root.val)\n                inorder(root.right)\n\n        self.cur = 0\n        self.vals = []\n        inorder(root)\n\n    def next(self) -> int:\n        res = self.vals[self.cur]\n        self.cur += 1\n        return res\n\n    def hasNext(self) -> bool:\n        return self.cur < len(self.vals)\n\n\n# Your BSTIterator object will be instantiated and called as such:\n# obj = BSTIterator(root)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()\n", "class BSTIterator:\n  def __init__(self, root: TreeNode | None):\n    self.i = 0\n    self.vals = []\n    self._inorder(root)\n\n  def next(self) -> int:\n    self.i += 1\n    return self.vals[self.i - 1]\n\n  def hasNext(self) -> bool:\n    return self.i < len(self.vals)\n\n  def _inorder(self, root: TreeNode | None) -> None:\n    if not root:\n      return\n    self._inorder(root.left)\n    self.vals.append(root.val)\n    self._inorder(root.right)\n", "class BSTIterator:\n  def __init__(self, root: TreeNode | None):\n    self.stack = []\n    self._pushLeftsUntilNull(root)\n\n  def next(self) -> int:\n    root = self.stack.pop()\n    self._pushLeftsUntilNull(root.right)\n    return root.val\n\n  def hasNext(self) -> bool:\n    return self.stack\n\n  def _pushLeftsUntilNull(self, root: TreeNode | None) -> None:\n    while root:\n      self.stack.append(root)\n      root = root.left\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 133, "slug": "clone-graph", "solutions": ["\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val = 0, neighbors = None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\"\"\"\n\nfrom typing import Optional\n\n\nclass Solution:\n    def cloneGraph(self, node: Optional[\"Node\"]) -> Optional[\"Node\"]:\n        def dfs(node):\n            if node is None:\n                return None\n            if node in g:\n                return g[node]\n            cloned = Node(node.val)\n            g[node] = cloned\n            for nxt in node.neighbors:\n                cloned.neighbors.append(dfs(nxt))\n            return cloned\n\n        g = defaultdict()\n        return dfs(node)\n", "class Solution:\n  def cloneGraph(self, node: 'Node') -> 'Node':\n    if not node:\n      return None\n\n    q = collections.deque([node])\n    map = {node: Node(node.val)}\n\n    while q:\n      u = q.popleft()\n      for v in u.neighbors:\n        if v not in map:\n          map[v] = Node(v.val)\n          q.append(v)\n        map[u].neighbors.append(map[v])\n\n    return map[node]\n", "class Solution:\n  def cloneGraph(self, node: 'Node') -> 'Node':\n    if not node:\n      return None\n    if node in self.map:\n      return self.map[node]\n\n    newNode = Node(node.val, [])\n    self.map[node] = newNode\n\n    for neighbor in node.neighbors:\n      self.map[node].neighbors.append(self.cloneGraph(neighbor))\n\n    return newNode\n\n  map = {}\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 105, "slug": "construct-binary-tree-from-preorder-and-inorder-traversal", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        def dfs(i: int, j: int, n: int) -> Optional[TreeNode]:\n            if n <= 0:\n                return None\n            v = preorder[i]\n            k = d[v]\n            l = dfs(i + 1, j, k - j)\n            r = dfs(i + 1 + k - j, k + 1, n - k + j - 1)\n            return TreeNode(v, l, r)\n\n        d = {v: i for i, v in enumerate(inorder)}\n        return dfs(0, 0, len(preorder))\n", "class Solution:\n  def buildTree(\n      self,\n      preorder: list[int],\n      inorder: list[int],\n  ) -> TreeNode | None:\n    inToIndex = {num: i for i, num in enumerate(inorder)}\n\n    def build(\n        preStart: int,\n        preEnd: int,\n        inStart: int,\n        inEnd: int,\n    ) -> TreeNode | None:\n      if preStart > preEnd:\n        return None\n\n      rootVal = preorder[preStart]\n      rootInIndex = inToIndex[rootVal]\n      leftSize = rootInIndex - inStart\n\n      root = TreeNode(rootVal)\n      root.left = build(preStart + 1, preStart + leftSize,\n                        inStart, rootInIndex - 1)\n      root.right = build(preStart + leftSize + 1,\n                         preEnd, rootInIndex + 1, inEnd)\n      return root\n\n    return build(0, len(preorder) - 1, 0, len(inorder) - 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 197, "slug": "rising-temperature", "solutions": ["import pandas as pd\n\n\ndef rising_temperature(weather: pd.DataFrame) -> pd.DataFrame:\n    weather.sort_values(by=\"recordDate\", inplace=True)\n    return weather[\n        (weather.temperature.diff() > 0) & (weather.recordDate.diff().dt.days == 1)\n    ][[\"id\"]]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 174, "slug": "dungeon-game", "solutions": ["class Solution:\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\n        m, n = len(dungeon), len(dungeon[0])\n        dp = [[inf] * (n + 1) for _ in range(m + 1)]\n        dp[m][n - 1] = dp[m - 1][n] = 1\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j])\n        return dp[0][0]\n", "class Solution:\n  def calculateMinimumHP(self, dungeon: list[list[int]]) -> int:\n    m = len(dungeon)\n    n = len(dungeon[0])\n    dp = [math.inf] * (n + 1)\n    dp[n - 1] = 1\n\n    for i in reversed(range(m)):\n      for j in reversed(range(n)):\n        dp[j] = min(dp[j], dp[j + 1]) - dungeon[i][j]\n        dp[j] = max(dp[j], 1)\n\n    return dp[0]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 190, "slug": "reverse-bits", "solutions": ["class Solution:\n    def reverseBits(self, n: int) -> int:\n        ans = 0\n        for i in range(32):\n            ans |= (n & 1) << (31 - i)\n            n >>= 1\n        return ans\n", "class Solution:\n  def reverseBits(self, n: int) -> int:\n    ans = 0\n\n    for i in range(32):\n      if n >> i & 1:\n        ans |= 1 << 31 - i\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 149, "slug": "max-points-on-a-line", "solutions": ["class Solution:\n    def maxPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        ans = 1\n        for i in range(n):\n            x1, y1 = points[i]\n            for j in range(i + 1, n):\n                x2, y2 = points[j]\n                cnt = 2\n                for k in range(j + 1, n):\n                    x3, y3 = points[k]\n                    a = (y2 - y1) * (x3 - x1)\n                    b = (y3 - y1) * (x2 - x1)\n                    cnt += a == b\n                ans = max(ans, cnt)\n        return ans\n", "class Solution:\n  def maxPoints(self, points: list[list[int]]) -> int:\n    ans = 0\n\n    def gcd(a: int, b: int) -> int:\n      return a if b == 0 else gcd(b, a % b)\n\n    def getSlope(p: list[int], q: list[int]) -> tuple[int, int]:\n      dx = p[0] - q[0]\n      dy = p[1] - q[1]\n      if dx == 0:\n        return (0, p[0])\n      if dy == 0:\n        return (p[1], 0)\n      d = gcd(dx, dy)\n      return (dx // d, dy // d)\n\n    for i, p in enumerate(points):\n      slopeCount = collections.defaultdict(int)\n      samePoints = 1\n      maxPoints = 0  # the maximum number of points with the same slope\n      for j in range(i + 1, len(points)):\n        q = points[j]\n        if p == q:\n          samePoints += 1\n        else:\n          slope = getSlope(p, q)\n          slopeCount[slope] += 1\n          maxPoints = max(maxPoints, slopeCount[slope])\n      ans = max(ans, samePoints + maxPoints)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 180, "slug": "consecutive-numbers", "solutions": ["import pandas as pd\n\n\ndef consecutive_numbers(logs: pd.DataFrame) -> pd.DataFrame:\n    all_the_same = lambda lst: lst.nunique() == 1\n    logs[\"is_consecutive\"] = (\n        logs[\"num\"].rolling(window=3, center=True, min_periods=3).apply(all_the_same)\n    )\n    return (\n        logs.query(\"is_consecutive == 1.0\")[[\"num\"]]\n        .drop_duplicates()\n        .rename(columns={\"num\": \"ConsecutiveNums\"})\n    )\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 141, "slug": "linked-list-cycle", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\n\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        s = set()\n        while head:\n            if head in s:\n                return True\n            s.add(head)\n            head = head.next\n        return False\n", "class Solution:\n  def hasCycle(self, head: ListNode) -> bool:\n    slow = head\n    fast = head\n\n    while fast and fast.next:\n      slow = slow.next\n      fast = fast.next.next\n      if slow == fast:\n        return True\n\n    return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 199, "slug": "binary-tree-right-side-view", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        ans = []\n        if root is None:\n            return ans\n        q = deque([root])\n        while q:\n            ans.append(q[0].val)\n            for _ in range(len(q)):\n                node = q.popleft()\n                if node.right:\n                    q.append(node.right)\n                if node.left:\n                    q.append(node.left)\n        return ans\n", "class Solution:\n  def rightSideView(self, root: TreeNode | None) -> list[int]:\n    ans = []\n\n    def dfs(root: TreeNode | None, depth: int) -> None:\n      if not root:\n        return\n\n      if depth == len(ans):\n        ans.append(root.val)\n      dfs(root.right, depth + 1)\n      dfs(root.left, depth + 1)\n\n    dfs(root, 0)\n    return ans\n", "class Solution:\n  def rightSideView(self, root: TreeNode | None) -> list[int]:\n    if not root:\n      return []\n\n    ans = []\n    q = collections.deque([root])\n\n    while q:\n      size = len(q)\n      for i in range(size):\n        root = q.popleft()\n        if i == size - 1:\n          ans.append(root.val)\n        if root.left:\n          q.append(root.left)\n        if root.right:\n          q.append(root.right)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 138, "slug": "copy-list-with-random-pointer", "solutions": ["\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\n\nclass Solution:\n    def copyRandomList(self, head: \"Optional[Node]\") -> \"Optional[Node]\":\n        d = {}\n        dummy = tail = Node(0)\n        cur = head\n        while cur:\n            node = Node(cur.val)\n            tail.next = node\n            tail = tail.next\n            d[cur] = node\n            cur = cur.next\n        cur = head\n        while cur:\n            d[cur].random = d[cur.random] if cur.random else None\n            cur = cur.next\n        return dummy.next\n", "class Solution:\n  def copyRandomList(self, head: 'Node') -> 'Node':\n    if not head:\n      return None\n    if head in self.map:\n      return self.map[head]\n\n    newNode = Node(head.val)\n    self.map[head] = newNode\n    newNode.next = self.copyRandomList(head.next)\n    newNode.random = self.copyRandomList(head.random)\n    return newNode\n\n  map = {}\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 120, "slug": "triangle", "solutions": ["class Solution:\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\n        n = len(triangle)\n        f = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1):\n                f[i][j] = min(f[i + 1][j], f[i + 1][j + 1]) + triangle[i][j]\n        return f[0][0]\n", "class Solution:\n  def minimumTotal(self, triangle: list[list[int]]) -> int:\n    for i in reversed(range(len(triangle) - 1)):\n      for j in range(i + 1):\n        triangle[i][j] += min(triangle[i + 1][j],\n                              triangle[i + 1][j + 1])\n\n    return triangle[0][0]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 170, "slug": "two-sum-iii-data-structure-design", "solutions": ["class TwoSum:\n\n    def __init__(self):\n        self.cnt = defaultdict(int)\n\n    def add(self, number: int) -> None:\n        self.cnt[number] += 1\n\n    def find(self, value: int) -> bool:\n        for x, v in self.cnt.items():\n            y = value - x\n            if y in self.cnt and (x != y or v > 1):\n                return True\n        return False\n\n\n# Your TwoSum object will be instantiated and called as such:\n# obj = TwoSum()\n# obj.add(number)\n# param_2 = obj.find(value)\n", "class TwoSum:\n  def __init__(self):\n    self.count = collections.Counter()\n\n  def add(self, number: int) -> None:\n    self.count[number] += 1\n\n  def find(self, value: int) -> bool:\n    for key, freq in self.count.items():\n      remain = value - key\n      if key == remain and freq > 1:\n        return True\n      if key != remain and remain in self.count:\n        return True\n\n    return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 134, "slug": "gas-station", "solutions": ["class Solution:\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\n        n = len(gas)\n        i = j = n - 1\n        cnt = s = 0\n        while cnt < n:\n            s += gas[j] - cost[j]\n            cnt += 1\n            j = (j + 1) % n\n            while s < 0 and cnt < n:\n                i -= 1\n                s += gas[i] - cost[i]\n                cnt += 1\n        return -1 if s < 0 else i\n", "class Solution:\n  def canCompleteCircuit(self, gas: list[int], cost: list[int]) -> int:\n    ans = 0\n    net = 0\n    summ = 0\n\n    # Try to start from each index.\n    for i in range(len(gas)):\n      net += gas[i] - cost[i]\n      summ += gas[i] - cost[i]\n      if summ < 0:\n        summ = 0\n        ans = i + 1  # Start from the next index.\n\n    return -1 if net < 0 else ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 127, "slug": "word-ladder", "solutions": ["class Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        words = set(wordList)\n        q = deque([beginWord])\n        ans = 1\n        while q:\n            ans += 1\n            for _ in range(len(q)):\n                s = q.popleft()\n                s = list(s)\n                for i in range(len(s)):\n                    ch = s[i]\n                    for j in range(26):\n                        s[i] = chr(ord('a') + j)\n                        t = ''.join(s)\n                        if t not in words:\n                            continue\n                        if t == endWord:\n                            return ans\n                        q.append(t)\n                        words.remove(t)\n                    s[i] = ch\n        return 0\n", "class Solution:\n  def ladderLength(\n      self,\n      beginWord: str,\n      endWord: str,\n      wordList: list[str],\n  ) -> int:\n    wordSet = set(wordList)\n    if endWord not in wordSet:\n      return 0\n\n    q = collections.deque([beginWord])\n\n    step = 1\n    while q:\n      for _ in range(len(q)):\n        wordList = list(q.popleft())\n        for i, cache in enumerate(wordList):\n          for c in string.ascii_lowercase:\n            wordList[i] = c\n            word = ''.join(wordList)\n            if word == endWord:\n              return step + 1\n            if word in wordSet:\n              q.append(word)\n              wordSet.remove(word)\n          wordList[i] = cache\n      step += 1\n\n    return 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 167, "slug": "two-sum-ii-input-array-is-sorted", "solutions": ["class Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        n = len(numbers)\n        for i in range(n - 1):\n            x = target - numbers[i]\n            j = bisect_left(numbers, x, lo=i + 1)\n            if j < n and numbers[j] == x:\n                return [i + 1, j + 1]\n", "class Solution:\n  def twoSum(self, numbers: list[int], target: int) -> list[int]:\n    l = 0\n    r = len(numbers) - 1\n\n    while l < r:\n      summ = numbers[l] + numbers[r]\n      if summ == target:\n        return [l + 1, r + 1]\n      if summ < target:\n        l += 1\n      else:\n        r -= 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 103, "slug": "binary-tree-zigzag-level-order-traversal", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        ans = []\n        if root is None:\n            return ans\n        q = deque([root])\n        ans = []\n        left = 1\n        while q:\n            t = []\n            for _ in range(len(q)):\n                node = q.popleft()\n                t.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            ans.append(t if left else t[::-1])\n            left ^= 1\n        return ans\n", "class Solution:\n  def zigzagLevelOrder(self, root: TreeNode | None) -> list[list[int]]:\n    if not root:\n      return []\n\n    ans = []\n    dq = collections.deque([root])\n    isLeftToRight = True\n\n    while dq:\n      currLevel = []\n      for _ in range(len(dq)):\n        if isLeftToRight:\n          node = dq.popleft()\n          currLevel.append(node.val)\n          if node.left:\n            dq.append(node.left)\n          if node.right:\n            dq.append(node.right)\n        else:\n          node = dq.pop()\n          currLevel.append(node.val)\n          if node.right:\n            dq.appendleft(node.right)\n          if node.left:\n            dq.appendleft(node.left)\n      ans.append(currLevel)\n      isLeftToRight = not isLeftToRight\n\n    return ans\n", "class Solution:\n  def zigzagLevelOrder(self, root: TreeNode | None) -> list[list[int]]:\n    if not root:\n      return []\n\n    ans = []\n    q = collections.deque([root])\n    isLeftToRight = True\n\n    while q:\n      size = len(q)\n      currLevel = [0] * size\n      for i in range(size):\n        node = q.popleft()\n        index = i if isLeftToRight else size - i - 1\n        currLevel[index] = node.val\n        if node.left:\n          q.append(node.left)\n        if node.right:\n          q.append(node.right)\n      ans.append(currLevel)\n      isLeftToRight = not isLeftToRight\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 146, "slug": "lru-cache", "solutions": ["class Node:\n    def __init__(self, key: int = 0, val: int = 0):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.size = 0\n        self.capacity = capacity\n        self.cache = {}\n        self.head = Node()\n        self.tail = Node()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self.remove_node(node)\n        self.add_to_head(node)\n        return node.val\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            node = self.cache[key]\n            self.remove_node(node)\n            node.val = value\n            self.add_to_head(node)\n        else:\n            node = Node(key, value)\n            self.cache[key] = node\n            self.add_to_head(node)\n            self.size += 1\n            if self.size > self.capacity:\n                node = self.tail.prev\n                self.cache.pop(node.key)\n                self.remove_node(node)\n                self.size -= 1\n\n    def remove_node(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def add_to_head(self, node):\n        node.next = self.head.next\n        node.prev = self.head\n        self.head.next = node\n        node.next.prev = node\n\n\n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)\n", "class Node:\n  def __init__(self, key: int, value: int):\n    self.key = key\n    self.value = value\n    self.prev = None\n    self.next = None\n\n\nclass LRUCache:\n  def __init__(self, capacity: int):\n    self.capacity = capacity\n    self.keyToNode = {}\n    self.head = Node(-1, -1)\n    self.tail = Node(-1, -1)\n    self.join(self.head, self.tail)\n\n  def get(self, key: int) -> int:\n    if key not in self.keyToNode:\n      return -1\n\n    node = self.keyToNode[key]\n    self.remove(node)\n    self.moveToHead(node)\n    return node.value\n\n  def put(self, key: int, value: int) -> None:\n    if key in self.keyToNode:\n      node = self.keyToNode[key]\n      node.value = value\n      self.remove(node)\n      self.moveToHead(node)\n      return\n\n    if len(self.keyToNode) == self.capacity:\n      lastNode = self.tail.prev\n      del self.keyToNode[lastNode.key]\n      self.remove(lastNode)\n\n    self.moveToHead(Node(key, value))\n    self.keyToNode[key] = self.head.next\n\n  def join(self, node1: Node, node2: Node):\n    node1.next = node2\n    node2.prev = node1\n\n  def moveToHead(self, node: Node):\n    self.join(node, self.head.next)\n    self.join(self.head, node)\n\n  def remove(self, node: Node):\n    self.join(node.prev, node.next)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 117, "slug": "populating-next-right-pointers-in-each-node-ii", "solutions": ["\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\"\"\"\n\n\nclass Solution:\n    def connect(self, root: \"Node\") -> \"Node\":\n        if root is None:\n            return root\n        q = deque([root])\n        while q:\n            p = None\n            for _ in range(len(q)):\n                node = q.popleft()\n                if p:\n                    p.next = node\n                p = node\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n        return root\n", "class Solution:\n  def connect(self, root: 'Node') -> 'Node':\n    node = root  # the node that is above the current needling\n\n    while node:\n      dummy = Node(0)  # a dummy node before needling\n      # Needle the children of the node.\n      needle = dummy\n      while node:\n        if node.left:  # Needle the left child.\n          needle.next = node.left\n          needle = needle.next\n        if node.right:  # Needle the right child.\n          needle.next = node.right\n          needle = needle.next\n        node = node.next\n      node = dummy.next  # Move the node to the next level.\n\n    return root\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 119, "slug": "pascals-triangle-ii", "solutions": ["class Solution:\n    def getRow(self, rowIndex: int) -> List[int]:\n        f = [1] * (rowIndex + 1)\n        for i in range(2, rowIndex + 1):\n            for j in range(i - 1, 0, -1):\n                f[j] += f[j - 1]\n        return f\n", "class Solution:\n  def getRow(self, rowIndex: int) -> list[int]:\n    ans = [1] * (rowIndex + 1)\n\n    for i in range(2, rowIndex + 1):\n      for j in range(1, i):\n        ans[i - j] += ans[i - j - 1]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 175, "slug": "combine-two-tables", "solutions": ["import pandas as pd\n\n\ndef combine_two_tables(person: pd.DataFrame, address: pd.DataFrame) -> pd.DataFrame:\n    return pd.merge(left=person, right=address, how=\"left\", on=\"personId\")[\n        [\"firstName\", \"lastName\", \"city\", \"state\"]\n    ]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 104, "slug": "maximum-depth-of-binary-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: TreeNode) -> int:\n        if root is None:\n            return 0\n        l, r = self.maxDepth(root.left), self.maxDepth(root.right)\n        return 1 + max(l, r)\n", "class Solution:\n  def maxDepth(self, root: TreeNode | None) -> int:\n    if not root:\n      return 0\n    return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 186, "slug": "reverse-words-in-a-string-ii", "solutions": ["class Solution:\n    def reverseWords(self, s: List[str]) -> None:\n        def reverse(i: int, j: int):\n            while i < j:\n                s[i], s[j] = s[j], s[i]\n                i, j = i + 1, j - 1\n\n        i, n = 0, len(s)\n        for j, c in enumerate(s):\n            if c == \" \":\n                reverse(i, j - 1)\n                i = j + 1\n            elif j == n - 1:\n                reverse(i, j)\n        reverse(0, n - 1)\n", "class Solution:\n  def reverseWords(self, s: list[str]) -> None:\n    def reverse(l: int, r: int) -> None:\n      while l < r:\n        s[l], s[r] = s[r], s[l]\n        l += 1\n        r -= 1\n\n    def reverseWords(n: int) -> None:\n      i = 0\n      j = 0\n\n      while i < n:\n        while i < j or (i < n and s[i] == ' '):  # Skip the spaces.\n          i += 1\n        while j < i or (j < n and s[j] != ' '):  # Skip the spaces.\n          j += 1\n        reverse(i, j - 1)  # Reverse the word.\n\n    reverse(0, len(s) - 1)  # Reverse the whole string.\n    reverseWords(len(s))  # Reverse each word.\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 130, "slug": "surrounded-regions", "solutions": ["class Solution:\n    def solve(self, board: List[List[str]]) -> None:\n        def dfs(i: int, j: int):\n            if not (0 <= i < m and 0 <= j < n and board[i][j] == \"O\"):\n                return\n            board[i][j] = \".\"\n            for a, b in pairwise((-1, 0, 1, 0, -1)):\n                dfs(i + a, j + b)\n\n        m, n = len(board), len(board[0])\n        for i in range(m):\n            dfs(i, 0)\n            dfs(i, n - 1)\n        for j in range(n):\n            dfs(0, j)\n            dfs(m - 1, j)\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == \".\":\n                    board[i][j] = \"O\"\n                elif board[i][j] == \"O\":\n                    board[i][j] = \"X\"\n", "class Solution:\n  def solve(self, board: list[list[str]]) -> None:\n    if not board:\n      return\n\n    m = len(board)\n    n = len(board[0])\n\n    def dfs(i: int, j: int) -> None:\n      \"\"\"Marks the grids with 'O' that stretch from the four sides to '*'.\"\"\"\n      if i < 0 or i == m or j < 0 or j == n:\n        return\n      if board[i][j] != 'O':\n        return\n      board[i][j] = '*'\n      dfs(i + 1, j)\n      dfs(i - 1, j)\n      dfs(i, j + 1)\n      dfs(i, j - 1)\n\n    for i in range(m):\n      for j in range(n):\n        if i * j == 0 or i == m - 1 or j == n - 1:\n          dfs(i, j)\n\n    for row in board:\n      for i, c in enumerate(row):\n        row[i] = 'O' if c == '*' else 'X'\n", "class Solution:\n  def solve(self, board: list[list[str]]) -> None:\n    if not board:\n      return\n\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(board)\n    n = len(board[0])\n    q = collections.deque()\n\n    for i in range(m):\n      for j in range(n):\n        if i * j == 0 or i == m - 1 or j == n - 1:\n          if board[i][j] == 'O':\n            q.append((i, j))\n            board[i][j] = '*'\n\n    # Mark the grids that stretch from the four sides with '*'.\n    while q:\n      i, j = q.popleft()\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if board[x][y] != 'O':\n          continue\n        q.append((x, y))\n        board[x][y] = '*'\n\n    for row in board:\n      for i, c in enumerate(row):\n        row[i] = 'O' if c == '*' else 'X'\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 110, "slug": "balanced-binary-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\n        def height(root):\n            if root is None:\n                return 0\n            l, r = height(root.left), height(root.right)\n            if l == -1 or r == -1 or abs(l - r) > 1:\n                return -1\n            return 1 + max(l, r)\n\n        return height(root) >= 0\n", "class Solution:\n  def isBalanced(self, root: TreeNode | None) -> bool:\n    def maxDepth(root: TreeNode | None) -> int:\n      \"\"\"Returns the height of root if root is balanced; otherwise, returns -1.\"\"\"\n      if not root:\n        return 0\n\n      left = maxDepth(root.left)\n      if left == -1:\n        return -1\n      right = maxDepth(root.right)\n      if right == -1:\n        return -1\n      if abs(left - right) > 1:\n        return -1\n\n      return 1 + max(maxDepth(root.left), maxDepth(root.right))\n\n    return maxDepth(root) != -1\n", "class Solution:\n  def isBalanced(self, root: TreeNode | None) -> bool:\n    ans = True\n\n    def maxDepth(root: TreeNode | None) -> int:\n      \"\"\"Returns the height of root and sets ans to false if root unbalanced.\"\"\"\n      nonlocal ans\n      if not root or not ans:\n        return 0\n      left = maxDepth(root.left)\n      right = maxDepth(root.right)\n      if abs(left - right) > 1:\n        ans = False\n      return max(left, right) + 1\n\n    maxDepth(root)\n    return ans\n", "class Solution:\n  def isBalanced(self, root: TreeNode | None) -> bool:\n    if not root:\n      return True\n\n    def maxDepth(root: TreeNode | None) -> int:\n      if not root:\n        return 0\n      return 1 + max(maxDepth(root.left), maxDepth(root.right))\n\n    return (abs(maxDepth(root.left) - maxDepth(root.right)) <= 1 and\n            self.isBalanced(root.left) and\n            self.isBalanced(root.right))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 140, "slug": "word-break-ii", "solutions": ["class Trie:\n    def __init__(self):\n        self.children = [None] * 26\n        self.is_end = False\n\n    def insert(self, word):\n        node = self\n        for c in word:\n            idx = ord(c) - ord('a')\n            if node.children[idx] is None:\n                node.children[idx] = Trie()\n            node = node.children[idx]\n        node.is_end = True\n\n    def search(self, word):\n        node = self\n        for c in word:\n            idx = ord(c) - ord('a')\n            if node.children[idx] is None:\n                return False\n            node = node.children[idx]\n        return node.is_end\n\n\nclass Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\n        def dfs(s):\n            if not s:\n                return [[]]\n            res = []\n            for i in range(1, len(s) + 1):\n                if trie.search(s[:i]):\n                    for v in dfs(s[i:]):\n                        res.append([s[:i]] + v)\n            return res\n\n        trie = Trie()\n        for w in wordDict:\n            trie.insert(w)\n        ans = dfs(s)\n        return [' '.join(v) for v in ans]\n", "class Solution:\n  def wordBreak(self, s: str, wordDict: list[str]) -> list[str]:\n    wordSet = set(wordDict)\n\n    @functools.lru_cache(None)\n    def wordBreak(s: str) -> list[str]:\n      ans = []\n\n      # 1 <= len(prefix) < len(s)\n      for i in range(1, len(s)):\n        prefix = s[0:i]\n        suffix = s[i:]\n        if prefix in wordSet:\n          for word in wordBreak(suffix):\n            ans.append(prefix + ' ' + word)\n\n      # `wordSet` contains the whole string s, so don't add any space.\n      if s in wordSet:\n        ans.append(s)\n\n      return ans\n\n    return wordBreak(s)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 155, "slug": "min-stack", "solutions": ["class MinStack:\n    def __init__(self):\n        self.stk1 = []\n        self.stk2 = [inf]\n\n    def push(self, val: int) -> None:\n        self.stk1.append(val)\n        self.stk2.append(min(val, self.stk2[-1]))\n\n    def pop(self) -> None:\n        self.stk1.pop()\n        self.stk2.pop()\n\n    def top(self) -> int:\n        return self.stk1[-1]\n\n    def getMin(self) -> int:\n        return self.stk2[-1]\n\n\n# Your MinStack object will be instantiated and called as such:\n# obj = MinStack()\n# obj.push(val)\n# obj.pop()\n# param_3 = obj.top()\n# param_4 = obj.getMin()\n", "class MinStack:\n  def __init__(self):\n    self.stack = []\n\n  def push(self, x: int) -> None:\n    mn = x if not self.stack else min(self.stack[-1][1], x)\n    self.stack.append([x, mn])\n\n  def pop(self) -> None:\n    self.stack.pop()\n\n  def top(self) -> int:\n    return self.stack[-1][0]\n\n  def getMin(self) -> int:\n    return self.stack[-1][1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 168, "slug": "excel-sheet-column-title", "solutions": ["class Solution:\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = []\n        while columnNumber:\n            columnNumber -= 1\n            res.append(chr(ord('A') + columnNumber % 26))\n            columnNumber //= 26\n        return ''.join(res[::-1])\n", "class Solution:\n  def convertToTitle(self, n: int) -> str:\n    return (self.convertToTitle((n - 1) // 26) + chr(ord('A') + (n - 1) % 26)\n            if n\n            else '')\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 184, "slug": "department-highest-salary", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 178, "slug": "rank-scores", "solutions": ["import pandas as pd\n\n\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\n    # Use the rank method to assign ranks to the scores in descending order with no gaps\n    scores[\"rank\"] = scores[\"score\"].rank(method=\"dense\", ascending=False)\n\n    # Drop id column & Sort the DataFrame by score in descending order\n    result_df = scores.drop(\"id\", axis=1).sort_values(by=\"score\", ascending=False)\n\n    return result_df\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 154, "slug": "find-minimum-in-rotated-sorted-array-ii", "solutions": ["class Solution:\n    def findMin(self, nums: List[int]) -> int:\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) >> 1\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            elif nums[mid] < nums[right]:\n                right = mid\n            else:\n                right -= 1\n        return nums[left]\n", "class Solution:\n  def findMin(self, nums: list[int]) -> int:\n    l = 0\n    r = len(nums) - 1\n\n    while l < r:\n      m = (l + r) // 2\n      if nums[m] == nums[r]:\n        r -= 1\n      elif nums[m] < nums[r]:\n        r = m\n      else:\n        l = m + 1\n\n    return nums[l]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 129, "slug": "sum-root-to-leaf-numbers", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        def dfs(root, s):\n            if root is None:\n                return 0\n            s = s * 10 + root.val\n            if root.left is None and root.right is None:\n                return s\n            return dfs(root.left, s) + dfs(root.right, s)\n\n        return dfs(root, 0)\n", "class Solution:\n  def sumNumbers(self, root: TreeNode | None) -> int:\n    ans = 0\n\n    def dfs(root: TreeNode | None, path: int) -> None:\n      nonlocal ans\n      if not root:\n        return\n      if not root.left and not root.right:\n        ans += path * 10 + root.val\n        return\n\n      dfs(root.left, path * 10 + root.val)\n      dfs(root.right, path * 10 + root.val)\n\n    dfs(root, 0)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 152, "slug": "maximum-product-subarray", "solutions": ["class Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        ans = f = g = nums[0]\n        for x in nums[1:]:\n            ff, gg = f, g\n            f = max(x, ff * x, gg * x)\n            g = min(x, ff * x, gg * x)\n            ans = max(ans, f)\n        return ans\n", "class Solution:\n  def maxProduct(self, nums: list[int]) -> int:\n    ans = nums[0]\n    dpMin = nums[0]  # the minimum so far\n    dpMax = nums[0]  # the maximum so far\n\n    for i in range(1, len(nums)):\n      num = nums[i]\n      prevMin = dpMin  # dpMin[i - 1]\n      prevMax = dpMax  # dpMax[i - 1]\n      if num < 0:\n        dpMin = min(prevMax * num, num)\n        dpMax = max(prevMin * num, num)\n      else:\n        dpMin = min(prevMin * num, num)\n        dpMax = max(prevMax * num, num)\n\n      ans = max(ans, dpMax)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 147, "slug": "insertion-sort-list", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def insertionSortList(self, head: ListNode) -> ListNode:\n        if head is None or head.next is None:\n            return head\n        dummy = ListNode(head.val, head)\n        pre, cur = dummy, head\n        while cur:\n            if pre.val <= cur.val:\n                pre, cur = cur, cur.next\n                continue\n            p = dummy\n            while p.next.val <= cur.val:\n                p = p.next\n            t = cur.next\n            cur.next = p.next\n            p.next = cur\n            pre.next = t\n            cur = t\n        return dummy.next\n", "class Solution:\n  def insertionSortList(self, head: ListNode | None) -> ListNode | None:\n    dummy = ListNode(0)\n    prev = dummy  # the last and thus largest of the sorted list\n\n    while head:  # the current inserting node\n      next = head.next  # Cache the next inserting node.\n      if prev.val >= head.val:\n        prev = dummy  # Move `prev` to the front.\n      while prev.next and prev.next.val < head.val:\n        prev = prev.next\n      head.next = prev.next\n      prev.next = head\n      head = next  # Update the current inserting node.\n\n    return dummy.next\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 135, "slug": "candy", "solutions": ["class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        left = [1] * n\n        right = [1] * n\n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                left[i] = left[i - 1] + 1\n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                right[i] = right[i + 1] + 1\n        return sum(max(a, b) for a, b in zip(left, right))\n", "class Solution:\n  def candy(self, ratings: list[int]) -> int:\n    n = len(ratings)\n\n    ans = 0\n    l = [1] * n\n    r = [1] * n\n\n    for i in range(1, n):\n      if ratings[i] > ratings[i - 1]:\n        l[i] = l[i - 1] + 1\n\n    for i in range(n - 2, -1, -1):\n      if ratings[i] > ratings[i + 1]:\n        r[i] = r[i + 1] + 1\n\n    for a, b in zip(l, r):\n      ans += max(a, b)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 131, "slug": "palindrome-partitioning", "solutions": ["class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        def dfs(i: int):\n            if i == n:\n                ans.append(t[:])\n                return\n            for j in range(i, n):\n                if f[i][j]:\n                    t.append(s[i : j + 1])\n                    dfs(j + 1)\n                    t.pop()\n\n        n = len(s)\n        f = [[True] * n for _ in range(n)]\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                f[i][j] = s[i] == s[j] and f[i + 1][j - 1]\n        ans = []\n        t = []\n        dfs(0)\n        return ans\n", "class Solution:\n  def partition(self, s: str) -> list[list[str]]:\n    ans = []\n\n    def isPalindrome(s: str) -> bool:\n      return s == s[::-1]\n\n    def dfs(s: str, j: int, path: list[str], ans: list[list[str]]) -> None:\n      if j == len(s):\n        ans.append(path)\n        return\n\n      for i in range(j, len(s)):\n        if isPalindrome(s[j: i + 1]):\n          dfs(s, i + 1, path + [s[j: i + 1]], ans)\n\n    dfs(s, 0, [], ans)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 193, "slug": "valid-phone-numbers", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 132, "slug": "palindrome-partitioning-ii", "solutions": ["class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        g = [[True] * n for _ in range(n)]\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                g[i][j] = s[i] == s[j] and g[i + 1][j - 1]\n        f = list(range(n))\n        for i in range(1, n):\n            for j in range(i + 1):\n                if g[j][i]:\n                    f[i] = min(f[i], 1 + f[j - 1] if j else 0)\n        return f[-1]\n", "class Solution:\n  def minCut(self, s: str) -> int:\n    n = len(s)\n    # isPalindrome[i][j] := True if s[i..j] is a palindrome\n    isPalindrome = [[True] * n for _ in range(n)]\n    # dp[i] := the minimum cuts needed for a palindrome partitioning of s[0..i]\n    dp = [n] * n\n\n    for l in range(2, n + 1):\n      i = 0\n      for j in range(l - 1, n):\n        isPalindrome[i][j] = s[i] == s[j] and isPalindrome[i + 1][j - 1]\n        i += 1\n\n    for i in range(n):\n      if isPalindrome[0][i]:\n        dp[i] = 0\n        continue\n\n      # Try all the possible partitions.\n      for j in range(i):\n        if isPalindrome[j + 1][i]:\n          dp[i] = min(dp[i], dp[j] + 1)\n\n    return dp[-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 171, "slug": "excel-sheet-column-number", "solutions": ["class Solution:\n    def titleToNumber(self, columnTitle: str) -> int:\n        ans = 0\n        for c in map(ord, columnTitle):\n            ans = ans * 26 + c - ord(\"A\") + 1\n        return ans\n", "class Solution:\n  def titleToNumber(self, columnTitle: str) -> int:\n    return functools.reduce(lambda subtotal, c:\n                            subtotal * 26 + ord(c) - ord('@'), columnTitle, 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 153, "slug": "find-minimum-in-rotated-sorted-array", "solutions": ["class Solution:\n    def findMin(self, nums: List[int]) -> int:\n        if nums[0] <= nums[-1]:\n            return nums[0]\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) >> 1\n            if nums[0] <= nums[mid]:\n                left = mid + 1\n            else:\n                right = mid\n        return nums[left]\n", "class Solution:\n  def findMin(self, nums: list[int]) -> int:\n    l = 0\n    r = len(nums) - 1\n\n    while l < r:\n      m = (l + r) // 2\n      if nums[m] < nums[r]:\n        r = m\n      else:\n        l = m + 1\n\n    return nums[l]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 165, "slug": "compare-version-numbers", "solutions": ["class Solution:\n    def compareVersion(self, version1: str, version2: str) -> int:\n        m, n = len(version1), len(version2)\n        i = j = 0\n        while i < m or j < n:\n            a = b = 0\n            while i < m and version1[i] != '.':\n                a = a * 10 + int(version1[i])\n                i += 1\n            while j < n and version2[j] != '.':\n                b = b * 10 + int(version2[j])\n                j += 1\n            if a != b:\n                return -1 if a < b else 1\n            i, j = i + 1, j + 1\n        return 0\n", "class Solution:\n  def compareVersion(self, version1: str, version2: str) -> int:\n    levels1 = version1.split('.')\n    levels2 = version2.split('.')\n    length = max(len(levels1), len(levels2))\n\n    for i in range(length):\n      v1 = int(levels1[i]) if i < len(levels1) else 0\n      v2 = int(levels2[i]) if i < len(levels2) else 0\n      if v1 < v2:\n        return -1\n      if v1 > v2:\n        return 1\n\n    return 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 128, "slug": "longest-consecutive-sequence", "solutions": ["class Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        s = set(nums)\n        ans = 0\n        d = defaultdict(int)\n        for x in nums:\n            y = x\n            while y in s:\n                s.remove(y)\n                y += 1\n            d[x] = d[y] + y - x\n            ans = max(ans, d[x])\n        return ans\n", "class Solution:\n  def longestConsecutive(self, nums: list[int]) -> int:\n    ans = 0\n    seen = set(nums)\n\n    for num in seen:\n      # `num` is the start of a sequence.\n      if num - 1 in seen:\n        continue\n      length = 0\n      while num in seen:\n        num += 1\n        length += 1\n      ans = max(ans, length)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 187, "slug": "repeated-dna-sequences", "solutions": ["class Solution:\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\n        cnt = Counter()\n        ans = []\n        for i in range(len(s) - 10 + 1):\n            t = s[i : i + 10]\n            cnt[t] += 1\n            if cnt[t] == 2:\n                ans.append(t)\n        return ans\n", "class Solution:\n  def findRepeatedDnaSequences(self, s: str) -> list[str]:\n    ans = set()\n    seen = set()\n\n    for i in range(len(s) - 9):\n      seq = s[i:i + 10]\n      if seq in seen:\n        ans.add(seq)\n      seen.add(seq)\n\n    return list(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 102, "slug": "binary-tree-level-order-traversal", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        ans = []\n        if root is None:\n            return ans\n        q = deque([root])\n        while q:\n            t = []\n            for _ in range(len(q)):\n                node = q.popleft()\n                t.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            ans.append(t)\n        return ans\n", "class Solution:\n  def levelOrder(self, root: TreeNode | None) -> list[list[int]]:\n    if not root:\n      return []\n\n    ans = []\n    q = collections.deque([root])\n\n    while q:\n      currLevel = []\n      for _ in range(len(q)):\n        node = q.popleft()\n        currLevel.append(node.val)\n        if node.left:\n          q.append(node.left)\n        if node.right:\n          q.append(node.right)\n      ans.append(currLevel)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 185, "slug": "department-top-three-salaries", "solutions": ["import pandas as pd\n\n\ndef top_three_salaries(\n    employee: pd.DataFrame, department: pd.DataFrame\n) -> pd.DataFrame:\n    salary_cutoff = (\n        employee.drop_duplicates([\"salary\", \"departmentId\"])\n        .groupby(\"departmentId\")[\"salary\"]\n        .nlargest(3)\n        .groupby(\"departmentId\")\n        .min()\n    )\n    employee[\"Department\"] = department.set_index(\"id\")[\"name\"][\n        employee[\"departmentId\"]\n    ].values\n    employee[\"cutoff\"] = salary_cutoff[employee[\"departmentId\"]].values\n    return employee[employee[\"salary\"] >= employee[\"cutoff\"]].rename(\n        columns={\"name\": \"Employee\", \"salary\": \"Salary\"}\n    )[[\"Department\", \"Employee\", \"Salary\"]]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 144, "slug": "binary-tree-preorder-traversal", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        def dfs(root):\n            if root is None:\n                return\n            ans.append(root.val)\n            dfs(root.left)\n            dfs(root.right)\n\n        ans = []\n        dfs(root)\n        return ans\n", "class Solution:\n  def preorderTraversal(self, root: TreeNode | None) -> list[int]:\n    if not root:\n      return []\n\n    ans = []\n    stack = [root]\n\n    while stack:\n      node = stack.pop()\n      ans.append(node.val)\n      if node.right:\n        stack.append(node.right)\n      if node.left:\n        stack.append(node.left)\n\n    return ans\n", "class Solution:\n  def preorderTraversal(self, root: TreeNode | None) -> list[int]:\n    ans = []\n\n    def preorder(root: TreeNode | None) -> None:\n      if not root:\n        return\n\n      ans.append(root.val)\n      preorder(root.left)\n      preorder(root.right)\n\n    preorder(root)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 176, "slug": "second-highest-salary", "solutions": ["import pandas as pd\n\n\ndef second_highest_salary(employee: pd.DataFrame) -> pd.DataFrame:\n    # Drop any duplicate salary values to avoid counting duplicates as separate salary ranks\n    unique_salaries = employee[\"salary\"].drop_duplicates()\n\n    # Sort the unique salaries in descending order and get the second highest salary\n    second_highest = (\n        unique_salaries.nlargest(2).iloc[-1] if len(unique_salaries) >= 2 else None\n    )\n\n    # If the second highest salary doesn't exist (e.g., there are fewer than two unique salaries), return None\n    if second_highest is None:\n        return pd.DataFrame({\"SecondHighestSalary\": [None]})\n\n    # Create a DataFrame with the second highest salary\n    result_df = pd.DataFrame({\"SecondHighestSalary\": [second_highest]})\n\n    return result_df\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 182, "slug": "duplicate-emails", "solutions": ["import pandas as pd\n\n\ndef duplicate_emails(person: pd.DataFrame) -> pd.DataFrame:\n    results = pd.DataFrame()\n\n    results = person.loc[person.duplicated(subset=[\"email\"]), [\"email\"]]\n\n    return results.drop_duplicates()\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 183, "slug": "customers-who-never-order", "solutions": ["import pandas as pd\n\n\ndef find_customers(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:\n    # Select the customers whose 'id' is not present in the orders DataFrame's 'customerId' column.\n    df = customers[~customers[\"id\"].isin(orders[\"customerId\"])]\n\n    # Build a DataFrame that only contains the 'name' column and rename it as 'Customers'.\n    df = df[[\"name\"]].rename(columns={\"name\": \"Customers\"})\n\n    return df\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 106, "slug": "construct-binary-tree-from-inorder-and-postorder-traversal", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\n        def dfs(i: int, j: int, n: int) -> Optional[TreeNode]:\n            if n <= 0:\n                return None\n            v = postorder[j + n - 1]\n            k = d[v]\n            l = dfs(i, j, k - i)\n            r = dfs(k + 1, j + k - i, n - k + i - 1)\n            return TreeNode(v, l, r)\n\n        d = {v: i for i, v in enumerate(inorder)}\n        return dfs(0, 0, len(inorder))\n", "class Solution:\n  def buildTree(\n      self,\n      inorder: list[int],\n      postorder: list[int],\n  ) -> TreeNode | None:\n    inToIndex = {num: i for i, num in enumerate(inorder)}\n\n    def build(\n        inStart: int,\n        inEnd: int,\n        postStart: int,\n        postEnd: int,\n    ) -> TreeNode | None:\n      if inStart > inEnd:\n        return None\n\n      rootVal = postorder[postEnd]\n      rootInIndex = inToIndex[rootVal]\n      leftSize = rootInIndex - inStart\n\n      root = TreeNode(rootVal)\n      root.left = build(inStart, rootInIndex - 1,  postStart,\n                        postStart + leftSize - 1)\n      root.right = build(rootInIndex + 1, inEnd,  postStart + leftSize,\n                         postEnd - 1)\n      return root\n\n    return build(0, len(inorder) - 1, 0, len(postorder) - 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 136, "slug": "single-number", "solutions": ["class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        return reduce(xor, nums)\n", "class Solution:\n  def singleNumber(self, nums: list[int]) -> int:\n    return functools.reduce(operator.xor, nums, 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 139, "slug": "word-break", "solutions": ["class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        words = set(wordDict)\n        n = len(s)\n        f = [True] + [False] * n\n        for i in range(1, n + 1):\n            f[i] = any(f[j] and s[j:i] in words for j in range(i))\n        return f[n]\n", "class Solution:\n  def wordBreak(self, s: str, wordDict: list[str]) -> bool:\n    wordSet = set(wordDict)\n\n    @functools.lru_cache(None)\n    def wordBreak(s: str) -> bool:\n      \"\"\"Returns True if s can be segmented.\"\"\"\n      if s in wordSet:\n        return True\n      return any(s[:i] in wordSet and wordBreak(s[i:]) for i in range(len(s)))\n\n    return wordBreak(s)\n", "class Solution:\n  def wordBreak(self, s: str, wordDict: list[str]) -> bool:\n    n = len(s)\n    maxLength = len(max(wordDict, key=len))\n    wordSet = set(wordDict)\n    # dp[i] := True if s[0..i) can be segmented\n    dp = [True] + [False] * n\n\n    for i in range(1, n + 1):\n      for j in reversed(range(i)):\n        if i - j > maxLength:\n          break\n        # s[0..j) can be segmented and s[j..i) is in the wordSet, so s[0..i)\n        # can be segmented.\n        if dp[j] and s[j:i] in wordSet:\n          dp[i] = True\n          break\n\n    return dp[n]\n", "class Solution:\n  def wordBreak(self, s: str, wordDict: list[str]) -> bool:\n    wordSet = set(wordDict)\n\n    @functools.lru_cache(None)\n    def wordBreak(i: int) -> bool:\n      \"\"\"Returns True if s[i..n) can be segmented.\"\"\"\n      if i == len(s):\n        return True\n      return any(s[i: j] in wordSet and wordBreak(j)\n                 for j in range(i + 1, len(s) + 1))\n\n    return wordBreak(0)\n", "class Solution:\n  def wordBreak(self, s: str, wordDict: list[str]) -> bool:\n    n = len(s)\n    wordSet = set(wordDict)\n    # dp[i] := True if s[0..i) can be segmented\n    dp = [True] + [False] * n\n\n    for i in range(1, n + 1):\n      for j in range(i):\n        # s[0..j) can be segmented and s[j..i) is in `wordSet`, so s[0..i) can\n        # be segmented.\n        if dp[j] and s[j:i] in wordSet:\n          dp[i] = True\n          break\n\n    return dp[n]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 126, "slug": "word-ladder-ii", "solutions": ["class Solution:\n    def findLadders(\n        self, beginWord: str, endWord: str, wordList: List[str]\n    ) -> List[List[str]]:\n        def dfs(path, cur):\n            if cur == beginWord:\n                ans.append(path[::-1])\n                return\n            for precursor in prev[cur]:\n                path.append(precursor)\n                dfs(path, precursor)\n                path.pop()\n\n        ans = []\n        words = set(wordList)\n        if endWord not in words:\n            return ans\n        words.discard(beginWord)\n        dist = {beginWord: 0}\n        prev = defaultdict(set)\n        q = deque([beginWord])\n        found = False\n        step = 0\n        while q and not found:\n            step += 1\n            for i in range(len(q), 0, -1):\n                p = q.popleft()\n                s = list(p)\n                for i in range(len(s)):\n                    ch = s[i]\n                    for j in range(26):\n                        s[i] = chr(ord('a') + j)\n                        t = ''.join(s)\n                        if dist.get(t, 0) == step:\n                            prev[t].add(p)\n                        if t not in words:\n                            continue\n                        prev[t].add(p)\n                        words.discard(t)\n                        q.append(t)\n                        dist[t] = step\n                        if endWord == t:\n                            found = True\n                    s[i] = ch\n        if found:\n            path = [endWord]\n            dfs(path, endWord)\n        return ans\n", "class Solution:\n  def findLadders(self, beginWord: str, endWord: str, wordList: list[str]) -> list[list[str]]:\n    wordSet = set(wordList)\n    if endWord not in wordList:\n      return []\n\n    # {\"hit\": [\"hot\"], \"hot\": [\"dot\", \"lot\"], ...}\n    graph: dict[str, list[str]] = collections.defaultdict(list)\n\n    # Build the graph from the beginWord to the endWord.\n    if not self._bfs(beginWord, endWord, wordSet, graph):\n      return []\n\n    ans = []\n\n    self._dfs(graph, beginWord, endWord, [beginWord], ans)\n    return ans\n\n  def _bfs(\n      self,\n      beginWord: str,\n      endWord: str,\n      wordSet: set[str],\n      graph: dict[str, list[str]],\n  ) -> bool:\n    q1 = {beginWord}\n    q2 = {endWord}\n    backward = False\n\n    while q1 and q2:\n      for word in q1:\n        wordSet.discard(word)\n      for word in q2:\n        wordSet.discard(word)\n      # Always expand the smaller queue.\n      if len(q1) > len(q2):\n        q1, q2 = q2, q1\n        backward = not backward\n      q = set()\n      reachEndWord = False\n      for parent in q1:\n        for child in self._getChildren(parent, wordSet, q2):\n          if child in wordSet or child in q2:\n            q.add(child)\n            if backward:\n              graph[child].append(parent)\n            else:\n              graph[parent].append(child)\n          if child in q2:\n            reachEndWord = True\n      if reachEndWord:\n        return True\n      q1 = q\n\n    return False\n\n  def _getChildren(self, parent: str, wordSet: set[str], q2) -> list[str]:\n    children = []\n    s = list(parent)\n\n    for i, cache in enumerate(s):\n      for c in string.ascii_lowercase:\n        if c == cache:\n          continue\n        s[i] = c\n        child = ''.join(s)\n        if child in wordSet or child in q2:\n          children.append(child)\n      s[i] = cache\n\n    return children\n\n  def _dfs(\n      self,\n      graph: dict[str, list[str]],\n      word: str,\n      endWord: str,\n      path: list[str],\n      ans: list[list[str]],\n  ) -> None:\n    if word == endWord:\n      ans.append(path.copy())\n      return\n\n    for child in graph.get(word, []):\n      path.append(child)\n      self._dfs(graph, child, endWord, path, ans)\n      path.pop()\n", "class Solution:\n  def findLadders(self, beginWord: str, endWord: str, wordList: list[str]) -> list[list[str]]:\n    wordSet = set(wordList)\n    if endWord not in wordList:\n      return []\n\n    # {\"hit\": [\"hot\"], \"hot\": [\"dot\", \"lot\"], ...}\n    graph: dict[str, list[str]] = collections.defaultdict(list)\n\n    # Build the graph from the beginWord to the endWord.\n    if not self._bfs(beginWord, endWord, wordSet, graph):\n      return []\n\n    ans = []\n    self._dfs(graph, beginWord, endWord, [beginWord], ans)\n    return ans\n\n  def _bfs(\n      self,\n      beginWord: str,\n      endWord: str,\n      wordSet: set[str],\n      graph: dict[str, list[str]],\n  ) -> bool:\n    currentLevelWords = {beginWord}\n\n    while currentLevelWords:\n      for word in currentLevelWords:\n        wordSet.discard(word)\n      nextLevelWords = set()\n      reachEndWord = False\n      for parent in currentLevelWords:\n        for child in self._getChildren(parent, wordSet):\n          if child in wordSet:\n            nextLevelWords.add(child)\n            graph[parent].append(child)\n          if child == endWord:\n            reachEndWord = True\n      if reachEndWord:\n        return True\n      currentLevelWords = nextLevelWords\n\n    return False\n\n  def _getChildren(self, parent: str, wordSet: set[str]) -> list[str]:\n    children = []\n    s = list(parent)\n\n    for i, cache in enumerate(s):\n      for c in string.ascii_lowercase:\n        if c == cache:\n          continue\n        s[i] = c\n        child = ''.join(s)\n        if child in wordSet:\n          children.append(child)\n      s[i] = cache\n\n    return children\n\n  def _dfs(\n      self,\n      graph: dict[str, list[str]],\n      word: str,\n      endWord: str,\n      path: list[str],\n      ans: list[list[str]],\n  ) -> None:\n    if word == endWord:\n      ans.append(path.copy())\n      return\n\n    for child in graph.get(word, []):\n      path.append(child)\n      self._dfs(graph, child, endWord, path, ans)\n      path.pop()\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 122, "slug": "best-time-to-buy-and-sell-stock-ii", "solutions": ["class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        return sum(max(0, b - a) for a, b in pairwise(prices))\n", "class Solution:\n  def maxProfit(self, prices: list[int]) -> int:\n    sell = 0\n    hold = -math.inf\n\n    for price in prices:\n      sell = max(sell, hold + price)\n      hold = max(hold, sell - price)\n\n    return sell\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 160, "slug": "intersection-of-two-linked-lists", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        a, b = headA, headB\n        while a != b:\n            a = a.next if a else headB\n            b = b.next if b else headA\n        return a\n", "class Solution:\n  def getIntersectionNode(\n      self,\n      headA: ListNode,\n      headB: ListNode,\n  ) -> ListNode | None:\n    a = headA\n    b = headB\n\n    while a != b:\n      a = a.next if a else headB\n      b = b.next if b else headA\n\n    return a\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 169, "slug": "majority-element", "solutions": ["class Solution:\n    def majorityElement(self, nums: List[int]) -> int:\n        cnt = m = 0\n        for x in nums:\n            if cnt == 0:\n                m, cnt = x, 1\n            else:\n                cnt += 1 if m == x else -1\n        return m\n", "class Solution:\n  def majorityElement(self, nums: list[int]) -> int:\n    ans = None\n    count = 0\n\n    for num in nums:\n      if count == 0:\n        ans = num\n      count += (1 if num == ans else -1)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 111, "slug": "minimum-depth-of-binary-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minDepth(self, root: Optional[TreeNode]) -> int:\n        if root is None:\n            return 0\n        if root.left is None:\n            return 1 + self.minDepth(root.right)\n        if root.right is None:\n            return 1 + self.minDepth(root.left)\n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))\n", "class Solution:\n  def minDepth(self, root: TreeNode | None) -> int:\n    if not root:\n      return 0\n\n    q = collections.deque([root])\n\n    step = 1\n    while q:\n      for _ in range(len(q)):\n        node = q.popleft()\n        if not node.left and not node.right:\n          return step\n        if node.left:\n          q.append(node.left)\n        if node.right:\n          q.append(node.right)\n      step += 1\n", "class Solution:\n  def minDepth(self, root: TreeNode | None) -> int:\n    if not root:\n      return 0\n    if not root.left:\n      return self.minDepth(root.right) + 1\n    if not root.right:\n      return self.minDepth(root.left) + 1\n    return min(self.minDepth(root.left), self.minDepth(root.right)) + 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 107, "slug": "binary-tree-level-order-traversal-ii", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        ans = []\n        if root is None:\n            return ans\n        q = deque([root])\n        while q:\n            t = []\n            for _ in range(len(q)):\n                node = q.popleft()\n                t.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            ans.append(t)\n        return ans[::-1]\n", "class Solution:\n  def levelOrderBottom(self, root: TreeNode | None) -> list[list[int]]:\n    if not root:\n      return []\n\n    ans = []\n    q = collections.deque([root])\n\n    while q:\n      currLevel = []\n      for _ in range(len(q)):\n        node = q.popleft()\n        currLevel.append(node.val)\n        if node.left:\n          q.append(node.left)\n        if node.right:\n          q.append(node.right)\n      ans.append(currLevel)\n\n    return ans[::-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 123, "slug": "best-time-to-buy-and-sell-stock-iii", "solutions": ["class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        # \n        f1, f2, f3, f4 = -prices[0], 0, -prices[0], 0\n        for price in prices[1:]:\n            f1 = max(f1, -price)\n            f2 = max(f2, f1 + price)\n            f3 = max(f3, f2 - price)\n            f4 = max(f4, f3 + price)\n        return f4\n", "class Solution:\n  def maxProfit(self, prices: list[int]) -> int:\n    sellTwo = 0\n    holdTwo = -math.inf\n    sellOne = 0\n    holdOne = -math.inf\n\n    for price in prices:\n      sellTwo = max(sellTwo, holdTwo + price)\n      holdTwo = max(holdTwo, sellOne - price)\n      sellOne = max(sellOne, holdOne + price)\n      holdOne = max(holdOne, -price)\n\n    return sellTwo\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 151, "slug": "reverse-words-in-a-string", "solutions": ["class Solution:\n    def reverseWords(self, s: str) -> str:\n        words = []\n        i, n = 0, len(s)\n        while i < n:\n            while i < n and s[i] == \" \":\n                i += 1\n            if i < n:\n                j = i\n                while j < n and s[j] != \" \":\n                    j += 1\n                words.append(s[i:j])\n                i = j\n        return \" \".join(words[::-1])\n", "class Solution:\n  def reverseWords(self, s: str) -> str:\n    return ' '.join(reversed(s.split()))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 179, "slug": "largest-number", "solutions": ["class Solution:\n    def largestNumber(self, nums: List[int]) -> str:\n        nums = [str(v) for v in nums]\n        nums.sort(key=cmp_to_key(lambda a, b: 1 if a + b < b + a else -1))\n        return \"0\" if nums[0] == \"0\" else \"\".join(nums)\n", "class LargerStrKey(str):\n  def __lt__(x: str, y: str) -> bool:\n    return x + y > y + x\n\n\nclass Solution:\n  def largestNumber(self, nums: list[int]) -> str:\n    return ''.join(sorted(map(str, nums), key=LargerStrKey)).lstrip('0') or '0'\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 124, "slug": "binary-tree-maximum-path-sum", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\n        def dfs(root: Optional[TreeNode]) -> int:\n            if root is None:\n                return 0\n            left = max(0, dfs(root.left))\n            right = max(0, dfs(root.right))\n            nonlocal ans\n            ans = max(ans, root.val + left + right)\n            return root.val + max(left, right)\n\n        ans = -inf\n        dfs(root)\n        return ans\n", "class Solution:\n  def maxPathSum(self, root: TreeNode | None) -> int:\n    ans = -math.inf\n\n    def maxPathSumDownFrom(root: TreeNode | None) -> int:\n      \"\"\"\n      Returns the maximum path sum starting from the current root, where\n      root.val is always included.\n      \"\"\"\n      nonlocal ans\n      if not root:\n        return 0\n\n      l = max(0, maxPathSumDownFrom(root.left))\n      r = max(0, maxPathSumDownFrom(root.right))\n      ans = max(ans, root.val + l + r)\n      return root.val + max(l, r)\n\n    maxPathSumDownFrom(root)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 137, "slug": "single-number-ii", "solutions": ["class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        ans = 0\n        for i in range(32):\n            cnt = sum(num >> i & 1 for num in nums)\n            if cnt % 3:\n                if i == 31:\n                    ans -= 1 << i\n                else:\n                    ans |= 1 << i\n        return ans\n", "class Solution:\n  def singleNumber(self, nums: list[int]) -> int:\n    ones = 0\n    twos = 0\n\n    for num in nums:\n      ones ^= (num & ~twos)\n      twos ^= (num & ~ones)\n\n    return ones\n", "class Solution:\n  def singleNumber(self, nums: list[int]) -> int:\n    ones = 0\n    twos = 0\n\n    for num in nums:\n      ones ^= num & ~twos\n      twos ^= num & ~ones\n\n    return ones\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 148, "slug": "sort-list", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head is None or head.next is None:\n            return head\n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        l1, l2 = head, slow.next\n        slow.next = None\n        l1, l2 = self.sortList(l1), self.sortList(l2)\n        dummy = ListNode()\n        tail = dummy\n        while l1 and l2:\n            if l1.val <= l2.val:\n                tail.next = l1\n                l1 = l1.next\n            else:\n                tail.next = l2\n                l2 = l2.next\n            tail = tail.next\n        tail.next = l1 or l2\n        return dummy.next\n", "class Solution:\n  def sortList(self, head: ListNode) -> ListNode:\n    def split(head: ListNode, k: int) -> ListNode:\n      while k > 1 and head:\n        head = head.next\n        k -= 1\n      rest = head.next if head else None\n      if head:\n        head.next = None\n      return rest\n\n    def merge(l1: ListNode, l2: ListNode) -> tuple:\n      dummy = ListNode(0)\n      tail = dummy\n\n      while l1 and l2:\n        if l1.val > l2.val:\n          l1, l2 = l2, l1\n        tail.next = l1\n        l1 = l1.next\n        tail = tail.next\n      tail.next = l1 if l1 else l2\n      while tail.next:\n        tail = tail.next\n\n      return dummy.next, tail\n\n    length = 0\n    curr = head\n    while curr:\n      length += 1\n      curr = curr.next\n\n    dummy = ListNode(0, head)\n\n    k = 1\n    while k < length:\n      curr = dummy.next\n      tail = dummy\n      while curr:\n        l = curr\n        r = split(l, k)\n        curr = split(r, k)\n        mergedHead, mergedTail = merge(l, r)\n        tail.next = mergedHead\n        tail = mergedTail\n      k *= 2\n\n    return dummy.next\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 157, "slug": "read-n-characters-given-read4", "solutions": ["\"\"\"\nThe read4 API is already defined for you.\n\n    @param buf4, a list of characters\n    @return an integer\n    def read4(buf4):\n\n# Below is an example of how the read4 API can be called.\nfile = File(\"abcdefghijk\") # File is \"abcdefghijk\", initially file pointer (fp) points to 'a'\nbuf4 = [' '] * 4 # Create buffer with enough space to store characters\nread4(buf4) # read4 returns 4. Now buf = ['a','b','c','d'], fp points to 'e'\nread4(buf4) # read4 returns 4. Now buf = ['e','f','g','h'], fp points to 'i'\nread4(buf4) # read4 returns 3. Now buf = ['i','j','k',...], fp points to end of file\n\"\"\"\n\n\nclass Solution:\n    def read(self, buf, n):\n        \"\"\"\n        :type buf: Destination buffer (List[str])\n        :type n: Number of characters to read (int)\n        :rtype: The number of actual characters read (int)\n        \"\"\"\n        i = 0\n        buf4 = [0] * 4\n        v = 5\n        while v >= 4:\n            v = read4(buf4)\n            for j in range(v):\n                buf[i] = buf4[j]\n                i += 1\n                if i >= n:\n                    return n\n        return i\n", "\"\"\"\nThe read4 API is already defined for you.\n  def read4(buf4: list[str]) -> int:\n\n# Below is an example of how the read4 API can be called.\nfile = File(\"abcdefghijk\") # File is \"abcdefghijk\", initially file pointer (fp) points to 'a'\nbuf4 = [' '] * 4 # Create buffer with enough space to store characters\nread4(buf4) # Read4 returns 4. Now buf = ['a','b','c','d'], fp points to 'e'\nread4(buf4) # Read4 returns 4. Now buf = ['e','f','g','h'], fp points to 'i'\nread4(buf4) # Read4 returns 3. Now buf = ['i','j','k',...], fp points to end of file\n\"\"\"\n\n\nclass Solution:\n  def read(self, buf: list[str], n: int) -> int:\n    buf4 = [' '] * 4\n    i4 = 0  # buf4's index\n    n4 = 0  # buf4's size\n    i = 0  # buf's index\n\n    while i < n:\n      if i4 == n4:  # All the characters in the buf4 are consumed.\n        i4 = 0  # Reset the buf4's index.\n        n4 = read4(buf4)  # Read <= 4 characters from the file to the buf4.\n        if n4 == 0:  # Reach the EOF.\n          return i\n      buf[i] = buf4[i4]\n      i += 1\n      i4 += 1\n\n    return i\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 108, "slug": "convert-sorted-array-to-binary-search-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:\n        def dfs(l: int, r: int) -> Optional[TreeNode]:\n            if l > r:\n                return None\n            mid = (l + r) >> 1\n            return TreeNode(nums[mid], dfs(l, mid - 1), dfs(mid + 1, r))\n\n        return dfs(0, len(nums) - 1)\n", "class Solution:\n  def sortedArrayToBST(self, nums: list[int]) -> TreeNode | None:\n    def build(l: int, r: int) -> TreeNode | None:\n      if l > r:\n        return None\n      m = (l + r) // 2\n      return TreeNode(nums[m],\n                      build(l, m - 1),\n                      build(m + 1, r))\n\n    return build(0, len(nums) - 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 177, "slug": "nth-highest-salary", "solutions": ["import pandas as pd\n\n\ndef nth_highest_salary(employee: pd.DataFrame, N: int) -> pd.DataFrame:\n    unique_salaries = employee.salary.unique()\n    if len(unique_salaries) < N:\n        return pd.DataFrame([np.NaN], columns=[f\"getNthHighestSalary({N})\"])\n    else:\n        salary = sorted(unique_salaries, reverse=True)[N - 1]\n        return pd.DataFrame([salary], columns=[f\"getNthHighestSalary({N})\"])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 121, "slug": "best-time-to-buy-and-sell-stock", "solutions": ["class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        ans, mi = 0, inf\n        for v in prices:\n            ans = max(ans, v - mi)\n            mi = min(mi, v)\n        return ans\n", "class Solution:\n  def maxProfit(self, prices: list[int]) -> int:\n    sellOne = 0\n    holdOne = -math.inf\n\n    for price in prices:\n      sellOne = max(sellOne, holdOne + price)\n      holdOne = max(holdOne, -price)\n\n    return sellOne\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 114, "slug": "flatten-binary-tree-to-linked-list", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def flatten(self, root: Optional[TreeNode]) -> None:\n        \"\"\"\n        Do not return anything, modify root in-place instead.\n        \"\"\"\n        while root:\n            if root.left:\n                pre = root.left\n                while pre.right:\n                    pre = pre.right\n                pre.right = root.right\n                root.right = root.left\n                root.left = None\n            root = root.right\n", "class Solution:\n  def flatten(self, root: TreeNode | None) -> None:\n    if not root:\n      return\n\n    self.flatten(root.left)\n    self.flatten(root.right)\n\n    left = root.left  # flattened left\n    right = root.right  # flattened right\n\n    root.left = None\n    root.right = left\n\n    # Connect the original right subtree to the end of the new right subtree.\n    rightmost = root\n    while rightmost.right:\n      rightmost = rightmost.right\n    rightmost.right = right\n", "class Solution:\n  def flatten(self, root: TreeNode | None) -> None:\n    if not root:\n      return\n\n    while root:\n      if root.left:\n        # Find the rightmost root\n        rightmost = root.left\n        while rightmost.right:\n          rightmost = rightmost.right\n        # Rewire the connections\n        rightmost.right = root.right\n        root.right = root.left\n        root.left = None\n      # Move on to the right side of the tree\n      root = root.right\n", "class Solution:\n  def flatten(self, root: TreeNode | None) -> None:\n    if not root:\n      return\n\n    stack = [root]\n\n    while stack:\n      root = stack.pop()\n      if root.right:\n        stack.append(root.right)\n      if root.left:\n        stack.append(root.left)\n      if stack:\n        root.right = stack[-1]\n      root.left = None\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 192, "slug": "word-frequency", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 158, "slug": "read-n-characters-given-read4-ii-call-multiple-times", "solutions": ["# The read4 API is already defined for you.\n# def read4(buf4: List[str]) -> int:\n\n\nclass Solution:\n    def __init__(self):\n        self.buf4 = [None] * 4\n        self.i = self.size = 0\n\n    def read(self, buf: List[str], n: int) -> int:\n        j = 0\n        while j < n:\n            if self.i == self.size:\n                self.size = read4(self.buf4)\n                self.i = 0\n                if self.size == 0:\n                    break\n            while j < n and self.i < self.size:\n                buf[j] = self.buf4[self.i]\n                self.i += 1\n                j += 1\n        return j\n", "# The read4 API is already defined for you.\n# Def read4(buf4: list[str]) -> int:\n\nclass Solution:\n  def read(self, buf: list[str], n: int) -> int:\n    i = 0  # buf's index\n\n    while i < n:\n      if self.i4 == self.n4:  # All the characters in the buf4 are consumed.\n        self.i4 = 0  # Reset the buf4's index.\n        # Read <= 4 characters from the file to the buf4.\n        self.n4 = read4(self.buf4)\n        if self.n4 == 0:  # Reach the EOF.\n          return i\n      buf[i] = self.buf4[self.i4]\n      i += 1\n      self.i4 += 1\n\n    return i\n\n  buf4 = [' '] * 4\n  i4 = 0  # buf4's index\n  n4 = 0  # buf4's size\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 195, "slug": "tenth-line", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 145, "slug": "binary-tree-postorder-traversal", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        def dfs(root):\n            if root is None:\n                return\n            dfs(root.left)\n            dfs(root.right)\n            ans.append(root.val)\n\n        ans = []\n        dfs(root)\n        return ans\n", "class Solution:\n  def postorderTraversal(self, root: TreeNode | None) -> list[int]:\n    if not root:\n      return []\n\n    ans = []\n    stack = [root]\n\n    while stack:\n      node = stack.pop()\n      ans.append(node.val)\n      if node.left:\n        stack.append(node.left)\n      if node.right:\n        stack.append(node.right)\n\n    return ans[::-1]\n", "class Solution:\n  def postorderTraversal(self, root: TreeNode | None) -> list[int]:\n    ans = []\n\n    def postorder(root: TreeNode | None) -> None:\n      if not root:\n        return\n\n      postorder(root.left)\n      postorder(root.right)\n      ans.append(root.val)\n\n    postorder(root)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 162, "slug": "find-peak-element", "solutions": ["class Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) >> 1\n            if nums[mid] > nums[mid + 1]:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n", "class Solution:\n  def findPeakElement(self, nums: list[int]) -> int:\n    l = 0\n    r = len(nums) - 1\n\n    while l < r:\n      m = (l + r) // 2\n      if nums[m] >= nums[m + 1]:\n        r = m\n      else:\n        l = m + 1\n\n    return l\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 143, "slug": "reorder-list", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reorderList(self, head: Optional[ListNode]) -> None:\n        fast = slow = head\n        while fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        cur = slow.next\n        slow.next = None\n\n        pre = None\n        while cur:\n            t = cur.next\n            cur.next = pre\n            pre, cur = cur, t\n        cur = head\n\n        while pre:\n            t = pre.next\n            pre.next = cur.next\n            cur.next = pre\n            cur, pre = pre.next, t\n", "class Solution:\n  def reorderList(self, head: ListNode) -> None:\n    def findMid(head: ListNode):\n      prev = None\n      slow = head\n      fast = head\n\n      while fast and fast.next:\n        prev = slow\n        slow = slow.next\n        fast = fast.next.next\n      prev.next = None\n\n      return slow\n\n    def reverse(head: ListNode) -> ListNode:\n      prev = None\n      curr = head\n\n      while curr:\n        next = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next\n\n      return prev\n\n    def merge(l1: ListNode, l2: ListNode) -> None:\n      while l2:\n        next = l1.next\n        l1.next = l2\n        l1 = l2\n        l2 = next\n\n    if not head or not head.next:\n      return\n\n    mid = findMid(head)\n    reversed = reverse(mid)\n    merge(head, reversed)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 181, "slug": "employees-earning-more-than-their-managers", "solutions": ["import pandas as pd\n\n\ndef find_employees(employee: pd.DataFrame) -> pd.DataFrame:\n    merged = employee.merge(\n        employee, left_on=\"managerId\", right_on=\"id\", suffixes=(\"\", \"_manager\")\n    )\n    result = merged[merged[\"salary\"] > merged[\"salary_manager\"]][[\"name\"]]\n    result.columns = [\"Employee\"]\n    return result\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 125, "slug": "valid-palindrome", "solutions": ["class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        i, j = 0, len(s) - 1\n        while i < j:\n            if not s[i].isalnum():\n                i += 1\n            elif not s[j].isalnum():\n                j -= 1\n            elif s[i].lower() != s[j].lower():\n                return False\n            else:\n                i, j = i + 1, j - 1\n        return True\n", "class Solution:\n  def isPalindrome(self, s: str) -> bool:\n    l = 0\n    r = len(s) - 1\n\n    while l < r:\n      while l < r and not s[l].isalnum():\n        l += 1\n      while l < r and not s[r].isalnum():\n        r -= 1\n      if s[l].lower() != s[r].lower():\n        return False\n      l += 1\n      r -= 1\n\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 164, "slug": "maximum-gap", "solutions": ["class Solution:\n    def maximumGap(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n < 2:\n            return 0\n        mi, mx = min(nums), max(nums)\n        bucket_size = max(1, (mx - mi) // (n - 1))\n        bucket_count = (mx - mi) // bucket_size + 1\n        buckets = [[inf, -inf] for _ in range(bucket_count)]\n        for v in nums:\n            i = (v - mi) // bucket_size\n            buckets[i][0] = min(buckets[i][0], v)\n            buckets[i][1] = max(buckets[i][1], v)\n        ans = 0\n        prev = inf\n        for curmin, curmax in buckets:\n            if curmin > curmax:\n                continue\n            ans = max(ans, curmin - prev)\n            prev = curmax\n        return ans\n", "class Bucket:\n  def __init__(self, mn: int, mx: int):\n    self.mn = mn\n    self.mx = mx\n\n\nclass Solution:\n  def maximumGap(self, nums: list[int]) -> int:\n    if len(nums) < 2:\n      return 0\n\n    mn = min(nums)\n    mx = max(nums)\n    if mn == mx:\n      return 0\n\n    gap = math.ceil((mx - mn) / (len(nums) - 1))\n    bucketSize = (mx - mn) // gap + 1\n    buckets = [Bucket(math.inf, -math.inf) for _ in range(bucketSize)]\n\n    for num in nums:\n      i = (num - mn) // gap\n      buckets[i].mn = min(buckets[i].mn, num)\n      buckets[i].mx = max(buckets[i].mx, num)\n\n    ans = 0\n    prevMax = mn\n\n    for bucket in buckets:\n      if bucket.mn == math.inf:\n        continue  # empty bucket\n      ans = max(ans, bucket.mn - prevMax)\n      prevMax = bucket.mx\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 156, "slug": "binary-tree-upside-down", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def upsideDownBinaryTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        if root is None or root.left is None:\n            return root\n        new_root = self.upsideDownBinaryTree(root.left)\n        root.left.right = root\n        root.left.left = root.right\n        root.left = None\n        root.right = None\n        return new_root\n", "class Solution:\n  def upsideDownBinaryTree(self, root: TreeNode | None) -> TreeNode | None:\n    prevRoot = None\n    prevRightChild = None\n\n    while root:\n      nextRoot = root.left  # Cache the next root.\n      root.left = prevRightChild\n      prevRightChild = root.right\n      root.right = prevRoot\n      prevRoot = root  # Record the previous root.\n      root = nextRoot  # Update the root.\n\n    return prevRoot\n", "class Solution:\n  def upsideDownBinaryTree(self, root: TreeNode | None) -> TreeNode | None:\n    if not root or not root.left:\n      return root\n\n    newRoot = self.upsideDownBinaryTree(root.left)\n    root.left.left = root.right  # 2's left = 3 (root's right)\n    root.left.right = root  # 2's right = 1 (root)\n    root.left = None\n    root.right = None\n    return newRoot\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 191, "slug": "number-of-1-bits", "solutions": ["class Solution:\n    def hammingWeight(self, n: int) -> int:\n        ans = 0\n        while n:\n            n &= n - 1\n            ans += 1\n        return ans\n", "class Solution:\n  def hammingWeight(self, n: int) -> int:\n    ans = 0\n\n    for i in range(32):\n      if (n >> i) & 1:\n        ans += 1\n\n    return ans\n", "class Solution:\n  def hammingWeight(self, n: int) -> int:\n    return n.bit_count()\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 163, "slug": "missing-ranges", "solutions": ["class Solution:\n    def findMissingRanges(\n        self, nums: List[int], lower: int, upper: int\n    ) -> List[List[int]]:\n        n = len(nums)\n        if n == 0:\n            return [[lower, upper]]\n        ans = []\n        if nums[0] > lower:\n            ans.append([lower, nums[0] - 1])\n        for a, b in pairwise(nums):\n            if b - a > 1:\n                ans.append([a + 1, b - 1])\n        if nums[-1] < upper:\n            ans.append([nums[-1] + 1, upper])\n        return ans\n", "class Solution:\n  def findMissingRanges(\n      self,\n      nums: list[int],\n      lower: int,\n      upper: int,\n  ) -> list[list[int]]:\n    def getRange(lo: int, hi: int) -> list[int]:\n      if lo == hi:\n        return [lo, lo]\n      return [lo, hi]\n\n    if not nums:\n      return [getRange(lower, upper)]\n\n    ans = []\n\n    if nums[0] > lower:\n      ans.append(getRange(lower, nums[0] - 1))\n\n    for prev, curr in zip(nums, nums[1:]):\n      if curr > prev + 1:\n        ans.append(getRange(prev + 1, curr - 1))\n\n    if nums[-1] < upper:\n      ans.append(getRange(nums[-1] + 1, upper))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 101, "slug": "symmetric-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\n        def dfs(root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:\n            if root1 == root2:\n                return True\n            if root1 is None or root2 is None or root1.val != root2.val:\n                return False\n            return dfs(root1.left, root2.right) and dfs(root1.right, root2.left)\n\n        return dfs(root.left, root.right)\n", "class Solution:\n  def isSymmetric(self, root: TreeNode | None) -> bool:\n    def isSymmetric(p: TreeNode | None, q: TreeNode | None) -> bool:\n      if not p or not q:\n        return p == q\n      return (p.val == q.val and\n              isSymmetric(p.left, q.right) and\n              isSymmetric(p.right, q.left))\n\n    return isSymmetric(root, root)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 100, "slug": "same-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p == q:\n            return True\n        if p is None or q is None or p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n", "class Solution:\n  def isSameTree(self, p: TreeNode | None, q: TreeNode | None) -> bool:\n    if not p or not q:\n      return p == q\n    return (p.val == q.val and\n            self.isSameTree(p.left, q.left) and\n            self.isSameTree(p.right, q.right))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 166, "slug": "fraction-to-recurring-decimal", "solutions": ["class Solution:\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\n        if numerator == 0:\n            return \"0\"\n        ans = []\n        neg = (numerator > 0) ^ (denominator > 0)\n        if neg:\n            ans.append(\"-\")\n        a, b = abs(numerator), abs(denominator)\n        ans.append(str(a // b))\n        a %= b\n        if a == 0:\n            return \"\".join(ans)\n        ans.append(\".\")\n        d = {}\n        while a:\n            d[a] = len(ans)\n            a *= 10\n            ans.append(str(a // b))\n            a %= b\n            if a in d:\n                ans.insert(d[a], \"(\")\n                ans.append(\")\")\n                break\n        return \"\".join(ans)\n", "class Solution:\n  def fractionToDecimal(self, numerator: int, denominator: int) -> str:\n    if numerator == 0:\n      return '0'\n\n    ans = ''\n\n    if (numerator < 0) ^ (denominator < 0):\n      ans += '-'\n\n    numerator = abs(numerator)\n    denominator = abs(denominator)\n    ans += str(numerator // denominator)\n\n    if numerator % denominator == 0:\n      return ans\n\n    ans += '.'\n    dict = {}\n\n    remainder = numerator % denominator\n    while remainder:\n      if remainder in dict:\n        ans = ans[:dict[remainder]] + '(' + ans[dict[remainder]:] + ')'\n        break\n      dict[remainder] = len(ans)\n      remainder *= 10\n      ans += str(remainder // denominator)\n      remainder %= denominator\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 113, "slug": "path-sum-ii", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:\n        def dfs(root, s):\n            if root is None:\n                return\n            s += root.val\n            t.append(root.val)\n            if root.left is None and root.right is None and s == targetSum:\n                ans.append(t[:])\n            dfs(root.left, s)\n            dfs(root.right, s)\n            t.pop()\n\n        ans = []\n        t = []\n        dfs(root, 0)\n        return ans\n", "class Solution:\n  def pathSum(self, root: TreeNode, summ: int) -> list[list[int]]:\n    ans = []\n\n    def dfs(root: TreeNode, summ: int, path: list[int]) -> None:\n      if not root:\n        return\n      if root.val == summ and not root.left and not root.right:\n        ans.append(path + [root.val])\n        return\n\n      dfs(root.left, summ - root.val, path + [root.val])\n      dfs(root.right, summ - root.val, path + [root.val])\n\n    dfs(root, summ, [])\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 159, "slug": "longest-substring-with-at-most-two-distinct-characters", "solutions": ["class Solution:\n    def lengthOfLongestSubstringTwoDistinct(self, s: str) -> int:\n        cnt = Counter()\n        ans = j = 0\n        for i, c in enumerate(s):\n            cnt[c] += 1\n            while len(cnt) > 2:\n                cnt[s[j]] -= 1\n                if cnt[s[j]] == 0:\n                    cnt.pop(s[j])\n                j += 1\n            ans = max(ans, i - j + 1)\n        return ans\n", "class Solution:\n  def lengthOfLongestSubstringTwoDistinct(self, s: str) -> int:\n    ans = 0\n    distinct = 0\n    count = [0] * 128\n\n    l = 0\n    for r, c in enumerate(s):\n      count[ord(c)] += 1\n      if count[ord(c)] == 1:\n        distinct += 1\n      while distinct == 3:\n        count[ord(s[l])] -= 1\n        if count[ord(s[l])] == 0:\n          distinct -= 1\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 189, "slug": "rotate-array", "solutions": ["class Solution:\n    def rotate(self, nums: List[int], k: int) -> None:\n        def reverse(i: int, j: int):\n            while i < j:\n                nums[i], nums[j] = nums[j], nums[i]\n                i, j = i + 1, j - 1\n\n        n = len(nums)\n        k %= n\n        reverse(0, n - 1)\n        reverse(0, k - 1)\n        reverse(k, n - 1)\n", "class Solution:\n  def rotate(self, nums: list[int], k: int) -> None:\n    k %= len(nums)\n    self.reverse(nums, 0, len(nums) - 1)\n    self.reverse(nums, 0, k - 1)\n    self.reverse(nums, k, len(nums) - 1)\n\n  def reverse(self, nums: list[int], l: int, r: int) -> None:\n    while l < r:\n      nums[l], nums[r] = nums[r], nums[l]\n      l += 1\n      r -= 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 196, "slug": "delete-duplicate-emails", "solutions": ["import pandas as pd\n\n\n# Modify Person in place\ndef delete_duplicate_emails(person: pd.DataFrame) -> None:\n    # Sort the rows based on id (Ascending order)\n    person.sort_values(by=\"id\", ascending=True, inplace=True)\n    # Drop the duplicates based on email.\n    person.drop_duplicates(subset=\"email\", keep=\"first\", inplace=True)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 172, "slug": "factorial-trailing-zeroes", "solutions": ["class Solution:\n    def trailingZeroes(self, n: int) -> int:\n        ans = 0\n        while n:\n            n //= 5\n            ans += n\n        return ans\n", "class Solution:\n  def trailingZeroes(self, n: int) -> int:\n    return 0 if n == 0 else n // 5 + self.trailingZeroes(n // 5)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 194, "slug": "transpose-file", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 116, "slug": "populating-next-right-pointers-in-each-node", "solutions": ["\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\"\"\"\n\n\nclass Solution:\n    def connect(self, root: \"Optional[Node]\") -> \"Optional[Node]\":\n        if root is None:\n            return root\n        q = deque([root])\n        while q:\n            p = None\n            for _ in range(len(q)):\n                node = q.popleft()\n                if p:\n                    p.next = node\n                p = node\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n        return root\n", "class Solution:\n  def connect(self, root: 'Node') -> 'Node':\n    node = root  # the node that is above the current needling\n\n    while node and node.left:\n      dummy = Node(0)  # a dummy node before needling\n      # Needle the children of the node.\n      needle = dummy\n      while node:\n        needle.next = node.left\n        needle = needle.next\n        needle.next = node.right\n        needle = needle.next\n        node = node.next\n      node = dummy.next  # Move the node to the next level.\n\n    return root\n", "class Solution:\n  def connect(self, root: 'Node | None') -> 'Node | None':\n    if not root:\n      return None\n\n    def connectTwoNodes(p, q) -> None:\n      if not p:\n        return\n      p.next = q\n      connectTwoNodes(p.left, p.right)\n      connectTwoNodes(q.left, q.right)\n      connectTwoNodes(p.right, q.left)\n\n    connectTwoNodes(root.left, root.right)\n    return root\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 115, "slug": "distinct-subsequences", "solutions": ["class Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n        m, n = len(s), len(t)\n        f = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            f[i][0] = 1\n        for i, a in enumerate(s, 1):\n            for j, b in enumerate(t, 1):\n                f[i][j] = f[i - 1][j]\n                if a == b:\n                    f[i][j] += f[i - 1][j - 1]\n        return f[m][n]\n", "class Solution:\n  def numDistinct(self, s: str, t: str) -> int:\n    m = len(s)\n    n = len(t)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n      dp[i][0] = 1\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        if s[i - 1] == t[j - 1]:\n          dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n        else:\n          dp[i][j] = dp[i - 1][j]\n\n    return dp[m][n]\n", "class Solution:\n  def numDistinct(self, s: str, t: str) -> int:\n    m = len(s)\n    n = len(t)\n    dp = [1] + [0] * n\n\n    for i in range(1, m + 1):\n      for j in range(n, 1 - 1, -1):\n        if s[i - 1] == t[j - 1]:\n          dp[j] += dp[j - 1]\n\n    return dp[n]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 112, "slug": "path-sum", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\n        def dfs(root, s):\n            if root is None:\n                return False\n            s += root.val\n            if root.left is None and root.right is None and s == targetSum:\n                return True\n            return dfs(root.left, s) or dfs(root.right, s)\n\n        return dfs(root, 0)\n", "class Solution:\n  def hasPathSum(self, root: TreeNode, summ: int) -> bool:\n    if not root:\n      return False\n    if root.val == summ and not root.left and not root.right:\n      return True\n    return (self.hasPathSum(root.left, summ - root.val) or\n            self.hasPathSum(root.right, summ - root.val))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1167, "slug": "minimum-cost-to-connect-sticks", "solutions": ["class Solution:\n    def connectSticks(self, sticks: List[int]) -> int:\n        heapify(sticks)\n        ans = 0\n        while len(sticks) > 1:\n            z = heappop(sticks) + heappop(sticks)\n            ans += z\n            heappush(sticks, z)\n        return ans\n", "class Solution:\n  def connectSticks(self, sticks: list[int]) -> int:\n    ans = 0\n    heapq.heapify(sticks)\n\n    while len(sticks) > 1:\n      x = heapq.heappop(sticks)\n      y = heapq.heappop(sticks)\n      ans += x + y\n      heapq.heappush(sticks, x + y)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1122, "slug": "relative-sort-array", "solutions": ["class Solution:\n    def relativeSortArray(self, arr1: List[int], arr2: List[int]) -> List[int]:\n        pos = {x: i for i, x in enumerate(arr2)}\n        return sorted(arr1, key=lambda x: pos.get(x, 1000 + x))\n", "class Solution:\n  def relativeSortArray(self, arr1: list[int], arr2: list[int]) -> list[int]:\n    ans = []\n    count = [0] * 1001\n\n    for a in arr1:\n      count[a] += 1\n\n    for a in arr2:\n      while count[a] > 0:\n        ans.append(a)\n        count[a] -= 1\n\n    for num in range(1001):\n      for _ in range(count[num]):\n        ans.append(num)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1175, "slug": "prime-arrangements", "solutions": ["class Solution:\n    def numPrimeArrangements(self, n: int) -> int:\n        def count(n):\n            cnt = 0\n            primes = [True] * (n + 1)\n            for i in range(2, n + 1):\n                if primes[i]:\n                    cnt += 1\n                    for j in range(i + i, n + 1, i):\n                        primes[j] = False\n            return cnt\n\n        cnt = count(n)\n        ans = factorial(cnt) * factorial(n - cnt)\n        return ans % (10**9 + 7)\n", "class Solution:\n  def numPrimeArrangements(self, n: int) -> int:\n    MOD = 1_000_000_007\n\n    def factorial(n: int) -> int:\n      fact = 1\n      for i in range(2, n + 1):\n        fact = fact * i % MOD\n      return fact\n\n    count = self._countPrimes(n)\n    return factorial(count) * factorial(n - count) % MOD\n\n  def _countPrimes(self, n: int) -> int:\n    isPrime = [False] * 2 + [True] * (n - 1)\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n + 1, i):\n          isPrime[j] = False\n    return sum(isPrime)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1185, "slug": "day-of-the-week", "solutions": ["class Solution:\n    def dayOfTheWeek(self, day: int, month: int, year: int) -> str:\n        return datetime.date(year, month, day).strftime('%A')\n", "class Solution:\n  def dayOfTheWeek(self, day: int, month: int, year: int) -> str:\n    def isLeapYear(year: int) -> bool:\n      return (year % 4 == 0 and year % 100 != 0) or year % 400 == 0\n\n    week = [\"Sunday\", \"Monday\", \"Tuesday\",\n            \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\n    days = [31, 29 if isLeapYear(\n        year) else 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    count = 0\n\n    for i in range(1971, year):\n      count += 366 if i % 4 == 0 else 365\n    for i in range(month - 1):\n      count += days[i]\n    count += day\n\n    return week[(count + 4) % 7]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1186, "slug": "maximum-subarray-sum-with-one-deletion", "solutions": ["class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        n = len(arr)\n        left = [0] * n\n        right = [0] * n\n        s = 0\n        for i, x in enumerate(arr):\n            s = max(s, 0) + x\n            left[i] = s\n        s = 0\n        for i in range(n - 1, -1, -1):\n            s = max(s, 0) + arr[i]\n            right[i] = s\n        ans = max(left)\n        for i in range(1, n - 1):\n            ans = max(ans, left[i - 1] + right[i + 1])\n        return ans\n", "class Solution:\n  # Very similar to 53. Maximum Subarray\n  def maximumSum(self, arr: list[int]) -> int:\n    ans = -math.inf\n    zero = -math.inf  # no deletion\n    one = -math.inf   # <= 1 deletion\n\n    for a in arr:\n      one = max(a, one + a, zero)\n      zero = max(a, zero + a)\n      ans = max(ans, one)\n\n    return ans\n", "class Solution:\n  # Very similar to 53. Maximum Subarray\n  def maximumSum(self, arr: list[int]) -> int:\n    # dp[0][i] := the maximum sum subarray ending in i (no deletion)\n    # dp[1][i] := the maximum sum subarray ending in i (at most 1 deletion)\n    dp = [[0] * len(arr) for _ in range(2)]\n\n    dp[0][0] = arr[0]\n    dp[1][0] = arr[0]\n    for i in range(1, len(arr)):\n      dp[0][i] = max(arr[i], dp[0][i - 1] + arr[i])\n      dp[1][i] = max(arr[i], dp[1][i - 1] + arr[i], dp[0][i - 1])\n\n    return max(dp[1])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1128, "slug": "number-of-equivalent-domino-pairs", "solutions": ["class Solution:\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\n        cnt = Counter()\n        ans = 0\n        for a, b in dominoes:\n            x = a * 10 + b if a < b else b * 10 + a\n            ans += cnt[x]\n            cnt[x] += 1\n        return ans\n", "class Solution:\n  def numEquivDominoPairs(self, dominoes: list[list[int]]) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    for domino in dominoes:\n      key = min(domino[0], domino[1]) * 10 + max(domino[0], domino[1])\n      ans += count[key]\n      count[key] += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1181, "slug": "before-and-after-puzzle", "solutions": ["class Solution:\n    def beforeAndAfterPuzzles(self, phrases: List[str]) -> List[str]:\n        ps = []\n        for p in phrases:\n            ws = p.split()\n            ps.append((ws[0], ws[-1]))\n        n = len(ps)\n        ans = []\n        for i in range(n):\n            for j in range(n):\n                if i != j and ps[i][1] == ps[j][0]:\n                    ans.append(phrases[i] + phrases[j][len(ps[j][0]) :])\n        return sorted(set(ans))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1192, "slug": "critical-connections-in-a-network", "solutions": ["class Solution:\n    def criticalConnections(\n        self, n: int, connections: List[List[int]]\n    ) -> List[List[int]]:\n        def tarjan(a: int, fa: int):\n            nonlocal now\n            now += 1\n            dfn[a] = low[a] = now\n            for b in g[a]:\n                if b == fa:\n                    continue\n                if not dfn[b]:\n                    tarjan(b, a)\n                    low[a] = min(low[a], low[b])\n                    if low[b] > dfn[a]:\n                        ans.append([a, b])\n                else:\n                    low[a] = min(low[a], dfn[b])\n\n        g = [[] for _ in range(n)]\n        for a, b in connections:\n            g[a].append(b)\n            g[b].append(a)\n\n        dfn = [0] * n\n        low = [0] * n\n        now = 0\n        ans = []\n        tarjan(0, -1)\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1157, "slug": "online-majority-element-in-subarray", "solutions": ["class Node:\n    __slots__ = (\"l\", \"r\", \"x\", \"cnt\")\n\n    def __init__(self):\n        self.l = self.r = 0\n        self.x = self.cnt = 0\n\n\nclass SegmentTree:\n    def __init__(self, nums):\n        self.nums = nums\n        n = len(nums)\n        self.tr = [Node() for _ in range(n << 2)]\n        self.build(1, 1, n)\n\n    def build(self, u, l, r):\n        self.tr[u].l, self.tr[u].r = l, r\n        if l == r:\n            self.tr[u].x = self.nums[l - 1]\n            self.tr[u].cnt = 1\n            return\n        mid = (l + r) >> 1\n        self.build(u << 1, l, mid)\n        self.build(u << 1 | 1, mid + 1, r)\n        self.pushup(u)\n\n    def query(self, u, l, r):\n        if self.tr[u].l >= l and self.tr[u].r <= r:\n            return self.tr[u].x, self.tr[u].cnt\n        mid = (self.tr[u].l + self.tr[u].r) >> 1\n        if r <= mid:\n            return self.query(u << 1, l, r)\n        if l > mid:\n            return self.query(u << 1 | 1, l, r)\n        x1, cnt1 = self.query(u << 1, l, r)\n        x2, cnt2 = self.query(u << 1 | 1, l, r)\n        if x1 == x2:\n            return x1, cnt1 + cnt2\n        if cnt1 >= cnt2:\n            return x1, cnt1 - cnt2\n        else:\n            return x2, cnt2 - cnt1\n\n    def pushup(self, u):\n        if self.tr[u << 1].x == self.tr[u << 1 | 1].x:\n            self.tr[u].x = self.tr[u << 1].x\n            self.tr[u].cnt = self.tr[u << 1].cnt + self.tr[u << 1 | 1].cnt\n        elif self.tr[u << 1].cnt >= self.tr[u << 1 | 1].cnt:\n            self.tr[u].x = self.tr[u << 1].x\n            self.tr[u].cnt = self.tr[u << 1].cnt - self.tr[u << 1 | 1].cnt\n        else:\n            self.tr[u].x = self.tr[u << 1 | 1].x\n            self.tr[u].cnt = self.tr[u << 1 | 1].cnt - self.tr[u << 1].cnt\n\n\nclass MajorityChecker:\n    def __init__(self, arr: List[int]):\n        self.tree = SegmentTree(arr)\n        self.d = defaultdict(list)\n        for i, x in enumerate(arr):\n            self.d[x].append(i)\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        x, _ = self.tree.query(1, left + 1, right + 1)\n        l = bisect_left(self.d[x], left)\n        r = bisect_left(self.d[x], right + 1)\n        return x if r - l >= threshold else -1\n\n\n# Your MajorityChecker object will be instantiated and called as such:\n# obj = MajorityChecker(arr)\n# param_1 = obj.query(left,right,threshold)\n", "class MajorityChecker:\n  def __init__(self, arr: list[int]):\n    self.arr = arr\n    self.TIMES = 20  # 2^TIMES >> |arr|\n    self.numToIndices = collections.defaultdict(list)\n\n    for i, a in enumerate(self.arr):\n      self.numToIndices[a].append(i)\n\n  def query(self, left: int, right: int, threshold: int) -> int:\n    for _ in range(self.TIMES):\n      randIndex = random.randint(left, right)\n      num = self.arr[randIndex]\n      indices = self.numToIndices[num]\n      l = bisect.bisect_left(indices, left)\n      r = bisect.bisect_right(indices, right)\n      if r - l >= threshold:\n        return num\n\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1101, "slug": "the-earliest-moment-when-everyone-become-friends", "solutions": ["class Solution:\n    def earliestAcq(self, logs: List[List[int]], n: int) -> int:\n        def find(x):\n            if p[x] != x:\n                p[x] = find(p[x])\n            return p[x]\n\n        p = list(range(n))\n        for t, x, y in sorted(logs):\n            if find(x) == find(y):\n                continue\n            p[find(x)] = find(y)\n            n -= 1\n            if n == 1:\n                return t\n        return -1\n", "class UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n\n  def getCount(self) -> int:\n    return self.count\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def earliestAcq(self, logs: list[list[int]], n: int) -> int:\n    uf = UnionFind(n)\n\n    # Sort `logs` by timestamp.\n    logs.sort(key=lambda x: x[0])\n\n    for timestamp, x, y in logs:\n      uf.unionByRank(x, y)\n      if uf.getCount() == 1:\n        return timestamp\n\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1172, "slug": "dinner-plate-stacks", "solutions": ["class DinnerPlates:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.stacks = []\n        self.not_full = SortedSet()\n\n    def push(self, val: int) -> None:\n        if not self.not_full:\n            self.stacks.append([val])\n            if self.capacity > 1:\n                self.not_full.add(len(self.stacks) - 1)\n        else:\n            index = self.not_full[0]\n            self.stacks[index].append(val)\n            if len(self.stacks[index]) == self.capacity:\n                self.not_full.discard(index)\n\n    def pop(self) -> int:\n        return self.popAtStack(len(self.stacks) - 1)\n\n    def popAtStack(self, index: int) -> int:\n        if index < 0 or index >= len(self.stacks) or not self.stacks[index]:\n            return -1\n        val = self.stacks[index].pop()\n        if index == len(self.stacks) - 1 and not self.stacks[-1]:\n            while self.stacks and not self.stacks[-1]:\n                self.not_full.discard(len(self.stacks) - 1)\n                self.stacks.pop()\n        else:\n            self.not_full.add(index)\n        return val\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n  def __init__(self, capacity: int):\n    self.capacity = capacity\n    self.stacks = []\n    self.minHeap = [0]  # the minimum indices of the stacks to push\n\n  def push(self, val: int) -> None:\n    index = self.minHeap[0]\n    # Add a new stack on demand.\n    if index == len(self.stacks):\n      self.stacks.append([])\n    # Push the new value.\n    self.stacks[index].append(val)\n    # If the stack pushed is full, remove its candidacy from `minHeap`.\n    if len(self.stacks[index]) == self.capacity:\n      heapq.heappop(self.minHeap)\n      # If `minHeap` is empty, the next available stack index is |stacks|.\n      if not self.minHeap:\n        heapq.heappush(self.minHeap, len(self.stacks))\n\n  def pop(self) -> int:\n    # Remove empty stacks from the back.\n    while self.stacks and not self.stacks[-1]:\n      self.stacks.pop()\n    if not self.stacks:\n      return -1\n    return self.popAtStack(len(self.stacks) - 1)\n\n  def popAtStack(self, index: int) -> int:\n    if index >= len(self.stacks) or not self.stacks[index]:\n      return -1\n    # If the stack is going to have space, add its candiday to `minHeap`.\n    if len(self.stacks[index]) == self.capacity:\n      heapq.heappush(self.minHeap, index)\n    return self.stacks[index].pop()\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1135, "slug": "connecting-cities-with-minimum-cost", "solutions": ["class Solution:\n    def minimumCost(self, n: int, connections: List[List[int]]) -> int:\n        def find(x):\n            if p[x] != x:\n                p[x] = find(p[x])\n            return p[x]\n\n        connections.sort(key=lambda x: x[2])\n        p = list(range(n))\n        ans = 0\n        for x, y, cost in connections:\n            x, y = x - 1, y - 1\n            if find(x) == find(y):\n                continue\n            p[find(x)] = find(y)\n            ans += cost\n            n -= 1\n            if n == 1:\n                return ans\n        return -1\n", "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def minimumCost(self, n: int, connections: list[list[int]]) -> int:\n    ans = 0\n    uf = UnionFind(n + 1)\n\n    # Sort by cost.\n    connections.sort(key=lambda x: x[2])\n\n    for u, v, cost in connections:\n      if uf.find(u) == uf.find(v):\n        continue\n      uf.unionByRank(u, v)\n      ans += cost\n\n    root = uf.find(1)\n    if any(uf.find(i) != root for i in range(1, n + 1)):\n      return -1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1162, "slug": "as-far-from-land-as-possible", "solutions": ["class Solution:\n    def maxDistance(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        q = deque((i, j) for i in range(n) for j in range(n) if grid[i][j])\n        ans = -1\n        if len(q) in (0, n * n):\n            return ans\n        dirs = (-1, 0, 1, 0, -1)\n        while q:\n            for _ in range(len(q)):\n                i, j = q.popleft()\n                for a, b in pairwise(dirs):\n                    x, y = i + a, j + b\n                    if 0 <= x < n and 0 <= y < n and grid[x][y] == 0:\n                        grid[x][y] = 1\n                        q.append((x, y))\n            ans += 1\n        return ans\n", "class Solution:\n  def maxDistance(self, grid: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    q = collections.deque()\n    water = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 0:\n          water += 1\n        else:\n          q.append((i, j))\n\n    if water == 0 or water == m * n:\n      return -1\n\n    ans = 0\n    d = 0\n\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        ans = d\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if grid[x][y] > 0:\n            continue\n          q.append((x, y))\n          grid[x][y] = 2  # Mark as visited.\n      d += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1150, "slug": "check-if-a-number-is-majority-element-in-a-sorted-array", "solutions": ["class Solution:\n    def isMajorityElement(self, nums: List[int], target: int) -> bool:\n        left = bisect_left(nums, target)\n        right = bisect_right(nums, target)\n        return right - left > len(nums) // 2\n", "class Solution:\n  def isMajorityElement(self, nums: list[int], target: int) -> bool:\n    n = len(nums)\n    i = bisect.bisect_left(nums, target)\n    return i + n // 2 < n and nums[i + n // 2] == target\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1145, "slug": "binary-tree-coloring-game", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def btreeGameWinningMove(self, root: Optional[TreeNode], n: int, x: int) -> bool:\n        def dfs(root):\n            if root is None or root.val == x:\n                return root\n            return dfs(root.left) or dfs(root.right)\n\n        def count(root):\n            if root is None:\n                return 0\n            return 1 + count(root.left) + count(root.right)\n\n        node = dfs(root)\n        l, r = count(node.left), count(node.right)\n        return max(l, r, n - l - r - 1) > n // 2\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1166, "slug": "design-file-system", "solutions": ["class Trie:\n    def __init__(self, v: int = -1):\n        self.children = {}\n        self.v = v\n\n    def insert(self, w: str, v: int) -> bool:\n        node = self\n        ps = w.split(\"/\")\n        for p in ps[1:-1]:\n            if p not in node.children:\n                return False\n            node = node.children[p]\n        if ps[-1] in node.children:\n            return False\n        node.children[ps[-1]] = Trie(v)\n        return True\n\n    def search(self, w: str) -> int:\n        node = self\n        for p in w.split(\"/\")[1:]:\n            if p not in node.children:\n                return -1\n            node = node.children[p]\n        return node.v\n\n\nclass FileSystem:\n    def __init__(self):\n        self.trie = Trie()\n\n    def createPath(self, path: str, value: int) -> bool:\n        return self.trie.insert(path, value)\n\n    def get(self, path: str) -> int:\n        return self.trie.search(path)\n\n\n# Your FileSystem object will be instantiated and called as such:\n# obj = FileSystem()\n# param_1 = obj.createPath(path,value)\n# param_2 = obj.get(path)\n", "class TrieNode:\n  def __init__(self, value: int = 0):\n    self.children: dict[str, TrieNode] = {}\n    self.value = value\n\n\nclass FileSystem:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def createPath(self, path: str, value: int) -> bool:\n    node: TrieNode = self.root\n    subpaths = path.split('/')\n\n    for i in range(1, len(subpaths) - 1):\n      if subpaths[i] not in node.children:\n        return False\n      node = node.children[subpaths[i]]\n\n    if subpaths[-1] in node.children:\n      return False\n    node.children[subpaths[-1]] = TrieNode(value)\n    return True\n\n  def get(self, path: str) -> int:\n    node: TrieNode = self.root\n\n    for subpath in path.split('/')[1:]:\n      if subpath not in node.children:\n        return -1\n      node = node.children[subpath]\n\n    return node.value\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1179, "slug": "reformat-department-table", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1125, "slug": "smallest-sufficient-team", "solutions": ["class Solution:\n    def smallestSufficientTeam(\n        self, req_skills: List[str], people: List[List[str]]\n    ) -> List[int]:\n        d = {s: i for i, s in enumerate(req_skills)}\n        m, n = len(req_skills), len(people)\n        p = [0] * n\n        for i, ss in enumerate(people):\n            for s in ss:\n                p[i] |= 1 << d[s]\n        f = [inf] * (1 << m)\n        g = [0] * (1 << m)\n        h = [0] * (1 << m)\n        f[0] = 0\n        for i in range(1 << m):\n            if f[i] == inf:\n                continue\n            for j in range(n):\n                if f[i] + 1 < f[i | p[j]]:\n                    f[i | p[j]] = f[i] + 1\n                    g[i | p[j]] = j\n                    h[i | p[j]] = i\n        i = (1 << m) - 1\n        ans = []\n        while i:\n            ans.append(g[i])\n            i = h[i]\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1161, "slug": "maximum-level-sum-of-a-binary-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: Optional[TreeNode]) -> int:\n        q = deque([root])\n        mx = -inf\n        i = 0\n        while q:\n            i += 1\n            s = 0\n            for _ in range(len(q)):\n                node = q.popleft()\n                s += node.val\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            if mx < s:\n                mx = s\n                ans = i\n        return ans\n", "class Solution:\n  def maxLevelSum(self, root: TreeNode | None) -> int:\n    ans = 0\n    maxLevelSum = -math.inf\n    q = collections.deque([root])\n\n    level = 1\n    while q:\n      levelSum = 0\n      for _ in range(len(q)):\n        node = q.popleft()\n        levelSum += node.val\n        if node.left:\n          q.append(node.left)\n        if node.right:\n          q.append(node.right)\n      if levelSum > maxLevelSum:\n        maxLevelSum = levelSum\n        ans = level\n      level += 1\n\n    return ans\n", "class Solution:\n  def maxLevelSum(self, root: TreeNode | None) -> int:\n    # levelSums[i] := the sum of level (i + 1) (1-indexed)\n    levelSums = []\n\n    def dfs(root: TreeNode | None, level: int) -> None:\n      if not root:\n        return\n      if len(levelSums) == level:\n        levelSums.append(0)\n      levelSums[level] += root.val\n      dfs(root.left, level + 1)\n      dfs(root.right, level + 1)\n\n    dfs(root, 0)\n    return 1 + levelSums.index(max(levelSums))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1117, "slug": "building-h2o", "solutions": ["from threading import Semaphore\n\n\nclass H2O:\n    def __init__(self):\n        self.h = Semaphore(2)\n        self.o = Semaphore(0)\n\n    def hydrogen(self, releaseHydrogen: \"Callable[[], None]\") -> None:\n        self.h.acquire()\n        # releaseHydrogen() outputs \"H\". Do not change or remove this line.\n        releaseHydrogen()\n        if self.h._value == 0:\n            self.o.release()\n\n    def oxygen(self, releaseOxygen: \"Callable[[], None]\") -> None:\n        self.o.acquire()\n        # releaseOxygen() outputs \"O\". Do not change or remove this line.\n        releaseOxygen()\n        self.h.release(2)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1184, "slug": "distance-between-bus-stops", "solutions": ["class Solution:\n    def distanceBetweenBusStops(\n        self, distance: List[int], start: int, destination: int\n    ) -> int:\n        s = sum(distance)\n        t, n = 0, len(distance)\n        while start != destination:\n            t += distance[start]\n            start = (start + 1) % n\n        return min(t, s - t)\n", "class Solution:\n  def distanceBetweenBusStops(\n      self,\n      distance: list[int],\n      start: int, destination: int,\n  ) -> int:\n    clockwise = 0\n    counterclockwise = 0\n\n    if start > destination:\n      start, destination = destination, start\n\n    for i, d in enumerate(distance):\n      if i >= start and i < destination:\n        clockwise += d\n      else:\n        counterclockwise += d\n\n    return min(clockwise, counterclockwise)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1156, "slug": "swap-for-longest-repeated-character-substring", "solutions": ["class Solution:\n    def maxRepOpt1(self, text: str) -> int:\n        cnt = Counter(text)\n        n = len(text)\n        ans = i = 0\n        while i < n:\n            j = i\n            while j < n and text[j] == text[i]:\n                j += 1\n            l = j - i\n            k = j + 1\n            while k < n and text[k] == text[i]:\n                k += 1\n            r = k - j - 1\n            ans = max(ans, min(l + r + 1, cnt[text[i]]))\n            i = j\n        return ans\n", "class Solution:\n  def maxRepOpt1(self, text: str) -> int:\n    count = collections.Counter(text)\n    groups = [[c, len(list(group))]\n              for c, group in itertools.groupby(text)]\n    ans = max(min(length + 1, count[c]) for c, length in groups)\n\n    for i in range(1, len(groups) - 1):\n      if groups[i - 1][0] == groups[i + 1][0] and groups[i][1] == 1:\n        ans = max(\n            ans,\n            min(groups[i - 1][1] + groups[i + 1][1] + 1, count\n                [groups[i - 1][0]]))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1108, "slug": "defanging-an-ip-address", "solutions": ["class Solution:\n    def defangIPaddr(self, address: str) -> str:\n        return address.replace('.', '[.]')\n", "class Solution:\n  def defangIPaddr(self, address: str) -> str:\n    return address.replace('.', '[.]')\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1153, "slug": "string-transforms-into-another-string", "solutions": ["class Solution:\n    def canConvert(self, str1: str, str2: str) -> bool:\n        if str1 == str2:\n            return True\n        if len(set(str2)) == 26:\n            return False\n        d = {}\n        for a, b in zip(str1, str2):\n            if a not in d:\n                d[a] = b\n            elif d[a] != b:\n                return False\n        return True\n", "class Solution:\n  def canConvert(self, str1: str, str2: str) -> bool:\n    if str1 == str2:\n      return True\n\n    mappings = {}\n\n    for a, b in zip(str1, str2):\n      if mappings.get(a, b) != b:\n        return False\n      mappings[a] = b\n\n    # No letter in the str1 maps to > 1 letter in the str2 and there is at\n    # lest one temporary letter can break any loops.\n    return len(set(str2)) < 26\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1104, "slug": "path-in-zigzag-labelled-binary-tree", "solutions": ["class Solution:\n    def pathInZigZagTree(self, label: int) -> List[int]:\n        x = i = 1\n        while (x << 1) <= label:\n            x <<= 1\n            i += 1\n        ans = [0] * i\n        while i:\n            ans[i - 1] = label\n            label = ((1 << (i - 1)) + (1 << i) - 1 - label) >> 1\n            i -= 1\n        return ans\n", "class Solution:\n  def pathInZigZagTree(self, label: int) -> list[int]:\n    def boundarySum(level: int):\n      return 2**level + 2**(level + 1) - 1\n\n    ans = []\n\n    for l in range(21):\n      if 2**l > label:\n        level = l - 1\n        break\n\n    if level % 2 == 1:\n      label = boundarySum(level) - label\n\n    for l in reversed(range(level + 1)):\n      ans.append(label if l % 2 == 0 else boundarySum(l) - label)\n      label //= 2\n\n    return ans[::-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1143, "slug": "longest-common-subsequence", "solutions": ["class Solution:\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        m, n = len(text1), len(text2)\n        f = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if text1[i - 1] == text2[j - 1]:\n                    f[i][j] = f[i - 1][j - 1] + 1\n                else:\n                    f[i][j] = max(f[i - 1][j], f[i][j - 1])\n        return f[m][n]\n", "class Solution:\n  def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n    m = len(text1)\n    n = len(text2)\n    # dp[i][j] := the length of LCS(text1[0..i), text2[0..j))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m):\n      for j in range(n):\n        dp[i + 1][j + 1] = (1 + dp[i][j] if text1[i] == text2[j]\n                            else max(dp[i][j + 1], dp[i + 1][j]))\n\n    return dp[m][n]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1115, "slug": "print-foobar-alternately", "solutions": ["from threading import Semaphore\n\n\nclass FooBar:\n    def __init__(self, n):\n        self.n = n\n        self.f = Semaphore(1)\n        self.b = Semaphore(0)\n\n    def foo(self, printFoo: \"Callable[[], None]\") -> None:\n        for _ in range(self.n):\n            self.f.acquire()\n            # printFoo() outputs \"foo\". Do not change or remove this line.\n            printFoo()\n            self.b.release()\n\n    def bar(self, printBar: \"Callable[[], None]\") -> None:\n        for _ in range(self.n):\n            self.b.acquire()\n            # printBar() outputs \"bar\". Do not change or remove this line.\n            printBar()\n            self.f.release()\n", "from threading import Semaphore\n\n\nclass FooBar:\n  def __init__(self, n):\n    self.n = n\n    self.fooSemaphore = Semaphore(1)\n    self.barSemaphore = Semaphore(0)\n\n  def foo(self, printFoo: 'Callable[[], None]') -> None:\n    for _ in range(self.n):\n      self.fooSemaphore.acquire()\n      printFoo()\n      self.barSemaphore.release()\n\n  def bar(self, printBar: 'Callable[[], None]') -> None:\n    for _ in range(self.n):\n      self.barSemaphore.acquire()\n      printBar()\n      self.fooSemaphore.release()\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1141, "slug": "user-activity-for-the-past-30-days-i", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1178, "slug": "number-of-valid-words-for-each-puzzle", "solutions": ["class Solution:\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        cnt = Counter()\n        for w in words:\n            mask = 0\n            for c in w:\n                mask |= 1 << (ord(c) - ord(\"a\"))\n            cnt[mask] += 1\n\n        ans = []\n        for p in puzzles:\n            mask = 0\n            for c in p:\n                mask |= 1 << (ord(c) - ord(\"a\"))\n            x, i, j = 0, ord(p[0]) - ord(\"a\"), mask\n            while j:\n                if j >> i & 1:\n                    x += cnt[j]\n                j = (j - 1) & mask\n            ans.append(x)\n        return ans\n", "class Solution:\n  def findNumOfValidWords(\n      self,\n      words: list[str],\n      puzzles: list[str],\n  ) -> list[int]:\n    ans = []\n    binaryCount = collections.Counter()\n\n    for word in words:\n      mask = 0\n      for c in word:\n        mask |= 1 << ord(c) - ord('a')\n      binaryCount[mask] += 1\n\n    for puzzle in puzzles:\n      valid = 0\n      n = len(puzzle) - 1\n      for i in range(1 << n):\n        mask = 1 << ord(puzzle[0]) - ord('a')\n        for j in range(n):\n          if i >> j & 1:\n            mask |= 1 << ord(puzzle[j + 1]) - ord('a')\n        if mask in binaryCount:\n          valid += binaryCount[mask]\n      ans.append(valid)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1182, "slug": "shortest-distance-to-target-color", "solutions": ["class Solution:\n    def shortestDistanceColor(\n        self, colors: List[int], queries: List[List[int]]\n    ) -> List[int]:\n        n = len(colors)\n        right = [[inf] * 3 for _ in range(n + 1)]\n        for i in range(n - 1, -1, -1):\n            for j in range(3):\n                right[i][j] = right[i + 1][j]\n            right[i][colors[i] - 1] = i\n        left = [[-inf] * 3 for _ in range(n + 1)]\n        for i, c in enumerate(colors, 1):\n            for j in range(3):\n                left[i][j] = left[i - 1][j]\n            left[i][c - 1] = i - 1\n        ans = []\n        for i, c in queries:\n            d = min(i - left[i + 1][c - 1], right[i][c - 1] - i)\n            ans.append(-1 if d > n else d)\n        return ans\n", "class Solution:\n  def shortestDistanceColor(\n      self,\n      colors: list[int],\n      queries: list[list[int]],\n  ) -> list[int]:\n    NUM_COLOR = 3\n    n = len(colors)\n    ans = []\n    # left[i][c] := the closest index of color c in index i to the left\n    left = [[0] * (NUM_COLOR + 1) for _ in range(n)]\n    # right[i][c] := the closest index of color c in index i to the right\n    right = [[0] * (NUM_COLOR + 1) for _ in range(n)]\n\n    colorToLatestIndex = [0, -1, -1, -1]  # 0-indexed, -1 means N//A\n    for i, color in enumerate(colors):\n      colorToLatestIndex[color] = i\n      for c in range(1, NUM_COLOR + 1):\n        left[i][c] = colorToLatestIndex[c]\n\n    colorToLatestIndex = [0, -1, -1, -1]  # Reset.\n    for i in range(n - 1, -1, -1):\n      colorToLatestIndex[colors[i]] = i\n      for c in range(1, NUM_COLOR + 1):\n        right[i][c] = colorToLatestIndex[c]\n\n    for i, c in queries:\n      leftDist = math.inf if left[i][c] == -1 else i - left[i][c]\n      rightDist = math.inf if right[i][c] == -1 else right[i][c] - i\n      minDist = min(leftDist, rightDist)\n      ans.append(-1 if minDist == math.inf else minDist)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1142, "slug": "user-activity-for-the-past-30-days-ii", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1188, "slug": "design-bounded-blocking-queue", "solutions": ["from threading import Semaphore\n\n\nclass BoundedBlockingQueue(object):\n    def __init__(self, capacity: int):\n        self.s1 = Semaphore(capacity)\n        self.s2 = Semaphore(0)\n        self.q = deque()\n\n    def enqueue(self, element: int) -> None:\n        self.s1.acquire()\n        self.q.append(element)\n        self.s2.release()\n\n    def dequeue(self) -> int:\n        self.s2.acquire()\n        ans = self.q.popleft()\n        self.s1.release()\n        return ans\n\n    def size(self) -> int:\n        return len(self.q)\n", "from threading import Semaphore\n\n\nclass BoundedBlockingQueue:\n  def __init__(self, capacity: int):\n    self.q = collections.deque()\n    self.enqueueSemaphore = Semaphore(capacity)\n    self.dequeueSemaphore = Semaphore(0)\n\n  def enqueue(self, element: int) -> None:\n    self.enqueueSemaphore.acquire()\n    self.q.append(element)\n    self.dequeueSemaphore.release()\n\n  def dequeue(self) -> int:\n    self.dequeueSemaphore.acquire()\n    element = self.q.popleft()\n    self.enqueueSemaphore.release()\n    return element\n\n  def size(self) -> int:\n    return len(self.q)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1124, "slug": "longest-well-performing-interval", "solutions": ["class Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        ans = s = 0\n        pos = {}\n        for i, x in enumerate(hours):\n            s += 1 if x > 8 else -1\n            if s > 0:\n                ans = i + 1\n            elif s - 1 in pos:\n                ans = max(ans, i - pos[s - 1])\n            if s not in pos:\n                pos[s] = i\n        return ans\n", "class Solution:\n  def longestWPI(self, hours: list[int]) -> int:\n    ans = 0\n    prefix = 0\n    dict = {}\n\n    for i in range(len(hours)):\n      prefix += 1 if hours[i] > 8 else -1\n      if prefix > 0:\n        ans = i + 1\n      else:\n        if prefix not in dict:\n          dict[prefix] = i\n        if prefix - 1 in dict:\n          ans = max(ans, i - dict[prefix - 1])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1139, "slug": "largest-1-bordered-square", "solutions": ["class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        down = [[0] * n for _ in range(m)]\n        right = [[0] * n for _ in range(m)]\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                if grid[i][j]:\n                    down[i][j] = down[i + 1][j] + 1 if i + 1 < m else 1\n                    right[i][j] = right[i][j + 1] + 1 if j + 1 < n else 1\n        for k in range(min(m, n), 0, -1):\n            for i in range(m - k + 1):\n                for j in range(n - k + 1):\n                    if (\n                        down[i][j] >= k\n                        and right[i][j] >= k\n                        and right[i + k - 1][j] >= k\n                        and down[i][j + k - 1] >= k\n                    ):\n                        return k * k\n        return 0\n", "class Solution:\n  def largest1BorderedSquare(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    # leftOnes[i][j] := consecutive 1s in the left of grid[i][j]\n    leftOnes = [[0] * n for _ in range(m)]\n    # topOnes[i][j] := consecutive 1s in the top of grid[i][j]\n    topOnes = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1:\n          leftOnes[i][j] = 1 if j == 0 else 1 + leftOnes[i][j - 1]\n          topOnes[i][j] = 1 if i == 0 else 1 + topOnes[i - 1][j]\n\n    for sz in range(min(m, n), 0, -1):\n      for i in range(m - sz + 1):\n        for j in range(n - sz + 1):\n          x = i + sz - 1\n          y = j + sz - 1\n          # If grid[i..x][j..y] has all 1s on its border.\n          if min(\n                  leftOnes[i][y],\n                  leftOnes[x][y],\n                  topOnes[x][j],\n                  topOnes[x][y]) >= sz:\n            return sz * sz\n\n    return 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1190, "slug": "reverse-substrings-between-each-pair-of-parentheses", "solutions": ["class Solution:\n    def reverseParentheses(self, s: str) -> str:\n        stk = []\n        for c in s:\n            if c == \")\":\n                t = []\n                while stk[-1] != \"(\":\n                    t.append(stk.pop())\n                stk.pop()\n                stk.extend(t)\n            else:\n                stk.append(c)\n        return \"\".join(stk)\n", "class Solution:\n  def reverseParentheses(self, s: str) -> str:\n    ans = []\n    stack = []\n    pair = {}\n\n    for i, c in enumerate(s):\n      if c == '(':\n        stack.append(i)\n      elif c == ')':\n        j = stack.pop()\n        pair[i] = j\n        pair[j] = i\n\n    i = 0\n    d = 1\n    while i < len(s):\n      if s[i] in '()':\n        i = pair[i]\n        d = -d\n      else:\n        ans.append(s[i])\n      i += d\n\n    return ''.join(ans)\n", "class Solution:\n  def reverseParentheses(self, s: str) -> str:\n    stack = []\n    ans = []\n\n    for c in s:\n      if c == '(':\n        stack.append(len(ans))\n      elif c == ')':\n        # Reverse the corresponding substring between ().\n        j = stack.pop()\n        ans[j:] = ans[j:][::-1]\n      else:\n        ans.append(c)\n\n    return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1146, "slug": "snapshot-array", "solutions": ["class SnapshotArray:\n\n    def __init__(self, length: int):\n        self.arr = [[] for _ in range(length)]\n        self.i = 0\n\n    def set(self, index: int, val: int) -> None:\n        self.arr[index].append((self.i, val))\n\n    def snap(self) -> int:\n        self.i += 1\n        return self.i - 1\n\n    def get(self, index: int, snap_id: int) -> int:\n        i = bisect_left(self.arr[index], (snap_id, inf)) - 1\n        return 0 if i < 0 else self.arr[index][i][1]\n\n\n# Your SnapshotArray object will be instantiated and called as such:\n# obj = SnapshotArray(length)\n# obj.set(index,val)\n# param_2 = obj.snap()\n# param_3 = obj.get(index,snap_id)\n", "class SnapshotArray:\n  def __init__(self, length: int):\n    self.snaps = [[[0, 0]] for _ in range(length)]\n    self.snap_id = 0\n\n  def set(self, index: int, val: int) -> None:\n    snap = self.snaps[index][-1]\n    if snap[0] == self.snap_id:\n      snap[1] = val\n    else:\n      self.snaps[index].append([self.snap_id, val])\n\n  def snap(self) -> int:\n    self.snap_id += 1\n    return self.snap_id - 1\n\n  def get(self, index: int, snap_id: int) -> int:\n    i = bisect_left(self.snaps[index], [snap_id + 1]) - 1\n    return self.snaps[index][i][1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1131, "slug": "maximum-of-absolute-value-expression", "solutions": ["class Solution:\n    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\n        dirs = (1, -1, -1, 1, 1)\n        ans = -inf\n        for a, b in pairwise(dirs):\n            mx, mi = -inf, inf\n            for i, (x, y) in enumerate(zip(arr1, arr2)):\n                mx = max(mx, a * x + b * y + i)\n                mi = min(mi, a * x + b * y + i)\n                ans = max(ans, mx - mi)\n        return ans\n", "class Solution:\n  def maxAbsValExpr(self, arr1: list[int], arr2: list[int]) -> int:\n    n = len(arr1)\n    a = [arr1[i] + arr2[i] + i for i in range(n)]\n    b = [arr1[i] + arr2[i] - i for i in range(n)]\n    c = [arr1[i] - arr2[i] + i for i in range(n)]\n    d = [arr1[i] - arr2[i] - i for i in range(n)]\n    return max(map(lambda x: max(x) - min(x), (a, b, c, d)))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1111, "slug": "maximum-nesting-depth-of-two-valid-parentheses-strings", "solutions": ["class Solution:\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\n        ans = [0] * len(seq)\n        x = 0\n        for i, c in enumerate(seq):\n            if c == \"(\":\n                ans[i] = x & 1\n                x += 1\n            else:\n                x -= 1\n                ans[i] = x & 1\n        return ans\n", "class Solution:\n  def maxDepthAfterSplit(self, seq: str) -> list[int]:\n    ans = []\n    depth = 1\n\n    # Put all odd-depth parentheses in one group and even-depth parentheses in the other group.\n    for c in seq:\n      if c == '(':\n        depth += 1\n        ans.append(depth % 2)\n      else:\n        ans.append(depth % 2)\n        depth -= 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1102, "slug": "path-with-maximum-minimum-value", "solutions": ["class Solution:\n    def maximumMinimumPath(self, grid: List[List[int]]) -> int:\n        def find(x: int) -> int:\n            if p[x] != x:\n                p[x] = find(p[x])\n            return p[x]\n\n        m, n = len(grid), len(grid[0])\n        p = list(range(m * n))\n        q = [(v, i, j) for i, row in enumerate(grid) for j, v in enumerate(row)]\n        q.sort()\n        ans = 0\n        dirs = (-1, 0, 1, 0, -1)\n        vis = set()\n        while find(0) != find(m * n - 1):\n            v, i, j = q.pop()\n            ans = v\n            vis.add((i, j))\n            for a, b in pairwise(dirs):\n                x, y = i + a, j + b\n                if (x, y) in vis:\n                    p[find(i * n + j)] = find(x * n + y)\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1176, "slug": "diet-plan-performance", "solutions": ["class Solution:\n    def dietPlanPerformance(\n        self, calories: List[int], k: int, lower: int, upper: int\n    ) -> int:\n        s = list(accumulate(calories, initial=0))\n        ans, n = 0, len(calories)\n        for i in range(n - k + 1):\n            t = s[i + k] - s[i]\n            if t < lower:\n                ans -= 1\n            elif t > upper:\n                ans += 1\n        return ans\n", "class Solution:\n  def dietPlanPerformance(\n      self,\n      calories: list[int],\n      k: int,\n      lower: int,\n      upper: int,\n  ) -> int:\n    ans = 0\n    summ = 0\n\n    for i, calorie in enumerate(calories):\n      summ += calorie\n      if i < k - 1:\n        continue\n      if i >= k:\n        summ -= calories[i - k]\n      if summ < lower:\n        ans -= 1\n      elif summ > upper:\n        ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1154, "slug": "day-of-the-year", "solutions": ["class Solution:\n    def dayOfYear(self, date: str) -> int:\n        y, m, d = (int(s) for s in date.split('-'))\n        v = 29 if y % 400 == 0 or (y % 4 == 0 and y % 100) else 28\n        days = [31, v, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n        return sum(days[: m - 1]) + d\n", "class Solution:\n  def dayOfYear(self, date: str) -> int:\n    def isLeapYear(year: int) -> bool:\n      return (year % 4 == 0 and year % 100 != 0) or year % 400 == 0\n\n    year = int(date[:4])\n    month = int(date[5:7])\n    day = int(date[8:])\n    days = [31, 29 if isLeapYear(\n        year) else 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n    return sum(days[:month - 1]) + day\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1136, "slug": "parallel-courses", "solutions": ["class Solution:\n    def minimumSemesters(self, n: int, relations: List[List[int]]) -> int:\n        g = defaultdict(list)\n        indeg = [0] * n\n        for prev, nxt in relations:\n            prev, nxt = prev - 1, nxt - 1\n            g[prev].append(nxt)\n            indeg[nxt] += 1\n        q = deque(i for i, v in enumerate(indeg) if v == 0)\n        ans = 0\n        while q:\n            ans += 1\n            for _ in range(len(q)):\n                i = q.popleft()\n                n -= 1\n                for j in g[i]:\n                    indeg[j] -= 1\n                    if indeg[j] == 0:\n                        q.append(j)\n        return -1 if n else ans\n", "from enum import Enum\n\n\nclass State(Enum):\n  INIT = 0\n  VISITING = 1\n  VISITED = 2\n\n\nclass Solution:\n  def minimumSemesters(self, n: int, relations: list[list[int]]) -> int:\n    graph = [[] for _ in range(n)]\n    states = [State.INIT] * n\n    depth = [1] * n\n\n    for u, v in relations:\n      graph[u - 1].append(v - 1)\n\n    def hasCycle(u: int) -> bool:\n      if states[u] == State.VISITING:\n        return True\n      if states[u] == State.VISITED:\n        return False\n      states[u] = State.VISITING\n      for v in graph[u]:\n        if hasCycle(v):\n          return True\n        depth[u] = max(depth[u], 1 + depth[v])\n      states[u] = State.VISITED\n      return False\n\n    if any(hasCycle(i) for i in range(n)):\n      return -1\n    return max(depth)\n", "class Solution:\n  def minimumSemesters(self, n: int, relations: list[list[int]]) -> int:\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n\n    # Build the graph.\n    for u, v in relations:\n      graph[u - 1].append(v - 1)\n      inDegrees[v - 1] += 1\n\n    # Perform topological sorting.\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    step = 0\n    while q:\n      for _ in range(len(q)):\n        u = q.popleft()\n        n -= 1\n        for v in graph[u]:\n          inDegrees[v] -= 1\n          if inDegrees[v] == 0:\n            q.append(v)\n      step += 1\n\n    return step if n == 0 else -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1100, "slug": "find-k-length-substrings-with-no-repeated-characters", "solutions": ["class Solution:\n    def numKLenSubstrNoRepeats(self, s: str, k: int) -> int:\n        cnt = Counter(s[:k])\n        ans = int(len(cnt) == k)\n        for i in range(k, len(s)):\n            cnt[s[i]] += 1\n            cnt[s[i - k]] -= 1\n            if cnt[s[i - k]] == 0:\n                cnt.pop(s[i - k])\n            ans += int(len(cnt) == k)\n        return ans\n", "class Solution:\n  def numKLenSubstrNoRepeats(self, s: str, k: int) -> int:\n    ans = 0\n    unique = 0\n    count = collections.Counter()\n\n    for i, c in enumerate(s):\n      count[c] += 1\n      if count[c] == 1:\n        unique += 1\n      if i >= k:\n        count[s[i - k]] -= 1\n        if count[s[i - k]] == 0:\n          unique -= 1\n        if unique == k:\n          ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1174, "slug": "immediate-food-delivery-ii", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1130, "slug": "minimum-cost-tree-from-leaf-values", "solutions": ["class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        @cache\n        def dfs(i: int, j: int) -> Tuple:\n            if i == j:\n                return 0, arr[i]\n            s, mx = inf, -1\n            for k in range(i, j):\n                s1, mx1 = dfs(i, k)\n                s2, mx2 = dfs(k + 1, j)\n                t = s1 + s2 + mx1 * mx2\n                if s > t:\n                    s = t\n                    mx = max(mx1, mx2)\n            return s, mx\n\n        return dfs(0, len(arr) - 1)[0]\n", "class Solution:\n  def mctFromLeafValues(self, arr: list[int]) -> int:\n    ans = 0\n    stack = [math.inf]\n\n    for a in arr:\n      while stack and stack[-1] <= a:\n        mid = stack.pop()\n        # Multiply mid with next greater element in the array,\n        # On the left (stack[-1]) or on the right (current number a)\n        ans += min(stack[-1], a) * mid\n      stack.append(a)\n\n    return ans + sum(a * b for a, b in zip(stack[1:], stack[2:]))\n", "class Solution:\n  def mctFromLeafValues(self, arr: list[int]) -> int:\n    ans = 0\n\n    while len(arr) > 1:\n      i = arr.index(min(arr))\n      ans += min(arr[i - 1:i] + arr[i + 1:i + 2]) * arr.pop(i)\n\n    return ans\n", "class Solution:\n  def mctFromLeafValues(self, arr: list[int]) -> int:\n    n = len(arr)\n    # dp[i][j] := the minimum cost of arr[i..j]\n    dp = [[0] * n for _ in range(n)]\n    # maxVal[i][j] := the maximum value of arr[i..j]\n    maxVal = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n      maxVal[i][i] = arr[i]\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        maxVal[i][j] = max(maxVal[i][j - 1], maxVal[i + 1][j])\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        dp[i][j] = math.inf\n        for k in range(i, j):\n          dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] +\n                         maxVal[i][k] * maxVal[k + 1][j])\n\n    return dp[0][-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1133, "slug": "largest-unique-number", "solutions": ["class Solution:\n    def largestUniqueNumber(self, nums: List[int]) -> int:\n        cnt = Counter(nums)\n        return max((x for x, v in cnt.items() if v == 1), default=-1)\n", "class Solution:\n  def largestUniqueNumber(self, nums: list[int]) -> int:\n    return max([num for num, freq in collections.Counter(nums).items()\n                if freq == 1], default=-1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1197, "slug": "minimum-knight-moves", "solutions": ["class Solution:\n    def minKnightMoves(self, x: int, y: int) -> int:\n        q = deque([(0, 0)])\n        ans = 0\n        vis = {(0, 0)}\n        dirs = ((-2, 1), (-1, 2), (1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1))\n        while q:\n            for _ in range(len(q)):\n                i, j = q.popleft()\n                if (i, j) == (x, y):\n                    return ans\n                for a, b in dirs:\n                    c, d = i + a, j + b\n                    if (c, d) not in vis:\n                        vis.add((c, d))\n                        q.append((c, d))\n            ans += 1\n        return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1194, "slug": "tournament-winners", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1105, "slug": "filling-bookcase-shelves", "solutions": ["class Solution:\n    def minHeightShelves(self, books: List[List[int]], shelfWidth: int) -> int:\n        n = len(books)\n        f = [0] * (n + 1)\n        for i, (w, h) in enumerate(books, 1):\n            f[i] = f[i - 1] + h\n            for j in range(i - 1, 0, -1):\n                w += books[j - 1][0]\n                if w > shelfWidth:\n                    break\n                h = max(h, books[j - 1][1])\n                f[i] = min(f[i], f[j - 1] + h)\n        return f[n]\n", "class Solution:\n  def minHeightShelves(self, books: list[list[int]], shelfWidth: int) -> int:\n    # dp[i] := the minimum height to place the first i books\n    dp = [0] + [math.inf] * len(books)\n\n    for i in range(len(books)):\n      sumThickness = 0\n      maxHeight = 0\n      # Place books[j..i] on a new shelf.\n      for j in range(i, -1, -1):\n        thickness, height = books[j]\n        sumThickness += thickness\n        if sumThickness > shelfWidth:\n          break\n        maxHeight = max(maxHeight, height)\n        dp[i + 1] = min(dp[i + 1], dp[j] + maxHeight)\n\n    return dp[-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1158, "slug": "market-analysis-i", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1180, "slug": "count-substrings-with-only-one-distinct-letter", "solutions": ["class Solution:\n    def countLetters(self, s: str) -> int:\n        n = len(s)\n        i = ans = 0\n        while i < n:\n            j = i\n            while j < n and s[j] == s[i]:\n                j += 1\n            ans += (1 + j - i) * (j - i) // 2\n            i = j\n        return ans\n", "class Solution:\n  def countLetters(self, s: str) -> int:\n    ans = 0\n    dp = 0  # the length of the running letter\n    letter = '@'  # the running letter\n\n    for c in s:\n      if c == letter:\n        dp += 1\n      else:\n        dp = 1\n        letter = c\n      ans += dp  # Add the number of substrings ending in the current letter.\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1170, "slug": "compare-strings-by-frequency-of-the-smallest-character", "solutions": ["class Solution:\n    def numSmallerByFrequency(self, queries: List[str], words: List[str]) -> List[int]:\n        def f(s: str) -> int:\n            cnt = Counter(s)\n            return next(cnt[c] for c in ascii_lowercase if cnt[c])\n\n        n = len(words)\n        nums = sorted(f(w) for w in words)\n        return [n - bisect_right(nums, f(q)) for q in queries]\n", "class Solution:\n  def numSmallerByFrequency(\n      self,\n      queries: list[str],\n      words: list[str],\n  ) -> list[int]:\n    ans = []\n    wordsFreq = sorted([word.count(min(word)) for word in words])\n\n    for q in queries:\n      count = q.count(min(q))\n      index = bisect.bisect(wordsFreq, count)\n      ans.append(len(words) - index)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1121, "slug": "divide-array-into-increasing-sequences", "solutions": ["class Solution:\n    def canDivideIntoSubsequences(self, nums: List[int], k: int) -> bool:\n        mx = max(len(list(x)) for _, x in groupby(nums))\n        return mx * k <= len(nums)\n", "class Solution:\n  def canDivideIntoSubsequences(self, nums: list[int], k: int) -> bool:\n    # Find the number with the maxFreq, we need at least maxFreq * k elements\n    # e.g. nums = [1, 2, 2, 3, 4], we have maxFreq = 2 (two 2s), so we have to\n    # Split nums into two subsequences say k = 3, the minimum length of nums is 2 x\n    # 3 = 6, which is impossible if len(nums) = 5\n    return len(nums) >= k * max(Counter(nums).values())\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1151, "slug": "minimum-swaps-to-group-all-1s-together", "solutions": ["class Solution:\n    def minSwaps(self, data: List[int]) -> int:\n        k = data.count(1)\n        mx = t = sum(data[:k])\n        for i in range(k, len(data)):\n            t += data[i]\n            t -= data[i - k]\n            mx = max(mx, t)\n        return k - mx\n", "class Solution:\n  def minSwaps(self, data: list[int]) -> int:\n    k = data.count(1)\n    ones = 0  # the number of ones in the window\n    maxOnes = 0  # the maximum number of ones in the window\n\n    for i, num in enumerate(data):\n      if i >= k and data[i - k]:\n        ones -= 1\n      if num:\n        ones += 1\n      maxOnes = max(maxOnes, ones)\n\n    return k - maxOnes\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1147, "slug": "longest-chunked-palindrome-decomposition", "solutions": ["class Solution:\n    def longestDecomposition(self, text: str) -> int:\n        ans = 0\n        i, j = 0, len(text) - 1\n        while i <= j:\n            k = 1\n            ok = False\n            while i + k - 1 < j - k + 1:\n                if text[i : i + k] == text[j - k + 1 : j + 1]:\n                    ans += 2\n                    i += k\n                    j -= k\n                    ok = True\n                    break\n                k += 1\n            if not ok:\n                ans += 1\n                break\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1165, "slug": "single-row-keyboard", "solutions": ["class Solution:\n    def calculateTime(self, keyboard: str, word: str) -> int:\n        pos = {c: i for i, c in enumerate(keyboard)}\n        ans = i = 0\n        for c in word:\n            ans += abs(pos[c] - i)\n            i = pos[c]\n        return ans\n", "class Solution:\n  def calculateTime(self, keyboard: str, word: str) -> int:\n    letterToIndex = {c: i for i, c in enumerate(keyboard)}\n    return (letterToIndex[word[0]] +\n            sum(abs(letterToIndex[a] - letterToIndex[b])\n            for a, b in itertools.pairwise(word)))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1187, "slug": "make-array-strictly-increasing", "solutions": ["class Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        arr2.sort()\n        m = 0\n        for x in arr2:\n            if m == 0 or x != arr2[m - 1]:\n                arr2[m] = x\n                m += 1\n        arr2 = arr2[:m]\n        arr = [-inf] + arr1 + [inf]\n        n = len(arr)\n        f = [inf] * n\n        f[0] = 0\n        for i in range(1, n):\n            if arr[i - 1] < arr[i]:\n                f[i] = f[i - 1]\n            j = bisect_left(arr2, arr[i])\n            for k in range(1, min(i - 1, j) + 1):\n                if arr[i - k - 1] < arr2[j - k]:\n                    f[i] = min(f[i], f[i - k - 1] + k)\n        return -1 if f[n - 1] >= inf else f[n - 1]\n", "class Solution:\n  def makeArrayIncreasing(self, arr1: list[int], arr2: list[int]) -> int:\n    # dp[i] := the minimum steps to reach i at previous round\n    dp = {-1: 0}\n\n    arr2.sort()\n\n    for a in arr1:\n      newDp = collections.defaultdict(lambda: math.inf)\n      for val, steps in dp.items():\n        # It's possible to use the value in the arr1.\n        if a > val:\n          newDp[a] = min(newDp[a], steps)\n        # Also try the value in the arr2.\n        i = bisect_right(arr2, val)\n        if i < len(arr2):\n          newDp[arr2[i]] = min(newDp[arr2[i]], steps + 1)\n      if not newDp:\n        return -1\n      dp = newDp\n\n    return min(dp.values())\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1123, "slug": "lowest-common-ancestor-of-deepest-leaves", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def lcaDeepestLeaves(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        def dfs(root):\n            if root is None:\n                return None, 0\n            l, d1 = dfs(root.left)\n            r, d2 = dfs(root.right)\n            if d1 > d2:\n                return l, d1 + 1\n            if d1 < d2:\n                return r, d2 + 1\n            return root, d1 + 1\n\n        return dfs(root)[0]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1129, "slug": "shortest-path-with-alternating-colors", "solutions": ["class Solution:\n    def shortestAlternatingPaths(\n        self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]\n    ) -> List[int]:\n        g = [defaultdict(list), defaultdict(list)]\n        for i, j in redEdges:\n            g[0][i].append(j)\n        for i, j in blueEdges:\n            g[1][i].append(j)\n        ans = [-1] * n\n        vis = set()\n        q = deque([(0, 0), (0, 1)])\n        d = 0\n        while q:\n            for _ in range(len(q)):\n                i, c = q.popleft()\n                if ans[i] == -1:\n                    ans[i] = d\n                vis.add((i, c))\n                c ^= 1\n                for j in g[c][i]:\n                    if (j, c) not in vis:\n                        q.append((j, c))\n            d += 1\n        return ans\n", "from enum import Enum\n\n\nclass Color(Enum):\n  INIT = 0\n  RED = 1\n  BLUE = 2\n\n\nclass Solution:\n  def shortestAlternatingPaths(\n      self,\n      n: int,\n      redEdges: list[list[int]],\n      blueEdges: list[list[int]],\n  ) -> list[int]:\n    ans = [-1] * n\n    graph = [[] for _ in range(n)]  # graph[u] := [(v, edgeColor)]\n    q = collections.deque([(0, Color.INIT)])  # [(u, prevColor)]\n\n    for u, v in redEdges:\n      graph[u].append((v, Color.RED))\n\n    for u, v in blueEdges:\n      graph[u].append((v, Color.BLUE))\n\n    step = 0\n    while q:\n      for _ in range(len(q)):\n        u, prevColor = q.popleft()\n        if ans[u] == -1:\n          ans[u] = step\n        for i, (v, edgeColor) in enumerate(graph[u]):\n          if v == -1 or edgeColor == prevColor:\n            continue\n          q.append((v, edgeColor))\n          graph[u][i] = (-1, edgeColor)  # Mark (u, v) as used.\n      step += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1120, "slug": "maximum-average-subtree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maximumAverageSubtree(self, root: Optional[TreeNode]) -> float:\n        def dfs(root):\n            if root is None:\n                return 0, 0\n            ls, ln = dfs(root.left)\n            rs, rn = dfs(root.right)\n            s = root.val + ls + rs\n            n = 1 + ln + rn\n            nonlocal ans\n            ans = max(ans, s / n)\n            return s, n\n\n        ans = 0\n        dfs(root)\n        return ans\n", "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass T:\n  summ: int\n  count: int\n  maxAverage: int\n\n\nclass Solution:\n  def maximumAverageSubtree(self, root: TreeNode | None) -> float:\n    def maximumAverage(root: TreeNode | None) -> T:\n      if not root:\n        return T(0, 0, 0)\n\n      left = maximumAverage(root.left)\n      right = maximumAverage(root.right)\n\n      summ = root.val + left.summ + right.summ\n      count = 1 + left.count + right.count\n      maxAverage = max(summ / count, left.maxAverage, right.maxAverage)\n      return T(summ, count, maxAverage)\n\n    return maximumAverage(root).maxAverage\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1127, "slug": "user-purchase-platform", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1171, "slug": "remove-zero-sum-consecutive-nodes-from-linked-list", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode(next=head)\n        last = {}\n        s, cur = 0, dummy\n        while cur:\n            s += cur.val\n            last[s] = cur\n            cur = cur.next\n        s, cur = 0, dummy\n        while cur:\n            s += cur.val\n            cur.next = last[s].next\n            cur = cur.next\n        return dummy.next\n", "class Solution:\n  def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n    dummy = ListNode(0, head)\n    prefix = 0\n    prefixToNode = {0: dummy}\n\n    while head:\n      prefix += head.val\n      prefixToNode[prefix] = head\n      head = head.next\n\n    prefix = 0\n    head = dummy\n\n    while head:\n      prefix += head.val\n      head.next = prefixToNode[prefix].next\n      head = head.next\n\n    return dummy.next\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1137, "slug": "n-th-tribonacci-number", "solutions": ["class Solution:\n    def tribonacci(self, n: int) -> int:\n        a, b, c = 0, 1, 1\n        for _ in range(n):\n            a, b, c = b, c, a + b + c\n        return a\n", "class Solution:\n  def tribonacci(self, n: int) -> int:\n    if n < 2:\n      return n\n\n    dp = [0, 1, 1]\n\n    for _ in range(3, n + 1):\n      dp[0], dp[1], dp[2] = dp[1], dp[2], sum(dp)\n\n    return dp[2]\n", "class Solution:\n  def tribonacci(self, n: int) -> int:\n    dp = [0, 1, 1]\n\n    for i in range(3, n + 1):\n      dp[i % 3] = sum(dp)\n\n    return dp[n % 3]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1155, "slug": "number-of-dice-rolls-with-target-sum", "solutions": ["class Solution:\n    def numRollsToTarget(self, n: int, k: int, target: int) -> int:\n        f = [[0] * (target + 1) for _ in range(n + 1)]\n        f[0][0] = 1\n        mod = 10**9 + 7\n        for i in range(1, n + 1):\n            for j in range(1, min(i * k, target) + 1):\n                for h in range(1, min(j, k) + 1):\n                    f[i][j] = (f[i][j] + f[i - 1][j - h]) % mod\n        return f[n][target]\n", "class Solution:\n  def numRollsToTarget(self, n: int, k: int, target: int) -> int:\n    MOD = 1_000_000_007\n    dp = [1] + [0] * target\n\n    for _ in range(n):  # n dices\n      newDp = [0] * (target + 1)\n      for i in range(1, k + 1):  # numbers 1, 2, ..., f\n        for t in range(i, target + 1):  # all the possible targets\n          newDp[t] += dp[t - i]\n          newDp[t] %= MOD\n      dp = newDp\n\n    return dp[target]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1195, "slug": "fizz-buzz-multithreaded", "solutions": ["from threading import Semaphore\n\n\nclass FizzBuzz:\n  def __init__(self, n: int):\n    self.n = n\n    self.fizzSemaphore = Semaphore(0)\n    self.buzzSemaphore = Semaphore(0)\n    self.fizzbuzzSemaphore = Semaphore(0)\n    self.numberSemaphore = Semaphore(1)\n\n  # printFizz() outputs \"fizz\"\n  def fizz(self, printFizz: 'Callable[[], None]') -> None:\n    for i in range(1, self.n + 1):\n      if i % 3 == 0 and i % 15 != 0:\n        self.fizzSemaphore.acquire()\n        printFizz()\n        self.numberSemaphore.release()\n\n  # printBuzz() outputs \"buzz\"\n  def buzz(self, printBuzz: 'Callable[[], None]') -> None:\n    for i in range(1, self.n + 1):\n      if i % 5 == 0 and i % 15 != 0:\n        self.buzzSemaphore.acquire()\n        printBuzz()\n        self.numberSemaphore.release()\n\n  # printFizzBuzz() outputs \"fizzbuzz\"\n  def fizzbuzz(self, printFizzBuzz: 'Callable[[], None]') -> None:\n    for i in range(1, self.n + 1):\n      if i % 15 == 0:\n        self.fizzbuzzSemaphore.acquire()\n        printFizzBuzz()\n        self.numberSemaphore.release()\n\n  # printNumber(x) outputs \"x\", where x is an integer.\n  def number(self, printNumber: 'Callable[[int], None]') -> None:\n    for i in range(1, self.n + 1):\n      self.numberSemaphore.acquire()\n      if i % 15 == 0:\n        self.fizzbuzzSemaphore.release()\n      elif i % 3 == 0:\n        self.fizzSemaphore.release()\n      elif i % 5 == 0:\n        self.buzzSemaphore.release()\n      else:\n        printNumber(i)\n        self.numberSemaphore.release()\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1152, "slug": "analyze-user-website-visit-pattern", "solutions": ["class Solution:\n    def mostVisitedPattern(\n        self, username: List[str], timestamp: List[int], website: List[str]\n    ) -> List[str]:\n        d = defaultdict(list)\n        for user, _, site in sorted(\n            zip(username, timestamp, website), key=lambda x: x[1]\n        ):\n            d[user].append(site)\n\n        cnt = Counter()\n        for sites in d.values():\n            m = len(sites)\n            s = set()\n            if m > 2:\n                for i in range(m - 2):\n                    for j in range(i + 1, m - 1):\n                        for k in range(j + 1, m):\n                            s.add((sites[i], sites[j], sites[k]))\n            for t in s:\n                cnt[t] += 1\n        return sorted(cnt.items(), key=lambda x: (-x[1], x[0]))[0][0]\n", "class Solution:\n  def mostVisitedPattern(\n      self,\n      username: list[str],\n      timestamp: list[int],\n      website: list[str],\n  ) -> list[str]:\n    userToSites = collections.defaultdict(list)\n\n    # Sort websites of each user by timestamp.\n    for user, _, site in sorted(\n            zip(username, timestamp, website),\n            key=lambda x: x[1]):\n      userToSites[user].append(site)\n\n    # For each of three websites, count its frequency.\n    patternCount = collections.Counter()\n\n    for user, sites in userToSites.items():\n      patternCount.update(Counter(set(itertools.combinations(sites, 3))))\n\n    return max(sorted(patternCount), key=patternCount.get)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1118, "slug": "number-of-days-in-a-month", "solutions": ["class Solution:\n    def numberOfDays(self, year: int, month: int) -> int:\n        leap = (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)\n        days = [0, 31, 29 if leap else 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n        return days[month]\n", "class Solution:\n  def numberOfDays(self, year: int, month: int) -> int:\n    days = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n    def isLeapYear(year: int) -> bool:\n      return year % 4 == 0 and year % 100 != 0 or year % 400 == 0\n    return 29 if month == 2 and isLeapYear(year) else days[month]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1138, "slug": "alphabet-board-path", "solutions": ["class Solution:\n    def alphabetBoardPath(self, target: str) -> str:\n        i = j = 0\n        ans = []\n        for c in target:\n            v = ord(c) - ord(\"a\")\n            x, y = v // 5, v % 5\n            while j > y:\n                j -= 1\n                ans.append(\"L\")\n            while i > x:\n                i -= 1\n                ans.append(\"U\")\n            while j < y:\n                j += 1\n                ans.append(\"R\")\n            while i < x:\n                i += 1\n                ans.append(\"D\")\n            ans.append(\"!\")\n        return \"\".join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1144, "slug": "decrease-elements-to-make-array-zigzag", "solutions": ["class Solution:\n    def movesToMakeZigzag(self, nums: List[int]) -> int:\n        ans = [0, 0]\n        n = len(nums)\n        for i in range(2):\n            for j in range(i, n, 2):\n                d = 0\n                if j:\n                    d = max(d, nums[j] - nums[j - 1] + 1)\n                if j < n - 1:\n                    d = max(d, nums[j] - nums[j + 1] + 1)\n                ans[i] += d\n        return min(ans)\n", "class Solution:\n  def movesToMakeZigzag(self, nums: list[int]) -> int:\n    decreasing = [0] * 2\n\n    for i, num in enumerate(nums):\n      l = nums[i - 1] if i > 0 else 1001\n      r = nums[i + 1] if i + 1 < len(nums) else 1001\n      decreasing[i % 2] += max(0, num - min(l, r) + 1)\n\n    return min(decreasing[0], decreasing[1])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1173, "slug": "immediate-food-delivery-i", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1116, "slug": "print-zero-even-odd", "solutions": ["from threading import Semaphore\n\n\nclass ZeroEvenOdd:\n    def __init__(self, n):\n        self.n = n\n        self.z = Semaphore(1)\n        self.e = Semaphore(0)\n        self.o = Semaphore(0)\n\n    # printNumber(x) outputs \"x\", where x is an integer.\n    def zero(self, printNumber: 'Callable[[int], None]') -> None:\n        for i in range(self.n):\n            self.z.acquire()\n            printNumber(0)\n            if i % 2 == 0:\n                self.o.release()\n            else:\n                self.e.release()\n\n    def even(self, printNumber: 'Callable[[int], None]') -> None:\n        for i in range(2, self.n + 1, 2):\n            self.e.acquire()\n            printNumber(i)\n            self.z.release()\n\n    def odd(self, printNumber: 'Callable[[int], None]') -> None:\n        for i in range(1, self.n + 1, 2):\n            self.o.acquire()\n            printNumber(i)\n            self.z.release()\n", "from threading import Semaphore\n\n\nclass ZeroEvenOdd:\n  def __init__(self, n):\n    self.n = n\n    self.zeroSemaphore = Semaphore(1)\n    self.evenSemaphore = Semaphore(0)\n    self.oddSemaphore = Semaphore(0)\n\n  # printNumber(x) outputs \"x\", where x is an integer.\n  def zero(self, printNumber: 'Callable[[int], None]') -> None:\n    for i in range(self.n):\n      self.zeroSemaphore.acquire()\n      printNumber(0)\n      (self.oddSemaphore if i & 2 == 0 else self.evenSemaphore).release()\n\n  def even(self, printNumber: 'Callable[[int], None]') -> None:\n    for i in range(2, self.n + 1, 2):\n      self.evenSemaphore.acquire()\n      printNumber(i)\n      self.zeroSemaphore.release()\n\n  def odd(self, printNumber: 'Callable[[int], None]') -> None:\n    for i in range(1, self.n + 1, 2):\n      self.oddSemaphore.acquire()\n      printNumber(i)\n      self.zeroSemaphore.release()\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1189, "slug": "maximum-number-of-balloons", "solutions": ["class Solution:\n    def maxNumberOfBalloons(self, text: str) -> int:\n        cnt = Counter(text)\n        cnt['o'] >>= 1\n        cnt['l'] >>= 1\n        return min(cnt[c] for c in 'balon')\n", "class Solution:\n  def maxNumberOfBalloons(self, text: str) -> int:\n    count = collections.Counter(text)\n    return min(\n        count['b'],\n        count['a'],\n        count['l'] // 2, count['o'] // 2, count['n'])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1149, "slug": "article-views-ii", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1110, "slug": "delete-nodes-and-return-forest", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def delNodes(\n        self, root: Optional[TreeNode], to_delete: List[int]\n    ) -> List[TreeNode]:\n        def dfs(root: Optional[TreeNode]) -> Optional[TreeNode]:\n            if root is None:\n                return None\n            root.left, root.right = dfs(root.left), dfs(root.right)\n            if root.val not in s:\n                return root\n            if root.left:\n                ans.append(root.left)\n            if root.right:\n                ans.append(root.right)\n            return None\n\n        s = set(to_delete)\n        ans = []\n        if dfs(root):\n            ans.append(root)\n        return ans\n", "class Solution:\n  def delNodes(self, root: TreeNode, to_delete: list[int]) -> list[TreeNode]:\n    ans = []\n    toDeleteSet = set(to_delete)\n\n    def dfs(root: TreeNode, isRoot: bool) -> TreeNode:\n      if not root:\n        return None\n\n      deleted = root.val in toDeleteSet\n      if isRoot and not deleted:\n        ans.append(root)\n\n      # If root is deleted, both children have the possibility to be a new root\n      root.left = dfs(root.left, deleted)\n      root.right = dfs(root.right, deleted)\n      return None if deleted else root\n\n    dfs(root, True)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1126, "slug": "active-businesses", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1168, "slug": "optimize-water-distribution-in-a-village", "solutions": ["class Solution:\n    def minCostToSupplyWater(\n        self, n: int, wells: List[int], pipes: List[List[int]]\n    ) -> int:\n        def find(x: int) -> int:\n            if p[x] != x:\n                p[x] = find(p[x])\n            return p[x]\n\n        for i, w in enumerate(wells, 1):\n            pipes.append([0, i, w])\n        pipes.sort(key=lambda x: x[2])\n        p = list(range(n + 1))\n        ans = 0\n        for a, b, c in pipes:\n            pa, pb = find(a), find(b)\n            if pa != pb:\n                p[pa] = pb\n                n -= 1\n                ans += c\n                if n == 0:\n                    return ans\n", "class Solution:\n  def minCostToSupplyWater(\n      self,\n      n: int,\n      wells: list[int],\n      pipes: list[list[int]],\n  ) -> int:\n    ans = 0\n    graph = [[] for _ in range(n + 1)]\n    minHeap = []  # (d, u)\n\n    for u, v, w in pipes:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    # Connect virtual 0 with nodes 1 to n.\n    for i, well in enumerate(wells):\n      graph[0].append((i + 1, well))\n      heapq.heappush(minHeap, (well, i + 1))\n\n    mst = {0}\n\n    while len(mst) < n + 1:\n      d, u = heapq.heappop(minHeap)\n      if u in mst:\n        continue\n      # Add the new vertex.\n      mst.add(u)\n      ans += d\n      # Expand if possible.\n      for v, w in graph[u]:\n        if v not in mst:\n          heapq.heappush(minHeap, (w, v))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1169, "slug": "invalid-transactions", "solutions": ["class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        d = defaultdict(list)\n        idx = set()\n        for i, x in enumerate(transactions):\n            name, time, amount, city = x.split(\",\")\n            time, amount = int(time), int(amount)\n            d[name].append((time, city, i))\n            if amount > 1000:\n                idx.add(i)\n            for t, c, j in d[name]:\n                if c != city and abs(time - t) <= 60:\n                    idx.add(i)\n                    idx.add(j)\n        return [transactions[i] for i in idx]\n", "class Solution:\n  def invalidTransactions(self, transactions: list[str]) -> list[str]:\n    ans = []\n    nameToTrans = collections.defaultdict(list)\n\n    for t in transactions:\n      name, time, amount, city = t.split(',')\n      time, amount = int(time), int(amount)\n      nameToTrans[name].append({'time': time, 'city': city})\n\n    for t in transactions:\n      name, time, amount, city = t.split(',')\n      time, amount = int(time), int(amount)\n      if amount > 1000:\n        ans.append(t)\n      elif name in nameToTrans:\n        for sameName in nameToTrans[name]:\n          if abs(sameName['time'] - time) <= 60 and sameName['city'] != city:\n            ans.append(t)\n            break\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1191, "slug": "k-concatenation-maximum-sum", "solutions": ["class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        s = mx_pre = mi_pre = mx_sub = 0\n        for x in arr:\n            s += x\n            mx_pre = max(mx_pre, s)\n            mi_pre = min(mi_pre, s)\n            mx_sub = max(mx_sub, s - mi_pre)\n        ans = mx_sub\n        mod = 10**9 + 7\n        if k == 1:\n            return ans % mod\n        mx_suf = s - mi_pre\n        ans = max(ans, mx_pre + mx_suf)\n        if s > 0:\n            ans = max(ans, (k - 2) * s + mx_pre + mx_suf)\n        return ans % mod\n", "class Solution:\n  def kConcatenationMaxSum(self, arr: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    sz = len(arr) * (1 if k == 1 else 2)\n    summ = sum(arr)\n    # The concatenated array will be [arr1, arr2, ..., arrk].\n    # If sum(arr) > 0 and k > 2, then arr2, ..., arr(k - 1) should be included.\n    # Equivalently, maxSubarraySum is from arr1 and arrk.\n    if summ > 0 and k > 2:\n      return (self._kadane(arr, sz) + summ * (k - 2)) % MOD\n    return self._kadane(arr, sz) % MOD\n\n  def _kadane(self, arr: list[int], sz: int) -> int:\n    ans = 0\n    summ = 0\n    for i in range(sz):\n      a = arr[i % len(arr)]\n      summ = max(a, summ + a)\n      ans = max(ans, summ)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1114, "slug": "print-in-order", "solutions": ["class Foo:\n    def __init__(self):\n        self.l2 = threading.Lock()\n        self.l3 = threading.Lock()\n        self.l2.acquire()\n        self.l3.acquire()\n\n    def first(self, printFirst: 'Callable[[], None]') -> None:\n        printFirst()\n        self.l2.release()\n\n    def second(self, printSecond: 'Callable[[], None]') -> None:\n        self.l2.acquire()\n        printSecond()\n        self.l3.release()\n\n    def third(self, printThird: 'Callable[[], None]') -> None:\n        self.l3.acquire()\n        printThird()\n", "from threading import Lock\n\n\nclass Foo:\n  def __init__(self):\n    self.firstDone = Lock()\n    self.secondDone = Lock()\n    self.firstDone.acquire()\n    self.secondDone.acquire()\n\n  def first(self, printFirst: 'Callable[[], None]') -> None:\n    printFirst()\n    self.firstDone.release()\n\n  def second(self, printSecond: 'Callable[[], None]') -> None:\n    self.firstDone.acquire()\n    printSecond()\n    self.secondDone.release()\n\n  def third(self, printThird: 'Callable[[], None]') -> None:\n    self.secondDone.acquire()\n    printThird()\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1119, "slug": "remove-vowels-from-a-string", "solutions": ["class Solution:\n    def removeVowels(self, s: str) -> str:\n        return \"\".join(c for c in s if c not in \"aeiou\")\n", "class Solution:\n  def removeVowels(self, s: str) -> str:\n    return re.sub('a|e|i|o|u', '', s)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1164, "slug": "product-price-at-a-given-date", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1163, "slug": "last-substring-in-lexicographical-order", "solutions": ["class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i, j, k = 0, 1, 0\n        while j + k < len(s):\n            if s[i + k] == s[j + k]:\n                k += 1\n            elif s[i + k] < s[j + k]:\n                i += k + 1\n                k = 0\n                if i >= j:\n                    j = i + 1\n            else:\n                j += k + 1\n                k = 0\n        return s[i:]\n", "class Solution:\n  def lastSubstring(self, s: str) -> str:\n    i = 0\n    j = 1\n    k = 0  # the number of the same letters of s[i..n) and s[j..n)\n\n    while j + k < len(s):\n      if s[i + k] == s[j + k]:\n        k += 1\n      elif s[i + k] > s[j + k]:\n        # Skip s[j..j + k) and advance to s[j + k + 1] to find a possible\n        # lexicographically larger substring since s[i..i + k) == s[j..j + k)\n        # and s[i + k] > s[j + k).\n        j = j + k + 1\n        k = 0\n      else:\n        # Skip s[i..i + k) and advance to s[i + k + 1] or s[j] to find a\n        # possible lexicographically larger substring since\n        # s[i..i + k) == s[j..j + k) and s[i + k] < s[j + k).\n        # Note that it's unnecessary to explore s[i + k + 1..j) if\n        # i + k + 1 < j since they are already explored by j.\n        i = max(i + k + 1, j)\n        j = i + 1\n        k = 0\n\n    return s[i:]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1159, "slug": "market-analysis-ii", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1112, "slug": "highest-grade-for-each-student", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1107, "slug": "new-users-daily-count", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1109, "slug": "corporate-flight-bookings", "solutions": ["class Solution:\n    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:\n        ans = [0] * n\n        for first, last, seats in bookings:\n            ans[first - 1] += seats\n            if last < n:\n                ans[last] -= seats\n        return list(accumulate(ans))\n", "class Solution:\n  def corpFlightBookings(self, bookings: list[list[int]], n: int) -> list[int]:\n    ans = [0] * n\n\n    for booking in bookings:\n      ans[booking[0] - 1] += booking[2]\n      if booking[1] < n:\n        ans[booking[1]] -= booking[2]\n\n    for i in range(1, n):\n      ans[i] += ans[i - 1]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1140, "slug": "stone-game-ii", "solutions": ["class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        @cache\n        def dfs(i, m):\n            if m * 2 >= n - i:\n                return s[n] - s[i]\n            return max(\n                s[n] - s[i] - dfs(i + x, max(m, x)) for x in range(1, m << 1 | 1)\n            )\n\n        n = len(piles)\n        s = list(accumulate(piles, initial=0))\n        return dfs(0, 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1196, "slug": "how-many-apples-can-you-put-into-the-basket", "solutions": ["class Solution:\n    def maxNumberOfApples(self, weight: List[int]) -> int:\n        weight.sort()\n        s = 0\n        for i, x in enumerate(weight):\n            s += x\n            if s > 5000:\n                return i\n        return len(weight)\n", "class Solution:\n  def maxNumberOfApples(self, weight: list[int]) -> int:\n    summ = 0\n\n    for i, w in enumerate(sorted(weight)):\n      summ += w\n      if summ > 5000:\n        return i\n\n    return len(weight)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1106, "slug": "parsing-a-boolean-expression", "solutions": ["class Solution:\n    def parseBoolExpr(self, expression: str) -> bool:\n        stk = []\n        for c in expression:\n            if c in 'tf!&|':\n                stk.append(c)\n            elif c == ')':\n                t = f = 0\n                while stk[-1] in 'tf':\n                    t += stk[-1] == 't'\n                    f += stk[-1] == 'f'\n                    stk.pop()\n                match stk.pop():\n                    case '!':\n                        c = 't' if f else 'f'\n                    case '&':\n                        c = 'f' if f else 't'\n                    case '|':\n                        c = 't' if t else 'f'\n                stk.append(c)\n        return stk[0] == 't'\n", "class Solution:\n  def parseBoolExpr(self, expression: str) -> bool:\n    def dfs(s: int, e: int) -> list[str]:\n      if s == e:\n        return True if expression[s] == 't' else False\n\n      exps = []\n      layer = 0\n\n      for i in range(s, e + 1):\n        c = expression[i]\n        if layer == 0 and c in '!&|':\n          op = c\n        elif c == '(':\n          layer += 1\n          if layer == 1:\n            left = i + 1\n        elif c == ')':\n          layer -= 1\n          if layer == 0:\n            exps.append(dfs(left, i - 1))\n        elif c == ',' and layer == 1:\n          exps.append(dfs(left, i - 1))\n          left = i + 1\n\n      if op == '|':\n        return functools.reduce(operator.or_, exps)\n      if op == '&':\n        return functools.reduce(operator.and_, exps)\n      if op == '!':\n        return not exps[0]\n\n    return dfs(0, len(expression) - 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1199, "slug": "minimum-time-to-build-blocks", "solutions": ["class Solution:\n    def minBuildTime(self, blocks: List[int], split: int) -> int:\n        heapify(blocks)\n        while len(blocks) > 1:\n            heappop(blocks)\n            heappush(blocks, heappop(blocks) + split)\n        return blocks[0]\n", "class Solution:\n  def minBuildTime(self, blocks: list[int], split: int) -> int:\n    minHeap = blocks.copy()\n    heapify(minHeap)\n\n    while len(minHeap) > 1:\n      heapq.heappop(minHeap)  # the minimum\n      x = heapq.heappop(minHeap)  # the second minimum\n      heapq.heappush(minHeap, x + split)\n\n    return minHeap[0]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1148, "slug": "article-views-i", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1134, "slug": "armstrong-number", "solutions": ["class Solution:\n    def isArmstrong(self, n: int) -> bool:\n        k = len(str(n))\n        s, x = 0, n\n        while x:\n            s += (x % 10) ** k\n            x //= 10\n        return s == n\n", "class Solution:\n  def isArmstrong(self, n: int) -> bool:\n    s = str(n)\n    k = len(s)\n    return sum(pow(int(c), k) for c in s) == n\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1113, "slug": "reported-posts", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1177, "slug": "can-make-palindrome-from-substring", "solutions": ["class Solution:\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n        n = len(s)\n        ss = [[0] * 26 for _ in range(n + 1)]\n        for i, c in enumerate(s, 1):\n            ss[i] = ss[i - 1][:]\n            ss[i][ord(c) - ord(\"a\")] += 1\n        ans = []\n        for l, r, k in queries:\n            cnt = sum((ss[r + 1][j] - ss[l][j]) & 1 for j in range(26))\n            ans.append(cnt // 2 <= k)\n        return ans\n", "class Solution:\n  def canMakePaliQueries(self, s: str, queries: list[list[int]]) -> list[bool]:\n    dp = [0] * (len(s) + 1)\n\n    for i in range(1, len(s) + 1):\n      dp[i] = dp[i - 1] ^ 1 << ord(s[i - 1]) - ord('a')\n\n    return [\n        (dp[right + 1] ^ dp[left]).bit_count() // 2 <= k\n        for left, right, k in queries\n    ]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1198, "slug": "find-smallest-common-element-in-all-rows", "solutions": ["class Solution:\n    def smallestCommonElement(self, mat: List[List[int]]) -> int:\n        cnt = Counter()\n        for row in mat:\n            for x in row:\n                cnt[x] += 1\n                if cnt[x] == len(mat):\n                    return x\n        return -1\n", "class Solution:\n  def smallestCommonElement(self, mat: list[list[int]]) -> int:\n    MAX = 10000\n    count = [0] * (MAX + 1)\n\n    for row in mat:\n      for a in row:\n        count[a] += 1\n        if count[a] == len(mat):\n          return a\n\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1193, "slug": "monthly-transactions-i", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1103, "slug": "distribute-candies-to-people", "solutions": ["class Solution:\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\n        ans = [0] * num_people\n        i = 0\n        while candies:\n            ans[i % num_people] += min(candies, i + 1)\n            candies -= min(candies, i + 1)\n            i += 1\n        return ans\n", "class Solution:\n  def distributeCandies(self, candies: int, n: int) -> list[int]:\n    ans = [0] * n\n    rows = int((-n + (n**2 + 8 * n**2 * candies)**0.5) / (2 * n**2))\n    accumN = rows * (rows - 1) * n // 2\n\n    for i in range(n):\n      ans[i] = accumN + rows * (i + 1)\n\n    givenCandies = (n**2 * rows**2 + n * rows) // 2\n    candies -= givenCandies\n    lastGiven = rows * n\n    i = 0\n\n    while candies > 0:\n      lastGiven += 1\n      actualGiven = min(lastGiven, candies)\n      candies -= actualGiven\n      ans[i] += actualGiven\n      i += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1132, "slug": "reported-posts-ii", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1160, "slug": "find-words-that-can-be-formed-by-characters", "solutions": ["class Solution:\n    def countCharacters(self, words: List[str], chars: str) -> int:\n        cnt = Counter(chars)\n        ans = 0\n        for w in words:\n            wc = Counter(w)\n            if all(cnt[c] >= v for c, v in wc.items()):\n                ans += len(w)\n        return ans\n", "class Solution:\n  def countCharacters(self, words: list[str], chars: str) -> int:\n    ans = 0\n    count = collections.Counter(chars)\n\n    for word in words:\n      tempCount = count.copy()\n      for c in word:\n        tempCount[c] -= 1\n        if tempCount[c] < 0:\n          ans -= len(word)\n          break\n      ans += len(word)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1183, "slug": "maximum-number-of-ones", "solutions": ["class Solution:\n    def maximumNumberOfOnes(\n        self, width: int, height: int, sideLength: int, maxOnes: int\n    ) -> int:\n        x = sideLength\n        cnt = [0] * (x * x)\n        for i in range(width):\n            for j in range(height):\n                k = (i % x) * x + (j % x)\n                cnt[k] += 1\n        cnt.sort(reverse=True)\n        return sum(cnt[:maxOnes])\n", "class Solution:\n  def maximumNumberOfOnes(\n      self,\n      width: int,\n      height: int,\n      sideLength: int,\n      maxOnes: int,\n  ) -> int:\n    submatrix = [[0] * sideLength for _ in range(sideLength)]\n\n    for i in range(width):\n      for j in range(height):\n        submatrix[i % sideLength][j % sideLength] += 1\n\n    return sum(heapq.nlargest(maxOnes, [a for row in submatrix for a in row]))\n", "class Solution:\n  def maximumNumberOfOnes(\n      self,\n      width: int,\n      height: int,\n      sideLength: int,\n      maxOnes: int,\n  ) -> int:\n    subCount = []\n\n    def getCount(length: int, index: int) -> int:\n      return (length - index - 1) // sideLength + 1\n\n    for i in range(sideLength):\n      for j in range(sideLength):\n        subCount.append(getCount(width, i) * getCount(height, j))\n\n    return sum(sorted(subCount, reverse=True)[:maxOnes])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2386, "slug": "find-the-k-sum-of-an-array", "solutions": ["class Solution:\n    def kSum(self, nums: List[int], k: int) -> int:\n        mx = 0\n        for i, x in enumerate(nums):\n            if x > 0:\n                mx += x\n            else:\n                nums[i] = -x\n        nums.sort()\n        h = [(0, 0)]\n        for _ in range(k - 1):\n            s, i = heappop(h)\n            if i < len(nums):\n                heappush(h, (s + nums[i], i + 1))\n                if i:\n                    heappush(h, (s + nums[i] - nums[i - 1], i + 1))\n        return mx - h[0][0]\n", "class Solution:\n  def kSum(self, nums: list[int], k: int) -> int:\n    maxSum = sum(num for num in nums if num > 0)\n    absNums = sorted(abs(num) for num in nums)\n    # (the next maximum sum, the next index i)\n    maxHeap = [(-(maxSum - absNums[0]), 0)]\n    nextMaxSum = maxSum\n\n    for _ in range(k - 1):\n      nextMaxSum, i = heapq.heappop(maxHeap)\n      nextMaxSum *= -1\n      if i + 1 < len(absNums):\n        heapq.heappush(maxHeap, (-(nextMaxSum - absNums[i + 1]), i + 1))\n        heapq.heappush(\n            maxHeap, (-(nextMaxSum - absNums[i + 1] + absNums[i]), i + 1))\n\n    return nextMaxSum\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2363, "slug": "merge-similar-items", "solutions": ["class Solution:\n    def mergeSimilarItems(\n        self, items1: List[List[int]], items2: List[List[int]]\n    ) -> List[List[int]]:\n        cnt = Counter()\n        for v, w in chain(items1, items2):\n            cnt[v] += w\n        return sorted(cnt.items())\n", "class Solution:\n  def mergeSimilarItems(self, items1: list[list[int]],\n                        items2: list[list[int]]) -> list[list[int]]:\n    return sorted(\n        (Counter(dict(items1)) + collections.Counter(dict(items2))).items())\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2335, "slug": "minimum-amount-of-time-to-fill-cups", "solutions": ["class Solution:\n    def fillCups(self, amount: List[int]) -> int:\n        ans = 0\n        while sum(amount):\n            amount.sort()\n            ans += 1\n            amount[2] -= 1\n            amount[1] = max(0, amount[1] - 1)\n        return ans\n", "class Solution:\n  def fillCups(self, amount: list[int]) -> int:\n    return max(max(amount), (sum(amount) + 1) // 2)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2343, "slug": "query-kth-smallest-trimmed-number", "solutions": ["class Solution:\n    def smallestTrimmedNumbers(\n        self, nums: List[str], queries: List[List[int]]\n    ) -> List[int]:\n        ans = []\n        for k, trim in queries:\n            t = sorted((v[-trim:], i) for i, v in enumerate(nums))\n            ans.append(t[k - 1][1])\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2331, "slug": "evaluate-boolean-binary-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\n        if root.left is None:\n            return bool(root.val)\n        op = or_ if root.val == 2 else and_\n        return op(self.evaluateTree(root.left), self.evaluateTree(root.right))\n", "class Solution:\n  def evaluateTree(self, root: TreeNode | None) -> bool:\n    if root.val < 2:\n      return root.val\n    if root.val == 2:  # OR\n      return self.evaluateTree(root.left) or self.evaluateTree(root.right)\n    # AND\n    return self.evaluateTree(root.left) and self.evaluateTree(root.right)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2322, "slug": "minimum-score-after-removals-on-a-tree", "solutions": ["class Solution:\n    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\n        def dfs(i, fa, x):\n            res = nums[i]\n            for j in g[i]:\n                if j != fa and j != x:\n                    res ^= dfs(j, i, x)\n            return res\n\n        def dfs2(i, fa, x):\n            nonlocal s, s1, ans\n            res = nums[i]\n            for j in g[i]:\n                if j != fa and j != x:\n                    a = dfs2(j, i, x)\n                    res ^= a\n                    b = s1 ^ a\n                    c = s ^ s1\n                    t = max(a, b, c) - min(a, b, c)\n                    ans = min(ans, t)\n            return res\n\n        g = defaultdict(list)\n        for a, b in edges:\n            g[a].append(b)\n            g[b].append(a)\n\n        s = 0\n        for v in nums:\n            s ^= v\n        n = len(nums)\n        ans = inf\n        for i in range(n):\n            for j in g[i]:\n                s1 = dfs(i, -1, j)\n                dfs2(i, -1, j)\n        return ans\n", "class Solution:\n  def minimumScore(self, nums: list[int], edges: list[list[int]]) -> int:\n    n = len(nums)\n    xors = functools.reduce(operator.xor, nums)\n    subXors = nums[:]\n    tree = [[] for _ in range(n)]\n    children = [{i} for i in range(n)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, prev: int) -> tuple[int, set[int]]:\n      for v in tree[u]:\n        if v == prev:\n          continue\n        vXor, vChildren = dfs(v, u)\n        subXors[u] ^= vXor\n        children[u] |= vChildren\n      return subXors[u], children[u]\n\n    dfs(0, -1)\n\n    ans = math.inf\n    for i in range(len(edges)):\n      a, b = edges[i]\n      if b in children[a]:\n        a, b = b, a\n      for j in range(i):\n        c, d = edges[j]\n        if d in children[c]:\n          c, d = d, c\n\n        if c in children[a] and a != c:\n          cands = [subXors[c], subXors[a] ^ subXors[c], xors ^ subXors[a]]\n        elif a in children[c] and a != c:\n          cands = [subXors[a], subXors[c] ^ subXors[a], xors ^ subXors[c]]\n        else:\n          cands = [subXors[a], subXors[c], xors ^ subXors[a] ^ subXors[c]]\n        ans = min(ans, max(cands) - min(cands))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2347, "slug": "best-poker-hand", "solutions": ["class Solution:\n    def bestHand(self, ranks: List[int], suits: List[str]) -> str:\n        # if len(set(suits)) == 1:\n        if all(a == b for a, b in pairwise(suits)):\n            return 'Flush'\n        cnt = Counter(ranks)\n        if any(v >= 3 for v in cnt.values()):\n            return 'Three of a Kind'\n        if any(v == 2 for v in cnt.values()):\n            return 'Pair'\n        return 'High Card'\n", "class Solution:\n  def bestHand(self, ranks: list[int], suits: list[str]) -> str:\n    if all(suit == suits[0] for suit in suits):\n      return 'Flush'\n\n    match max(Counter(ranks).values()):\n      case 5 | 4 | 3:\n        return 'Three of a Kind'\n      case 2:\n        return 'Pair'\n      case _:\n        return 'High Card'\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2342, "slug": "max-sum-of-a-pair-with-equal-sum-of-digits", "solutions": ["class Solution:\n    def maximumSum(self, nums: List[int]) -> int:\n        d = defaultdict(int)\n        ans = -1\n        for v in nums:\n            x, y = 0, v\n            while y:\n                x += y % 10\n                y //= 10\n            if x in d:\n                ans = max(ans, d[x] + v)\n            d[x] = max(d[x], v)\n        return ans\n", "class Solution:\n  def maximumSum(self, nums: list[int]) -> int:\n    MAX = 9 * 9  # 999,999,999\n    ans = -1\n    count = [[] for _ in range(MAX + 1)]\n\n    for num in nums:\n      count[self._getDigitSum(num)].append(num)\n\n    for groupNums in count:\n      if len(groupNums) < 2:\n        continue\n      groupNums.sort(reverse=True)\n      ans = max(ans, groupNums[0] + groupNums[1])\n\n    return ans\n\n  def _getDigitSum(self, num: int) -> int:\n    return sum(int(digit) for digit in str(num))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2353, "slug": "design-a-food-rating-system", "solutions": ["class FoodRatings:\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\n        self.d = defaultdict(SortedList)\n        self.g = {}\n        for food, cuisine, rating in zip(foods, cuisines, ratings):\n            self.d[cuisine].add((-rating, food))\n            self.g[food] = (rating, cuisine)\n\n    def changeRating(self, food: str, newRating: int) -> None:\n        oldRating, cuisine = self.g[food]\n        self.g[food] = (newRating, cuisine)\n        self.d[cuisine].remove((-oldRating, food))\n        self.d[cuisine].add((-newRating, food))\n\n    def highestRated(self, cuisine: str) -> str:\n        return self.d[cuisine][0][1]\n\n\n# Your FoodRatings object will be instantiated and called as such:\n# obj = FoodRatings(foods, cuisines, ratings)\n# obj.changeRating(food,newRating)\n# param_2 = obj.highestRated(cuisine)\n", "from sortedcontainers import SortedSet\n\n\nclass FoodRatings:\n  def __init__(self, foods: list[str], cuisines: list[str], ratings: list[int]):\n    self.cuisineToRatingAndFoods = collections.defaultdict(\n        lambda: SortedSet(key=lambda x: (-x[0], x[1])))\n    self.foodToCuisine = {}\n    self.foodToRating = {}\n\n    for food, cuisine, rating in zip(foods, cuisines, ratings):\n      self.cuisineToRatingAndFoods[cuisine].add((rating, food))\n      self.foodToCuisine[food] = cuisine\n      self.foodToRating[food] = rating\n\n  def changeRating(self, food: str, newRating: int) -> None:\n    cuisine = self.foodToCuisine[food]\n    oldRating = self.foodToRating[food]\n    ratingAndFoods = self.cuisineToRatingAndFoods[cuisine]\n    ratingAndFoods.remove((oldRating, food))\n    ratingAndFoods.add((newRating, food))\n    self.foodToRating[food] = newRating\n\n  def highestRated(self, cuisine: str) -> str:\n    return self.cuisineToRatingAndFoods[cuisine][0][1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2309, "slug": "greatest-english-letter-in-upper-and-lower-case", "solutions": ["class Solution:\n    def greatestLetter(self, s: str) -> str:\n        ss = set(s)\n        for c in ascii_uppercase[::-1]:\n            if c in ss and c.lower() in ss:\n                return c\n        return ''\n", "class Solution:\n  def greatestLetter(self, s: str) -> str:\n    seen = set(s)\n\n    for i in range(25, -1, -1):\n      if (chr(ord('a') + i) in seen and\n              chr(ord('A') + i) in seen):\n        return chr(ord('A') + i)\n\n    return ''\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2385, "slug": "amount-of-time-for-binary-tree-to-be-infected", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\n        def dfs(node: Optional[TreeNode], fa: Optional[TreeNode]):\n            if node is None:\n                return\n            if fa:\n                g[node.val].append(fa.val)\n                g[fa.val].append(node.val)\n            dfs(node.left, node)\n            dfs(node.right, node)\n\n        def dfs2(node: int, fa: int) -> int:\n            ans = 0\n            for nxt in g[node]:\n                if nxt != fa:\n                    ans = max(ans, 1 + dfs2(nxt, node))\n            return ans\n\n        g = defaultdict(list)\n        dfs(root, None)\n        return dfs2(start, -1)\n", "class Solution:\n  def amountOfTime(self, root: TreeNode | None, start: int) -> int:\n    ans = -1\n    graph = self._getGraph(root)\n    q = collections.deque([start])\n    seen = {start}\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        u = q.popleft()\n        if u not in graph:\n          continue\n        for v in graph[u]:\n          if v in seen:\n            continue\n          q.append(v)\n          seen.add(v)\n\n    return ans\n\n  def _getGraph(self, root: TreeNode | None) -> dict[int, list[int]]:\n    graph = collections.defaultdict(list)\n    q = collections.deque([(root, -1)])  # (node, parent)\n\n    while q:\n      node, parent = q.popleft()\n      if parent != -1:\n        graph[parent].append(node.val)\n        graph[node.val].append(parent)\n      if node.left:\n        q.append((node.left, node.val))\n      if node.right:\n        q.append((node.right, node.val))\n\n    return graph\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2352, "slug": "equal-row-and-column-pairs", "solutions": ["class Solution:\n    def equalPairs(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        ans = 0\n        for i in range(n):\n            for j in range(n):\n                ans += all(grid[i][k] == grid[k][j] for k in range(n))\n        return ans\n", "class Solution:\n  def equalPairs(self, grid: list[list[int]]) -> int:\n    n = len(grid)\n    ans = 0\n\n    for i in range(n):\n      for j in range(n):\n        k = 0\n        while k < n:\n          if grid[i][k] != grid[k][j]:\n            break\n          k += 1\n        if k == n:  # R[i] == C[j]\n          ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2339, "slug": "all-the-matches-of-the-league", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2345, "slug": "finding-the-number-of-visible-mountains", "solutions": ["class Solution:\n    def visibleMountains(self, peaks: List[List[int]]) -> int:\n        arr = [(x - y, x + y) for x, y in peaks]\n        cnt = Counter(arr)\n        arr.sort(key=lambda x: (x[0], -x[1]))\n        ans, cur = 0, -inf\n        for l, r in arr:\n            if r <= cur:\n                continue\n            cur = r\n            if cnt[(l, r)] == 1:\n                ans += 1\n        return ans\n", "class Solution:\n  def visibleMountains(self, peaks: list[list[int]]) -> int:\n    count = collections.Counter((x, y) for x, y in peaks)\n    peaks = sorted([k for k, v in count.items() if v == 1])\n    stack = []\n\n    # Returns True if `peak1` is hidden by `peak2`\n    def isHidden(peak1: list[int], peak2: list[int]) -> bool:\n      x1, y1 = peak1\n      x2, y2 = peak2\n      return x1 - y1 >= x2 - y2 and x1 + y1 <= x2 + y2\n\n    for i, peak in enumerate(peaks):\n      while stack and isHidden(peaks[stack[-1]], peak):\n        stack.pop()\n      if stack and isHidden(peak, peaks[stack[-1]]):\n        continue\n      stack.append(i)\n\n    return len(stack)\n", "class Solution:\n  def visibleMountains(self, peaks: list[list[int]]) -> int:\n    ans = 0\n    maxRightFoot = 0\n\n    peaks.sort(key=lambda x: (x[0] - x[1], -x[0]))\n\n    for i, peak in enumerate(peaks):\n      overlapWithNext = i + 1 < len(peaks) and peak == peaks[i + 1]\n      currRightFoot = peak[0] + peak[1]\n      if currRightFoot > maxRightFoot:\n        if not overlapWithNext:\n          ans += 1\n        maxRightFoot = currRightFoot\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2357, "slug": "make-array-zero-by-subtracting-equal-amounts", "solutions": ["class Solution:\n    def minimumOperations(self, nums: List[int]) -> int:\n        return len({x for x in nums if x})\n", "class Solution:\n  def minimumOperations(self, nums: list[int]) -> int:\n    return len(set(nums) - {0})\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2391, "slug": "minimum-amount-of-time-to-collect-garbage", "solutions": ["class Solution:\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\n        last = {}\n        ans = 0\n        for i, s in enumerate(garbage):\n            ans += len(s)\n            for c in s:\n                last[c] = i\n        ts = 0\n        for i, t in enumerate(travel, 1):\n            ts += t\n            ans += sum(ts for j in last.values() if i == j)\n        return ans\n", "class Solution:\n  def garbageCollection(self, garbage: list[str], travel: list[int]) -> int:\n    prefix = list(itertools.accumulate(travel))\n\n    def getTime(c: str) -> int:\n      characterCount = 0\n      lastIndex = -1\n      for i, s in enumerate(garbage):\n        if any(g == c for g in s):\n          lastIndex = i\n        characterCount += s.count(c)\n      return characterCount + (0 if lastIndex <= 0 else prefix[lastIndex - 1])\n\n    return getTime('M') + getTime('P') + getTime('G')\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2359, "slug": "find-closest-node-to-given-two-nodes", "solutions": ["class Solution:\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        def dijkstra(i):\n            dist = [inf] * n\n            dist[i] = 0\n            q = [(0, i)]\n            while q:\n                i = heappop(q)[1]\n                for j in g[i]:\n                    if dist[j] > dist[i] + 1:\n                        dist[j] = dist[i] + 1\n                        heappush(q, (dist[j], j))\n            return dist\n\n        g = defaultdict(list)\n        for i, j in enumerate(edges):\n            if j != -1:\n                g[i].append(j)\n        n = len(edges)\n        d1 = dijkstra(node1)\n        d2 = dijkstra(node2)\n        ans, d = -1, inf\n        for i, (a, b) in enumerate(zip(d1, d2)):\n            if (t := max(a, b)) < d:\n                d = t\n                ans = i\n        return ans\n", "class Solution:\n  def closestMeetingNode(self, edges: list[int], node1: int, node2: int) -> int:\n    MAX = 10000\n    dist1 = self._getDist(edges, node1)\n    dist2 = self._getDist(edges, node2)\n    minDist = MAX\n    ans = -1\n\n    for i, (d1, d2) in enumerate(zip(dist1, dist2)):\n      if min(d1, d2) >= 0:\n        maxDist = max(d1, d2)\n        if maxDist < minDist:\n          minDist = maxDist\n          ans = i\n\n    return ans\n\n  def _getDist(self, edges: list[int], u: int) -> list[int]:\n    dist = [-1] * len(edges)\n    d = 0\n    while u != -1 and dist[u] == -1:\n      dist[u] = d\n      d += 1\n      u = edges[u]\n    return dist\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2392, "slug": "build-a-matrix-with-conditions", "solutions": ["class Solution:\n    def buildMatrix(\n        self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]\n    ) -> List[List[int]]:\n        def f(cond):\n            g = defaultdict(list)\n            indeg = [0] * (k + 1)\n            for a, b in cond:\n                g[a].append(b)\n                indeg[b] += 1\n            q = deque([i for i, v in enumerate(indeg[1:], 1) if v == 0])\n            res = []\n            while q:\n                for _ in range(len(q)):\n                    i = q.popleft()\n                    res.append(i)\n                    for j in g[i]:\n                        indeg[j] -= 1\n                        if indeg[j] == 0:\n                            q.append(j)\n            return None if len(res) != k else res\n\n        row = f(rowConditions)\n        col = f(colConditions)\n        if row is None or col is None:\n            return []\n        ans = [[0] * k for _ in range(k)]\n        m = [0] * (k + 1)\n        for i, v in enumerate(col):\n            m[v] = i\n        for i, v in enumerate(row):\n            ans[i][m[v]] = v\n        return ans\n", "class Solution:\n  def buildMatrix(self, k: int, rowConditions: list[list[int]],\n                  colConditions: list[list[int]]) -> list[list[int]]:\n    rowOrder = self._topologicalSort(rowConditions, k)\n    if not rowOrder:\n      return []\n\n    colOrder = self._topologicalSort(colConditions, k)\n    if not colOrder:\n      return []\n\n    ans = [[0] * k for _ in range(k)]\n    nodeToRowIndex = [0] * (k + 1)\n\n    for i, node in enumerate(rowOrder):\n      nodeToRowIndex[node] = i\n\n    for j, node in enumerate(colOrder):\n      i = nodeToRowIndex[node]\n      ans[i][j] = node\n\n    return ans\n\n  def _topologicalSort(self, conditions: list[list[int]], n: int) -> list[int]:\n    order = []\n    graph = [[] for _ in range(n + 1)]\n    inDegrees = [0] * (n + 1)\n\n    # Build the graph.\n    for u, v in conditions:\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    # Perform topological sorting.\n    q = collections.deque([i for i in range(1, n + 1) if inDegrees[i] == 0])\n\n    while q:\n      u = q.popleft()\n      order.append(u)\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    return order if len(order) == n else []\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2328, "slug": "number-of-increasing-paths-in-a-grid", "solutions": ["class Solution:\n    def countPaths(self, grid: List[List[int]]) -> int:\n        @cache\n        def dfs(i: int, j: int) -> int:\n            ans = 1\n            for a, b in pairwise((-1, 0, 1, 0, -1)):\n                x, y = i + a, j + b\n                if 0 <= x < m and 0 <= y < n and grid[i][j] < grid[x][y]:\n                    ans = (ans + dfs(x, y)) % mod\n            return ans\n\n        mod = 10**9 + 7\n        m, n = len(grid), len(grid[0])\n        return sum(dfs(i, j) for i in range(m) for j in range(n)) % mod\n", "class Solution:\n  def countPaths(self, grid: list[list[int]]) -> int:\n    MOD = 1_000_000_007\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int) -> int:\n      \"\"\"Returns the number of increasing paths starting from (i, j).\"\"\"\n      ans = 1  # The current cell contributes 1 length.\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if grid[x][y] <= grid[i][j]:\n          continue\n        ans += dp(x, y)\n        ans %= MOD\n      return ans\n\n    return sum(dp(i, j)\n               for i in range(m)\n               for j in range(n)) % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2317, "slug": "maximum-xor-after-operations", "solutions": ["class Solution:\n    def maximumXOR(self, nums: List[int]) -> int:\n        return reduce(or_, nums)\n", "class Solution:\n  def maximumXOR(self, nums: list[int]) -> int:\n    # 1. nums[i] & (nums[i] ^ x) enables you to turn 1-bit to 0-bit from\n    #    nums[i] since x is arbitrary.\n    # 2. The i-th bit of the XOR of all the elements is 1 if the i-th bit is 1\n    #    for an odd number of elements.\n    # 3. Therefore, the question is equivalent to: if you can convert any digit\n    #    from 1 to 0 for any number, what is the maximum for XOR(nums[i]).\n    # 4. The maximum we can get is of course to make every digit of the answer\n    #    to be 1 if possible\n    # 5. Therefore, OR(nums[i]) is an approach.\n    return functools.reduce(operator.ior, nums)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2348, "slug": "number-of-zero-filled-subarrays", "solutions": ["class Solution:\n    def zeroFilledSubarray(self, nums: List[int]) -> int:\n        ans = cnt = 0\n        for v in nums:\n            cnt = 0 if v else cnt + 1\n            ans += cnt\n        return ans\n", "class Solution:\n  def zeroFilledSubarray(self, nums: list[int]) -> int:\n    ans = 0\n    indexBeforeZero = -1\n\n    for i, num in enumerate(nums):\n      if num:\n        indexBeforeZero = i\n      else:\n        ans += i - indexBeforeZero\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2367, "slug": "number-of-arithmetic-triplets", "solutions": ["class Solution:\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\n        return sum(b - a == diff and c - b == diff for a, b, c in combinations(nums, 3))\n", "class Solution:\n  def arithmeticTriplets(self, nums: list[int], diff: int) -> int:\n    MAX = 200\n    ans = 0\n    count = [False] * (MAX + 1)\n\n    for num in nums:\n      if num >= 2 * diff and count[num - diff] and count[num - 2 * diff]:\n        ans += 1\n      count[num] = True\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2399, "slug": "check-distances-between-same-letters", "solutions": ["class Solution:\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\n        d = defaultdict(int)\n        for i, c in enumerate(map(ord, s), 1):\n            j = c - ord(\"a\")\n            if d[j] and i - d[j] - 1 != distance[j]:\n                return False\n            d[j] = i\n        return True\n", "class Solution:\n  def checkDistances(self, s: str, distance: list[int]) -> bool:\n    firstSeenIndex = [-1] * 26\n\n    for i, c in enumerate(s):\n      j = ord(c) - ord('a')\n      prevIndex = firstSeenIndex[j]\n      if prevIndex != -1 and i - prevIndex - 1 != distance[j]:\n        return False\n      firstSeenIndex[j] = i\n\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2329, "slug": "product-sales-analysis-v", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2381, "slug": "shifting-letters-ii", "solutions": ["class Solution:\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\n        n = len(s)\n        d = [0] * (n + 1)\n        for i, j, v in shifts:\n            if v == 0:\n                v = -1\n            d[i] += v\n            d[j + 1] -= v\n        for i in range(1, n + 1):\n            d[i] += d[i - 1]\n        return ''.join(\n            chr(ord('a') + (ord(s[i]) - ord('a') + d[i] + 26) % 26) for i in range(n)\n        )\n", "class Solution:\n  def shiftingLetters(self, s: str, shifts: list[list[int]]) -> str:\n    ans = []\n    currShift = 0\n    timeline = [0] * (len(s) + 1)\n\n    for start, end, direction in shifts:\n      diff = 1 if direction else -1\n      timeline[start] += diff\n      timeline[end + 1] -= diff\n\n    for i, c in enumerate(s):\n      currShift = (currShift + timeline[i]) % 26\n      num = (ord(c) - ord('a') + currShift + 26) % 26\n      ans.append(chr(ord('a') + num))\n\n    return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2300, "slug": "successful-pairs-of-spells-and-potions", "solutions": ["class Solution:\n    def successfulPairs(\n        self, spells: List[int], potions: List[int], success: int\n    ) -> List[int]:\n        potions.sort()\n        m = len(potions)\n        return [m - bisect_left(potions, success / v) for v in spells]\n", "class Solution:\n  def successfulPairs(\n      self,\n      spells: list[int],\n      potions: list[int],\n      success: int,\n  ) -> list[int]:\n    potions.sort()\n\n    def firstIndexSuccess(spell: int):\n      \"\"\"Returns the first index i s.t. spell * potions[i] >= success.\"\"\"\n      l = 0\n      r = len(potions)\n      while l < r:\n        m = (l + r) // 2\n        if spell * potions[m] >= success:\n          r = m\n        else:\n          l = m + 1\n      return l\n\n    return [len(potions) - firstIndexSuccess(spell) for spell in spells]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2373, "slug": "largest-local-values-in-a-matrix", "solutions": ["class Solution:\n    def largestLocal(self, grid: List[List[int]]) -> List[List[int]]:\n        n = len(grid)\n        ans = [[0] * (n - 2) for _ in range(n - 2)]\n        for i in range(n - 2):\n            for j in range(n - 2):\n                ans[i][j] = max(\n                    grid[x][y] for x in range(i, i + 3) for y in range(j, j + 3)\n                )\n        return ans\n", "class Solution:\n  def largestLocal(self, grid: list[list[int]]) -> list[list[int]]:\n    n = len(grid)\n    ans = [[0] * (n - 2) for _ in range(n - 2)]\n\n    for i in range(n - 2):\n      for j in range(n - 2):\n        for x in range(i, i + 3):\n          for y in range(j, j + 3):\n            ans[i][j] = max(ans[i][j], grid[x][y])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2312, "slug": "selling-pieces-of-wood", "solutions": ["class Solution:\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\n        @cache\n        def dfs(h: int, w: int) -> int:\n            ans = d[h].get(w, 0)\n            for i in range(1, h // 2 + 1):\n                ans = max(ans, dfs(i, w) + dfs(h - i, w))\n            for i in range(1, w // 2 + 1):\n                ans = max(ans, dfs(h, i) + dfs(h, w - i))\n            return ans\n\n        d = defaultdict(dict)\n        for h, w, p in prices:\n            d[h][w] = p\n        return dfs(m, n)\n", "class Solution:\n  def sellingWood(self, m: int, n: int, prices: list[list[int]]) -> int:\n    # dp[i][j] := the maximum money of cutting i x j piece of wood\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for h, w, price in prices:\n      dp[h][w] = price\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        for h in range(1, i // 2 + 1):\n          dp[i][j] = max(dp[i][j], dp[h][j] + dp[i - h][j])\n        for w in range(1, j // 2 + 1):\n          dp[i][j] = max(dp[i][j], dp[i][w] + dp[i][j - w])\n\n    return dp[m][n]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2356, "slug": "number-of-unique-subjects-taught-by-each-teacher", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2378, "slug": "choose-edges-to-maximize-score-in-a-tree", "solutions": ["class Solution:\n    def maxScore(self, edges: List[List[int]]) -> int:\n        def dfs(i):\n            a = b = t = 0\n            for j, w in g[i]:\n                x, y = dfs(j)\n                a += y\n                b += y\n                t = max(t, x - y + w)\n            b += t\n            return a, b\n\n        g = defaultdict(list)\n        for i, (p, w) in enumerate(edges[1:], 1):\n            g[p].append((i, w))\n        return dfs(0)[1]\n", "class Solution:\n  def maxScore(self, edges: list[list[int]]) -> int:\n    n = len(edges)\n    graph = [[] for _ in range(n)]\n\n    for i, (parent, weight) in enumerate(edges):\n      if parent != -1:\n        graph[parent].append((i, weight))\n\n    takeRoot, notTakeRoot = self._dfs(graph, 0)\n    return max(takeRoot, notTakeRoot)\n\n  def _dfs(self, graph: list[list[int]], u: int) -> tuple[int, int]:\n    \"\"\"\n    Returns (the maximum sum at u if we take one u->v edge,\n             the maximum sum at u if we don't take any child edge).\n    \"\"\"\n    bestEdge = 0\n    notTakeU = 0\n\n    for v, w in graph[u]:\n      takeV, notTakeV = self._dfs(graph, v)\n      bestEdge = max(bestEdge, w + notTakeV - takeV)\n      notTakeU += takeV\n\n    return (bestEdge + notTakeU, notTakeU)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2355, "slug": "maximum-number-of-books-you-can-take", "solutions": ["class Solution:\n    def maximumBooks(self, books: List[int]) -> int:\n        nums = [v - i for i, v in enumerate(books)]\n        n = len(nums)\n        left = [-1] * n\n        stk = []\n        for i, v in enumerate(nums):\n            while stk and nums[stk[-1]] >= v:\n                stk.pop()\n            if stk:\n                left[i] = stk[-1]\n            stk.append(i)\n        ans = 0\n        dp = [0] * n\n        dp[0] = books[0]\n        for i, v in enumerate(books):\n            j = left[i]\n            cnt = min(v, i - j)\n            u = v - cnt + 1\n            s = (u + v) * cnt // 2\n            dp[i] = s + (0 if j == -1 else dp[j])\n            ans = max(ans, dp[i])\n        return ans\n", "class Solution:\n  def maximumBooks(self, books: list[int]) -> int:\n    # dp[i] := the maximum the number of books we can take from books[0..i] with taking all of\n    # books[i]\n    dp = [0] * len(books)\n    stack = []  # the possible indices we can reach\n\n    for i, book in enumerate(books):\n      # We may take all of books[j], where books[j] < books[i] - (i - j).\n      while stack and books[stack[-1]] >= book - (i - stack[-1]):\n        stack.pop()\n      # We can now take books[j + 1..i].\n      j = stack[-1] if stack else -1\n      lastPicked = book - (i - j) + 1\n      if lastPicked > 1:\n        # book + (book - 1) + ... + (book - (i - j) + 1)\n        dp[i] = (book + lastPicked) * (i - j) // 2\n      else:\n        # 1 + 2 + ... + book\n        dp[i] = book * (book + 1) // 2\n      if j >= 0:\n        dp[i] += dp[j]\n      stack.append(i)\n\n    return max(dp)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2375, "slug": "construct-smallest-number-from-di-string", "solutions": ["class Solution:\n    def smallestNumber(self, pattern: str) -> str:\n        def dfs(u):\n            nonlocal ans\n            if ans:\n                return\n            if u == len(pattern) + 1:\n                ans = ''.join(t)\n                return\n            for i in range(1, 10):\n                if not vis[i]:\n                    if u and pattern[u - 1] == 'I' and int(t[-1]) >= i:\n                        continue\n                    if u and pattern[u - 1] == 'D' and int(t[-1]) <= i:\n                        continue\n                    vis[i] = True\n                    t.append(str(i))\n                    dfs(u + 1)\n                    vis[i] = False\n                    t.pop()\n\n        vis = [False] * 10\n        t = []\n        ans = None\n        dfs(0)\n        return ans\n", "class Solution:\n  def smallestNumber(self, pattern: str) -> str:\n    ans = []\n    stack = ['1']\n\n    for c in pattern:\n      maxSorFar = stack[-1]\n      if c == 'I':\n        while stack:\n          maxSorFar = max(maxSorFar, stack[-1])\n          ans.append(stack.pop())\n      stack.append(chr(ord(maxSorFar) + 1))\n\n    while stack:\n      ans.append(stack.pop())\n\n    return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2336, "slug": "smallest-number-in-infinite-set", "solutions": ["class SmallestInfiniteSet:\n    def __init__(self):\n        self.s = SortedSet(range(1, 1001))\n\n    def popSmallest(self) -> int:\n        x = self.s[0]\n        self.s.remove(x)\n        return x\n\n    def addBack(self, num: int) -> None:\n        self.s.add(num)\n\n\n# Your SmallestInfiniteSet object will be instantiated and called as such:\n# obj = SmallestInfiniteSet()\n# param_1 = obj.popSmallest()\n# obj.addBack(num)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2368, "slug": "reachable-nodes-with-restrictions", "solutions": ["class Solution:\n    def reachableNodes(\n        self, n: int, edges: List[List[int]], restricted: List[int]\n    ) -> int:\n        def dfs(i: int) -> int:\n            vis.add(i)\n            return 1 + sum(j not in vis and dfs(j) for j in g[i])\n\n        g = defaultdict(list)\n        for a, b in edges:\n            g[a].append(b)\n            g[b].append(a)\n        vis = set(restricted)\n        return dfs(0)\n", "class Solution:\n  def reachableNodes(\n      self,\n      n: int,\n      edges: list[list[int]],\n      restricted: list[int],\n  ) -> int:\n    tree = [[] for _ in range(n)]\n    seen = set(restricted)\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int) -> int:\n      if u in seen:\n        return 0\n      seen.add(u)\n      return 1 + sum(dfs(v) for v in tree[u])\n\n    return dfs(0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2321, "slug": "maximum-score-of-spliced-array", "solutions": ["class Solution:\n    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\n        def f(nums1, nums2):\n            d = [a - b for a, b in zip(nums1, nums2)]\n            t = mx = d[0]\n            for v in d[1:]:\n                if t > 0:\n                    t += v\n                else:\n                    t = v\n                mx = max(mx, t)\n            return mx\n\n        s1, s2 = sum(nums1), sum(nums2)\n        return max(s2 + f(nums1, nums2), s1 + f(nums2, nums1))\n", "class Solution:\n  def maximumsSplicedArray(self, nums1: list[int], nums2: list[int]) -> int:\n    def kadane(nums1: list[int], nums2: list[int]) -> int:\n      \"\"\"\n      Returns the maximum gain of swapping some numbers in `nums1` with some\n      numbers in `nums2`.\n      \"\"\"\n      gain = 0\n      maxGain = 0\n\n      for num1, num2 in zip(nums1, nums2):\n        gain = max(0, gain + num2 - num1)\n        maxGain = max(maxGain, gain)\n\n      return maxGain + sum(nums1)\n\n    return max(kadane(nums1, nums2), kadane(nums2, nums1))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2390, "slug": "removing-stars-from-a-string", "solutions": ["class Solution:\n    def removeStars(self, s: str) -> str:\n        ans = []\n        for c in s:\n            if c == '*':\n                ans.pop()\n            else:\n                ans.append(c)\n        return ''.join(ans)\n", "class Solution:\n  def removeStars(self, s: str) -> str:\n    ans = []\n    for c in s:\n      if c == '*':\n        ans.pop()\n      else:\n        ans.append(c)\n    return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2362, "slug": "generate-the-invoice", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2395, "slug": "find-subarrays-with-equal-sum", "solutions": ["class Solution:\n    def findSubarrays(self, nums: List[int]) -> bool:\n        vis = set()\n        for a, b in pairwise(nums):\n            if (x := a + b) in vis:\n                return True\n            vis.add(x)\n        return False\n", "class Solution:\n  def findSubarrays(self, nums: list[int]) -> bool:\n    seen = set()\n\n    for a, b in zip(nums, nums[1:]):\n      summ = a + b\n      if summ in seen:\n        return True\n      seen.add(summ)\n\n    return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2361, "slug": "minimum-costs-using-the-train-line", "solutions": ["class Solution:\n    def minimumCosts(\n        self, regular: List[int], express: List[int], expressCost: int\n    ) -> List[int]:\n        n = len(regular)\n        f = [0] * (n + 1)\n        g = [inf] * (n + 1)\n        cost = [0] * n\n        for i, (a, b) in enumerate(zip(regular, express), 1):\n            f[i] = min(f[i - 1] + a, g[i - 1] + a)\n            g[i] = min(f[i - 1] + expressCost + b, g[i - 1] + b)\n            cost[i - 1] = min(f[i], g[i])\n        return cost\n", "class Solution:\n  def minimumCosts(\n      self,\n      regular: list[int],\n      express: list[int],\n      expressCost: int,\n  ) -> list[int]:\n    n = len(regular)\n    ans = [0] * n\n    # the minimum cost to reach the current stop in a regular route\n    dpReg = 0\n    # the minimum cost to reach the current stop in an express route\n    dpExp = expressCost\n\n    for i in range(n):\n      prevReg = dpReg\n      prevExp = dpExp\n      dpReg = min(prevReg + regular[i], prevExp + 0 + regular[i])\n      dpExp = min(prevReg + expressCost + express[i], prevExp + express[i])\n      ans[i] = min(dpReg, dpExp)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2366, "slug": "minimum-replacements-to-sort-the-array", "solutions": ["class Solution:\n    def minimumReplacement(self, nums: List[int]) -> int:\n        ans = 0\n        n = len(nums)\n        mx = nums[-1]\n        for i in range(n - 2, -1, -1):\n            if nums[i] <= mx:\n                mx = nums[i]\n                continue\n            k = (nums[i] + mx - 1) // mx\n            ans += k - 1\n            mx = nums[i] // k\n        return ans\n", "class Solution:\n  def minimumReplacement(self, nums: list[int]) -> int:\n    ans = 0\n    mx = nums[-1]\n\n    for i in range(len(nums) - 2, -1, -1):\n      ops = (nums[i] - 1) // mx\n      ans += ops\n      mx = nums[i] // (ops + 1)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2351, "slug": "first-letter-to-appear-twice", "solutions": ["class Solution:\n    def repeatedCharacter(self, s: str) -> str:\n        cnt = Counter()\n        for c in s:\n            cnt[c] += 1\n            if cnt[c] == 2:\n                return c\n", "class Solution:\n  def repeatedCharacter(self, s: str) -> str:\n    seen = [False] * 26\n\n    for c in s:\n      if seen[ord(c) - ord('a')]:\n        return c\n      seen[ord(c) - ord('a')] = True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2370, "slug": "longest-ideal-subsequence", "solutions": ["class Solution:\n    def longestIdealString(self, s: str, k: int) -> int:\n        n = len(s)\n        ans = 1\n        dp = [1] * n\n        d = {s[0]: 0}\n        for i in range(1, n):\n            a = ord(s[i])\n            for b in ascii_lowercase:\n                if abs(a - ord(b)) > k:\n                    continue\n                if b in d:\n                    dp[i] = max(dp[i], dp[d[b]] + 1)\n            d[s[i]] = i\n        return max(dp)\n", "class Solution:\n  def longestIdealString(self, s: str, k: int) -> int:\n    # dp[i] := the longest subsequence that ends in ('a' + i)\n    dp = [0] * 26\n\n    for c in s:\n      i = ord(c) - ord('a')\n      dp[i] = 1 + self._getMaxReachable(dp, i, k)\n\n    return max(dp)\n\n  def _getMaxReachable(self, dp: list[int], i: int, k: int) -> int:\n    first = max(0, i - k)\n    last = min(25, i + k)\n    maxReachable = 0\n    for j in range(first, last + 1):\n      maxReachable = max(maxReachable, dp[j])\n    return maxReachable\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2384, "slug": "largest-palindromic-number", "solutions": ["class Solution:\n    def largestPalindromic(self, num: str) -> str:\n        cnt = Counter(num)\n        ans = ''\n        for i in range(9, -1, -1):\n            v = str(i)\n            if cnt[v] % 2:\n                ans = v\n                cnt[v] -= 1\n                break\n        for i in range(10):\n            v = str(i)\n            if cnt[v]:\n                cnt[v] //= 2\n                s = cnt[v] * v\n                ans = s + ans + s\n        return ans.strip('0') or '0'\n", "class Solution:\n  def largestPalindromic(self, num: str) -> str:\n    count = collections.Counter(num)\n    firstHalf = ''.join(count[i] // 2 * i for i in '9876543210').lstrip('0')\n    mid = self._getMid(count)\n    return (firstHalf + mid + firstHalf[::-1]) or '0'\n\n  def _getMid(self, count: dict[str, int]) -> str:\n    for c in '9876543210':\n      if count[c] & 1:\n        return c\n    return ''\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2337, "slug": "move-pieces-to-obtain-a-string", "solutions": ["class Solution:\n    def canChange(self, start: str, target: str) -> bool:\n        a = [(v, i) for i, v in enumerate(start) if v != '_']\n        b = [(v, i) for i, v in enumerate(target) if v != '_']\n        if len(a) != len(b):\n            return False\n        for (c, i), (d, j) in zip(a, b):\n            if c != d:\n                return False\n            if c == 'L' and i < j:\n                return False\n            if c == 'R' and i > j:\n                return False\n        return True\n", "class Solution:\n  def canChange(self, start: str, target: str) -> bool:\n    n = len(start)\n    i = 0  # start's index\n    j = 0  # target's index\n\n    while i <= n and j <= n:\n      while i < n and start[i] == '_':\n        i += 1\n      while j < n and target[j] == '_':\n        j += 1\n      if i == n or j == n:\n        return i == n and j == n\n      if start[i] != target[j]:\n        return False\n      if start[i] == 'R' and i > j:\n        return False\n      if start[i] == 'L' and i < j:\n        return False\n      i += 1\n      j += 1\n\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2371, "slug": "minimize-maximum-value-in-a-grid", "solutions": ["class Solution:\n    def minScore(self, grid: List[List[int]]) -> List[List[int]]:\n        m, n = len(grid), len(grid[0])\n        nums = [(v, i, j) for i, row in enumerate(grid) for j, v in enumerate(row)]\n        nums.sort()\n        row_max = [0] * m\n        col_max = [0] * n\n        ans = [[0] * n for _ in range(m)]\n        for _, i, j in nums:\n            ans[i][j] = max(row_max[i], col_max[j]) + 1\n            row_max[i] = col_max[j] = ans[i][j]\n        return ans\n", "class Solution:\n  def minScore(self, grid: list[list[int]]) -> list[list[int]]:\n    m = len(grid)\n    n = len(grid[0])\n    ans = [[0] * n for _ in range(m)]\n    valAndIndices = []\n    rows = [0] * m  # rows[i] := the maximum used number so far\n    cols = [0] * n  # cols[j] := the maximum used number so far\n\n    for i in range(m):\n      for j in range(n):\n        valAndIndices.append((grid[i][j], i, j))\n\n    valAndIndices.sort()\n\n    for _, i, j in valAndIndices:\n      nextAvailable = max(rows[i], cols[j]) + 1\n      ans[i][j] = nextAvailable\n      rows[i] = nextAvailable\n      cols[j] = nextAvailable\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2303, "slug": "calculate-amount-paid-in-taxes", "solutions": ["class Solution:\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\n        ans = prev = 0\n        for upper, percent in brackets:\n            ans += max(0, min(income, upper) - prev) * percent\n            prev = upper\n        return ans / 100\n", "class Solution:\n  def calculateTax(self, brackets: list[list[int]], income: int) -> float:\n    ans = 0\n    prev = 0\n\n    for upper, percent in brackets:\n      if income < upper:\n        return ans + (income - prev) * percent / 100.0\n      ans += (upper - prev) * percent / 100.0\n      prev = upper\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2354, "slug": "number-of-excellent-pairs", "solutions": ["class Solution:\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\n        s = set(nums)\n        ans = 0\n        cnt = Counter()\n        for v in s:\n            cnt[v.bit_count()] += 1\n        for v in s:\n            t = v.bit_count()\n            for i, x in cnt.items():\n                if t + i >= k:\n                    ans += x\n        return ans\n", "class Solution:\n  def countExcellentPairs(self, nums: list[int], k: int) -> int:\n    count = collections.Counter(map(int.bit_count, set(nums)))\n    return sum(count[i] * count[j]\n               for i in count\n               for j in count\n               if i + j >= k)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2310, "slug": "sum-of-numbers-with-units-digit-k", "solutions": ["class Solution:\n    def minimumNumbers(self, num: int, k: int) -> int:\n        if num == 0:\n            return 0\n        for i in range(1, num + 1):\n            if (t := num - k * i) >= 0 and t % 10 == 0:\n                return i\n        return -1\n", "class Solution:\n  def minimumNumbers(self, num: int, k: int) -> int:\n    if num == 0:\n      return 0\n\n    # Assume the size of the set is n, and the numbers in the set are X1, X2,\n    # ..., Xn. Since the units digit of each number is k, X1 + X2 + ... + Xn =\n    # N * k + 10 * (x1 + x2 + ... + xn) = num. Therefore, the goal is to find\n    # the n s.t. n * k % 10 = num % 10\n    for i in range(1, 11):\n      if i * k > num + 1:\n        break\n      if i * k % 10 == num % 10:\n        return i\n\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2315, "slug": "count-asterisks", "solutions": ["class Solution:\n    def countAsterisks(self, s: str) -> int:\n        ans, ok = 0, 1\n        for c in s:\n            if c == \"*\":\n                ans += ok\n            elif c == \"|\":\n                ok ^= 1\n        return ans\n", "class Solution:\n  def countAsterisks(self, s: str) -> int:\n    ans = 0\n    bars = 0\n\n    for c in s:\n      if c == '|':\n        bars += 1\n      elif c == '*' and bars % 2 == 0:\n        ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2302, "slug": "count-subarrays-with-score-less-than-k", "solutions": ["class Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        s = list(accumulate(nums, initial=0))\n        ans = 0\n        for i in range(1, len(s)):\n            left, right = 0, i\n            while left < right:\n                mid = (left + right + 1) >> 1\n                if (s[i] - s[i - mid]) * mid < k:\n                    left = mid\n                else:\n                    right = mid - 1\n            ans += left\n        return ans\n", "class Solution:\n  def countSubarrays(self, nums: list[int], k: int) -> int:\n    ans = 0\n    summ = 0\n\n    l = 0\n    for r, num in enumerate(nums):\n      summ += num\n      while summ * (r - l + 1) >= k:\n        summ -= nums[l]\n        l += 1\n      ans += r - l + 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2332, "slug": "the-latest-time-to-catch-a-bus", "solutions": ["class Solution:\n    def latestTimeCatchTheBus(\n        self, buses: List[int], passengers: List[int], capacity: int\n    ) -> int:\n        buses.sort()\n        passengers.sort()\n        j = 0\n        for t in buses:\n            c = capacity\n            while c and j < len(passengers) and passengers[j] <= t:\n                c, j = c - 1, j + 1\n        j -= 1\n        ans = buses[-1] if c else passengers[j]\n        while ~j and passengers[j] == ans:\n            ans, j = ans - 1, j - 1\n        return ans\n", "class Solution:\n  def latestTimeCatchTheBus(\n      self,\n      buses: list[int],\n      passengers: list[int],\n      capacity: int,\n  ) -> int:\n    buses.sort()\n    passengers.sort()\n\n    if passengers[0] > buses[-1]:\n      return buses[-1]\n\n    ans = passengers[0] - 1\n    i = 0  # buses' index\n    j = 0  # passengers' index\n\n    while i < len(buses):\n      # Greedily make passengers catch `buses[i]`.\n      arrived = 0\n      while arrived < capacity and j < len(passengers) and passengers[j] <= buses[i]:\n        if j > 0 and passengers[j] != passengers[j - 1] + 1:\n          ans = passengers[j] - 1\n        j += 1\n        arrived += 1\n      # There's room for `buses[i]` to carry a passenger arriving at the\n      # `buses[i]`.\n      if arrived < capacity and j > 0 and passengers[j - 1] != buses[i]:\n        ans = buses[i]\n      i += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2333, "slug": "minimum-sum-of-squared-difference", "solutions": ["class Solution:\n    def minSumSquareDiff(\n        self, nums1: List[int], nums2: List[int], k1: int, k2: int\n    ) -> int:\n        d = [abs(a - b) for a, b in zip(nums1, nums2)]\n        k = k1 + k2\n        if sum(d) <= k:\n            return 0\n        left, right = 0, max(d)\n        while left < right:\n            mid = (left + right) >> 1\n            if sum(max(v - mid, 0) for v in d) <= k:\n                right = mid\n            else:\n                left = mid + 1\n        for i, v in enumerate(d):\n            d[i] = min(left, v)\n            k -= max(0, v - left)\n        for i, v in enumerate(d):\n            if k == 0:\n                break\n            if v == left:\n                k -= 1\n                d[i] -= 1\n        return sum(v * v for v in d)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2396, "slug": "strictly-palindromic-number", "solutions": ["class Solution:\n    def isStrictlyPalindromic(self, n: int) -> bool:\n        return False\n", "class Solution:\n  def isStrictlyPalindromic(self, n: int) -> bool:\n    return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2319, "slug": "check-if-matrix-is-x-matrix", "solutions": ["class Solution:\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                if i == j or i + j == len(grid) - 1:\n                    if v == 0:\n                        return False\n                elif v:\n                    return False\n        return True\n", "class Solution:\n  def checkXMatrix(self, grid: list[list[int]]) -> bool:\n    n = len(grid)\n\n    for i in range(n):\n      for j in range(n):\n        if i == j or i + j == n - 1:  # in diagonal\n          if grid[i][j] == 0:\n            return False\n        elif grid[i][j]:   # not in diagonal\n          return False\n\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2376, "slug": "count-special-integers", "solutions": ["class Solution:\n    def countSpecialNumbers(self, n: int) -> int:\n        @cache\n        def dfs(i: int, mask: int, lead: bool, limit: bool) -> int:\n            if i >= len(s):\n                return int(lead ^ 1)\n            up = int(s[i]) if limit else 9\n            ans = 0\n            for j in range(up + 1):\n                if mask >> j & 1:\n                    continue\n                if lead and j == 0:\n                    ans += dfs(i + 1, mask, True, limit and j == up)\n                else:\n                    ans += dfs(i + 1, mask | 1 << j, False, limit and j == up)\n            return ans\n\n        s = str(n)\n        return dfs(0, 0, True, True)\n", "class Solution:\n  # Same as 1012. Numbers With Repeated Digits\n  def countSpecialNumbers(self, n: int) -> int:\n    s = str(n)\n\n    @functools.lru_cache(None)\n    def dp(i: int, used: int, isTight: bool) -> int:\n      \"\"\"\n      Returns the number of special integers, considering the i-th digit, where\n      `used` is the bitmask of the used digits, and `isTight` indicates if the\n      current digit is tightly bound.\n      \"\"\"\n      if i == len(s):\n        return 1\n\n      res = 0\n      maxDigit = int(s[i]) if isTight else 9\n\n      for d in range(maxDigit + 1):\n        # `d` is used.\n        if used >> d & 1:\n          continue\n        # Use `d` now.\n        nextIsTight = isTight and (d == maxDigit)\n        if used == 0 and d == 0:  # Don't count leading 0s as used.\n          res += dp(i + 1, used, nextIsTight)\n        else:\n          res += dp(i + 1, used | 1 << d, nextIsTight)\n\n      return res\n\n    return dp(0, 0, True) - 1  # - 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2301, "slug": "match-substring-after-replacement", "solutions": ["class Solution:\n    def matchReplacement(self, s: str, sub: str, mappings: List[List[str]]) -> bool:\n        d = defaultdict(set)\n        for a, b in mappings:\n            d[a].add(b)\n        for i in range(len(s) - len(sub) + 1):\n            if all(a == b or a in d[b] for a, b in zip(s[i : i + len(sub)], sub)):\n                return True\n        return False\n", "class Solution:\n  def matchReplacement(\n      self,\n      s: str,\n      sub: str,\n      mappings: list[list[str]],\n  ) -> bool:\n    isMapped = [[False] * 128 for _ in range(128)]\n\n    for old, new in mappings:\n      isMapped[ord(old)][ord(new)] = True\n\n    for i in range(len(s)):\n      if self._canTransform(s, i, sub, isMapped):\n        return True\n\n    return False\n\n  def _canTransform(\n      self,\n      s: str,\n      start: int,\n      sub: str,\n      isMapped: list[list[bool]],\n  ) -> bool:\n    if start + len(sub) > len(s):\n      return False\n\n    for i in range(len(sub)):\n      a = sub[i]\n      b = s[start + i]\n      if a != b and not isMapped[ord(a)][ord(b)]:\n        return False\n\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2305, "slug": "fair-distribution-of-cookies", "solutions": ["class Solution:\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\n        def dfs(i):\n            if i >= len(cookies):\n                nonlocal ans\n                ans = max(cnt)\n                return\n            for j in range(k):\n                if cnt[j] + cookies[i] >= ans or (j and cnt[j] == cnt[j - 1]):\n                    continue\n                cnt[j] += cookies[i]\n                dfs(i + 1)\n                cnt[j] -= cookies[i]\n\n        ans = inf\n        cnt = [0] * k\n        cookies.sort(reverse=True)\n        dfs(0)\n        return ans\n", "class Solution:\n  def distributeCookies(self, cookies: list[int], k: int) -> int:\n    ans = math.inf\n\n    def dfs(s: int, children: list[int]) -> None:\n      nonlocal ans\n      if s == len(cookies):\n        ans = min(ans, max(children))\n        return\n\n      for i in range(k):\n        children[i] += cookies[s]\n        dfs(s + 1, children)\n        children[i] -= cookies[s]\n\n    dfs(0, [0] * k)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2323, "slug": "find-minimum-time-to-finish-all-jobs-ii", "solutions": ["class Solution:\n    def minimumTime(self, jobs: List[int], workers: List[int]) -> int:\n        jobs.sort()\n        workers.sort()\n        return max((a + b - 1) // b for a, b in zip(jobs, workers))\n", "class Solution:\n  def minimumTime(self, jobs: list[int], workers: list[int]) -> int:\n    ans = 0\n\n    jobs.sort()\n    workers.sort()\n\n    for job, worker in zip(jobs, workers):\n      ans = max(ans, (job - 1) // worker + 1)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2313, "slug": "minimum-flips-in-binary-tree-to-get-result", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minimumFlips(self, root: Optional[TreeNode], result: bool) -> int:\n        def dfs(root: Optional[TreeNode]) -> (int, int):\n            if root is None:\n                return inf, inf\n            x = root.val\n            if x in (0, 1):\n                return x, x ^ 1\n            l, r = dfs(root.left), dfs(root.right)\n            if x == 2:\n                return l[0] + r[0], min(l[0] + r[1], l[1] + r[0], l[1] + r[1])\n            if x == 3:\n                return min(l[0] + r[0], l[0] + r[1], l[1] + r[0]), l[1] + r[1]\n            if x == 4:\n                return min(l[0] + r[0], l[1] + r[1]), min(l[0] + r[1], l[1] + r[0])\n            return min(l[1], r[1]), min(l[0], r[0])\n\n        return dfs(root)[int(result)]\n", "class Solution:\n  def minimumFlips(self, root: TreeNode | None, result: bool) -> int:\n    @functools.lru_cache(None)\n    def dp(root: TreeNode | None, target: bool) -> int:\n      \"\"\"Returns the minimum flips to make the subtree root become target.\"\"\"\n      if root.val in (0, 1):  # the leaf\n        return 0 if root.val == target else 1\n      if root.val == 5:  # NOT\n        return dp(root.left or root.right, not target)\n      if root.val == 2:  # OR\n        nextTargets = [(0, 1), (1, 0), (1, 1)] if target else [[0, 0]]\n      elif root.val == 3:  # AND\n        nextTargets = [(1, 1)] if target else [(0, 0), (0, 1), (1, 0)]\n      else:  # root.val == 4 XOR\n        nextTargets = [(0, 1), (1, 0)] if target else [(0, 0), (1, 1)]\n      return min(dp(root.left, leftTarget) + dp(root.right, rightTarget)\n                 for leftTarget, rightTarget in nextTargets)\n\n    return dp(root, result)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2346, "slug": "compute-the-rank-as-a-percentage", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2387, "slug": "median-of-a-row-wise-sorted-matrix", "solutions": ["class Solution:\n    def matrixMedian(self, grid: List[List[int]]) -> int:\n        def count(x):\n            return sum(bisect_right(row, x) for row in grid)\n\n        m, n = len(grid), len(grid[0])\n        target = (m * n + 1) >> 1\n        return bisect_left(range(10**6 + 1), target, key=count)\n", "class Solution:\n  def matrixMedian(self, grid: list[list[int]]) -> int:\n    noGreaterThanMedianCount = len(grid) * len(grid[0]) // 2 + 1\n    l = 1\n    r = 1_000_000\n\n    while l < r:\n      m = (l + r) // 2\n      if (sum(bisect.bisect_right(row, m) for row in grid) >=\n              noGreaterThanMedianCount):\n        r = m\n      else:\n        l = m + 1\n\n    return l\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2350, "slug": "shortest-impossible-sequence-of-rolls", "solutions": ["class Solution:\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\n        ans = 1\n        s = set()\n        for v in rolls:\n            s.add(v)\n            if len(s) == k:\n                ans += 1\n                s.clear()\n        return ans\n", "class Solution:\n  def shortestSequence(self, rolls: list[int], k: int) -> int:\n    ans = 1  # the the next target length\n    seen = set()\n\n    for roll in rolls:\n      seen.add(roll)\n      if len(seen) == k:\n        # Have all combinations that form `ans` length, and we are going to\n        # extend the sequence to `ans + 1` length.\n        ans += 1\n        seen.clear()\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2374, "slug": "node-with-highest-edge-score", "solutions": ["class Solution:\n    def edgeScore(self, edges: List[int]) -> int:\n        ans = 0\n        cnt = [0] * len(edges)\n        for i, j in enumerate(edges):\n            cnt[j] += i\n            if cnt[ans] < cnt[j] or (cnt[ans] == cnt[j] and j < ans):\n                ans = j\n        return ans\n", "class Solution:\n  def edgeScore(self, edges: list[int]) -> int:\n    scores = [0] * len(edges)\n    for i, edge in enumerate(edges):\n      scores[edge] += i\n    return scores.index(max(scores))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2307, "slug": "check-for-contradictions-in-equations", "solutions": ["class Solution:\n    def checkContradictions(\n        self, equations: List[List[str]], values: List[float]\n    ) -> bool:\n        def find(x: int) -> int:\n            if p[x] != x:\n                root = find(p[x])\n                w[x] *= w[p[x]]\n                p[x] = root\n            return p[x]\n\n        d = defaultdict(int)\n        n = 0\n        for e in equations:\n            for s in e:\n                if s not in d:\n                    d[s] = n\n                    n += 1\n        p = list(range(n))\n        w = [1.0] * n\n        eps = 1e-5\n        for (a, b), v in zip(equations, values):\n            a, b = d[a], d[b]\n            pa, pb = find(a), find(b)\n            if pa != pb:\n                p[pb] = pa\n                w[pb] = v * w[a] / w[b]\n            elif abs(v * w[a] - w[b]) >= eps:\n                return True\n        return False\n", "class Solution:\n  def checkContradictions(\n      self,\n      equations: list[list[str]],\n      values: list[float],\n  ) -> bool:\n    # Convert `string` to `int` for a better perfermance.\n    strToInt = {}\n\n    for u, v in equations:\n      strToInt.setdefault(u, len(strToInt))\n      strToInt.setdefault(v, len(strToInt))\n\n    graph = [[] for _ in range(len(strToInt))]\n    seen = [0.0] * len(graph)\n\n    for i, ((A, B), value) in enumerate(zip(equations, values)):\n      u = strToInt[A]\n      v = strToInt[B]\n      graph[u].append((v, value))\n      graph[v].append((u, 1 / value))\n\n    def dfs(u: int, val: float) -> bool:\n      if seen[u]:\n        return abs(val / seen[u] - 1) > 1e-5\n\n      seen[u] = val\n      return any(dfs(v, val / w) for v, w in graph[u])\n\n    for i in range(len(graph)):\n      if not seen[i] and dfs(i, 1.0):\n        return True\n\n    return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2382, "slug": "maximum-segment-sum-after-removals", "solutions": ["class Solution:\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\n        def find(x):\n            if p[x] != x:\n                p[x] = find(p[x])\n            return p[x]\n\n        def merge(a, b):\n            pa, pb = find(a), find(b)\n            p[pa] = pb\n            s[pb] += s[pa]\n\n        n = len(nums)\n        p = list(range(n))\n        s = [0] * n\n        ans = [0] * n\n        mx = 0\n        for j in range(n - 1, 0, -1):\n            i = removeQueries[j]\n            s[i] = nums[i]\n            if i and s[find(i - 1)]:\n                merge(i, i - 1)\n            if i < n - 1 and s[find(i + 1)]:\n                merge(i, i + 1)\n            mx = max(mx, s[find(i)])\n            ans[j - 1] = mx\n        return ans\n", "class Solution:\n  def maximumSegmentSum(\n      self,\n      nums: list[int],\n      removeQueries: list[int],\n  ) -> list[int]:\n    n = len(nums)\n    maxSum = 0\n    ans = [0] * n\n    # For the segment [l, r], record its sum in summ[l] and summ[r]\n    summ = [0] * n\n    # For the segment [l, r], record its count in count[l] and count[r]\n    count = [0] * n\n\n    for i in reversed(range(n)):\n      ans[i] = maxSum\n      j = removeQueries[i]\n\n      # Calculate `segmentSum`.\n      leftSum = summ[j - 1] if j > 0 else 0\n      rightSum = summ[j + 1] if j + 1 < n else 0\n      segmentSum = nums[j] + leftSum + rightSum\n\n      # Calculate `segmentCount`.\n      leftCount = count[j - 1] if j > 0 else 0\n      rightCount = count[j + 1] if j + 1 < n else 0\n      segmentCount = 1 + leftCount + rightCount\n\n      # Update `summ` and `count` of the segment [l, r].\n      l = j - leftCount\n      r = j + rightCount\n      summ[l] = segmentSum\n      summ[r] = segmentSum\n      count[l] = segmentCount\n      count[r] = segmentCount\n      maxSum = max(maxSum, segmentSum)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2360, "slug": "longest-cycle-in-a-graph", "solutions": ["class Solution:\n    def longestCycle(self, edges: List[int]) -> int:\n        n = len(edges)\n        vis = [False] * n\n        ans = -1\n        for i in range(n):\n            if vis[i]:\n                continue\n            j = i\n            cycle = []\n            while j != -1 and not vis[j]:\n                vis[j] = True\n                cycle.append(j)\n                j = edges[j]\n            if j == -1:\n                continue\n            m = len(cycle)\n            k = next((k for k in range(m) if cycle[k] == j), inf)\n            ans = max(ans, m - k)\n        return ans\n", "class Solution:\n  def longestCycle(self, edges: list[int]) -> int:\n    ans = -1\n    time = 1\n    timeVisited = [0] * len(edges)\n\n    for i, edge in enumerate(edges):\n      if timeVisited[i]:\n        continue\n      startTime = time\n      u = i\n      while u != -1 and not timeVisited[u]:\n        timeVisited[u] = time\n        time += 1\n        u = edges[u]  # Move to the next node.\n      if u != -1 and timeVisited[u] >= startTime:\n        ans = max(ans, time - timeVisited[u])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2388, "slug": "change-null-values-in-a-table-to-the-previous-value", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2304, "slug": "minimum-path-cost-in-a-grid", "solutions": ["class Solution:\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        f = grid[0]\n        for i in range(1, m):\n            g = [inf] * n\n            for j in range(n):\n                for k in range(n):\n                    g[j] = min(g[j], f[k] + moveCost[grid[i - 1][k]][j] + grid[i][j])\n            f = g\n        return min(f)\n", "class Solution:\n  def minPathCost(\n      self,\n      grid: list[list[int]],\n      moveCost: list[list[int]],\n  ) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    # dp[i][j] := the minimum cost to reach grid[i][j]\n    dp = [[math.inf] * n for _ in range(m)]\n    dp[0] = grid[0]\n\n    for i in range(1, m):\n      for j in range(n):\n        for k in range(n):\n          dp[i][j] = min(dp[i][j], dp[i - 1][k] +\n                         moveCost[grid[i - 1][k]][j] + grid[i][j])\n\n    return min(dp[-1])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2311, "slug": "longest-binary-subsequence-less-than-or-equal-to-k", "solutions": ["class Solution:\n    def longestSubsequence(self, s: str, k: int) -> int:\n        ans = v = 0\n        for c in s[::-1]:\n            if c == \"0\":\n                ans += 1\n            elif ans < 30 and (v | 1 << ans) <= k:\n                v |= 1 << ans\n                ans += 1\n        return ans\n", "class Solution:\n  def longestSubsequence(self, s: str, k: int) -> int:\n    oneCount = 0\n    num = 0\n    pow = 1\n\n    # Take as many 1s as possible from the right.\n    for i in reversed(range(len(s))):\n      if num + pow > k:\n        break\n      if s[i] == '1':\n        oneCount += 1\n        num += pow\n      pow *= 2\n\n    return s.count('0') + oneCount\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2314, "slug": "the-first-day-of-the-maximum-recorded-degree-in-each-city", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2379, "slug": "minimum-recolors-to-get-k-consecutive-black-blocks", "solutions": ["class Solution:\n    def minimumRecolors(self, blocks: str, k: int) -> int:\n        ans = cnt = blocks[:k].count('W')\n        for i in range(k, len(blocks)):\n            cnt += blocks[i] == 'W'\n            cnt -= blocks[i - k] == 'W'\n            ans = min(ans, cnt)\n        return ans\n", "class Solution:\n  def minimumRecolors(self, blocks: str, k: int) -> int:\n    countB = 0\n    maxCountB = 0\n\n    for i, block in enumerate(blocks):\n      if block == 'B':\n        countB += 1\n      if i >= k and blocks[i - k] == 'B':\n        countB -= 1\n      maxCountB = max(maxCountB, countB)\n\n    return k - maxCountB\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2340, "slug": "minimum-adjacent-swaps-to-make-a-valid-array", "solutions": ["class Solution:\n    def minimumSwaps(self, nums: List[int]) -> int:\n        i = j = 0\n        for k, v in enumerate(nums):\n            if v < nums[i] or (v == nums[i] and k < i):\n                i = k\n            if v >= nums[j] or (v == nums[j] and k > j):\n                j = k\n        return 0 if i == j else i + len(nums) - 1 - j - (i > j)\n", "class Solution:\n  def minimumSwaps(self, nums: list[int]) -> int:\n    minIndex = self._getLeftmostMinIndex(nums)\n    maxIndex = self._getRightmostMaxIndex(nums)\n    swaps = minIndex + (len(nums) - 1 - maxIndex)\n    return swaps if minIndex <= maxIndex else swaps - 1\n\n  def _getLeftmostMinIndex(self, nums: list[int]) -> int:\n    mn = nums[0]\n    minIndex = 0\n    for i in range(1, len(nums)):\n      if nums[i] < mn:\n        mn = nums[i]\n        minIndex = i\n    return minIndex\n\n  def _getRightmostMaxIndex(self, nums: list[int]) -> int:\n    mx = nums[-1]\n    maxIndex = len(nums) - 1\n    for i in range(len(nums) - 2, -1, -1):\n      if nums[i] > mx:\n        mx = nums[i]\n        maxIndex = i\n    return maxIndex\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2394, "slug": "employees-with-deductions", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2393, "slug": "count-strictly-increasing-subarrays", "solutions": ["class Solution:\n    def countSubarrays(self, nums: List[int]) -> int:\n        ans = cnt = 1\n        for x, y in pairwise(nums):\n            if x < y:\n                cnt += 1\n            else:\n                cnt = 1\n            ans += cnt\n        return ans\n", "class Solution:\n  def countSubarrays(self, nums: list[int]) -> int:\n    ans = 0\n\n    j = -1\n    for i, num in enumerate(nums):\n      if i > 0 and num <= nums[i - 1]:\n        j = i - 1\n      ans += i - j\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2316, "slug": "count-unreachable-pairs-of-nodes-in-an-undirected-graph", "solutions": ["class Solution:\n    def countPairs(self, n: int, edges: List[List[int]]) -> int:\n        def dfs(i: int) -> int:\n            if vis[i]:\n                return 0\n            vis[i] = True\n            return 1 + sum(dfs(j) for j in g[i])\n\n        g = [[] for _ in range(n)]\n        for a, b in edges:\n            g[a].append(b)\n            g[b].append(a)\n        vis = [False] * n\n        ans = s = 0\n        for i in range(n):\n            t = dfs(i)\n            ans += s * t\n            s += t\n        return ans\n", "class Solution:\n  def countPairs(self, n: int, edges: list[list[int]]) -> int:\n    ans = 0\n    graph = [[] for _ in range(n)]\n    seen = [0] * n\n    unreached = n\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    for i in range(n):\n      reached = self._dfs(graph, i, seen)\n      unreached -= reached\n      ans += unreached * reached\n\n    return ans\n\n  def _dfs(self, graph: list[list[int]], u: int, seen: list[bool]) -> int:\n    if seen[u]:\n      return 0\n    seen[u] = True\n    return functools.reduce(lambda subtotal, v:\n                            subtotal + self._dfs(graph, v, seen), graph[u], 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2383, "slug": "minimum-hours-of-training-to-win-a-competition", "solutions": ["class Solution:\n    def minNumberOfHours(\n        self, x: int, y: int, energy: List[int], experience: List[int]\n    ) -> int:\n        ans = 0\n        for dx, dy in zip(energy, experience):\n            if x <= dx:\n                ans += dx + 1 - x\n                x = dx + 1\n            if y <= dy:\n                ans += dy + 1 - y\n                y = dy + 1\n            x -= dx\n            y += dy\n        return ans\n", "class Solution:\n  def minNumberOfHours(\n      self,\n      initialEnergy: int,\n      initialExperience: int,\n      energy: list[int],\n      experience: list[int],\n  ) -> int:\n    return (self._getRequiredEnergy(initialEnergy, energy) +\n            self._getRequiredExperience(initialExperience, experience))\n\n  def _getRequiredEnergy(self, initialEnergy: int, energy: list[int]) -> int:\n    return max(0, sum(energy) + 1 - initialEnergy)\n\n  def _getRequiredExperience(\n      self,\n      currentExperience: int,\n      experience: list[int],\n  ) -> int:\n    requiredExperience = 0\n    for e in experience:\n      if e >= currentExperience:\n        requiredExperience += e + 1 - currentExperience\n        currentExperience += e + 1 - currentExperience\n      currentExperience += e\n    return requiredExperience\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2349, "slug": "design-a-number-container-system", "solutions": ["class NumberContainers:\n    def __init__(self):\n        self.d = {}\n        self.g = defaultdict(SortedSet)\n\n    def change(self, index: int, number: int) -> None:\n        if index in self.d:\n            old_number = self.d[index]\n            self.g[old_number].remove(index)\n        self.d[index] = number\n        self.g[number].add(index)\n\n    def find(self, number: int) -> int:\n        ids = self.g[number]\n        return ids[0] if ids else -1\n\n\n# Your NumberContainers object will be instantiated and called as such:\n# obj = NumberContainers()\n# obj.change(index,number)\n# param_2 = obj.find(number)\n", "from sortedcontainers import SortedSet\n\n\nclass NumberContainers:\n  def __init__(self):\n    self.numberToIndices = collections.defaultdict(SortedSet)\n    self.indexToNumber = {}\n\n  def change(self, index: int, number: int) -> None:\n    if index in self.indexToNumber:\n      originalNumber = self.indexToNumber[index]\n      self.numberToIndices[originalNumber].remove(index)\n      if len(self.numberToIndices[originalNumber]) == 0:\n        del self.numberToIndices[originalNumber]\n    self.indexToNumber[index] = number\n    self.numberToIndices[number].add(index)\n\n  def find(self, number: int) -> int:\n    if number in self.numberToIndices:\n      return self.numberToIndices[number][0]\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2365, "slug": "task-scheduler-ii", "solutions": ["class Solution:\n    def taskSchedulerII(self, tasks: List[int], space: int) -> int:\n        day = defaultdict(int)\n        ans = 0\n        for task in tasks:\n            ans += 1\n            ans = max(ans, day[task])\n            day[task] = ans + space + 1\n        return ans\n", "class Solution:\n  def taskSchedulerII(self, tasks: list[int], space: int) -> int:\n    taskToNextAvailable = collections.defaultdict(int)\n    ans = 0\n\n    for task in tasks:\n      ans = max(ans + 1, taskToNextAvailable[task])\n      taskToNextAvailable[task] = ans + space + 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2325, "slug": "decode-the-message", "solutions": ["class Solution:\n    def decodeMessage(self, key: str, message: str) -> str:\n        d = {\" \": \" \"}\n        i = 0\n        for c in key:\n            if c not in d:\n                d[c] = ascii_lowercase[i]\n                i += 1\n        return \"\".join(d[c] for c in message)\n", "class Solution:\n  def decodeMessage(self, key: str, message: str) -> str:\n    keyToActual = {' ': ' '}\n    currChar = 'a'\n\n    for c in key:\n      if c not in keyToActual:\n        keyToActual[c] = currChar\n        currChar = chr(ord(currChar) + 1)\n\n    return ''.join(keyToActual[c] for c in message)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2326, "slug": "spiral-matrix-iv", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\n        ans = [[-1] * n for _ in range(m)]\n        i = j = k = 0\n        dirs = (0, 1, 0, -1, 0)\n        while 1:\n            ans[i][j] = head.val\n            head = head.next\n            if head is None:\n                break\n            while 1:\n                x, y = i + dirs[k], j + dirs[k + 1]\n                if 0 <= x < m and 0 <= y < n and ans[x][y] == -1:\n                    i, j = x, y\n                    break\n                k = (k + 1) % 4\n        return ans\n", "class Solution:\n  def spiralMatrix(self, m: int, n: int, head: ListNode | None) -> list[list[int]]:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    ans = [[-1] * n for _ in range(m)]\n    x = 0  # the current x position\n    y = 0  # the current y position\n    d = 0\n\n    curr = head\n    while curr:\n      ans[x][y] = curr.val\n      if (x + DIRS[d][0] < 0 or x + DIRS[d][0] == m or y + DIRS[d][1] < 0 or\n              y + DIRS[d][1] == n or ans[x + DIRS[d][0]][y + DIRS[d][1]] != -1):\n        d = (d + 1) % 4\n      x += DIRS[d][0]\n      y += DIRS[d][1]\n      curr = curr.next\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2306, "slug": "naming-a-company", "solutions": ["class Solution:\n    def distinctNames(self, ideas: List[str]) -> int:\n        s = set(ideas)\n        f = [[0] * 26 for _ in range(26)]\n        for v in ideas:\n            i = ord(v[0]) - ord('a')\n            t = list(v)\n            for j in range(26):\n                t[0] = chr(ord('a') + j)\n                if ''.join(t) not in s:\n                    f[i][j] += 1\n        ans = 0\n        for v in ideas:\n            i = ord(v[0]) - ord('a')\n            t = list(v)\n            for j in range(26):\n                t[0] = chr(ord('a') + j)\n                if ''.join(t) not in s:\n                    ans += f[j][i]\n        return ans\n", "class Solution:\n  def distinctNames(self, ideas: list[str]) -> int:\n    ans = 0\n    # suffixes[i] := the set of strings omitting the first letter, where the\n    # first letter is ('a' + i)\n    suffixes = [set() for _ in range(26)]\n\n    for idea in ideas:\n      suffixes[ord(idea[0]) - ord('a')].add(idea[1:])\n\n    for i in range(25):\n      for j in range(i + 1, 26):\n        count = len(suffixes[i] & suffixes[j])\n        ans += 2 * (len(suffixes[i]) - count) * (len(suffixes[j]) - count)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2389, "slug": "longest-subsequence-with-limited-sum", "solutions": ["class Solution:\n    def answerQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        nums.sort()\n        s = list(accumulate(nums))\n        return [bisect_right(s, q) for q in queries]\n", "class Solution:\n  def answerQueries(self, nums: list[int], queries: list[int]) -> list[int]:\n    nums.sort()\n\n    def numOfElementsLessThan(query: int) -> int:\n      summ = 0\n      for i, num in enumerate(nums):\n        summ += num\n        if summ > query:\n          return i\n      return len(nums)\n\n    return [numOfElementsLessThan(query) for query in queries]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2334, "slug": "subarray-with-elements-greater-than-varying-threshold", "solutions": ["class Solution:\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\n        def find(x):\n            if p[x] != x:\n                p[x] = find(p[x])\n            return p[x]\n\n        def merge(a, b):\n            pa, pb = find(a), find(b)\n            if pa == pb:\n                return\n            p[pa] = pb\n            size[pb] += size[pa]\n\n        n = len(nums)\n        p = list(range(n))\n        size = [1] * n\n        arr = sorted(zip(nums, range(n)), reverse=True)\n        vis = [False] * n\n        for v, i in arr:\n            if i and vis[i - 1]:\n                merge(i, i - 1)\n            if i < n - 1 and vis[i + 1]:\n                merge(i, i + 1)\n            if v > threshold // size[find(i)]:\n                return size[find(i)]\n            vis[i] = True\n        return -1\n", "class Solution:\n  # Similar to 907. Sum of Subarray Minimums\n  def validSubarraySize(self, nums: list[int], threshold: int) -> int:\n    n = len(nums)\n    ans = 0\n    # prev[i] := the index k s.t. nums[k] is the previous minimum in nums[0..n)\n    prev = [-1] * n\n    # next[i] := the index k s.t. nums[k] is the next minimum in nums[i + 1..n)\n    next = [n] * n\n    stack = []\n\n    for i, a in enumerate(nums):\n      while stack and nums[stack[-1]] > a:\n        index = stack.pop()\n        next[index] = i\n      if stack:\n        prev[i] = stack[-1]\n      stack.append(i)\n\n    for i, (num, prevIndex, nextIndex) in enumerate(zip(nums, prev, next)):\n      k = (i - prevIndex) + (nextIndex - i) - 1\n      if num > threshold / k:\n        return k\n\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2320, "slug": "count-number-of-ways-to-place-houses", "solutions": ["class Solution:\n    def countHousePlacements(self, n: int) -> int:\n        mod = 10**9 + 7\n        f = [1] * n\n        g = [1] * n\n        for i in range(1, n):\n            f[i] = g[i - 1]\n            g[i] = (f[i - 1] + g[i - 1]) % mod\n        v = f[-1] + g[-1]\n        return v * v % mod\n", "class Solution:\n  def countHousePlacements(self, n: int) -> int:\n    MOD = 1_000_000_007\n    house = 1  # the number of ways ending in a house\n    space = 1  # the number of ways ending in a space\n    total = house + space\n\n    for _ in range(2, n + 1):\n      house = space\n      space = total\n      total = (house + space) % MOD\n\n    return total**2 % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2358, "slug": "maximum-number-of-groups-entering-a-competition", "solutions": ["class Solution:\n    def maximumGroups(self, grades: List[int]) -> int:\n        n = len(grades)\n        return bisect_right(range(n + 1), n * 2, key=lambda x: x * x + x) - 1\n", "class Solution:\n  def maximumGroups(self, grades: list[int]) -> int:\n    # Sort grades, then we can seperate the students into groups of sizes 1, 2,\n    # 3, ..., k, s.t. the i-th group < the (i + 1)-th group for both sum and\n    # size. So, we can rephrase the problem into:\n    #   Find the maximum k s.t. 1 + 2 + 3 + ... + k <= n\n\n    #  1 + 2 + 3 + ... + k <= n\n    #         k(k + 1) // 2 <= n\n    #              k^2 + k <= 2n\n    #   (k + 0.5)^2 - 0.25 <= 2n\n    #          (k + 0.5)^2 <= 2n + 0.25\n    #                    k <= sqrt(2n + 0.25) - 0.5\n    return int(math.sqrt(len(grades) * 2 + 0.25) - 0.5)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2380, "slug": "time-needed-to-rearrange-a-binary-string", "solutions": ["class Solution:\n    def secondsToRemoveOccurrences(self, s: str) -> int:\n        ans = 0\n        while s.count('01'):\n            s = s.replace('01', '10')\n            ans += 1\n        return ans\n", "class Solution:\n  def secondsToRemoveOccurrences(self, s: str) -> int:\n    ans = 0\n    zeros = 0\n\n    for c in s:\n      if c == '0':\n        zeros += 1\n      elif zeros > 0:  # c == '1'\n        ans = max(ans + 1, zeros)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2308, "slug": "arrange-table-by-gender", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2397, "slug": "maximum-rows-covered-by-columns", "solutions": ["class Solution:\n    def maximumRows(self, matrix: List[List[int]], numSelect: int) -> int:\n        rows = []\n        for row in matrix:\n            mask = reduce(or_, (1 << j for j, x in enumerate(row) if x), 0)\n            rows.append(mask)\n\n        ans = 0\n        for mask in range(1 << len(matrix[0])):\n            if mask.bit_count() != numSelect:\n                continue\n            t = sum((x & mask) == x for x in rows)\n            ans = max(ans, t)\n        return ans\n", "class Solution:\n  def maximumRows(self, matrix: list[list[int]], numSelect: int) -> int:\n    ans = 0\n\n    def dfs(colIndex: int, leftColsCount: int, mask: int):\n      nonlocal ans\n      if leftColsCount == 0:\n        ans = max(ans, self._getAllZerosRowCount(matrix, mask))\n        return\n\n      if colIndex == len(matrix[0]):\n        return\n\n      # Choose this column.\n      dfs(colIndex + 1, leftColsCount - 1, mask | 1 << colIndex)\n      # Don't choose this column.\n      dfs(colIndex + 1, leftColsCount, mask)\n\n    dfs(0, numSelect, 0)\n    return ans\n\n  def _getAllZerosRowCount(self, matrix: list[list[int]], mask: int) -> int:\n    count = 0\n    for row in matrix:\n      isAllZeros = True\n      for i, num in enumerate(row):\n        if num == 1 and (mask >> i & 1) == 0:\n          isAllZeros = False\n          break\n      if isAllZeros:\n        count += 1\n    return count\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2398, "slug": "maximum-number-of-robots-within-budget", "solutions": ["class Solution:\n    def maximumRobots(\n        self, chargeTimes: List[int], runningCosts: List[int], budget: int\n    ) -> int:\n        q = deque()\n        ans = s = l = 0\n        for r, (t, c) in enumerate(zip(chargeTimes, runningCosts)):\n            s += c\n            while q and chargeTimes[q[-1]] <= t:\n                q.pop()\n            q.append(r)\n            while q and (r - l + 1) * s + chargeTimes[q[0]] > budget:\n                if q[0] == l:\n                    q.popleft()\n                s -= runningCosts[l]\n                l += 1\n            ans = max(ans, r - l + 1)\n        return ans\n", "class Solution:\n  def maximumRobots(\n      self,\n      chargeTimes: list[int],\n      runningCosts: list[int],\n      budget: int,\n  ) -> int:\n    cost = 0\n    maxQ = collections.deque()  # Stores `chargeTimes[i]`.\n\n    j = 0  # window's range := [i..j], so k = i - j + 1\n    for i, (chargeTime, runningCost) in enumerate(\n            zip(chargeTimes, runningCosts)):\n      cost += runningCost\n      while maxQ and maxQ[-1] < chargeTime:\n        maxQ.pop()\n      maxQ.append(chargeTime)\n      if maxQ[0] + (i - j + 1) * cost > budget:\n        if maxQ[0] == chargeTimes[j]:\n          maxQ.popleft()\n        cost -= runningCosts[j]\n        j += 1\n\n    return len(chargeTimes) - j\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2377, "slug": "sort-the-olympic-table", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2318, "slug": "number-of-distinct-roll-sequences", "solutions": ["class Solution:\n    def distinctSequences(self, n: int) -> int:\n        if n == 1:\n            return 6\n        mod = 10**9 + 7\n        dp = [[[0] * 6 for _ in range(6)] for _ in range(n + 1)]\n        for i in range(6):\n            for j in range(6):\n                if gcd(i + 1, j + 1) == 1 and i != j:\n                    dp[2][i][j] = 1\n        for k in range(3, n + 1):\n            for i in range(6):\n                for j in range(6):\n                    if gcd(i + 1, j + 1) == 1 and i != j:\n                        for h in range(6):\n                            if gcd(h + 1, i + 1) == 1 and h != i and h != j:\n                                dp[k][i][j] += dp[k - 1][h][i]\n        ans = 0\n        for i in range(6):\n            for j in range(6):\n                ans += dp[-1][i][j]\n        return ans % mod\n", "class Solution:\n  def distinctSequences(self, n: int) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def dp(n: int, prev: int, prevPrev: int) -> int:\n      \"\"\"\n      Returns the number of distinct sequences for n dices with `prev` and\n      `prevPrev`.\n      \"\"\"\n      if n == 0:\n        return 1\n      res = 0\n      for dice in range(1, 7):\n        if (dice not in (prev, prevPrev) and\n                (prev == 0 or math.gcd(dice, prev) == 1)):\n          res += dp(n - 1, dice, prev)\n          res %= MOD\n      return res\n\n    return dp(n, 0, 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2338, "slug": "count-the-number-of-ideal-arrays", "solutions": ["class Solution:\n    def idealArrays(self, n: int, maxValue: int) -> int:\n        @cache\n        def dfs(i, cnt):\n            res = c[-1][cnt - 1]\n            if cnt < n:\n                k = 2\n                while k * i <= maxValue:\n                    res = (res + dfs(k * i, cnt + 1)) % mod\n                    k += 1\n            return res\n\n        c = [[0] * 16 for _ in range(n)]\n        mod = 10**9 + 7\n        for i in range(n):\n            for j in range(min(16, i + 1)):\n                c[i][j] = 1 if j == 0 else (c[i - 1][j] + c[i - 1][j - 1]) % mod\n        ans = 0\n        for i in range(1, maxValue + 1):\n            ans = (ans + dfs(i, 1)) % mod\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2324, "slug": "product-sales-analysis-iv", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2372, "slug": "calculate-the-influence-of-each-salesperson", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2364, "slug": "count-number-of-bad-pairs", "solutions": ["class Solution:\n    def countBadPairs(self, nums: List[int]) -> int:\n        cnt = Counter()\n        ans = 0\n        for i, x in enumerate(nums):\n            ans += i - cnt[i - x]\n            cnt[i - x] += 1\n        return ans\n", "class Solution:\n  def countBadPairs(self, nums: list[int]) -> int:\n    ans = 0\n    count = collections.Counter()  # (nums[i] - i)\n\n    for i, num in enumerate(nums):\n      #     count[nums[i] - i] := the number of good pairs\n      # i - count[nums[i] - i] := the number of bad pairs\n      ans += i - count[num - i]\n      count[num - i] += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2341, "slug": "maximum-number-of-pairs-in-array", "solutions": ["class Solution:\n    def numberOfPairs(self, nums: List[int]) -> List[int]:\n        cnt = Counter(nums)\n        s = sum(v // 2 for v in cnt.values())\n        return [s, len(nums) - s * 2]\n", "class Solution:\n  def numberOfPairs(self, nums: list[int]) -> list[int]:\n    ans = [0] * 2\n    count = collections.Counter(nums)\n\n    for i in range(101):\n      ans[0] += count[i] // 2\n      ans[1] += count[i] & 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2344, "slug": "minimum-deletions-to-make-array-divisible", "solutions": ["class Solution:\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\n        x = numsDivide[0]\n        for v in numsDivide[1:]:\n            x = gcd(x, v)\n        nums.sort()\n        for i, v in enumerate(nums):\n            if x % v == 0:\n                return i\n        return -1\n", "class Solution:\n  def minOperations(self, nums: list[int], numsDivide: list[int]) -> int:\n    gcd = functools.reduce(math.gcd, numsDivide)\n\n    for i, num in enumerate(sorted(nums)):\n      if gcd % num == 0:\n        return i\n\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2327, "slug": "number-of-people-aware-of-a-secret", "solutions": ["class Solution:\n    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\n        m = (n << 1) + 10\n        d = [0] * m\n        cnt = [0] * m\n        cnt[1] = 1\n        for i in range(1, n + 1):\n            if cnt[i]:\n                d[i] += cnt[i]\n                d[i + forget] -= cnt[i]\n                nxt = i + delay\n                while nxt < i + forget:\n                    cnt[nxt] += cnt[i]\n                    nxt += 1\n        mod = 10**9 + 7\n        return sum(d[: n + 1]) % mod\n", "class Solution:\n  def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\n    MOD = 1_000_000_007\n    share = 0\n    # dp[i] := the number of people know the secret at day i\n    dp = [0] * n  # Maps day i to i + 1.\n    dp[0] = 1\n\n    for i in range(1, n):\n      if i - delay >= 0:\n        share += dp[i - delay]\n      if i - forget >= 0:\n        share -= dp[i - forget]\n      share += MOD\n      share %= MOD\n      dp[i] = share\n\n    # People before day `n - forget - 1` already forget the secret.\n    return sum(dp[-forget:]) % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2369, "slug": "check-if-there-is-a-valid-partition-for-the-array", "solutions": ["class Solution:\n    def validPartition(self, nums: List[int]) -> bool:\n        @cache\n        def dfs(i: int) -> bool:\n            if i >= n:\n                return True\n            a = i + 1 < n and nums[i] == nums[i + 1]\n            b = i + 2 < n and nums[i] == nums[i + 1] == nums[i + 2]\n            c = (\n                i + 2 < n\n                and nums[i + 1] - nums[i] == 1\n                and nums[i + 2] - nums[i + 1] == 1\n            )\n            return (a and dfs(i + 2)) or ((b or c) and dfs(i + 3))\n\n        n = len(nums)\n        return dfs(0)\n", "class Solution:\n  def validPartition(self, nums: list[int]) -> bool:\n    n = len(nums)\n    # dp[i] := True if there's a valid partition for the first i numbers\n    dp = [False] * (n + 1)\n    dp[0] = True\n    dp[2] = nums[0] == nums[1]\n\n    for i in range(3, n + 1):\n      dp[i] = (\n          dp[i - 2] and nums[i - 2] == nums[i - 1]) or (\n          dp[i - 3]\n          and (\n              (nums[i - 3] == nums[i - 2] and nums[i - 2] == nums[i - 1])\n              or (\n                  nums[i - 3] + 1 == nums[i - 2] and nums[i - 2] + 1 == nums\n                  [i - 1])))\n\n    return dp[n]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2330, "slug": "valid-palindrome-iv", "solutions": ["class Solution:\n    def makePalindrome(self, s: str) -> bool:\n        i, j = 0, len(s) - 1\n        cnt = 0\n        while i < j:\n            cnt += s[i] != s[j]\n            i, j = i + 1, j - 1\n        return cnt <= 2\n", "class Solution:\n  def makePalindrome(self, s: str) -> bool:\n    change = 0\n    l = 0\n    r = len(s) - 1\n\n    while l < r:\n      if s[l] != s[r]:\n        change += 1\n        if change > 2:\n          return False\n      l += 1\n      r -= 1\n\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3313, "slug": "find-the-last-marked-nodes-in-tree", "solutions": ["class Solution:\n    def lastMarkedNodes(self, edges: List[List[int]]) -> List[int]:\n        def dfs(i: int, fa: int, dist: List[int]):\n            for j in g[i]:\n                if j != fa:\n                    dist[j] = dist[i] + 1\n                    dfs(j, i, dist)\n\n        n = len(edges) + 1\n        g = [[] for _ in range(n)]\n        for u, v in edges:\n            g[u].append(v)\n            g[v].append(u)\n\n        dist1 = [-1] * n\n        dist1[0] = 0\n        dfs(0, -1, dist1)\n        a = dist1.index(max(dist1))\n\n        dist2 = [-1] * n\n        dist2[a] = 0\n        dfs(a, -1, dist2)\n        b = dist2.index(max(dist2))\n\n        dist3 = [-1] * n\n        dist3[b] = 0\n        dfs(b, -1, dist3)\n\n        return [a if x > y else b for x, y in zip(dist2, dist3)]\n", "from dataclasses import dataclass\n\n\n@dataclass\nclass Node:\n  node: int = 0  # the node number\n  time: int = 0  # the time it got marked\n\n\nclass Last2:\n  def __init__(self, last1: Node = Node(), last2: Node = Node()):\n    self.last1 = last1  # the last marked node\n    self.last2 = last2  # the second last marked node\n\n\nclass Solution:\n  # Similar to 3241. Time Taken to Mark All Nodes\n  def lastMarkedNodes(self, edges: list[list[int]]) -> list[int]:\n    n = len(edges) + 1\n    ans = [0] * n\n    tree = [[] for _ in range(n)]\n    # dp[i] := the last marked two nodes for subtree rooted at node i, where\n    # each node contains the time it got marked\n    dp = [Last2()] * n\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    self._dfs(tree, 0, -1, dp)\n    self._reroot(tree, 0, -1, Node(), dp, ans)\n    return ans\n\n  def _dfs(\n      self,\n      tree: list[list[int]],\n      u: int,\n      prev: int,\n      dp: list[Last2]\n  ) -> Node:\n    \"\"\"\n    Performs a DFS traversal of the subtree rooted at node `u`, computes the\n    time taken to mark all nodes in the subtree, records the last two marked\n    nodes, and returns the last marked node.\n\n    These values are used later in the rerooting process.\n    \"\"\"\n    last1 = Node(u, 0)\n    last2 = Node()\n    for v in tree[u]:\n      if v == prev:\n        continue\n      child = self._dfs(tree, v, u, dp)\n      time = child.time + 1\n      if time > last1.time:\n        last2 = last1\n        last1 = Node(child.node, time)\n      elif time > last2.time:\n        last2 = Node(child.node, time)\n    dp[u] = Last2(last1, last2)\n    return last1\n\n  def _reroot(\n      self,\n      tree: list[list[int]],\n      u: int,\n      prev: int,\n      last: Node,\n      dp: list[list[int]],\n      ans: list[int]\n  ) -> None:\n    \"\"\"\n    Reroots the tree at node `u` and updates the answer array, where `last`\n    is the last marked node that doesn't go through `u`'s subtree.\n    \"\"\"\n    ans[u] = last.node if last.time > dp[u].last1.time else dp[u].last1.node\n    for v in tree[u]:\n      if v == prev:\n        continue\n      newLast = Node(last.node, last.time + 1)\n      if dp[u].last1.node == dp[v].last1.node:\n        alternativeTime = 1 + dp[u].last2.time\n        if alternativeTime > newLast.time:\n          newLast = Node(dp[u].last2.node, alternativeTime)\n      else:\n        alternativeTime = 1 + dp[u].last1.time\n        if alternativeTime > newLast.time:\n          newLast = Node(dp[u].last1.node, alternativeTime)\n      self._reroot(tree, v, u, newLast, dp, ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3350, "slug": "adjacent-increasing-subarrays-detection-ii", "solutions": ["class Solution:\n    def maxIncreasingSubarrays(self, nums: List[int]) -> int:\n        ans = pre = cur = 0\n        for i, x in enumerate(nums):\n            cur += 1\n            if i == len(nums) - 1 or x >= nums[i + 1]:\n                ans = max(ans, cur // 2, min(pre, cur))\n                pre, cur = cur, 0\n        return ans\n", "class Solution:\n  # Similar to 3349. Adjacent Increasing Subarrays Detection I\n  def maxIncreasingSubarrays(self, nums: list[int]) -> int:\n    ans = 0\n    increasing = 1\n    prevIncreasing = 0\n\n    for a, b in itertools.pairwise(nums):\n      if b > a:\n        increasing += 1\n      else:\n        prevIncreasing = increasing\n        increasing = 1\n      ans = max(ans, increasing // 2)\n      ans = max(ans, min(prevIncreasing, increasing))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3354, "slug": "make-array-elements-equal-to-zero", "solutions": ["class Solution:\n    def countValidSelections(self, nums: List[int]) -> int:\n        s = sum(nums)\n        ans = l = 0\n        for x in nums:\n            if x:\n                l += x\n            elif l * 2 == s:\n                ans += 2\n            elif abs(l * 2 - s) == 1:\n                ans += 1\n        return ans\n", "class Solution:\n  def countValidSelections(self, nums: list[int]) -> int:\n    ans = 0\n    prefix = list(itertools.accumulate(nums))\n    suffix = list(itertools.accumulate(nums[::-1]))[::-1]\n\n    for i, num in enumerate(nums):\n      if num > 0:\n        continue\n      if prefix[i] == suffix[i]:\n        ans += 2  # Go to either direction.\n      if abs(prefix[i] - suffix[i]) == 1:\n        ans += 1  # Go to the direction with the larger sum.\n\n    return ans\n", "class Solution:\n  def countValidSelections(self, nums: list[int]) -> int:\n    ans = 0\n    prefix = 0\n    suffix = sum(nums)\n\n    for i, num in enumerate(nums):\n      suffix -= num\n      prefix += num\n      if num > 0:\n        continue\n      if prefix == suffix:\n        ans += 2  # Go to either direction.\n      if abs(prefix - suffix) == 1:\n        ans += 1  # Go to the direction with the larger sum.\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3337, "slug": "total-characters-in-string-after-transformations-ii", "solutions": ["class Solution:\n  # Similar to 3335. Total Characters in String After Transformations I\n  def lengthAfterTransformations(self, s: str, t: int, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n\n    def matrixMult(A: list[list[int]], B: list[list[int]]) -> list[list[int]]:\n      \"\"\"Returns A * B.\"\"\"\n      sz = len(A)\n      C = [[0] * sz for _ in range(sz)]\n      for i in range(sz):\n        for j in range(sz):\n          for k in range(sz):\n            C[i][j] += A[i][k] * B[k][j]\n            C[i][j] %= MOD\n      return C\n\n    def matrixPow(M: list[list[int]], n: int) -> list[list[int]]:\n      \"\"\"Returns M^n.\"\"\"\n      if n == 0:\n        return [[1 if i == j else 0  # identity matrix\n                for j in range(len(M))]\n                for i in range(len(M))]\n      if n % 2 == 1:\n        return matrixMult(M, matrixPow(M, n - 1))\n      return matrixPow(matrixMult(M, M), n // 2)\n\n    # T[i][j] := the number of ways to transform ('a' + i) to ('a' + j)\n    T = self._getTransformationMatrix(nums)\n    poweredT = matrixPow(T, t)\n    count = [0] * 26\n    lengths = [0] * 26\n\n    for c in s:\n      count[ord(c) - ord('a')] += 1\n\n    for i in range(26):\n      for j in range(26):\n        lengths[j] += count[i] * poweredT[i][j]\n        lengths[j] %= MOD\n\n    return sum(lengths) % MOD\n\n  def _getTransformationMatrix(self, nums: list[int]) -> list[list[int]]:\n    T = [[0] * 26 for _ in range(26)]\n    for i, steps in enumerate(nums):\n      for step in range(1, steps + 1):\n        T[i][(i + step) % 26] += 1\n    return T\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3339, "slug": "find-the-number-of-k-even-arrays", "solutions": ["class Solution:\n    def countOfArrays(self, n: int, m: int, k: int) -> int:\n        @cache\n        def dfs(i: int, j: int, k: int) -> int:\n            if j < 0:\n                return 0\n            if i >= n:\n                return int(j == 0)\n            return (\n                cnt1 * dfs(i + 1, j, 1) + cnt0 * dfs(i + 1, j - (k & 1 ^ 1), 0)\n            ) % mod\n\n        cnt0 = m // 2\n        cnt1 = m - cnt0\n        mod = 10**9 + 7\n        ans = dfs(0, k, 1)\n        dfs.cache_clear()\n        return ans\n", "class Solution:\n  def countOfArrays(self, n: int, m: int, k: int) -> int:\n    MOD = 10**9 + 7\n    even = m // 2  # the number of even numbers in [1, m]\n    odd = m - even  # the number of odd numbers in [1, m]\n    # dp[j][0/1] := the number of arrays of length so far i with j consecutive\n    # even number pairs ending in an even number (0) or an odd number (1)\n    dp = [[0] * 2 for _ in range(k + 1)]\n\n    # Base case: arrays of length 1\n    # For an array of length 1, we can't have any even number pairs yet.\n    dp[0][0] = even\n    dp[0][1] = odd\n\n    for _ in range(2, n + 1):\n      newDp = [[0] * 2 for _ in range(k + 1)]\n      for j in range(k + 1):\n        # 1. Appending an even number to an array ending in an even number\n        #    creates a new consecutive even number pair.\n        # 2. Appending an even number to an array ending in an odd number.\n        newDp[j][0] = ((dp[j - 1][0] if j > 0 else 0) * even +\n                       dp[j][1] * even) % MOD\n        # 3. Appending an odd number to an array.\n        newDp[j][1] = sum(dp[j]) * odd % MOD\n      dp = newDp\n\n    return sum(dp[k]) % MOD\n", "class Solution:\n  def countOfArrays(self, n: int, m: int, k: int) -> int:\n    MOD = 10**9 + 7\n    even = m // 2  # the number of even numbers in [1, m]\n    odd = m - even  # the number of odd numbers in [1, m]\n    # dp[i][j][0/1] := the number of arrays of length i with j consecutive even\n    # number pairs ending in an even number (0) or an odd number (1)\n    dp = [[[0] * 2\n          for _ in range(k + 1)]\n          for _ in range(n + 1)]\n\n    # Base case: arrays of length 1\n    # For an array of length 1, we can't have any even number pairs yet.\n    dp[1][0][0] = even\n    dp[1][0][1] = odd\n\n    for i in range(2, n + 1):\n      for j in range(k + 1):\n        # 1. Appending an even number to an array ending in an even number\n        #    creates a new consecutive even number pair.\n        # 2. Appending an even number to an array ending in an odd number.\n        dp[i][j][0] = ((dp[i - 1][j - 1][0] if j > 0 else 0) * even +\n                       dp[i - 1][j][1] * even) % MOD\n        # 3. Appending an odd number to an array.\n        dp[i][j][1] = sum(dp[i - 1][j]) * odd % MOD\n\n    return sum(dp[n][k]) % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3329, "slug": "count-substrings-with-k-frequency-characters-ii", "solutions": ["class Solution:\n    def numberOfSubstrings(self, s: str, k: int) -> int:\n        cnt = Counter()\n        ans = l = 0\n        for c in s:\n            cnt[c] += 1\n            while cnt[c] >= k:\n                cnt[s[l]] -= 1\n                l += 1\n            ans += l\n        return ans\n", "class Solution:\n  def numberOfSubstrings(self, s: str, k: int) -> int:\n    n = len(s)\n    ans = n * (n + 1) // 2\n    count = collections.Counter()\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] += 1\n      while count[c] == k:\n        count[s[l]] -= 1\n        l += 1\n      ans -= r - l + 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3314, "slug": "construct-the-minimum-bitwise-array-i", "solutions": ["class Solution:\n    def minBitwiseArray(self, nums: List[int]) -> List[int]:\n        ans = []\n        for x in nums:\n            if x == 2:\n                ans.append(-1)\n            else:\n                for i in range(1, 32):\n                    if x >> i & 1 ^ 1:\n                        ans.append(x ^ 1 << (i - 1))\n                        break\n        return ans\n", "class Solution:\n  def minBitwiseArray(self, nums: list[int]) -> list[int]:\n    return [-1 if num == 2 else num - self._getLeadingOneOfLastGroupOfOnes(num)\n            for num in nums]\n\n  def _getLeadingOneOfLastGroupOfOnes(self, num: int) -> int:\n    \"\"\"\n    Returns the leading one of the last group of 1s in the binary\n    representation of num. For example, if num = 0b10111, the leading one of\n    the last group of 1s is 0b100.\n    \"\"\"\n    leadingOne = 1\n    while (num & leadingOne) > 0:\n      leadingOne <<= 1\n    return leadingOne >> 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3343, "slug": "count-number-of-balanced-permutations", "solutions": ["class Solution:\n    def countBalancedPermutations(self, num: str) -> int:\n        @cache\n        def dfs(i: int, j: int, a: int, b: int) -> int:\n            if i > 9:\n                return (j | a | b) == 0\n            if a == 0 and j:\n                return 0\n            ans = 0\n            for l in range(min(cnt[i], a) + 1):\n                r = cnt[i] - l\n                if 0 <= r <= b and l * i <= j:\n                    t = comb(a, l) * comb(b, r) * dfs(i + 1, j - l * i, a - l, b - r)\n                    ans = (ans + t) % mod\n            return ans\n\n        nums = list(map(int, num))\n        s = sum(nums)\n        if s % 2:\n            return 0\n        n = len(nums)\n        mod = 10**9 + 7\n        cnt = Counter(nums)\n        return dfs(0, s // 2, n // 2, (n + 1) // 2)\n", "class Solution:\n  def countBalancedPermutations(self, num: str) -> int:\n    nums = list(map(int, num))\n    summ = sum(nums)\n    if summ % 2 == 1:\n      return 0\n\n    nums.sort(reverse=True)\n\n    @functools.lru_cache(None)\n    def dp(even: int, odd: int, evenBalance: int) -> int:\n      \"\"\"\n      Returns the number of permutations where there are `even` even indices\n      left, `odd` odd indices left, and `evenBalance` is the target sum of the\n      remaining numbers to be placed in even indices.\n      \"\"\"\n      if evenBalance < 0:\n        return 0\n      if even == 0:\n        return (evenBalance == 0) * math.factorial(odd)\n      if odd == 0:\n        return (sum(nums[-(even + odd):]) == evenBalance) * math.factorial(even)\n      return (dp(even - 1, odd, evenBalance - nums[-(odd + even)]) * even +\n              dp(even, odd - 1, evenBalance) * odd)\n\n    MOD = 1_000_000_007\n    perm = functools.reduce(lambda x, y: x * math.factorial(y),\n                            collections.Counter(nums).values(), 1)\n    return (dp(even=(len(nums) + 1) // 2,\n               odd=len(nums) // 2,\n               evenBalance=summ // 2) // perm) % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3356, "slug": "zero-array-transformation-ii", "solutions": ["class Solution:\n    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:\n        def check(k: int) -> bool:\n            d = [0] * (len(nums) + 1)\n            for l, r, val in queries[:k]:\n                d[l] += val\n                d[r + 1] -= val\n            s = 0\n            for x, y in zip(nums, d):\n                s += y\n                if x > s:\n                    return False\n            return True\n\n        m = len(queries)\n        l = bisect_left(range(m + 1), True, key=check)\n        return -1 if l > m else l\n", "class Solution:\n  def minZeroArray(self, nums: list[int], queries: list[list[int]]) -> int:\n    line = [0] * (len(nums) + 1)\n    decrement = 0\n    k = 0\n\n    for i, num in enumerate(nums):\n      while decrement + line[i] < num:\n        if k == len(queries):\n          return -1\n        l, r, val = queries[k]\n        k += 1\n        if r < i:\n          continue\n        line[max(l, i)] += val\n        line[r + 1] -= val\n      decrement += line[i]\n\n    return k\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3328, "slug": "find-cities-in-each-state-ii", "solutions": ["import pandas as pd\n\n\ndef state_city_analysis(cities: pd.DataFrame) -> pd.DataFrame:\n    cities[\"matching_letter\"] = cities[\"city\"].str[0] == cities[\"state\"].str[0]\n\n    result = (\n        cities.groupby(\"state\")\n        .agg(\n            cities=(\"city\", lambda x: \", \".join(sorted(x))),\n            matching_letter_count=(\"matching_letter\", \"sum\"),\n            city_count=(\"city\", \"count\"),\n        )\n        .reset_index()\n    )\n\n    result = result[(result[\"city_count\"] >= 3) & (result[\"matching_letter_count\"] > 0)]\n\n    result = result.sort_values(\n        by=[\"matching_letter_count\", \"state\"], ascending=[False, True]\n    )\n\n    result = result.drop(columns=[\"city_count\"])\n\n    return result\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3398, "slug": "smallest-substring-with-identical-characters-i", "solutions": ["class Solution:\n    def minLength(self, s: str, numOps: int) -> int:\n        def check(m: int) -> bool:\n            cnt = 0\n            if m == 1:\n                t = \"01\"\n                cnt = sum(c == t[i & 1] for i, c in enumerate(s))\n                cnt = min(cnt, n - cnt)\n            else:\n                k = 0\n                for i, c in enumerate(s):\n                    k += 1\n                    if i == len(s) - 1 or c != s[i + 1]:\n                        cnt += k // (m + 1)\n                        k = 0\n            return cnt <= numOps\n\n        n = len(s)\n        return bisect_left(range(n), True, lo=1, key=check)\n", "class Solution:\n  def minLength(self, s: str, numOps: int) -> int:\n    def getMinOps(k: int) -> int:\n      \"\"\"\n      Returns the minimum number of operations needed to make all groups of\n      identical characters of length k or less.\n      \"\"\"\n      if k == 1:\n        res = sum(1 for i, c in enumerate(s) if int(c) == i % 2)\n        return min(res, len(s) - res)\n\n      res = 0\n      runningLen = 1\n\n      for a, b in itertools.pairwise(s):\n        if a == b:\n          runningLen += 1\n        else:\n          res += runningLen // (k + 1)\n          runningLen = 1\n\n      return res + runningLen // (k + 1)\n\n    return bisect_left(range(1, len(s) + 1),\n                       True, key=lambda m: getMinOps(m) <= numOps)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3392, "slug": "count-subarrays-of-length-three-with-a-condition", "solutions": ["class Solution:\n    def countSubarrays(self, nums: List[int]) -> int:\n        return sum(\n            (nums[i - 1] + nums[i + 1]) * 2 == nums[i] for i in range(1, len(nums) - 1)\n        )\n", "class Solution:\n  def countSubarrays(self, nums: list[int]) -> int:\n    return sum(b == (a + c) * 2\n               for a, b, c in zip(nums, nums[1:], nums[2:]))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3385, "slug": "minimum-time-to-break-locks-ii", "solutions": ["class MCFGraph:\n    class Edge(NamedTuple):\n        src: int\n        dst: int\n        cap: int\n        flow: int\n        cost: int\n\n    class _Edge:\n        def __init__(self, dst: int, cap: int, cost: int) -> None:\n            self.dst = dst\n            self.cap = cap\n            self.cost = cost\n            self.rev: Optional[MCFGraph._Edge] = None\n\n    def __init__(self, n: int) -> None:\n        self._n = n\n        self._g: List[List[MCFGraph._Edge]] = [[] for _ in range(n)]\n        self._edges: List[MCFGraph._Edge] = []\n\n    def add_edge(self, src: int, dst: int, cap: int, cost: int) -> int:\n        assert 0 <= src < self._n\n        assert 0 <= dst < self._n\n        assert 0 <= cap\n        m = len(self._edges)\n        e = MCFGraph._Edge(dst, cap, cost)\n        re = MCFGraph._Edge(src, 0, -cost)\n        e.rev = re\n        re.rev = e\n        self._g[src].append(e)\n        self._g[dst].append(re)\n        self._edges.append(e)\n        return m\n\n    def get_edge(self, i: int) -> Edge:\n        assert 0 <= i < len(self._edges)\n        e = self._edges[i]\n        re = cast(MCFGraph._Edge, e.rev)\n        return MCFGraph.Edge(re.dst, e.dst, e.cap + re.cap, re.cap, e.cost)\n\n    def edges(self) -> List[Edge]:\n        return [self.get_edge(i) for i in range(len(self._edges))]\n\n    def flow(self, s: int, t: int, flow_limit: Optional[int] = None) -> Tuple[int, int]:\n        return self.slope(s, t, flow_limit)[-1]\n\n    def slope(\n        self, s: int, t: int, flow_limit: Optional[int] = None\n    ) -> List[Tuple[int, int]]:\n        assert 0 <= s < self._n\n        assert 0 <= t < self._n\n        assert s != t\n        if flow_limit is None:\n            flow_limit = cast(int, sum(e.cap for e in self._g[s]))\n\n        dual = [0] * self._n\n        prev: List[Optional[Tuple[int, MCFGraph._Edge]]] = [None] * self._n\n\n        def refine_dual() -> bool:\n            pq = [(0, s)]\n            visited = [False] * self._n\n            dist: List[Optional[int]] = [None] * self._n\n            dist[s] = 0\n            while pq:\n                dist_v, v = heappop(pq)\n                if visited[v]:\n                    continue\n                visited[v] = True\n                if v == t:\n                    break\n                dual_v = dual[v]\n                for e in self._g[v]:\n                    w = e.dst\n                    if visited[w] or e.cap == 0:\n                        continue\n                    reduced_cost = e.cost - dual[w] + dual_v\n                    new_dist = dist_v + reduced_cost\n                    dist_w = dist[w]\n                    if dist_w is None or new_dist < dist_w:\n                        dist[w] = new_dist\n                        prev[w] = v, e\n                        heappush(pq, (new_dist, w))\n            else:\n                return False\n            dist_t = dist[t]\n            for v in range(self._n):\n                if visited[v]:\n                    dual[v] -= cast(int, dist_t) - cast(int, dist[v])\n            return True\n\n        flow = 0\n        cost = 0\n        prev_cost_per_flow: Optional[int] = None\n        result = [(flow, cost)]\n        while flow < flow_limit:\n            if not refine_dual():\n                break\n            f = flow_limit - flow\n            v = t\n            while prev[v] is not None:\n                u, e = cast(Tuple[int, MCFGraph._Edge], prev[v])\n                f = min(f, e.cap)\n                v = u\n            v = t\n            while prev[v] is not None:\n                u, e = cast(Tuple[int, MCFGraph._Edge], prev[v])\n                e.cap -= f\n                assert e.rev is not None\n                e.rev.cap += f\n                v = u\n            c = -dual[s]\n            flow += f\n            cost += f * c\n            if c == prev_cost_per_flow:\n                result.pop()\n            result.append((flow, cost))\n            prev_cost_per_flow = c\n        return result\n\n\nclass Solution:\n    def findMinimumTime(self, a: List[int]) -> int:\n        n = len(a)\n        s = n * 2\n        t = s + 1\n        g = MCFGraph(t + 1)\n\n        for i in range(n):\n            g.add_edge(s, i, 1, 0)\n            g.add_edge(i + n, t, 1, 0)\n            for j in range(n):\n                g.add_edge(i, j + n, 1, (a[i] - 1) // (j + 1) + 1)\n\n        return g.flow(s, t, n)[1]\n", "class Solution:\n  def findMinimumTime(self, strength: list[int]) -> int:\n    costs = [[(s + turn - 1) // turn\n             for s in strength]\n             for turn in range(1, len(strength) + 1)]\n    return self._hungarian(costs)[-1]\n\n  def _hungarian(self, costs):\n    \"\"\"\n    Returns an array `res` of length n (costs.length), with `res[i]` equaling\n    the minimum cost to assign the first (i + 1) turns to the first (i + 1)\n    locks using Hungarian algorithm, where costs[i][j] is the energy required\n    to break j-th lock in i-th turn.\n\n    https://en.wikipedia.org/wiki/Hungarian_algorithm\n    \"\"\"\n    numLocks = len(costs)\n    turnPotentials = [0] * numLocks\n    lockPotentials = [0] * (numLocks + 1)\n    lockAssignments = [-1] * (numLocks + 1)\n    res = []\n\n    for currentTurn in range(numLocks):\n      currentLock = numLocks\n      lockAssignments[currentLock] = currentTurn\n      minReducedCosts = [math.inf] * (numLocks + 1)\n      previousLockAssignments = [-1] * (numLocks + 1)\n      locksInOptimalPath = [False] * (numLocks + 1)\n\n      while lockAssignments[currentLock] != -1:\n        locksInOptimalPath[currentLock] = True\n        assignedTurn = lockAssignments[currentLock]\n        minCostDelta = math.inf\n        nextLock = None\n\n        for lock in range(numLocks):\n          if not locksInOptimalPath[lock]:\n            reducedCost = (\n                costs[assignedTurn][lock] -\n                turnPotentials[assignedTurn] -\n                lockPotentials[lock]\n            )\n            oldMin = minReducedCosts[lock]\n            minReducedCosts[lock] = min(oldMin, reducedCost)\n            if minReducedCosts[lock] < oldMin:\n              previousLockAssignments[lock] = currentLock\n            if minReducedCosts[lock] < minCostDelta:\n              minCostDelta = minReducedCosts[lock]\n              nextLock = lock\n\n        for lock in range(numLocks + 1):\n          if locksInOptimalPath[lock]:\n            turnPotentials[lockAssignments[lock]] += minCostDelta\n            lockPotentials[lock] -= minCostDelta\n          else:\n            minReducedCosts[lock] -= minCostDelta\n\n        currentLock = nextLock\n\n      while currentLock != numLocks:\n        lockAssignments[currentLock] = lockAssignments[previousLockAssignments[currentLock]]\n        currentLock = previousLockAssignments[currentLock]\n\n      res.append(-lockPotentials[numLocks])\n\n    return res\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3397, "slug": "maximum-number-of-distinct-elements-after-operations", "solutions": ["class Solution:\n    def maxDistinctElements(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        ans = 0\n        pre = -inf\n        for x in nums:\n            cur = min(x + k, max(x - k, pre + 1))\n            if cur > pre:\n                ans += 1\n                pre = cur\n        return ans\n", "class Solution:\n  def maxDistinctElements(self, nums: list[int], k: int) -> int:\n    ans = 0\n    occupied = -math.inf\n\n    for num in sorted(nums):\n      if occupied < num + k:\n        occupied = max(occupied + 1, num - k)\n        ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3319, "slug": "k-th-largest-perfect-subtree-size-in-binary-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:\n        def dfs(root: Optional[TreeNode]) -> int:\n            if root is None:\n                return 0\n            l, r = dfs(root.left), dfs(root.right)\n            if l < 0 or l != r:\n                return -1\n            cnt = l + r + 1\n            nums.append(cnt)\n            return cnt\n\n        nums = []\n        dfs(root)\n        if len(nums) < k:\n            return -1\n        nums.sort(reverse=True)\n        return nums[k - 1]\n", "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass T:\n  isPerfect: bool\n  sz: int\n\n\nclass Solution:\n  def kthLargestPerfectSubtree(self, root: TreeNode | None, k: int) -> int:\n    ans = []\n    self._dfs(root, ans)\n    if len(ans) < k:\n      return -1\n    return sorted(ans, reverse=True)[k - 1]\n\n  def _dfs(self, root: TreeNode, ans: list[int]) -> T:\n    if not root:\n      return T(True, 0)\n    l = self._dfs(root.left, ans)\n    r = self._dfs(root.right, ans)\n    if l.isPerfect and r.isPerfect and l.sz == r.sz:\n      sz = 1 + l.sz + r.sz\n      ans.append(sz)\n      return T(True, sz)\n    return T(False, 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3316, "slug": "find-maximum-removals-from-source-string", "solutions": ["class Solution:\n    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:\n        m, n = len(source), len(pattern)\n        f = [[-inf] * (n + 1) for _ in range(m + 1)]\n        f[0][0] = 0\n        s = set(targetIndices)\n        for i, c in enumerate(source, 1):\n            for j in range(n + 1):\n                f[i][j] = f[i - 1][j] + int((i - 1) in s)\n                if j and c == pattern[j - 1]:\n                    f[i][j] = max(f[i][j], f[i - 1][j - 1])\n        return f[m][n]\n", "class Solution:\n  def maxRemovals(\n      self,\n      source: str,\n      pattern: str,\n      targetIndices: list[int]\n  ) -> int:\n    m = len(source)\n    n = len(pattern)\n    target = set(targetIndices)\n    # dp[i][j] := the maximum number of operations that can be performed for\n    # source[i..m) and pattern[j..n)\n    dp = [[-math.inf] * (n + 1) for _ in range(m + 1)]\n    dp[m][n] = 0\n\n    for i in reversed(range(m)):\n      dp[i][n] = int(i in target) + dp[i + 1][n]\n      for j in reversed(range(n)):\n        pick = dp[i + 1][j + 1] if source[i] == pattern[j] else -math.inf\n        skip = int(i in target) + dp[i + 1][j]\n        dp[i][j] = max(pick, skip)\n\n    return 0 if dp[0][0] == -math.inf else dp[0][0]\n", "class Solution:\n  def maxRemovals(\n      self,\n      source: str,\n      pattern: str,\n      targetIndices: list[int]\n  ) -> int:\n    m = len(source)\n    n = len(pattern)\n    target = set(targetIndices)\n    # dp[j] := the maximum number of operations that can be performed for\n    # source so far and pattern[j..n)\n    dp = [-math.inf] * (n + 1)\n    dp[n] = 0\n\n    for i in reversed(range(m)):\n      newDp = dp[:]\n      newDp[n] = int(i in target) + dp[n]\n      for j in range(n):\n        pick = dp[j + 1] if source[i] == pattern[j] else -math.inf\n        skip = int(i in target) + dp[j]\n        newDp[j] = max(pick, skip)\n      dp = newDp\n\n    return 0 if dp[0] == -math.inf else dp[0]\n", "class Solution:\n  def maxRemovals(\n      self,\n      source: str,\n      pattern: str,\n      targetIndices: list[int]\n  ) -> int:\n    m = len(source)\n    n = len(pattern)\n    target = set(targetIndices)\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int) -> int:\n      \"\"\"\n      Returns the maximum number of operations that can be performed for\n      source[i..m) and pattern[j..n).\n      \"\"\"\n      if i == m:\n        return 0 if j == n else -math.inf\n      if j == n:\n        return int(i in target) + dp(i + 1, j)\n      pick = dp(i + 1, j + 1) if source[i] == pattern[j] else -math.inf\n      skip = int(i in target) + dp(i + 1, j)\n      return max(pick, skip)\n\n    ans = dp(0, 0)\n    return 0 if ans == -math.inf else ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3379, "slug": "transformed-array", "solutions": ["class Solution:\n    def constructTransformedArray(self, nums: List[int]) -> List[int]:\n        ans = []\n        n = len(nums)\n        for i, x in enumerate(nums):\n            ans.append(nums[(i + x + n) % n] if x else 0)\n        return ans\n", "class Solution:\n  def constructTransformedArray(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n    return [nums[(i + num % n + n) % n]\n            for i, num in enumerate(nums)]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3341, "slug": "find-minimum-time-to-reach-last-room-i", "solutions": ["class Solution:\n    def minTimeToReach(self, moveTime: List[List[int]]) -> int:\n        n, m = len(moveTime), len(moveTime[0])\n        dist = [[inf] * m for _ in range(n)]\n        dist[0][0] = 0\n        pq = [(0, 0, 0)]\n        dirs = (-1, 0, 1, 0, -1)\n        while 1:\n            d, i, j = heappop(pq)\n            if i == n - 1 and j == m - 1:\n                return d\n            if d > dist[i][j]:\n                continue\n            for a, b in pairwise(dirs):\n                x, y = i + a, j + b\n                if 0 <= x < n and 0 <= y < m:\n                    t = max(moveTime[x][y], dist[i][j]) + 1\n                    if dist[x][y] > t:\n                        dist[x][y] = t\n                        heappush(pq, (t, x, y))\n", "class Solution:\n  def minTimeToReach(self, moveTime: list[list[int]]) -> int:\n    return self._dijkstra(moveTime,\n                          (0, 0),\n                          (len(moveTime) - 1, len(moveTime[0]) - 1))\n\n  def _dijkstra(\n      self,\n      moveTime: list[list[int]],\n      src: tuple[int, int],\n      dst: tuple[int, int]\n  ) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(moveTime)\n    n = len(moveTime[0])\n    dist = [[math.inf] * n for _ in range(m)]\n\n    dist[0][0] = 0\n    minHeap = [(0, src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if u == dst:\n        return d\n      i, j = u\n      if d > dist[i][j]:\n        continue\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        newDist = max(moveTime[x][y], d) + 1\n        if newDist < dist[x][y]:\n          dist[x][y] = newDist\n          heapq.heappush(minHeap, (newDist, (x, y)))\n\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3394, "slug": "check-if-grid-can-be-cut-into-sections", "solutions": ["class Solution:\n    def countLineIntersections(self, coordinates: List[tuple[int, int]]) -> bool:\n        lines = 0\n        overlap = 0\n        for value, marker in coordinates:\n            if marker == 0:\n                overlap -= 1\n            else:\n                overlap += 1\n\n            if overlap == 0:\n                lines += 1\n\n        return lines >= 3\n\n    def checkValidCuts(self, n: int, rectangles: List[List[int]]) -> bool:\n        y_coordinates = []\n        x_coordinates = []\n\n        for rect in rectangles:\n            x1, y1, x2, y2 = rect\n            y_coordinates.append((y1, 1))  # start\n            y_coordinates.append((y2, 0))  # end\n\n            x_coordinates.append((x1, 1))  # start\n            x_coordinates.append((x2, 0))  # end\n\n        # Sort by coordinate value, and for tie, put end (0) before start (1)\n        y_coordinates.sort(key=lambda x: (x[0], x[1]))\n        x_coordinates.sort(key=lambda x: (x[0], x[1]))\n\n        return self.countLineIntersections(\n            y_coordinates\n        ) or self.countLineIntersections(x_coordinates)\n", "class Solution:\n  def checkValidCuts(self, n: int, rectangles: list[list[int]]) -> bool:\n    xs = [(startX, endX) for startX, _, endX, _ in rectangles]\n    ys = [(startY, endY) for _, startY, _, endY in rectangles]\n    return max(self._countMerged(xs),\n               self._countMerged(ys)) >= 3\n\n  def _countMerged(self, intervals: list[tuple[int, int]]) -> int:\n    count = 0\n    prevEnd = 0\n    for start, end in sorted(intervals):\n      if start < prevEnd:\n        prevEnd = max(prevEnd, end)\n      else:\n        prevEnd = end\n        count += 1\n    return count\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3374, "slug": "first-letter-capitalization-ii", "solutions": ["import pandas as pd\n\n\ndef capitalize_content(user_content: pd.DataFrame) -> pd.DataFrame:\n    def convert_text(text: str) -> str:\n        return \" \".join(\n            (\n                \"-\".join([part.capitalize() for part in word.split(\"-\")])\n                if \"-\" in word\n                else word.capitalize()\n            )\n            for word in text.split(\" \")\n        )\n\n    user_content[\"converted_text\"] = user_content[\"content_text\"].apply(convert_text)\n    return user_content.rename(columns={\"content_text\": \"original_text\"})[\n        [\"content_id\", \"original_text\", \"converted_text\"]\n    ]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3338, "slug": "second-highest-salary-ii", "solutions": ["import pandas as pd\n\n\ndef find_second_highest_salary(employees: pd.DataFrame) -> pd.DataFrame:\n    employees[\"rk\"] = employees.groupby(\"dept\")[\"salary\"].rank(\n        method=\"dense\", ascending=False\n    )\n    second_highest = employees[employees[\"rk\"] == 2][[\"emp_id\", \"dept\"]]\n    return second_highest.sort_values(by=\"emp_id\")\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3368, "slug": "first-letter-capitalization", "solutions": ["import pandas as pd\n\n\ndef process_text(user_content: pd.DataFrame) -> pd.DataFrame:\n    user_content[\"converted_text\"] = user_content[\"content_text\"].apply(\n        lambda text: \" \".join(word.capitalize() for word in text.split(\" \"))\n    )\n    return user_content[[\"content_id\", \"content_text\", \"converted_text\"]].rename(\n        columns={\"content_text\": \"original_text\"}\n    )\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3306, "slug": "count-of-substrings-containing-every-vowel-and-k-consonants-ii", "solutions": ["class Solution:\n    def countOfSubstrings(self, word: str, k: int) -> int:\n        def f(k: int) -> int:\n            cnt = Counter()\n            ans = l = x = 0\n            for c in word:\n                if c in \"aeiou\":\n                    cnt[c] += 1\n                else:\n                    x += 1\n                while x >= k and len(cnt) == 5:\n                    d = word[l]\n                    if d in \"aeiou\":\n                        cnt[d] -= 1\n                        if cnt[d] == 0:\n                            cnt.pop(d)\n                    else:\n                        x -= 1\n                    l += 1\n                ans += l\n            return ans\n\n        return f(k) - f(k + 1)\n", "class Solution:\n  # Same as 3305. Count of Substrings Containing Every Vowel and K Consonants I\n  def countOfSubstrings(self, word: str, k: int) -> int:\n    VOWELS = 'aeiou'\n\n    def substringsWithAtMost(k: int) -> int:\n      \"\"\"\n      Return the number of substrings containing every vowel with at most k\n      consonants.\n      \"\"\"\n      if k < 0:\n        return 0\n\n      res = 0\n      vowels = 0\n      uniqueVowels = 0\n      vowelLastSeen = {}\n\n      l = 0\n      for r, c in enumerate(word):\n        if c in VOWELS:\n          vowels += 1\n          if c not in vowelLastSeen or vowelLastSeen[c] < l:\n            uniqueVowels += 1\n          vowelLastSeen[c] = r\n        while r - l + 1 - vowels > k:\n          if word[l] in VOWELS:\n            vowels -= 1\n            if vowelLastSeen[word[l]] == l:\n              uniqueVowels -= 1\n          l += 1\n        if uniqueVowels == 5:\n          # Add substrings containing every vowel with at most k consonants to\n          # the answer. They are\n          # word[l..r], word[l + 1..r], ..., word[min(vowelLastSeen[vowel])..r]\n          res += min(vowelLastSeen[vowel] for vowel in VOWELS) - l + 1\n\n      return res\n\n    return substringsWithAtMost(k) - substringsWithAtMost(k - 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3318, "slug": "find-x-sum-of-all-k-long-subarrays-i", "solutions": ["class Solution:\n    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:\n        def add(v: int):\n            if cnt[v] == 0:\n                return\n            p = (cnt[v], v)\n            if l and p > l[0]:\n                nonlocal s\n                s += p[0] * p[1]\n                l.add(p)\n            else:\n                r.add(p)\n\n        def remove(v: int):\n            if cnt[v] == 0:\n                return\n            p = (cnt[v], v)\n            if p in l:\n                nonlocal s\n                s -= p[0] * p[1]\n                l.remove(p)\n            else:\n                r.remove(p)\n\n        l = SortedList()\n        r = SortedList()\n        cnt = Counter()\n        s = 0\n        n = len(nums)\n        ans = [0] * (n - k + 1)\n        for i, v in enumerate(nums):\n            remove(v)\n            cnt[v] += 1\n            add(v)\n            j = i - k + 1\n            if j < 0:\n                continue\n            while r and len(l) < x:\n                p = r.pop()\n                l.add(p)\n                s += p[0] * p[1]\n            while len(l) > x:\n                p = l.pop(0)\n                s -= p[0] * p[1]\n                r.add(p)\n            ans[j] = s\n\n            remove(nums[j])\n            cnt[nums[j]] -= 1\n            add(nums[j])\n        return ans\n", "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def findXSum(self, nums: list[int], k: int, x: int) -> list[int]:\n    ans = []\n    windowSum = 0\n    count = collections.Counter()\n    top = SortedList()\n    bot = SortedList()\n\n    def update(num: int, freq: int) -> None:\n      \"\"\"Updates the count of num by freq and the window sum accordingly.\"\"\"\n      nonlocal windowSum\n      if count[num] > 0:  # Clean up old values.\n        if [count[num], num] in bot:\n          bot.remove([count[num], num])\n        else:\n          top.remove([count[num], num])\n          windowSum -= num * count[num]\n      count[num] += freq\n      if count[num] > 0:\n        bot.add([count[num], num])\n\n    for i, num in enumerate(nums):\n      update(num, 1)\n      if i >= k:\n        update(nums[i - k], -1)\n      # Move the bottom element to the top if needed.\n      while bot and len(top) < x:\n        countB, b = bot.pop()\n        top.add([countB, b])\n        windowSum += b * countB\n      # Swap the bottom and top elements if needed.\n      while bot and bot[-1] > top[0]:\n        countB, b = bot.pop()\n        countT, t = top.pop(0)\n        bot.add([countT, t])\n        windowSum -= t * countT\n        top.add([countB, b])\n        windowSum += b * countB\n      if i >= k - 1:\n        ans.append(windowSum)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3321, "slug": "find-x-sum-of-all-k-long-subarrays-ii", "solutions": ["class Solution:\n    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:\n        def add(v: int):\n            if cnt[v] == 0:\n                return\n            p = (cnt[v], v)\n            if l and p > l[0]:\n                nonlocal s\n                s += p[0] * p[1]\n                l.add(p)\n            else:\n                r.add(p)\n\n        def remove(v: int):\n            if cnt[v] == 0:\n                return\n            p = (cnt[v], v)\n            if p in l:\n                nonlocal s\n                s -= p[0] * p[1]\n                l.remove(p)\n            else:\n                r.remove(p)\n\n        l = SortedList()\n        r = SortedList()\n        cnt = Counter()\n        s = 0\n        n = len(nums)\n        ans = [0] * (n - k + 1)\n        for i, v in enumerate(nums):\n            remove(v)\n            cnt[v] += 1\n            add(v)\n            j = i - k + 1\n            if j < 0:\n                continue\n            while r and len(l) < x:\n                p = r.pop()\n                l.add(p)\n                s += p[0] * p[1]\n            while len(l) > x:\n                p = l.pop(0)\n                s -= p[0] * p[1]\n                r.add(p)\n            ans[j] = s\n\n            remove(nums[j])\n            cnt[nums[j]] -= 1\n            add(nums[j])\n        return ans\n", "from sortedcontainers import SortedList\n\n\nclass Solution:\n  # Same as 3318. Find X-Sum of All K-Long Subarrays I\n  def findXSum(self, nums: list[int], k: int, x: int) -> list[int]:\n    ans = []\n    windowSum = 0\n    count = collections.Counter()\n    top = SortedList()  # the top x elements\n    bot = SortedList()  # the rest of the elements\n\n    def update(num: int, freq: int) -> None:\n      \"\"\"Updates the count of num by freq and the window sum accordingly.\"\"\"\n      nonlocal windowSum\n      if count[num] > 0:  # Clean up the old count.\n        if [count[num], num] in bot:\n          bot.remove([count[num], num])\n        else:\n          top.remove([count[num], num])\n          windowSum -= num * count[num]\n      count[num] += freq\n      if count[num] > 0:\n        bot.add([count[num], num])\n\n    for i, num in enumerate(nums):\n      update(num, 1)\n      if i >= k:\n        update(nums[i - k], -1)\n      # Move the bottom elements to the top if needed.\n      while bot and len(top) < x:\n        countB, b = bot.pop()\n        top.add([countB, b])\n        windowSum += b * countB\n      # Swap the bottom and top elements if needed.\n      while bot and bot[-1] > top[0]:\n        countB, b = bot.pop()\n        countT, t = top.pop(0)\n        bot.add([countT, t])\n        top.add([countB, b])\n        windowSum += b * countB\n        windowSum -= t * countT\n      if i >= k - 1:\n        ans.append(windowSum)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3364, "slug": "minimum-positive-sum-subarray", "solutions": ["class Solution:\n    def minimumSumSubarray(self, nums: List[int], l: int, r: int) -> int:\n        n = len(nums)\n        ans = inf\n        for i in range(n):\n            s = 0\n            for j in range(i, n):\n                s += nums[j]\n                if l <= j - i + 1 <= r and s > 0:\n                    ans = min(ans, s)\n        return -1 if ans == inf else ans\n", "class Solution:\n  def minimumSumSubarray(self, nums: list[int], l: int, r: int) -> int:\n    ans = math.inf\n\n    for windowSize in range(l, r + 1):\n      windowSum = sum(nums[:windowSize])\n      if windowSum > 0:\n        ans = min(ans, windowSum)\n      for i in range(windowSize, len(nums)):\n        windowSum -= nums[i - windowSize]\n        windowSum += nums[i]\n        if windowSum > 0:\n          ans = min(ans, windowSum)\n\n    return -1 if ans == math.inf else ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3370, "slug": "smallest-number-with-all-set-bits", "solutions": ["class Solution:\n    def smallestNumber(self, n: int) -> int:\n        x = 1\n        while x - 1 < n:\n            x <<= 1\n        return x - 1\n", "class Solution:\n  def smallestNumber(self, n: int) -> int:\n    return (1 << n.bit_length()) - 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3320, "slug": "count-the-number-of-winning-sequences", "solutions": ["class Solution:\n    def countWinningSequences(self, s: str) -> int:\n        def calc(x: int, y: int) -> int:\n            if x == y:\n                return 0\n            if x < y:\n                return 1 if x == 0 and y == 2 else -1\n            return -1 if x == 2 and y == 0 else 1\n\n        @cache\n        def dfs(i: int, j: int, k: int) -> int:\n            if len(s) - i <= j:\n                return 0\n            if i >= len(s):\n                return int(j < 0)\n            res = 0\n            for l in range(3):\n                if l == k:\n                    continue\n                res = (res + dfs(i + 1, j + calc(d[s[i]], l), l)) % mod\n            return res\n\n        mod = 10**9 + 7\n        d = {\"F\": 0, \"W\": 1, \"E\": 2}\n        ans = dfs(0, 0, -1)\n        dfs.cache_clear()\n        return ans\n", "class Solution:\n  def countWinningSequences(self, s: str) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def dp(i: int, prev: int, bob: int) -> int:\n      \"\"\"\n      Returns the number of distinct sequences Bob can use to beat Alice for\n      s[i..n), where the previous character is `prev` (0: F, 1: W, 2: E) and the\n      number of points that Bob is having is `bob`.\n      \"\"\"\n      if i == len(s):\n        return int(bob > 0)\n\n      f = 0  # If Bob summons a Fire Dragon at i.\n      w = 0  # If Bob summons a Water Serpent at i.\n      e = 0  # If Bob summons a Earth Golem at i.\n\n      match s[i]:\n        case 'F':\n          if prev != 0:\n            f = dp(i + 1, 0, bob) % MOD\n          if prev != 1:\n            w = dp(i + 1, 1, bob + 1) % MOD\n          if prev != 2:\n            e = dp(i + 1, 2, bob - 1) % MOD\n        case 'W':\n          if prev != 0:\n            f = dp(i + 1, 0, bob - 1) % MOD\n          if prev != 1:\n            w = dp(i + 1, 1, bob) % MOD\n          if prev != 2:\n            e = dp(i + 1, 2, bob + 1) % MOD\n        case 'E':\n          if prev != 0:\n            f = dp(i + 1, 0, bob + 1) % MOD\n          if prev != 1:\n            w = dp(i + 1, 1, bob - 1) % MOD\n          if prev != 2:\n            e = dp(i + 1, 2, bob) % MOD\n\n      return f + w + e\n\n    return (dp(0, 0, 0) + dp(0, 1, 0) + dp(0, 2, 0)) // 2 % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3317, "slug": "find-the-number-of-possible-ways-for-an-event", "solutions": ["class Solution:\n    def numberOfWays(self, n: int, x: int, y: int) -> int:\n        mod = 10**9 + 7\n        f = [[0] * (x + 1) for _ in range(n + 1)]\n        f[0][0] = 1\n        for i in range(1, n + 1):\n            for j in range(1, x + 1):\n                f[i][j] = (f[i - 1][j] * j + f[i - 1][j - 1] * (x - (j - 1))) % mod\n        ans, p = 0, 1\n        for j in range(1, x + 1):\n            p = p * y % mod\n            ans = (ans + f[n][j] * p) % mod\n        return ans\n", "class Solution:\n  def numberOfWays(self, n: int, x: int, y: int) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def fact(i: int) -> int:\n      return 1 if i <= 1 else i * fact(i - 1) % MOD\n\n    @functools.lru_cache(None)\n    def inv(i: int) -> int:\n      return pow(i, MOD - 2, MOD)\n\n    @functools.lru_cache(None)\n    def nCk(n: int, k: int) -> int:\n      return fact(n) * inv(fact(k)) * inv(fact(n - k)) % MOD\n\n    @functools.lru_cache(None)\n    def stirling(n: int, k: int) -> int:\n      \"\"\"\n      Returns the number of ways to partition a set of n objects into k\n      non-empty subsets.\n\n      https://en.wikipedia.org/wiki/Stirling_numbers_of_the_second_kind\n      \"\"\"\n      if k == 0 or n < k:\n        return 0\n      if k == 1 or n == k:\n        return 1\n      return (k * stirling(n - 1, k) + stirling(n - 1, k - 1)) % MOD\n\n    # 1. Choose `k` stages from `x` stages.\n    # 2. Partition `n` performers into `k` stages.\n    # 3. Permute `k` stages.\n    # 4. Score `k` stages with score in the range [1, y], so y^k ways.\n    return sum(nCk(x, k) * stirling(n, k) * fact(k) * pow(y, k, MOD) % MOD\n               for k in range(1, min(n, x) + 1)) % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3308, "slug": "find-top-performing-driver", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3396, "slug": "minimum-number-of-operations-to-make-elements-in-array-distinct", "solutions": ["class Solution:\n    def minimumOperations(self, nums: List[int]) -> int:\n        s = set()\n        for i in range(len(nums) - 1, -1, -1):\n            if nums[i] in s:\n                return i // 3 + 1\n            s.add(nums[i])\n        return 0\n", "class Solution:\n  def minimumOperations(self, nums: list[int]) -> int:\n    seen = set()\n    for i, num in reversed(list(enumerate(nums))):\n      if num in seen:\n        return (i + 1 + 2) // 3  # ceil((i + 1) / 3)\n      seen.add(num)\n    return 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3382, "slug": "maximum-area-rectangle-with-point-constraints-ii", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3381, "slug": "maximum-subarray-sum-with-length-divisible-by-k", "solutions": ["class Solution:\n    def maxSubarraySum(self, nums: List[int], k: int) -> int:\n        f = [inf] * k\n        ans = -inf\n        s = f[-1] = 0\n        for i, x in enumerate(nums):\n            s += x\n            ans = max(ans, s - f[i % k])\n            f[i % k] = min(f[i % k], s)\n        return ans\n", "class Solution:\n  def maxSubarraySum(self, nums: list[int], k: int) -> int:\n    ans = -math.inf\n    prefix = 0\n    # minPrefix[i % k] := the minimum prefix sum of the first i numbers\n    minPrefix = [math.inf] * k\n    minPrefix[k - 1] = 0\n\n    for i, num in enumerate(nums):\n      prefix += num\n      ans = max(ans, prefix - minPrefix[i % k])\n      minPrefix[i % k] = min(minPrefix[i % k], prefix)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3360, "slug": "stone-removal-game", "solutions": ["class Solution:\n    def canAliceWin(self, n: int) -> bool:\n        x, k = 10, 0\n        while n >= x:\n            n -= x\n            x -= 1\n            k += 1\n        return k % 2 == 1\n", "class Solution:\n  def canAliceWin(self, n: int) -> bool:\n    for stones in range(10, -1, -1):\n      if stones > n:\n        return stones % 2 == 1\n      n -= stones\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3311, "slug": "construct-2d-grid-matching-graph-layout", "solutions": ["class Solution:\n    def constructGridLayout(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n        g = [[] for _ in range(n)]\n        for u, v in edges:\n            g[u].append(v)\n            g[v].append(u)\n        deg = [-1] * 5\n        for x, ys in enumerate(g):\n            deg[len(ys)] = x\n        if deg[1] != -1:\n            row = [deg[1]]\n        elif deg[4] == -1:\n            x = deg[2]\n            for y in g[x]:\n                if len(g[y]) == 2:\n                    row = [x, y]\n                    break\n        else:\n            x = deg[2]\n            row = [x]\n            pre = x\n            x = g[x][0]\n            while len(g[x]) > 2:\n                row.append(x)\n                for y in g[x]:\n                    if y != pre and len(g[y]) < 4:\n                        pre = x\n                        x = y\n                        break\n            row.append(x)\n\n        ans = [row]\n        vis = [False] * n\n        for _ in range(n // len(row) - 1):\n            for x in row:\n                vis[x] = True\n            nxt = []\n            for x in row:\n                for y in g[x]:\n                    if not vis[y]:\n                        nxt.append(y)\n                        break\n            ans.append(nxt)\n            row = nxt\n        return ans\n", "class Solution:\n  def constructGridLayout(self, n: int, edges: list[list[int]]) -> list[list[int]]:\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    # Randomly choose a node with the minimum degree as the corner.\n    corner = min(range(len(graph)), key=lambda x: len(graph[x]))\n\n    seen = {corner}\n    firstRow = self._getFirstRow(graph, corner, seen)\n    cols = len(firstRow)\n    rows = n // cols\n\n    ans = [[0] * cols for _ in range(rows)]\n    ans[0] = firstRow\n\n    for i in range(1, rows):\n      for j in range(cols):\n        for v in graph[ans[i - 1][j]]:\n          if v not in seen:\n            ans[i][j] = v\n            seen.add(v)\n            break\n\n    return ans\n\n  def _getFirstRow(\n      self,\n      graph: list[list[int]],\n      corner: int,\n      seen: set[int]\n  ) -> list[int]:\n    cornerDegree = len(graph[corner])\n    row = [corner]\n    # Continue appending neighbors until we hit another corner.\n    while len(row) == 1 or len(graph[row[-1]]) == cornerDegree + 1:\n      # Sort neighbors by degree to prioritize smaller ones (shortest row built first).\n      graph[row[-1]].sort(key=lambda x: len(graph[x]))\n      for v in graph[row[-1]]:\n        if v not in seen and len(graph[v]) in (cornerDegree, cornerDegree + 1):\n          row.append(v)\n          seen.add(v)\n          break\n    return row\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3333, "slug": "find-the-original-typed-string-ii", "solutions": ["class Solution:\n  def possibleStringCount(self, word: str, k: int) -> int:\n    MOD = 1_000_000_007\n    groups = self._getConsecutiveLetters(word)\n    totalCombinations = functools.reduce(lambda subtotal, group:\n                                         subtotal * group % MOD, groups)\n    if k <= len(groups):\n      return totalCombinations\n\n    # dp[j] := the number of ways to form strings of length j using groups[0..i]\n    dp = [0] * k\n    dp[0] = 1  # Base case: empty string\n\n    for i, group in enumerate(groups):\n      newDp = [0] * k\n      windowSum = 0\n      for j in range(i, k):\n        newDp[j] = (newDp[j] + windowSum) % MOD\n        windowSum = (windowSum + dp[j]) % MOD\n        if j >= group:\n          windowSum = (windowSum - dp[j - group] + MOD) % MOD\n      dp = newDp\n\n    return (totalCombinations - sum(dp)) % MOD\n\n  def _getConsecutiveLetters(self, word: str) -> list[int]:\n    \"\"\"\n    Returns consecutive identical letters in the input string.\n    e.g. \"aabbbc\" -> [2, 3, 1].\n    \"\"\"\n    groups = []\n    group = 1\n    for i in range(1, len(word)):\n      if word[i] == word[i - 1]:\n        group += 1\n      else:\n        groups.append(group)\n        group = 1\n    groups.append(group)\n    return groups\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3344, "slug": "maximum-sized-array", "solutions": ["mx = 1330\nf = [0] * mx\nfor i in range(1, mx):\n    f[i] = f[i - 1] + i\n    for j in range(i):\n        f[i] += 2 * (i | j)\n\n\nclass Solution:\n    def maxSizedArray(self, s: int) -> int:\n        l, r = 1, mx\n        while l < r:\n            m = (l + r + 1) >> 1\n            if f[m - 1] * (m - 1) * m // 2 <= s:\n                l = m\n            else:\n                r = m - 1\n        return l\n", "class Solution:\n  def maxSizedArray(self, s: int) -> int:\n    def getNumbersWithBitSet(n: int, i: int) -> int:\n      \"\"\"\n      Returns the number of integers in [0, n - 1] with the i-th bit set.\n\n      For the i-th bit, numbers in the range [0, n - 1] can be divided into\n      groups of 2^(i + 1) numbers. In each group, exactly half of the numbers\n      have the i-th bit set.\n      \"\"\"\n      groupSize = 1 << (i + 1)\n      halfGroupSize = 1 << i\n      fullGroups = n // groupSize\n      remaining = max(0, (n % groupSize) - halfGroupSize)\n      return fullGroups * halfGroupSize + remaining\n\n    def getArraySum(n: int) -> int:\n      \"\"\"\n      Returns the sum of all i * (j OR k) values in 3D arrays of size n^3.\n\n        sum(i * (j OR k)), where 0 <= i, j, k < n\n      = 0 * (j OR k) + 1 * (j OR k) + ... + (n - 1) * (j OR k)\n      = (0 + 1 + ... + n - 1) * sum(j OR k)\n      = (n * (n - 1) / 2) * sum(j OR k)\n      \"\"\"\n      arithmeticSum = n * (n - 1) // 2  # 0 + 1 + ... + n - 1\n      orSum = 0  # the sum of (j OR k) values in 2D arrays of size n^2\n      for i in range(n.bit_length()):\n        numbersWithoutBit = n - getNumbersWithBitSet(n, i)\n        pairsWithBit = n**2 - numbersWithoutBit**2\n        orSum += pairsWithBit * (1 << i)  # Add contribution of this bit.\n      return arithmeticSum * orSum\n\n    if s == 0:\n      return 1\n    l = 0\n    r = 1196  # when s = 10^15, n = 1196\n    return bisect.bisect_right(range(l, r + 1), s, key=getArraySum) - 1 + l\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3302, "slug": "find-the-lexicographically-smallest-valid-sequence", "solutions": ["class Solution:\n  def validSequence(self, word1: str, word2: str) -> list[int]:\n    ans = []\n    # last[j] := the index i of the last occurrence in word1, where\n    # word1[i] == word2[j]\n    last = [-1] * len(word2)\n\n    i = len(word1) - 1\n    j = len(word2) - 1\n    while i >= 0 and j >= 0:\n      if word1[i] == word2[j]:\n        last[j] = i\n        j -= 1\n      i -= 1\n\n    canSkip = True\n    j = 0\n    for i, c in enumerate(word1):\n      if j == len(word2):\n        break\n      if c == word2[j]:\n        ans.append(i)\n        j += 1\n      elif canSkip and (j == len(word2) - 1 or i < last[j + 1]):\n        canSkip = False\n        ans.append(i)\n        j += 1\n\n    return ans if j == len(word2) else []\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3361, "slug": "shift-distance-between-two-strings", "solutions": ["class Solution:\n    def shiftDistance(\n        self, s: str, t: str, nextCost: List[int], previousCost: List[int]\n    ) -> int:\n        m = 26\n        s1 = [0] * (m << 1 | 1)\n        s2 = [0] * (m << 1 | 1)\n        for i in range(m << 1):\n            s1[i + 1] = s1[i] + nextCost[i % m]\n            s2[i + 1] = s2[i] + previousCost[(i + 1) % m]\n        ans = 0\n        for a, b in zip(s, t):\n            x, y = ord(a) - ord(\"a\"), ord(b) - ord(\"a\")\n            c1 = s1[y + m if y < x else y] - s1[x]\n            c2 = s2[x + m if x < y else x] - s2[y]\n            ans += min(c1, c2)\n        return ans\n", "class Solution:\n  def shiftDistance(\n      self,\n      s: str,\n      t: str,\n      nextCost: list[int],\n      previousCost: list[int]\n  ) -> int:\n    ans = 0\n    # prev[i][j]: the prev cost to shift from ('a' + i) to ('a' + j)\n    prev = [[0] * 26 for _ in range(26)]\n    # next[i][j]: the next cost to shift from ('a' + i) to ('a' + j)\n    next = [[0] * 26 for _ in range(26)]\n\n    for i in range(26):\n      cost = 0\n      for j in range(26):\n        next[i][(i + j) % 26] = cost\n        cost += nextCost[(i + j) % 26]\n\n    for i in range(26):\n      cost = 0\n      for j in range(26):\n        prev[i][(i - j + 26) % 26] = cost\n        cost += previousCost[(i - j + 26) % 26]\n\n    for a, b in zip(s, t):\n      i = ord(a) - ord('a')\n      j = ord(b) - ord('a')\n      ans += min(next[i][j], prev[i][j])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3393, "slug": "count-paths-with-the-given-xor-value", "solutions": ["class Solution:\n  def countPathsWithXorValue(self, grid: list[list[int]], k: int) -> int:\n    MOD = 1_000_000_007\n    m = len(grid)\n    n = len(grid[0])\n\n    @functools.lru_cache(None)\n    def count(i: int, j: int, xors: int) -> int:\n      \"\"\"\n      Return the number of paths from (i, j) to (m - 1, n - 1) with XOR value\n      `xors`.\n      \"\"\"\n      if i == m or j == n:\n        return 0\n      xors ^= grid[i][j]\n      if i == m - 1 and j == n - 1:\n        return int(xors == k)\n      right = count(i, j + 1, xors)\n      down = count(i + 1, j, xors)\n      return (right + down) % MOD\n\n    return count(0, 0, 0)\n", "class Solution:\n  def countPathsWithXorValue(self, grid, k):\n    MOD = 1_000_000_007\n    MAX = 15\n    m = len(grid)\n    n = len(grid[0])\n    # dp[i][j][xors] := the number of paths from (0, 0) to (i, j) with XOR\n    # value `xors`\n    dp = [[[0] * (MAX + 1)\n          for _ in range(n)]\n          for _ in range(m)]\n\n    dp[0][0][grid[0][0]] = 1\n\n    for i in range(m):\n      for j in range(n):\n        for xors in range(MAX + 1):\n          if i + 1 < m:\n            newXor = xors ^ grid[i + 1][j]\n            dp[i + 1][j][newXor] += dp[i][j][xors]\n            dp[i + 1][j][newXor] %= MOD\n          if j + 1 < n:\n            newXor = xors ^ grid[i][j + 1]\n            dp[i][j + 1][newXor] += dp[i][j][xors]\n            dp[i][j + 1][newXor] %= MOD\n\n    return dp[-1][-1][k]\n", "class Solution:\n  def countPathsWithXorValue(self, grid, k):\n    MOD = 1_000_000_007\n    MAX = 15\n    m = len(grid)\n    n = len(grid[0])\n    # dp[i][j][xors] := the number of paths from (i, j) to (m - 1, n - 1) with\n    # XOR value `xors`\n    dp = [[[0] * (MAX + 1)\n          for _ in range(n)]\n          for _ in range(m)]\n\n    dp[-1][-1][grid[-1][-1]] = 1\n\n    for i in reversed(range(m)):\n      for j in reversed(range(n)):\n        for xors in range(MAX + 1):\n          if i - 1 >= 0:\n            newXor = xors ^ grid[i - 1][j]\n            dp[i - 1][j][newXor] += dp[i][j][xors]\n            dp[i - 1][j][newXor] %= MOD\n          if j - 1 >= 0:\n            newXor = xors ^ grid[i][j - 1]\n            dp[i][j - 1][newXor] += dp[i][j][xors]\n            dp[i][j - 1][newXor] %= MOD\n\n    return dp[0][0][k]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3309, "slug": "maximum-possible-number-by-binary-concatenation", "solutions": ["class Solution:\n    def maxGoodNumber(self, nums: List[int]) -> int:\n        ans = 0\n        for arr in permutations(nums):\n            num = int(\"\".join(bin(i)[2:] for i in arr), 2)\n            ans = max(ans, num)\n        return ans\n", "class Solution:\n  def maxGoodNumber(self, nums: list[int]) -> int:\n    ans = 0\n\n    def concat(a: int, b: int) -> int:\n      \"\"\"Returns the concatenation of the binary representations of a and b.\"\"\"\n      return (a << b.bit_length()) + b\n\n    nums.sort(key=functools.cmp_to_key(\n        lambda a, b: concat(b, a) - concat(a, b)))\n\n    for num in nums:\n      ans = concat(ans, num)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3336, "slug": "find-the-number-of-subsequences-with-equal-gcd", "solutions": ["class Solution:\n  def subsequencePairCount(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    maxNum = max(nums)\n    # dp[i][x][y] := number of disjoint pairs `seq1` and `seq2` of\n    # nums[0..i - 1], where GCD(seq1) == x and GCD(seq2) == y\n    dp = [[[0] * (maxNum + 1)\n          for _ in range(maxNum + 1)]\n          for _ in range(len(nums) + 1)]\n    dp[0][0][0] = 1\n\n    for i, num in enumerate(nums):\n      for x in range(maxNum + 1):\n        for y in range(maxNum + 1):\n          # 1. Skip nums[i].\n          dp[i + 1][x][y] += dp[i][x][y]\n          dp[i + 1][x][y] %= MOD\n          # 2. Pick nums[i] in the first subsequence.\n          newX = math.gcd(x, num)\n          dp[i + 1][newX][y] += dp[i][x][y]\n          dp[i + 1][newX][y] %= MOD\n          # 3. Pick nums[i] in the second subsequence.\n          newY = math.gcd(y, num)\n          dp[i + 1][x][newY] += dp[i][x][y]\n          dp[i + 1][x][newY] %= MOD\n\n    return sum(dp[-1][g][g]\n               for g in range(1, maxNum + 1)) % MOD\n", "class Solution:\n  def subsequencePairCount(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def dp(i: int, x: int, y: int) -> int:\n      if i == len(nums):\n        return int(x > 0 and x == y)\n      # 1. Skip nums[i]\n      skip = dp(i + 1, x, y)\n      # 2. Pick nums[i] in the first subsequence\n      take1 = dp(i + 1, math.gcd(x, nums[i]), y)\n      # 3. Pick nums[i] in the second subsequence\n      take2 = dp(i + 1, x, math.gcd(y, nums[i]))\n      return (skip + take1 + take2) % MOD\n\n    return dp(0, 0, 0)\n", "class Solution:\n  def subsequencePairCount(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    maxNum = max(nums)\n    # dp[x][y] := number of disjoint pairs `seq1` and `seq2` of\n    # nums so far, where GCD(seq1) == x and GCD(seq2) == y\n    dp = [[0] * (maxNum + 1) for _ in range(maxNum + 1)]\n    dp[0][0] = 1\n\n    for num in nums:\n      newDp = [[0] * (maxNum + 1) for _ in range(maxNum + 1)]\n      for x in range(maxNum + 1):\n        for y in range(maxNum + 1):\n          # 1. Skip `num`.\n          newDp[x][y] += dp[x][y]\n          newDp[x][y] %= MOD\n          # 2. Pick `num` in the first subsequence.\n          newX = math.gcd(x, num)\n          newDp[newX][y] += dp[x][y]\n          newDp[newX][y] %= MOD\n          # 3. Pick `num` in the second subsequence.\n          newY = math.gcd(y, num)\n          newDp[x][newY] += dp[x][y]\n          newDp[x][newY] %= MOD\n      dp = newDp\n\n    return sum(dp[g][g]\n               for g in range(1, maxNum + 1)) % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3378, "slug": "count-connected-components-in-lcm-graph", "solutions": ["class DSU:\n    def __init__(self, n):\n        self.parent = {i: i for i in range(n)}\n        self.rank = {i: 0 for i in range(n)}\n\n    def make_set(self, v):\n        self.parent[v] = v\n        self.rank[v] = 1\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union_set(self, u, v):\n        u = self.find(u)\n        v = self.find(v)\n        if u != v:\n            if self.rank[u] < self.rank[v]:\n                u, v = v, u\n            self.parent[v] = u\n            if self.rank[u] == self.rank[v]:\n                self.rank[u] += 1\n\n\nclass Solution:\n    def countComponents(self, nums, threshold):\n        dsu = DSU(threshold + 1)\n\n        for num in nums:\n            for j in range(num, threshold + 1, num):\n                dsu.union_set(num, j)\n\n        unique_parents = set()\n        for num in nums:\n            if num > threshold:\n                unique_parents.add(num)\n            else:\n                unique_parents.add(dsu.find(num))\n\n        return len(unique_parents)\n", "class UnionFind:\n  def __init__(self):\n    self.id = {}\n    self.rank = collections.Counter()\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if u not in self.id:\n      self.id[u] = u\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def countComponents(self, nums: list[int], threshold: int) -> int:\n    uf = UnionFind()\n\n    for num in nums:\n      for multiple in range(2 * num, threshold + 1, num):\n        uf.unionByRank(num, multiple)\n\n    return len(set(uf.find(num) for num in nums))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3345, "slug": "smallest-divisible-digit-product-i", "solutions": ["class Solution:\n    def smallestNumber(self, n: int, t: int) -> int:\n        for i in count(n):\n            p = 1\n            x = i\n            while x:\n                p *= x % 10\n                x //= 10\n            if p % t == 0:\n                return i\n", "class Solution:\n  def smallestNumber(self, n: int, t: int) -> int:\n    return next(num for num in range(n, n + 10)\n                if self._getDigitProd(num) % t == 0)\n\n  def _getDigitProd(self, num: int) -> int:\n    digitProd = 1\n    while num > 0:\n      digitProd *= num % 10\n      num //= 10\n    return digitProd\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3359, "slug": "find-sorted-submatrices-with-maximum-element-at-most-k", "solutions": ["from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass T:\n  subarrayWidth: int\n  rowIndex: int\n  accumulatedSubmatrices: int\n\n\nclass Solution:\n  def countSubmatrices(self, grid: list[list[int]], k: int) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    # dp[i][j] := the number of valid subarrays ending in grid[i][j]\n    dp = [[0] * n for _ in range(m)]\n    # stacks[j] := the stack of valid\n    # (subarray width, row index, number of accumulated submatrices) ending in\n    # column j\n    stacks: list[T] = [[T(0, -1, 0)] for _ in range(n)]\n\n    for i, row in enumerate(grid):\n      for j, num in enumerate(row):\n        if num > k:\n          stacks[j] = [T(0, i, 0)]\n        else:\n          dp[i][j] = 1\n          if j > 0 and row[j - 1] <= k and row[j - 1] >= row[j]:\n            # Extend the valid subarrays to the current number.\n            dp[i][j] += dp[i][j - 1]\n          width = dp[i][j]\n          # Remove subarray widths greater than the current count since they\n          # will become invalid.\n          while stacks[j] and width < stacks[j][-1].subarrayWidth:\n            stacks[j].pop()\n          height = i - stacks[j][-1].rowIndex\n          newSubmatrices = width * height\n          accumulatedSubmatrices = (stacks[j][-1].accumulatedSubmatrices +\n                                    newSubmatrices)\n          ans += accumulatedSubmatrices\n          stacks[j].append(T(width, i, accumulatedSubmatrices))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3342, "slug": "find-minimum-time-to-reach-last-room-ii", "solutions": ["class Solution:\n    def minTimeToReach(self, moveTime: List[List[int]]) -> int:\n        n, m = len(moveTime), len(moveTime[0])\n        dist = [[inf] * m for _ in range(n)]\n        dist[0][0] = 0\n        pq = [(0, 0, 0)]\n        dirs = (-1, 0, 1, 0, -1)\n        while 1:\n            d, i, j = heappop(pq)\n            if i == n - 1 and j == m - 1:\n                return d\n            if d > dist[i][j]:\n                continue\n            for a, b in pairwise(dirs):\n                x, y = i + a, j + b\n                if 0 <= x < n and 0 <= y < m:\n                    t = max(moveTime[x][y], dist[i][j]) + (i + j) % 2 + 1\n                    if dist[x][y] > t:\n                        dist[x][y] = t\n                        heappush(pq, (t, x, y))\n", "class Solution:\n  # Similar to 3341. Find Minimum Time to Reach Last Room I\n  def minTimeToReach(self, moveTime: list[list[int]]) -> int:\n    return self._dijkstra(moveTime,\n                          (0, 0),\n                          (len(moveTime) - 1, len(moveTime[0]) - 1))\n\n  def _dijkstra(\n      self,\n      moveTime: list[list[int]],\n      src: tuple[int, int],\n      dst: tuple[int, int]\n  ) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(moveTime)\n    n = len(moveTime[0])\n    dist = [[math.inf] * n for _ in range(m)]\n\n    dist[0][0] = 0\n    minHeap = [(0, src)]  # (d, (ux, uy))\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if u == dst:\n        return d\n      i, j = u\n      if d > dist[i][j]:\n        continue\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        newDist = max(moveTime[x][y], d) + (i + j) % 2 + 1\n        if newDist < dist[x][y]:\n          dist[x][y] = newDist\n          heapq.heappush(minHeap, (newDist, (x, y)))\n\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3366, "slug": "minimum-array-sum", "solutions": ["class Solution:\n    def minArraySum(self, nums: List[int], d: int, op1: int, op2: int) -> int:\n        n = len(nums)\n        f = [[[inf] * (op2 + 1) for _ in range(op1 + 1)] for _ in range(n + 1)]\n        f[0][0][0] = 0\n        for i, x in enumerate(nums, 1):\n            for j in range(op1 + 1):\n                for k in range(op2 + 1):\n                    f[i][j][k] = f[i - 1][j][k] + x\n                    if j > 0:\n                        f[i][j][k] = min(f[i][j][k], f[i - 1][j - 1][k] + (x + 1) // 2)\n                    if k > 0 and x >= d:\n                        f[i][j][k] = min(f[i][j][k], f[i - 1][j][k - 1] + (x - d))\n                    if j > 0 and k > 0:\n                        y = (x + 1) // 2\n                        if y >= d:\n                            f[i][j][k] = min(f[i][j][k], f[i - 1][j - 1][k - 1] + y - d)\n                        if x >= d:\n                            f[i][j][k] = min(\n                                f[i][j][k], f[i - 1][j - 1][k - 1] + (x - d + 1) // 2\n                            )\n        ans = inf\n        for j in range(op1 + 1):\n            for k in range(op2 + 1):\n                ans = min(ans, f[n][j][k])\n        return ans\n", "class Solution:\n  def minArraySum(self, nums: list[int], k: int, op1: int, op2: int) -> int:\n    @functools.lru_cache(None)\n    def dp(i: int, op1: int, op2: int) -> int:\n      \"\"\"\n      Returns the minimum sum of nums[i..n - 1] with `op1` operations of op1 and\n      `op2` operations of op2.\n      \"\"\"\n      if i == len(nums):\n        return 0\n      res = nums[i] + dp(i + 1, op1, op2)\n      if op1 > 0:\n        res = min(res, (nums[i] + 1) // 2 + dp(i + 1, op1 - 1, op2))\n      if op2 > 0 and nums[i] >= k:\n        res = min(res, nums[i] - k + dp(i + 1, op1, op2 - 1))\n      if op1 > 0 and op2 > 0:\n        if (nums[i] + 1) // 2 >= k:\n          res = min(res, (nums[i] + 1) // 2 - k + dp(i + 1, op1 - 1, op2 - 1))\n        if nums[i] >= k:\n          res = min(res, (nums[i] - k + 1) // 2 + dp(i + 1, op1 - 1, op2 - 1))\n      return res\n\n    return dp(0, op1, op2)\n", "class Solution:\n  def minArraySum(self, nums: list[int], k: int, op1: int, op2: int) -> int:\n    n = len(nums)\n    # dp[i][j][k] := the minimum sum of nums[i..n - 1] with j operations of op1\n    # and k operations of op2\n    dp = [[[math.inf] * (op2 + 1)\n          for _ in range(op1 + 1)]\n          for _ in range(n + 1)]\n\n    # Base case: When index reaches the end of the array, the result is 0.\n    for i in range(op1 + 1):\n      for j in range(op2 + 1):\n        dp[n][i][j] = 0\n\n    for i in range(n - 1, -1, -1):\n      for o1 in range(op1 + 1):\n        for o2 in range(op2 + 1):\n          summ = nums[i] + dp[i + 1][o1][o2]\n          if o1 > 0:\n            summ = min(summ, (nums[i] + 1) // 2 + dp[i + 1][o1 - 1][o2])\n          if o2 > 0 and nums[i] >= k:\n            summ = min(summ, nums[i] - k + dp[i + 1][o1][o2 - 1])\n          if o1 > 0 and o2 > 0:\n            if (nums[i] + 1) // 2 >= k:\n              summ = min(summ,\n                         (nums[i] + 1) // 2 - k + dp[i + 1][o1 - 1][o2 - 1])\n            if nums[i] >= k:\n              summ = min(summ,\n                         (nums[i] - k + 1) // 2 + dp[i + 1][o1 - 1][o2 - 1])\n          dp[i][o1][o2] = summ\n\n    return dp[0][op1][op2]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3304, "slug": "find-the-k-th-character-in-string-game-i", "solutions": ["class Solution:\n    def kthCharacter(self, k: int) -> str:\n        word = [0]\n        while len(word) < k:\n            word.extend([(x + 1) % 26 for x in word])\n        return chr(ord(\"a\") + word[k - 1])\n", "class Solution:\n  def kthCharacter(self, k: int) -> str:\n    return string.ascii_lowercase[(k - 1).bit_count()]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3390, "slug": "longest-team-pass-streak", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3305, "slug": "count-of-substrings-containing-every-vowel-and-k-consonants-i", "solutions": ["class Solution:\n    def countOfSubstrings(self, word: str, k: int) -> int:\n        def f(k: int) -> int:\n            cnt = Counter()\n            ans = l = x = 0\n            for c in word:\n                if c in \"aeiou\":\n                    cnt[c] += 1\n                else:\n                    x += 1\n                while x >= k and len(cnt) == 5:\n                    d = word[l]\n                    if d in \"aeiou\":\n                        cnt[d] -= 1\n                        if cnt[d] == 0:\n                            cnt.pop(d)\n                    else:\n                        x -= 1\n                    l += 1\n                ans += l\n            return ans\n\n        return f(k) - f(k + 1)\n", "class Solution:\n  def countOfSubstrings(self, word: str, k: int) -> int:\n    VOWELS = 'aeiou'\n\n    def substringsWithAtMost(k: int) -> int:\n      \"\"\"\n      Return the number of substrings containing every vowel with at most k\n      consonants.\n      \"\"\"\n      if k == -1:\n        return 0\n\n      res = 0\n      vowels = 0\n      uniqueVowels = 0\n      vowelLastSeen = {}\n\n      l = 0\n      for r, c in enumerate(word):\n        if c in VOWELS:\n          vowels += 1\n          if c not in vowelLastSeen or vowelLastSeen[c] < l:\n            uniqueVowels += 1\n          vowelLastSeen[c] = r\n        while r - l + 1 - vowels > k:\n          if word[l] in VOWELS:\n            vowels -= 1\n            if vowelLastSeen[word[l]] == l:\n              uniqueVowels -= 1\n          l += 1\n        if uniqueVowels == 5:\n          # Add substrings containing every vowel with at most k consonants to\n          # the answer. They are\n          # word[l..r], word[l + 1..r], ..., word[min(vowelLastSeen[vowel])..r]\n          res += min(vowelLastSeen[vowel] for vowel in VOWELS) - l + 1\n\n      return res\n\n    return substringsWithAtMost(k) - substringsWithAtMost(k - 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3389, "slug": "minimum-operations-to-make-character-frequencies-equal", "solutions": ["class Solution:\n  def makeStringGood(self, s: str) -> int:\n    count = [0] * 26\n    for c in s:\n      count[ord(c) - ord('a')] += 1\n    return min(self._getMinOperations(count, target)\n               for target in range(1, max(count) + 1))\n\n  def _getMinOperations(self, count: list[int], target: int) -> int:\n    # dp[i] represents the minimum number of operations to make the frequency of\n    # (i..25)-th (0-indexed) letters equal to `target`.\n    dp = [0] * 27\n\n    for i in range(25, -1, -1):\n      # 1. Delete all the i-th letters.\n      deleteAllToZero = count[i]\n      # 2. Insert/delete the i-th letters to have `target` number of letters.\n      deleteOrInsertToTarget = abs(target - count[i])\n      dp[i] = min(deleteAllToZero, deleteOrInsertToTarget) + dp[i + 1]\n      if i + 1 < 26 and count[i + 1] < target:\n        nextDeficit = target - count[i + 1]\n        # Make the frequency of the i-th letter equal to the `target` or 0.\n        needToChange = count[i] if count[i] <= target else count[i] - target\n        changeToTarget = (\n            # 3. Change all the i-th letters to the next letter and then\n            # insert the remaining deficit for the next letter.\n            needToChange + (nextDeficit - needToChange) if nextDeficit > needToChange\n            # 4. Change `nextDeficit` i-th letters to the next letter and\n            # then delete the remaining i-th letters.\n            else nextDeficit + (needToChange - nextDeficit)\n        )\n        dp[i] = min(dp[i], changeToTarget + dp[i + 2])\n\n    return dp[0]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3330, "slug": "find-the-original-typed-string-i", "solutions": ["class Solution:\n    def possibleStringCount(self, word: str) -> int:\n        return 1 + sum(x == y for x, y in pairwise(word))\n", "class Solution:\n  def possibleStringCount(self, word: str) -> int:\n    return 1 + sum(a == b\n                   for a, b in itertools.pairwise(word))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3352, "slug": "count-k-reducible-numbers-less-than-n", "solutions": ["class Solution:\n  def countKReducibleNumbers(self, s: str, k: int) -> int:\n    MOD = 1_000_000_007\n    ops = self._getOps(s)\n\n    @functools.lru_cache(None)\n    def dp(i: int, setBits: int, isTight: bool) -> int:\n      \"\"\"\n      Returns the number of positive integers less than n that are k-reducible,\n      considering the i-th digit, where `setBits` is the number of set bits in\n      the current number, and `isTight` indicates if the current digit is\n      tightly bound.\n      \"\"\"\n      if i == len(s):\n        return int(ops[setBits] < k and not isTight)\n\n      res = 0\n      maxDigit = int(s[i]) if isTight else 1\n\n      for d in range(maxDigit + 1):\n        nextIsTight = isTight and (d == maxDigit)\n        res += dp(i + 1, setBits + d, nextIsTight)\n        res %= MOD\n      return res\n\n    return dp(0, 0, True) - 1  # - 0\n\n  def _getOps(self, s: str) -> int:\n    \"\"\"Returns the number of operations to reduce a number to 0.\"\"\"\n    ops = [0] * (len(s) + 1)\n    for num in range(2, len(s) + 1):\n      ops[num] = 1 + ops[num.bit_count()]\n    return ops\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3327, "slug": "check-if-dfs-strings-are-palindromes", "solutions": ["class Hashing:\n    __slots__ = [\"mod\", \"h\", \"p\"]\n\n    def __init__(self, s: List[str], base: int, mod: int):\n        self.mod = mod\n        self.h = [0] * (len(s) + 1)\n        self.p = [1] * (len(s) + 1)\n        for i in range(1, len(s) + 1):\n            self.h[i] = (self.h[i - 1] * base + ord(s[i - 1])) % mod\n            self.p[i] = (self.p[i - 1] * base) % mod\n\n    def query(self, l: int, r: int) -> int:\n        return (self.h[r] - self.h[l - 1] * self.p[r - l + 1]) % self.mod\n\n\nclass Solution:\n    def findAnswer(self, parent: List[int], s: str) -> List[bool]:\n        def dfs(i: int):\n            l = len(dfsStr) + 1\n            for j in g[i]:\n                dfs(j)\n            dfsStr.append(s[i])\n            r = len(dfsStr)\n            pos[i] = (l, r)\n\n        n = len(s)\n        g = [[] for _ in range(n)]\n        for i in range(1, n):\n            g[parent[i]].append(i)\n        dfsStr = []\n        pos = {}\n        dfs(0)\n\n        base, mod = 13331, 998244353\n        h1 = Hashing(dfsStr, base, mod)\n        h2 = Hashing(dfsStr[::-1], base, mod)\n        ans = []\n        for i in range(n):\n            l, r = pos[i]\n            k = r - l + 1\n            v1 = h1.query(l, l + k // 2 - 1)\n            v2 = h2.query(n - r + 1, n - r + 1 + k // 2 - 1)\n            ans.append(v1 == v2)\n        return ans\n", "class Solution:\n  def findAnswer(self, parent: list[int], s: str) -> list[bool]:\n    n = len(parent)\n    tree = [[] for _ in parent]\n    start = [0] * n  # start[i] := the start index of `dfsStr` of node i\n    end = [0] * n  # end[i] := the end index of `dfsStr` of node i\n    dfsStr = []\n\n    for i in range(1, n):\n      tree[parent[i]].append(i)\n\n    self._dfs(tree, 0, 0, s, start, end, dfsStr)\n    t = '#'.join('@' + ''.join(dfsStr) + '$')\n    p = self._manacher(t)\n    return [self._isPalindrome(s, e, p)\n            for s, e in zip(start, end)]\n\n  def _dfs(\n      self,\n      tree: list[list[int]],\n      u: int,\n      index: int,\n      s: str,\n      start: list[int],\n      end: list[int],\n      dfsStr: list[str]\n  ) -> int:\n    \"\"\"Returns the start index of the \"DFS string\" of u's next node.\"\"\"\n    start[u] = index\n    for v in tree[u]:\n      index = self._dfs(tree, v, index, s, start, end, dfsStr)\n    end[u] = index\n    dfsStr.append(s[u])\n    return index + 1\n\n  def _manacher(self, t: str) -> list[int]:\n    \"\"\"\n    Returns an array `p` s.t. `p[i]` is the length of the longest palindrome\n    centered at `t[i]`, where `t` is a string with delimiters and sentinels.\n    \"\"\"\n    p = [0] * len(t)\n    center = 0\n    for i in range(1, len(t) - 1):\n      rightBoundary = center + p[center]\n      mirrorIndex = center - (i - center)\n      if rightBoundary > i:\n        p[i] = min(rightBoundary - i, p[mirrorIndex])\n      # Try to expand the palindrome centered at i.\n      while t[i + 1 + p[i]] == t[i - 1 - p[i]]:\n        p[i] += 1\n      # If a palindrome centered at i expands past `rightBoundary`, adjust\n      # the center based on the expanded palindrome.\n      if i + p[i] > rightBoundary:\n        center = i\n    return p\n\n  def _isPalindrome(self, s: int, e: int, p: list[int]) -> bool:\n    \"\"\"\n    Returns true if `dfsStr[s..e]` is a palindrome by using the precomputed\n    array `p` from the Manacher's algorithm.\n\n    The precomputed array `p` is based on the string `t` with delimiters and\n    sentinels. Let `t = '#'.join('@' + dfsStr + '$')`. Then, the center of\n    `dfsStr` maps to `t[s + e + 2]` since `dfsStr[s]` maps to `t[2 * s + 2]`\n    and `dfsStr[e]` maps to `t[2 * e + 2]`. So, the center of `dfsStr` is\n    `t[(2 * s + 2 + 2 * e + 2) / 2] = t[s + e + 2]`.\n    \"\"\"\n    length = e - s + 1\n    center = s + e + 2\n    return p[center] >= length\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3399, "slug": "smallest-substring-with-identical-characters-ii", "solutions": ["class Solution:\n    def minLength(self, s: str, numOps: int) -> int:\n        def check(m: int) -> bool:\n            cnt = 0\n            if m == 1:\n                t = \"01\"\n                cnt = sum(c == t[i & 1] for i, c in enumerate(s))\n                cnt = min(cnt, n - cnt)\n            else:\n                k = 0\n                for i, c in enumerate(s):\n                    k += 1\n                    if i == len(s) - 1 or c != s[i + 1]:\n                        cnt += k // (m + 1)\n                        k = 0\n            return cnt <= numOps\n\n        n = len(s)\n        return bisect_left(range(n), True, lo=1, key=check)\n", "class Solution:\n  # Same as 3398. Smallest Substring With Identical Characters I\n  def minLength(self, s: str, numOps: int) -> int:\n    def getMinOps(k: int) -> int:\n      \"\"\"\n      Returns the minimum number of operations needed to make all groups of\n      identical characters of length k or less.\n      \"\"\"\n      if k == 1:\n        res = sum(1 for i, c in enumerate(s) if int(c) == i % 2)\n        return min(res, len(s) - res)\n\n      res = 0\n      runningLen = 1\n\n      for a, b in itertools.pairwise(s):\n        if a == b:\n          runningLen += 1\n        else:\n          res += runningLen // (k + 1)\n          runningLen = 1\n\n      return res + runningLen // (k + 1)\n\n    return bisect_left(range(1, len(s) + 1),\n                       True, key=lambda m: getMinOps(m) <= numOps)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3346, "slug": "maximum-frequency-of-an-element-after-performing-operations-i", "solutions": ["class Solution:\n    def maxFrequency(self, nums: List[int], k: int, numOperations: int) -> int:\n        cnt = defaultdict(int)\n        d = defaultdict(int)\n        for x in nums:\n            cnt[x] += 1\n            d[x] += 0\n            d[x - k] += 1\n            d[x + k + 1] -= 1\n        ans = s = 0\n        for x, t in sorted(d.items()):\n            s += t\n            ans = max(ans, min(s, cnt[x] + numOperations))\n        return ans\n", "from sortedcontainers import SortedDict\n\n\nclass Solution:\n  def maxFrequency(self, nums: list[int], k: int, numOperations: int) -> int:\n    ans = 1\n    adjustable = 0\n    count = collections.Counter(nums)\n    line = SortedDict()\n    candidates = set()\n\n    for num in nums:\n      line[num - k] = line.get(num - k, 0) + 1\n      line[num + k + 1] = line.get(num + k + 1, 0) - 1\n      candidates.add(num)\n      candidates.add(num - k)\n      candidates.add(num + k + 1)\n\n    for num in sorted(candidates):\n      adjustable += line.get(num, 0)\n      adjusted = adjustable - count[num]\n      ans = max(ans, count[num] + min(numOperations, adjusted))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3365, "slug": "rearrange-k-substrings-to-form-target-string", "solutions": ["class Solution:\n    def isPossibleToRearrange(self, s: str, t: str, k: int) -> bool:\n        cnt = Counter()\n        n = len(s)\n        m = n // k\n        for i in range(0, n, m):\n            cnt[s[i : i + m]] += 1\n            cnt[t[i : i + m]] -= 1\n        return all(v == 0 for v in cnt.values())\n", "class Solution:\n  def isPossibleToRearrange(self, s: str, t: str, k: int) -> bool:\n    n = len(s)\n    return (collections.Counter(s[i:i + n // k] for i in range(0, n, n // k)) ==\n            collections.Counter(t[i:i + n // k] for i in range(0, n, n // k)))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3324, "slug": "find-the-sequence-of-strings-appeared-on-the-screen", "solutions": ["class Solution:\n    def stringSequence(self, target: str) -> List[str]:\n        ans = []\n        for c in target:\n            s = ans[-1] if ans else \"\"\n            for a in ascii_lowercase:\n                t = s + a\n                ans.append(t)\n                if a == c:\n                    break\n        return ans\n", "class Solution:\n  def stringSequence(self, target: str) -> list[str]:\n    ans = []\n    s = []\n\n    for targetChar in target:\n      s.append('a')\n      ans.append(''.join(s))\n      for offset in range(ord('b'), ord(targetChar) + 1):\n        s[-1] = chr(offset)\n        ans.append(''.join(s))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3372, "slug": "maximize-the-number-of-target-nodes-after-connecting-trees-i", "solutions": ["class Solution:\n    def maxTargetNodes(\n        self, edges1: List[List[int]], edges2: List[List[int]], k: int\n    ) -> List[int]:\n        def build(edges: List[List[int]]) -> List[List[int]]:\n            n = len(edges) + 1\n            g = [[] for _ in range(n)]\n            for a, b in edges:\n                g[a].append(b)\n                g[b].append(a)\n            return g\n\n        def dfs(g: List[List[int]], a: int, fa: int, d: int) -> int:\n            if d < 0:\n                return 0\n            cnt = 1\n            for b in g[a]:\n                if b != fa:\n                    cnt += dfs(g, b, a, d - 1)\n            return cnt\n\n        g2 = build(edges2)\n        m = len(edges2) + 1\n        t = max(dfs(g2, i, -1, k - 1) for i in range(m))\n        g1 = build(edges1)\n        n = len(edges1) + 1\n        return [dfs(g1, i, -1, k) + t for i in range(n)]\n", "class Solution:\n  def maxTargetNodes(\n      self,\n      edges1: list[list[int]],\n      edges2: list[list[int]],\n      k: int\n  ) -> list[int]:\n    graph1 = self._buildGraph(edges1)\n    graph2 = self._buildGraph(edges2)\n    maxReachableInGraph2 = 0\n\n    if k > 0:\n      for i in range(len(edges2) + 1):\n        maxReachableInGraph2 = max(maxReachableInGraph2,\n                                   self._dfs(graph2, i, -1, k - 1))\n\n    return [maxReachableInGraph2 + self._dfs(graph1, i, -1, k)\n            for i in range(len(edges1) + 1)]\n\n  def _dfs(self, graph: list[list[int]], u: int, prev: int, k: int) -> int:\n    \"\"\"Returns the number of nodes that can be reached from u with k steps.\"\"\"\n    if k == 0:\n      return 1\n    res = 0\n    for v in graph[u]:\n      if v != prev:\n        res += self._dfs(graph, v, u, k - 1)\n    return 1 + res\n\n  def _buildGraph(self, edges: list[list[int]]) -> list[list[int]]:\n    graph = [[] for _ in range(len(edges) + 1)]\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n    return graph\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3310, "slug": "remove-methods-from-project", "solutions": ["class Solution:\n    def remainingMethods(\n        self, n: int, k: int, invocations: List[List[int]]\n    ) -> List[int]:\n        def dfs(i: int):\n            suspicious[i] = True\n            for j in g[i]:\n                if not suspicious[j]:\n                    dfs(j)\n\n        def dfs2(i: int):\n            vis[i] = True\n            for j in f[i]:\n                if not vis[j]:\n                    suspicious[j] = False\n                    dfs2(j)\n\n        f = [[] for _ in range(n)]\n        g = [[] for _ in range(n)]\n        for a, b in invocations:\n            f[a].append(b)\n            f[b].append(a)\n            g[a].append(b)\n        suspicious = [False] * n\n        dfs(k)\n\n        vis = [False] * n\n        ans = []\n        for i in range(n):\n            if not suspicious[i] and not vis[i]:\n                dfs2(i)\n        return [i for i in range(n) if not suspicious[i]]\n", "class Solution:\n  def remainingMethods(\n      self,\n      n: int,\n      k: int,\n      invocations: list[list[int]]\n  ) -> list[int]:\n    ans = []\n    graph = [[] for _ in range(n)]\n\n    for u, v in invocations:\n      graph[u].append(v)\n\n    q = collections.deque([k])\n    seen = {k}\n\n    while q:\n      for _ in range(len(q)):\n        for v in graph[q.popleft()]:\n          if v not in seen:\n            q.append(v)\n            seen.add(v)\n\n    for u in range(n):\n      if u in seen:\n        continue\n      for v in graph[u]:\n        if v in seen:\n          return list(range(n))\n      ans.append(u)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3332, "slug": "maximum-points-tourist-can-earn", "solutions": ["class Solution:\n    def maxScore(\n        self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]\n    ) -> int:\n        f = [[-inf] * n for _ in range(k + 1)]\n        f[0] = [0] * n\n        for i in range(1, k + 1):\n            for j in range(n):\n                for h in range(n):\n                    f[i][j] = max(\n                        f[i][j],\n                        f[i - 1][h]\n                        + (stayScore[i - 1][j] if j == h else travelScore[h][j]),\n                    )\n        return max(f[k])\n", "class Solution:\n  def maxScore(\n      self,\n      n: int,\n      k: int,\n      stayScore: list[list[int]],\n      travelScore: list[list[int]]\n  ) -> int:\n    # dp[j] := the maximum score after days so far being at city j\n    dp = [0] * n\n\n    for i in range(k):\n      newDp = [0] * n\n      for dest in range(n):\n        # 1. Stay at the current city.\n        newDp[dest] = dp[dest] + stayScore[i][dest]\n        # 2. Travel from any other city.\n        for curr in range(n):\n          if curr != dest:\n            newDp[dest] = max(newDp[dest],\n                              dp[curr] + travelScore[curr][dest])\n      dp = newDp\n\n    return max(dp)\n", "class Solution:\n  def maxScore(\n      self,\n      n: int,\n      k: int,\n      stayScore: list[list[int]],\n      travelScore: list[list[int]]\n  ) -> int:\n    # dp[i][j] := the maximum score after i days being at city j\n    dp = [[0] * n for _ in range(k + 1)]\n\n    for i in range(1, k + 1):\n      for dest in range(n):\n        # 1. Stay at the current city.\n        dp[i][dest] = dp[i - 1][dest] + stayScore[i - 1][dest]\n        # 2. Travel from any other city.\n        for curr in range(n):\n          if curr != dest:\n            dp[i][dest] = max(dp[i][dest],\n                              dp[i - 1][curr] + travelScore[curr][dest])\n\n    return max(dp[k])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3307, "slug": "find-the-k-th-character-in-string-game-ii", "solutions": ["class Solution:\n    def kthCharacter(self, k: int, operations: List[int]) -> str:\n        n, i = 1, 0\n        while n < k:\n            n *= 2\n            i += 1\n        d = 0\n        while n > 1:\n            if k > n // 2:\n                k -= n // 2\n                d += operations[i - 1]\n            n //= 2\n            i -= 1\n        return chr(d % 26 + ord(\"a\"))\n", "class Solution:\n  def kthCharacter(self, k: int, operations: list[int]) -> str:\n    operationsCount = math.ceil(math.log2(k))\n    increases = 0\n\n    for i in range(operationsCount - 1, -1, -1):\n      halfSize = 2**i\n      if k > halfSize:\n        k -= halfSize  # Move k from the right half to the left half.\n        increases += operations[i]\n\n    return string.ascii_lowercase[increases % 26]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3376, "slug": "minimum-time-to-break-locks-i", "solutions": ["class Solution:\n    def findMinimumTime(self, strength: List[int], K: int) -> int:\n        @cache\n        def dfs(i: int) -> int:\n            if i == (1 << len(strength)) - 1:\n                return 0\n            cnt = i.bit_count()\n            x = 1 + cnt * K\n            ans = inf\n            for j, s in enumerate(strength):\n                if i >> j & 1 ^ 1:\n                    ans = min(ans, dfs(i | 1 << j) + (s + x - 1) // x)\n            return ans\n\n        return dfs(0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3383, "slug": "minimum-runes-to-add-to-cast-spell", "solutions": ["class Solution:\n    def minRunesToAdd(\n        self, n: int, crystals: List[int], flowFrom: List[int], flowTo: List[int]\n    ) -> int:\n        def bfs(q: Deque[int]):\n            while q:\n                a = q.popleft()\n                for b in g[a]:\n                    if vis[b] == 1:\n                        continue\n                    vis[b] = 1\n                    q.append(b)\n\n        def dfs(a: int):\n            vis[a] = 2\n            for b in g[a]:\n                if vis[b] > 0:\n                    continue\n                dfs(b)\n            seq.append(a)\n\n        g = [[] for _ in range(n)]\n        for a, b in zip(flowFrom, flowTo):\n            g[a].append(b)\n\n        q = deque(crystals)\n        vis = [0] * n\n        for x in crystals:\n            vis[x] = 1\n        bfs(q)\n\n        seq = []\n        for i in range(n):\n            if vis[i] == 0:\n                dfs(i)\n        seq.reverse()\n        ans = 0\n        for i in seq:\n            if vis[i] == 2:\n                q = deque([i])\n                vis[i] = 1\n                bfs(q)\n                ans += 1\n        return ans\n", "class Solution:\n  def minRunesToAdd(\n      self,\n      n: int,\n      crystals: list[int],\n      flowFrom: list[int],\n      flowTo: list[int]\n  ) -> int:\n    graph = [[] for _ in range(n)]\n    reversedGraph = [[] for _ in range(n)]\n\n    for u, v in zip(flowFrom, flowTo):\n      graph[u].append(v)\n      reversedGraph[v].append(u)\n\n    # Identify Strongly Connected Components (SCC) using Kosaraju's Algorithm.\n    seen = set()\n    orderStack = []\n    componentIds = [-1] * n\n    componentCount = 0\n\n    for i in range(n):\n      if i not in seen:\n        self._kosaraju(graph, i, seen, orderStack)\n\n    while orderStack:\n      u = orderStack.pop()\n      if componentIds[u] == -1:\n        self._identifySCC(reversedGraph, u, componentIds, componentCount)\n        componentCount += 1\n\n    # Track crystal-containing components and inter-component edges.\n    hasCrystal = [False] * componentCount\n    hasInterComponentEdge = [False] * componentCount\n\n    for u in crystals:\n      hasCrystal[componentIds[u]] = True\n\n    for u, v in zip(flowFrom, flowTo):\n      id1 = componentIds[u]\n      id2 = componentIds[v]\n      if id1 != id2:  # Edge is inter-component.\n        hasInterComponentEdge[id2] = True\n\n    return sum(not hasCrystal[i] and not hasInterComponentEdge[i]\n               for i in range(componentCount))\n\n  def _kosaraju(\n      self,\n      graph: list[list[int]],\n      u: int,\n      seen: set[int],\n      orderStack: list\n  ) -> None:\n    \"\"\"Creates a topological order stack using Kosaraju's Algorithm.\"\"\"\n    seen.add(u)\n    for v in graph[u]:\n      if v not in seen:\n        self._kosaraju(graph, v, seen, orderStack)\n    orderStack.append(u)\n\n  def _identifySCC(\n      self,\n      reversedGraph: list[list[int]],\n      u: int,\n      componentIds: list[int],\n      componentId: int\n  ) -> None:\n    \"\"\"Assigns component IDs during SCC identification in the second DFS.\"\"\"\n    if componentIds[u] != -1:\n      return\n    componentIds[u] = componentId\n    for v in reversedGraph[u]:\n      if componentIds[v] == -1:\n        self._identifySCC(reversedGraph, v, componentIds, componentId)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3331, "slug": "find-subtree-sizes-after-changes", "solutions": ["class Solution:\n    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:\n        def dfs(i: int, fa: int):\n            ans[i] = 1\n            d[s[i]].append(i)\n            for j in g[i]:\n                dfs(j, i)\n            k = fa\n            if len(d[s[i]]) > 1:\n                k = d[s[i]][-2]\n            if k != -1:\n                ans[k] += ans[i]\n            d[s[i]].pop()\n\n        n = len(s)\n        g = [[] for _ in range(n)]\n        for i in range(1, n):\n            g[parent[i]].append(i)\n        d = defaultdict(list)\n        ans = [0] * n\n        dfs(0, -1)\n        return ans\n", "class Solution:\n  def findSubtreeSizes(self, parent: list[int], s: str) -> list[int]:\n    n = len(parent)\n    ans = [0] * n\n    newParent = parent.copy()\n    tree = [[] for _ in range(n)]\n\n    for i in range(1, n):\n      closest = self._findClosestAncestor(i, parent, s)\n      if closest != -1:\n        newParent[i] = closest\n\n    for i in range(1, n):\n      tree[newParent[i]].append(i)\n\n    self._dfs(tree, 0, ans)\n    return ans\n\n  def _findClosestAncestor(self, u: int, parent: list[int], s: str) -> int:\n    \"\"\"\n    Returns the closest ancestor of node `u` that has the same value as `u`.\n    \"\"\"\n    curr = parent[u]\n    while curr != -1:\n      if s[curr] == s[u]:\n        return curr\n      curr = parent[curr]\n    return -1\n\n  def _dfs(self, tree: list[list[int]], u: int, ans: list[int]) -> int:\n    sz = 1\n    for v in tree[u]:\n      sz += self._dfs(tree, v, ans)\n    ans[u] = sz\n    return sz\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3375, "slug": "minimum-operations-to-make-array-values-equal-to-k", "solutions": ["class Solution:\n    def minOperations(self, nums: List[int], k: int) -> int:\n        s = set()\n        mi = inf\n        for x in nums:\n            if x < k:\n                return -1\n            mi = min(mi, x)\n            s.add(x)\n        return len(s) - int(k == mi)\n", "class Solution:\n  def minOperations(self, nums: list[int], k: int) -> int:\n    numsSet = set(nums)\n    mn = min(nums)\n    if mn < k:\n      return -1\n    if mn > k:\n      return len(numsSet)\n    return len(numsSet) - 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3301, "slug": "maximize-the-total-height-of-unique-towers", "solutions": ["class Solution:\n    def maximumTotalSum(self, maximumHeight: List[int]) -> int:\n        maximumHeight.sort()\n        ans, mx = 0, inf\n        for x in maximumHeight[::-1]:\n            x = min(x, mx - 1)\n            if x <= 0:\n                return -1\n            ans += x\n            mx = x\n        return ans\n", "class Solution:\n  def maximumTotalSum(self, maximumHeight: list[int]) -> int:\n    ans = 0\n    mn = math.inf\n\n    for height in sorted(maximumHeight, reverse=True):\n      assigned = min(height, mn - 1)\n      if assigned == 0:\n        return -1\n      ans += assigned\n      mn = assigned\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3391, "slug": "design-a-3d-binary-matrix-with-efficient-layer-tracking", "solutions": ["class matrix3D:\n    def __init__(self, n: int):\n        self.g = [[[0] * n for _ in range(n)] for _ in range(n)]\n        self.cnt = [0] * n\n        self.sl = SortedList(key=lambda x: (-x[0], -x[1]))\n\n    def setCell(self, x: int, y: int, z: int) -> None:\n        if self.g[x][y][z]:\n            return\n        self.g[x][y][z] = 1\n        self.sl.discard((self.cnt[x], x))\n        self.cnt[x] += 1\n        self.sl.add((self.cnt[x], x))\n\n    def unsetCell(self, x: int, y: int, z: int) -> None:\n        if self.g[x][y][z] == 0:\n            return\n        self.g[x][y][z] = 0\n        self.sl.discard((self.cnt[x], x))\n        self.cnt[x] -= 1\n        if self.cnt[x]:\n            self.sl.add((self.cnt[x], x))\n\n    def largestMatrix(self) -> int:\n        return self.sl[0][1] if self.sl else len(self.g) - 1\n\n\n# Your matrix3D object will be instantiated and called as such:\n# obj = matrix3D(n)\n# obj.setCell(x,y,z)\n# obj.unsetCell(x,y,z)\n# param_3 = obj.largestMatrix()\n", "class Matrix3D:\n  def __init__(self, n: int):\n    self.isSet = set()\n    # count[x] := the number of set cells in the x-th layer\n    self.count = collections.Counter()\n    # (count[x], x)\n    self.pairs: SortedList = SortedList(key=lambda x: (-x[0], -x[1]))\n    self.pairs.update((0, x) for x in range(n))\n\n  def setCell(self, x: int, y: int, z: int) -> None:\n    if (x, y, z) in self.isSet:\n      return\n    self.isSet.add((x, y, z))\n    self.pairs.remove((self.count[x], x))\n    self.count[x] += 1\n    self.pairs.add((self.count[x], x))\n\n  def unsetCell(self, x: int, y: int, z: int) -> None:\n    if (x, y, z) not in self.isSet:\n      return\n    self.isSet.remove((x, y, z))\n    self.pairs.remove((self.count[x], x))\n    self.count[x] -= 1\n    self.pairs.add((self.count[x], x))\n\n  def largestMatrix(self) -> int:\n    return self.pairs[0][1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3334, "slug": "find-the-maximum-factor-score-of-array", "solutions": ["class Solution:\n    def maxScore(self, nums: List[int]) -> int:\n        n = len(nums)\n        suf_gcd = [0] * (n + 1)\n        suf_lcm = [0] * n + [1]\n        for i in range(n - 1, -1, -1):\n            suf_gcd[i] = gcd(suf_gcd[i + 1], nums[i])\n            suf_lcm[i] = lcm(suf_lcm[i + 1], nums[i])\n        ans = suf_gcd[0] * suf_lcm[0]\n        pre_gcd, pre_lcm = 0, 1\n        for i, x in enumerate(nums):\n            ans = max(ans, gcd(pre_gcd, suf_gcd[i + 1]) * lcm(pre_lcm, suf_lcm[i + 1]))\n            pre_gcd = gcd(pre_gcd, x)\n            pre_lcm = lcm(pre_lcm, x)\n        return ans\n", "class Solution:\n  def maxScore(self, nums: list[int]) -> int:\n    n = len(nums)\n    # prefixGcd[i] := GCD of nums[0..i]\n    # prefixLcm[i] := LCM of nums[0..i]\n    prefixGcd, prefixLcm = self._getPrefix(nums)\n    # suffixGcd[i] := GCD of nums[i..n - 1]\n    # suffixLcm[i] := LCM of nums[i..n - 1]\n    suffixGcd, suffixLcm = self._getSuffix(nums)\n    ans = suffixGcd[0] * suffixLcm[0]\n\n    for i in range(n):\n      gcd1 = prefixGcd[i - 1] if i > 0 else 0\n      gcd2 = suffixGcd[i + 1] if i + 1 < n else 0\n      lcm1 = prefixLcm[i - 1] if i > 0 else 1\n      lcm2 = suffixLcm[i + 1] if i + 1 < n else 1\n      score = math.gcd(gcd1, gcd2) * math.lcm(lcm1, lcm2)\n      ans = max(ans, score)\n\n    return ans\n\n  def _getPrefix(self, nums: list[int]) -> tuple[list[int], list[int]]:\n    \"\"\"Returns the prefix GCD and LCM arrays.\"\"\"\n    prefixGcd = []\n    prefixLcm = []\n    currGcd = 0\n    currLcm = 1\n    for num in nums:\n      currGcd = math.gcd(currGcd, num)\n      currLcm = math.lcm(currLcm, num)\n      prefixGcd.append(currGcd)\n      prefixLcm.append(currLcm)\n    return prefixGcd, prefixLcm\n\n  def _getSuffix(self, nums: list[int]) -> tuple[list[int], list[int]]:\n    \"\"\"Returns the suffix GCD and LCM arrays.\"\"\"\n    suffixGcd = []\n    suffixLcm = []\n    currGcd = 0\n    currLcm = 1\n    for num in reversed(nums):\n      currGcd = math.gcd(currGcd, num)\n      currLcm = math.lcm(currLcm, num)\n      suffixGcd.append(currGcd)\n      suffixLcm.append(currLcm)\n    return list(reversed(suffixGcd)), list(reversed(suffixLcm))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3347, "slug": "maximum-frequency-of-an-element-after-performing-operations-ii", "solutions": ["class Solution:\n    def maxFrequency(self, nums: List[int], k: int, numOperations: int) -> int:\n        cnt = defaultdict(int)\n        d = defaultdict(int)\n        for x in nums:\n            cnt[x] += 1\n            d[x] += 0\n            d[x - k] += 1\n            d[x + k + 1] -= 1\n        ans = s = 0\n        for x, t in sorted(d.items()):\n            s += t\n            ans = max(ans, min(s, cnt[x] + numOperations))\n        return ans\n", "from sortedcontainers import SortedDict\n\n\nclass Solution:\n  # Same as 3346. Maximum Frequency of an Element After Performing Operations I\n  def maxFrequency(self, nums: list[int], k: int, numOperations: int) -> int:\n    ans = 1\n    adjustable = 0\n    count = collections.Counter(nums)\n    line = SortedDict()\n    candidates = set()\n\n    for num in nums:\n      line[num - k] = line.get(num - k, 0) + 1\n      line[num + k + 1] = line.get(num + k + 1, 0) - 1\n      candidates.add(num)\n      candidates.add(num - k)\n      candidates.add(num + k + 1)\n\n    for num in sorted(candidates):\n      adjustable += line.get(num, 0)\n      adjusted = adjustable - count[num]\n      ans = max(ans, count[num] + min(numOperations, adjusted))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3358, "slug": "books-with-null-ratings", "solutions": ["import pandas as pd\n\n\ndef find_unrated_books(books: pd.DataFrame) -> pd.DataFrame:\n    unrated_books = books[books[\"rating\"].isnull()]\n    return unrated_books[[\"book_id\", \"title\", \"author\", \"published_year\"]].sort_values(\n        by=\"book_id\"\n    )\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3355, "slug": "zero-array-transformation-i", "solutions": ["class Solution:\n    def isZeroArray(self, nums: List[int], queries: List[List[int]]) -> bool:\n        d = [0] * (len(nums) + 1)\n        for l, r in queries:\n            d[l] += 1\n            d[r + 1] -= 1\n        s = 0\n        for x, y in zip(nums, d):\n            s += y\n            if x > s:\n                return False\n        return True\n", "class Solution:\n  def isZeroArray(self, nums: list[int], queries: list[list[int]]) -> bool:\n    line = [0] * (len(nums) + 1)\n    decrement = 0\n\n    for l, r in queries:\n      line[l] += 1\n      line[r + 1] -= 1\n\n    for i, num in enumerate(nums):\n      decrement += line[i]\n      if decrement < num:\n        return False\n\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3323, "slug": "minimize-connected-groups-by-inserting-interval", "solutions": ["class Solution:\n    def minConnectedGroups(self, intervals: List[List[int]], k: int) -> int:\n        intervals.sort()\n        merged = [intervals[0]]\n        for s, e in intervals[1:]:\n            if merged[-1][1] < s:\n                merged.append([s, e])\n            else:\n                merged[-1][1] = max(merged[-1][1], e)\n        ans = len(merged)\n        for i, (_, e) in enumerate(merged):\n            j = bisect_left(merged, [e + k + 1, 0])\n            ans = min(ans, len(merged) - (j - i - 1))\n        return ans\n", "class Solution:\n  def minConnectedGroups(self, intervals: list[list[int]], k: int) -> int:\n    mergedIntervals = 0\n    maxMergedIntervals = 0\n\n    intervals = self._merge(intervals)\n\n    i = 0\n    for _, end in intervals:\n      while i < len(intervals) and end + k >= intervals[i][0]:\n        mergedIntervals += 1\n        i += 1\n      mergedIntervals -= 1  # Exclude intervals[i].\n      maxMergedIntervals = max(maxMergedIntervals, mergedIntervals)\n\n    return len(intervals) - maxMergedIntervals\n\n  # Same as 56. Merge Intervals\n  def _merge(self, intervals: list[list[int]]) -> list[list[int]]:\n    res = []\n    for interval in sorted(intervals):\n      if not res or res[-1][1] < interval[0]:\n        res.append(interval)\n      else:\n        res[-1][1] = max(res[-1][1], interval[1])\n    return res\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3348, "slug": "smallest-divisible-digit-product-ii", "solutions": ["FACTOR_COUNTS = {\n    0: collections.Counter(),\n    1: collections.Counter(),\n    2: collections.Counter([2]),\n    3: collections.Counter([3]),\n    4: collections.Counter([2, 2]),\n    5: collections.Counter([5]),\n    6: collections.Counter([2, 3]),\n    7: collections.Counter([7]),\n    8: collections.Counter([2, 2, 2]),\n    9: collections.Counter([3, 3]),\n}\n\n\nclass Solution:\n  def smallestNumber(self, num: str, t: int) -> str:\n    primeCount, isDivisible = self._getPrimeCount(t)\n    if not isDivisible:\n      return '-1'\n\n    factorCount = self._getFactorCount(primeCount)\n    if sum(factorCount.values()) > len(num):\n      return ''.join(factor * freq for factor, freq in factorCount.items())\n\n    primeCountPrefix = sum((FACTOR_COUNTS[int(c)]\n                            for c in num), start=collections.Counter())\n    firstZeroIndex = next((i for i, d in enumerate(num) if d == '0'), len(num))\n    if firstZeroIndex == len(num) and primeCount <= primeCountPrefix:\n      return num\n\n    for i, c in reversed(list(enumerate(num))):\n      d = int(c)\n      # Remove the current digit's factors from primeCountPrefix.\n      primeCountPrefix -= FACTOR_COUNTS[d]\n      spaceAfterThisDigit = len(num) - 1 - i\n      if i <= firstZeroIndex:\n        for biggerDigit in range(d + 1, 10):\n          # Compute the required factors after replacing with a larger digit.\n          factorsAfterReplacement = self._getFactorCount(\n              primeCount - primeCountPrefix - FACTOR_COUNTS[biggerDigit]\n          )\n          # Check if the replacement is possible within the available space.\n          if sum(factorsAfterReplacement.values()) <= spaceAfterThisDigit:\n            # Fill extra space with '1', if any, and construct the result.\n            fillOnes = spaceAfterThisDigit - sum(\n                factorsAfterReplacement.values())\n            return (\n                num[:i]  # Keep the prefix unchanged.\n                + str(biggerDigit)  # Replace the current digit.\n                + '1' * fillOnes  # Fill remaining space with '1'.\n                + ''.join(factor * freq for factor,\n                          freq in factorsAfterReplacement.items())\n            )\n\n    # No solution of the same length exists, so we need to extend the number\n    # by prepending '1's and adding the required factors.\n    factorCount = self._getFactorCount(primeCount)\n    return (\n        '1' * (len(num) + 1 - sum(factorCount.values()))\n        + ''.join(factor * freq for factor, freq in factorCount.items())\n    )\n\n  def _getPrimeCount(self, t: int) -> tuple[dict[int, int], bool]:\n    \"\"\"\n    Returns the count of prime factors of t and if t is divisible by 2, 3, 5, 7.\n    \"\"\"\n    count = collections.Counter()\n    for prime in [2, 3, 5, 7]:\n      while t % prime == 0:\n        t //= prime\n        count[prime] += 1\n    return count, t == 1\n\n  def _getFactorCount(self, count: dict[int, int]) -> dict[str, int]:\n    \"\"\"Returns the required factors to form the smallest number.\"\"\"\n    count8, remaining2 = divmod(count[2], 3)  # 2^3 = 8\n    count9, count3 = divmod(count[3], 2)  # 3^2 = 9\n    count4, count2 = divmod(remaining2, 2)  # 2^2 = 4\n    # Combine 2 and 3 to 6 if both are present.\n    count2, count3, count6 = ((0, 0, 1) if count2 == 1 and count3 == 1\n                              else (count2, count3, 0))\n    # Combine 3 and 4 to 2 and 6 if both are present.\n    count2, count6, count3, count4 = ((1, 1, 0, 0)\n                                      if count3 == 1 and count4 == 1\n                                      else (count2, count6, count3, count4))\n    return {'2': count2, '3': count3, '4': count4, '5': count[5],\n            '6': count6, '7': count[7], '8': count8, '9': count9}\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3373, "slug": "maximize-the-number-of-target-nodes-after-connecting-trees-ii", "solutions": ["class Solution:\n    def maxTargetNodes(\n        self, edges1: List[List[int]], edges2: List[List[int]]\n    ) -> List[int]:\n        def build(edges: List[List[int]]) -> List[List[int]]:\n            n = len(edges) + 1\n            g = [[] for _ in range(n)]\n            for a, b in edges:\n                g[a].append(b)\n                g[b].append(a)\n            return g\n\n        def dfs(\n            g: List[List[int]], a: int, fa: int, c: List[int], d: int, cnt: List[int]\n        ):\n            c[a] = d\n            cnt[d] += 1\n            for b in g[a]:\n                if b != fa:\n                    dfs(g, b, a, c, d ^ 1, cnt)\n\n        g1 = build(edges1)\n        g2 = build(edges2)\n        n, m = len(g1), len(g2)\n        c1 = [0] * n\n        c2 = [0] * m\n        cnt1 = [0, 0]\n        cnt2 = [0, 0]\n        dfs(g2, 0, -1, c2, 0, cnt2)\n        dfs(g1, 0, -1, c1, 0, cnt1)\n        t = max(cnt2)\n        return [t + cnt1[c1[i]] for i in range(n)]\n", "class Solution:\n  def maxTargetNodes(\n      self,\n      edges1: list[list[int]],\n      edges2: list[list[int]]\n  ) -> list[int]:\n    n = len(edges1) + 1\n    m = len(edges2) + 1\n    graph1 = self._buildGraph(edges1)\n    graph2 = self._buildGraph(edges2)\n    parity1 = [False] * n\n    parity2 = [False] * m  # placeholder (parity2 is not used)\n    even1 = self._dfs(graph1, 0, -1, parity1, True)\n    even2 = self._dfs(graph2, 0, -1, parity2, True)\n    odd1 = n - even1\n    odd2 = m - even2\n\n    # Can connect the current node in tree1 to either an even node or an odd\n    # node in tree2.\n    return [(even1 if parity1[i] else odd1) + max(even2, odd2)\n            for i in range(n)]\n\n  def _dfs(\n      self,\n      graph: list[list[int]],\n      u: int,\n      prev: int,\n      parity: list[bool],\n      isEven: bool\n  ) -> int:\n    \"\"\"\n    Returns the number of nodes that can be reached from u with even steps.\n    \"\"\"\n    res = 1 if isEven else 0\n    parity[u] = isEven\n    for v in graph[u]:\n      if v != prev:\n        res += self._dfs(graph, v, u, parity, not isEven)\n    return res\n\n  def _buildGraph(self, edges: list[list[int]]) -> list[list[int]]:\n    graph = [[] for _ in range(len(edges) + 1)]\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n    return graph\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3340, "slug": "check-balanced-string", "solutions": ["class Solution:\n    def isBalanced(self, num: str) -> bool:\n        f = [0, 0]\n        for i, x in enumerate(map(int, num)):\n            f[i & 1] += x\n        return f[0] == f[1]\n", "class Solution:\n  def isBalanced(self, num: str) -> bool:\n    nums = list(map(int, num))\n    return sum(nums[::2]) == sum(nums[1::2])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3322, "slug": "premier-league-table-ranking-iii", "solutions": ["import pandas as pd\n\n\ndef process_team_standings(season_stats: pd.DataFrame) -> pd.DataFrame:\n    season_stats[\"points\"] = season_stats[\"wins\"] * 3 + season_stats[\"draws\"]\n    season_stats[\"goal_difference\"] = (\n        season_stats[\"goals_for\"] - season_stats[\"goals_against\"]\n    )\n\n    season_stats = season_stats.sort_values(\n        [\"season_id\", \"points\", \"goal_difference\", \"team_name\"],\n        ascending=[True, False, False, True],\n    )\n\n    season_stats[\"position\"] = season_stats.groupby(\"season_id\").cumcount() + 1\n\n    return season_stats[\n        [\"season_id\", \"team_id\", \"team_name\", \"points\", \"goal_difference\", \"position\"]\n    ]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3349, "slug": "adjacent-increasing-subarrays-detection-i", "solutions": ["class Solution:\n    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:\n        mx = pre = cur = 0\n        for i, x in enumerate(nums):\n            cur += 1\n            if i == len(nums) - 1 or x >= nums[i + 1]:\n                mx = max(mx, cur // 2, min(pre, cur))\n                pre, cur = cur, 0\n        return mx >= k\n", "class Solution:\n  def hasIncreasingSubarrays(self, nums: list[int], k: int) -> bool:\n    increasing = 1\n    prevIncreasing = 0\n\n    for a, b in itertools.pairwise(nums):\n      if b > a:\n        increasing += 1\n      else:\n        prevIncreasing = increasing\n        increasing = 1\n      if increasing // 2 >= k or min(prevIncreasing, increasing) >= k:\n        return True\n\n    return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3377, "slug": "digit-operations-to-make-two-integers-equal", "solutions": ["import heapq\n\n\nclass Solution:\n    def __init__(self):\n        self.sieve = []\n\n    def run_sieve(self):\n        self.sieve = [True] * 100000\n        self.sieve[0], self.sieve[1] = False, False\n        for i in range(2, 100000):\n            if self.sieve[i]:\n                for j in range(2 * i, 100000, i):\n                    self.sieve[j] = False\n\n    def solve(self, n, m):\n        pq = []\n        heapq.heappush(pq, (n, n))\n        visited = set()\n\n        while pq:\n            sum_, cur = heapq.heappop(pq)\n\n            if cur in visited:\n                continue\n            visited.add(cur)\n\n            if cur == m:\n                return sum_\n\n            s = list(str(cur))\n            for i in range(len(s)):\n                c = s[i]\n\n                if s[i] < '9':\n                    s[i] = chr(ord(s[i]) + 1)\n                    next_ = int(''.join(s))\n                    if not self.sieve[next_] and next_ not in visited:\n                        heapq.heappush(pq, (sum_ + next_, next_))\n                    s[i] = c\n\n                if s[i] > '0' and not (i == 0 and s[i] == '1'):\n                    s[i] = chr(ord(s[i]) - 1)\n                    next_ = int(''.join(s))\n                    if not self.sieve[next_] and next_ not in visited:\n                        heapq.heappush(pq, (sum_ + next_, next_))\n                    s[i] = c\n\n        return -1\n\n    def minOperations(self, n, m):\n        self.run_sieve()\n        if self.sieve[n] or self.sieve[m]:\n            return -1\n        return self.solve(n, m)\n", "class Solution:\n  def minOperations(self, n: int, m: int) -> int:\n    isPrime = self._sieveEratosthenes(10000)\n    if isPrime[n] or isPrime[m]:\n      return -1\n    return self._dijkstra(n, m, isPrime)\n\n  def _dijkstra(self, src: int, dst: int, isPrime: list[bool]) -> int:\n    seen = {src}\n    minHeap = [(src, src)]  # (cost, num)\n\n    while minHeap:\n      cost, curr = heapq.heappop(minHeap)\n      if curr == dst:\n        return cost\n      s = list(str(curr))\n      for i, c in enumerate(s):\n        if c < '9':\n          s[i] = str(int(c) + 1)\n          nextNum = int(''.join(s))\n          if not isPrime[nextNum] and nextNum not in seen:\n            heapq.heappush(minHeap, (cost + nextNum, nextNum))\n            seen.add(nextNum)\n          s[i] = c\n        if c > '0' and not (i == 0 and c == '1'):\n          s[i] = str(int(c) - 1)\n          nextNum = int(''.join(s))\n          if not isPrime[nextNum] and nextNum not in seen:\n            heapq.heappush(minHeap, (cost + nextNum, nextNum))\n            seen.add(nextNum)\n          s[i] = c\n\n    return -1\n\n  def _sieveEratosthenes(self, n: int) -> list[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3363, "slug": "find-the-maximum-number-of-fruits-collected", "solutions": ["class Solution:\n  def maxCollectedFruits(self, fruits: list[list[int]]) -> int:\n    n = len(fruits)\n\n    def getTopLeft() -> int:\n      return sum(fruits[i][i] for i in range(n))\n\n    def getTopRight() -> int:\n      # dp[i][j] := the number of fruits collected from (0, n - 1) to (i, j)\n      dp = [[0] * n for _ in range(n)]\n      dp[0][-1] = fruits[0][-1]\n      for x in range(n):\n        for y in range(n):\n          if x >= y and (x, y) != (n - 1, n - 1):\n            continue\n          for dx, dy in [(1, -1), (1, 0), (1, 1)]:\n            i = x - dx\n            j = y - dy\n            if i < 0 or i == n or j < 0 or j == n:\n              continue\n            if i < j < n - 1 - i:\n              continue\n            dp[x][y] = max(dp[x][y], dp[i][j] + fruits[x][y])\n      return dp[-1][-1]\n\n    def getBottomLeft() -> int:\n      # dp[i][j] := the number of fruits collected from (n - 1, 0) to (i, j)\n      dp = [[0] * n for _ in range(n)]\n      dp[-1][0] = fruits[-1][0]\n      for y in range(n):\n        for x in range(n):\n          if x <= y and (x, y) != (n - 1, n - 1):\n            continue\n          for dx, dy in [(-1, 1), (0, 1), (1, 1)]:\n            i = x - dx\n            j = y - dy\n            if i < 0 or i == n or j < 0 or j == n:\n              continue\n            if j < i < n - 1 - j:\n              continue\n            dp[x][y] = max(dp[x][y], dp[i][j] + fruits[x][y])\n      return dp[-1][-1]\n\n    return getTopLeft() + getTopRight() + getBottomLeft() - 2 * fruits[-1][-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3369, "slug": "design-an-array-statistics-tracker", "solutions": ["class StatisticsTracker:\n    def __init__(self):\n        self.q = deque()\n        self.s = 0\n        self.cnt = defaultdict(int)\n        self.sl = SortedList()\n        self.sl2 = SortedList(key=lambda x: (-x[1], x[0]))\n\n    def addNumber(self, number: int) -> None:\n        self.q.append(number)\n        self.sl.add(number)\n        self.sl2.discard((number, self.cnt[number]))\n        self.cnt[number] += 1\n        self.sl2.add((number, self.cnt[number]))\n        self.s += number\n\n    def removeFirstAddedNumber(self) -> None:\n        number = self.q.popleft()\n        self.sl.remove(number)\n        self.sl2.discard((number, self.cnt[number]))\n        self.cnt[number] -= 1\n        self.sl2.add((number, self.cnt[number]))\n        self.s -= number\n\n    def getMean(self) -> int:\n        return self.s // len(self.q)\n\n    def getMedian(self) -> int:\n        return self.sl[len(self.q) // 2]\n\n    def getMode(self) -> int:\n        return self.sl2[0][0]\n\n\n# Your StatisticsTracker object will be instantiated and called as such:\n# obj = StatisticsTracker()\n# obj.addNumber(number)\n# obj.removeFirstAddedNumber()\n# param_3 = obj.getMean()\n# param_4 = obj.getMedian()\n# param_5 = obj.getMode()\n", "from sortedcontainers import SortedList\n\n\nclass StatisticsTracker:\n  def __init__(self):\n    self.q = collections.deque()\n    self.count = collections.Counter()\n    self.sortedList = SortedList()\n    self.modeMaxHeap = []  # (frequency, number)\n    self.sum = 0\n\n  def addNumber(self, number: int) -> None:\n    self.q.append(number)\n    self.count[number] += 1\n    self.sortedList.add(number)\n    heapq.heappush(self.modeMaxHeap, (-self.count[number], number))\n    self.sum += number\n\n  def removeFirstAddedNumber(self) -> None:\n    number = self.q.popleft()\n    self.count[number] -= 1\n    self.sortedList.remove(number)\n    # Note: No need to update the heap now; we'll clean up stale entries when\n    # getting the mode.\n    self.sum -= number\n\n  def getMean(self) -> int:\n    return self.sum // len(self.q)\n\n  def getMedian(self) -> int:\n    return self.sortedList[len(self.sortedList) // 2]\n\n  def getMode(self) -> int:\n    # Removes stale heap entries where frequency no longer matches.\n    while self.modeMaxHeap:\n      frequency = -self.modeMaxHeap[0][0]\n      number = self.modeMaxHeap[0][1]\n      if self.count[number] == frequency:\n        return number\n      heapq.heappop(self.modeMaxHeap)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3351, "slug": "sum-of-good-subsequences", "solutions": ["class Solution:\n    def sumOfGoodSubsequences(self, nums: List[int]) -> int:\n        mod = 10**9 + 7\n        f = defaultdict(int)\n        g = defaultdict(int)\n        for x in nums:\n            f[x] += x\n            g[x] += 1\n            f[x] += f[x - 1] + g[x - 1] * x\n            g[x] += g[x - 1]\n            f[x] += f[x + 1] + g[x + 1] * x\n            g[x] += g[x + 1]\n        return sum(f.values()) % mod\n", "class Solution:\n  def sumOfGoodSubsequences(self, nums: list[int]) -> int:\n    MOD = 10**9 + 7\n    maxNum = max(nums)\n    # endsIn[i] := the number of good subsequences ending in i\n    endsIn = [0] * (maxNum + 2)\n    # dp[i] := the sum of good subsequences ending in i\n    dp = [0] * (maxNum + 2)\n\n    for num in nums:\n      seqsToAppend = 1 + endsIn[num - 1] + endsIn[num + 1]\n      dp[num] = (seqsToAppend * num +\n                 (dp[num] + dp[num - 1] + dp[num + 1])) % MOD\n      endsIn[num] += seqsToAppend % MOD\n\n    return sum(dp) % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3387, "slug": "maximize-amount-after-two-days-of-conversions", "solutions": ["class Solution:\n    def maxAmount(\n        self,\n        initialCurrency: str,\n        pairs1: List[List[str]],\n        rates1: List[float],\n        pairs2: List[List[str]],\n        rates2: List[float],\n    ) -> float:\n        d1 = self.build(pairs1, rates1, initialCurrency)\n        d2 = self.build(pairs2, rates2, initialCurrency)\n        return max(d1.get(a, 0) / r2 for a, r2 in d2.items())\n\n    def build(\n        self, pairs: List[List[str]], rates: List[float], init: str\n    ) -> Dict[str, float]:\n        def dfs(a: str, v: float):\n            d[a] = v\n            for b, r in g[a]:\n                if b not in d:\n                    dfs(b, v * r)\n\n        g = defaultdict(list)\n        for (a, b), r in zip(pairs, rates):\n            g[a].append((b, r))\n            g[b].append((a, 1 / r))\n        d = {}\n        dfs(init, 1)\n        return d\n", "class Solution:\n  def maxAmount(\n      self,\n      initialCurrency: str,\n      pairs1: list[list[str]],\n      rates1: list[float],\n      pairs2: list[list[str]],\n      rates2: list[float]\n  ) -> float:\n    # dp[currency] := the maximum amount of money to convert to `currency`\n    dp: dict[str, float] = collections.defaultdict(float)\n    dp[initialCurrency] = 1.0\n    self._bellman(dp, pairs1, rates1)\n    self._bellman(dp, pairs2, rates2)\n    return dp[initialCurrency]\n\n  def _bellman(\n      self,\n      dp: dict[str, float],\n      pairs: list[list[str]],\n      rates: list[float]\n  ) -> None:\n    for _ in range(len(pairs)):\n      for (start, target), rate in zip(pairs, rates):\n        dp[target] = max(dp[target], dp[start] * rate)\n        dp[start] = max(dp[start], dp[target] / rate)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3386, "slug": "button-with-longest-push-time", "solutions": ["class Solution:\n    def buttonWithLongestTime(self, events: List[List[int]]) -> int:\n        ans, t = events[0]\n        for (_, t1), (i, t2) in pairwise(events):\n            d = t2 - t1\n            if d > t or (d == t and i < ans):\n                ans, t = i, d\n        return ans\n", "class Solution:\n  def buttonWithLongestTime(self, events: list[list[int]]) -> int:\n    ans = 0\n    maxTimeTaken = 0\n    prevTime = 0\n\n    for index, time in events:\n      timeTaken = time - prevTime\n      if timeTaken > maxTimeTaken or timeTaken == maxTimeTaken and index < ans:\n        maxTimeTaken = timeTaken\n        ans = index\n      prevTime = time\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3312, "slug": "sorted-gcd-pair-queries", "solutions": ["class Solution:\n    def gcdValues(self, nums: List[int], queries: List[int]) -> List[int]:\n        mx = max(nums)\n        cnt = Counter(nums)\n        cnt_g = [0] * (mx + 1)\n        for i in range(mx, 0, -1):\n            v = 0\n            for j in range(i, mx + 1, i):\n                v += cnt[j]\n                cnt_g[i] -= cnt_g[j]\n            cnt_g[i] += v * (v - 1) // 2\n        s = list(accumulate(cnt_g))\n        return [bisect_right(s, q) for q in queries]\n", "class Solution:\n  def gcdValues(self, nums: list[int], queries: list[int]) -> list[int]:\n    maxNum = max(nums)\n    # countDivisor[d] := the number of `nums` having `num % d == 0`\n    countDivisor = [0] * (maxNum + 1)\n    # countGcdPair[g] := the number of pairs having gcd == g\n    countGcdPair = [0] * (maxNum + 1)\n\n    for num in nums:\n      for i in range(1, math.isqrt(num) + 1):\n        if num % i == 0:\n          countDivisor[i] += 1\n          if i != num // i:\n            countDivisor[num // i] += 1\n\n    for gcd in range(maxNum, 0, -1):\n      # There are C(countDivisor[gcd], 2) pairs that have a common divisor\n      # that's a multiple of `gcd` (including the one that equals to `gcd`).\n      # So, substract the multiples of `gcd` to have the number of pairs with a\n      # gcd that's exactly `gcd`.\n      countGcdPair[gcd] = countDivisor[gcd] * (countDivisor[gcd] - 1) // 2\n      for largerGcd in range(2 * gcd, maxNum + 1, gcd):\n        countGcdPair[gcd] -= countGcdPair[largerGcd]\n\n    # prefixCountGcdPair[g] := the number of pairs having gcd <= g\n    prefixCountGcdPair = list(itertools.accumulate(countGcdPair))\n    return [bisect.bisect_left(prefixCountGcdPair, query + 1)\n            for query in queries]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3371, "slug": "identify-the-largest-outlier-in-an-array", "solutions": ["class Solution:\n    def getLargestOutlier(self, nums: List[int]) -> int:\n        s = sum(nums)\n        cnt = Counter(nums)\n        ans = -inf\n        for x, v in cnt.items():\n            t = s - x\n            if t % 2 or cnt[t // 2] == 0:\n                continue\n            if x != t // 2 or v > 1:\n                ans = max(ans, x)\n        return ans\n", "class Solution:\n  def getLargestOutlier(self, nums: list[int]) -> int:\n    ans = -math.inf\n    summ = sum(nums)\n    count = collections.Counter(nums)\n\n    for num in nums:\n      withoutNum = summ - num\n      if withoutNum % 2 == 0:\n        specialSum = withoutNum // 2  # the sum of special numbers\n        if count[specialSum] > (1 if num == specialSum else 0):\n          ans = max(ans, num)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3362, "slug": "zero-array-transformation-iii", "solutions": ["from sortedcontainers import SortedList\n\n\nclass Solution:\n  def maxRemoval(self, nums: list[int], queries: list[list[int]]) -> int:\n    q = collections.deque(sorted(queries))\n    available = SortedList()  # available `r`s\n    running = SortedList()  # running `r`s\n\n    for i, num in enumerate(nums):\n      while q and q[0][0] <= i:\n        available.add(q.popleft()[1])\n      while running and running[0] < i:\n        running.pop(0)\n      while num > len(running):\n        if not available or available[-1] < i:\n          return -1\n        running.add(available.pop())\n\n    return len(available)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3300, "slug": "minimum-element-after-replacement-with-digit-sum", "solutions": ["class Solution:\n    def minElement(self, nums: List[int]) -> int:\n        return min(sum(int(b) for b in str(x)) for x in nums)\n", "class Solution:\n  def minElement(self, nums: list[int]) -> int:\n    return min(sum(map(int, str(num))) for num in nums)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3367, "slug": "maximize-sum-of-weights-after-edge-removals", "solutions": ["class Solution:\n    def maximizeSumOfWeights(self, edges: List[List[int]], k: int) -> int:\n        def dfs(u: int, fa: int) -> Tuple[int, int]:\n            s = 0\n            t = []\n            for v, w in g[u]:\n                if v == fa:\n                    continue\n                a, b = dfs(v, u)\n                s += a\n                if (d := (w + b - a)) > 0:\n                    t.append(d)\n            t.sort(reverse=True)\n            return s + sum(t[:k]), s + sum(t[: k - 1])\n\n        n = len(edges) + 1\n        g: List[List[Tuple[int, int]]] = [[] for _ in range(n)]\n        for u, v, w in edges:\n            g[u].append((v, w))\n            g[v].append((u, w))\n        x, y = dfs(0, -1)\n        return max(x, y)\n", "class Solution:\n  def maximizeSumOfWeights(self, edges: list[list[int]], k: int) -> int:\n    graph = [[] for _ in range(len(edges) + 1)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    def dfs(u: int, prev: int) -> tuple[int, int]:\n      \"\"\"\n      Returns\n      (the weight sum of the subtree rooted at u with at most k - 1 children,\n       the weight sum of the subtree rooted at u with at most k children).\n      \"\"\"\n      weightSum = 0\n      diffs = []\n      for v, w in graph[u]:\n        if v == prev:\n          continue\n        subK1, subK = dfs(v, u)\n        weightSum += subK\n        # If picking (u, v) makes the sum larger, we should pick it.\n        diffs.append(max(0, subK1 - subK + w))\n      return (weightSum + sum(heapq.nlargest(k - 1, diffs)),\n              weightSum + sum(heapq.nlargest(k, diffs)))\n\n    return dfs(0, -1)[1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3384, "slug": "team-dominance-by-pass-success", "solutions": ["import pandas as pd\n\n\ndef calculate_team_dominance(teams: pd.DataFrame, passes: pd.DataFrame) -> pd.DataFrame:\n    passes_with_teams = passes.merge(\n        teams, left_on=\"pass_from\", right_on=\"player_id\", suffixes=(\"\", \"_team_from\")\n    ).merge(\n        teams,\n        left_on=\"pass_to\",\n        right_on=\"player_id\",\n        suffixes=(\"_team_from\", \"_team_to\"),\n    )\n    passes_with_teams[\"half_number\"] = passes_with_teams[\"time_stamp\"].apply(\n        lambda x: 1 if x <= \"45:00\" else 2\n    )\n    passes_with_teams[\"dominance\"] = passes_with_teams.apply(\n        lambda row: 1 if row[\"team_name_team_from\"] == row[\"team_name_team_to\"] else -1,\n        axis=1,\n    )\n    result = (\n        passes_with_teams.groupby([\"team_name_team_from\", \"half_number\"])[\"dominance\"]\n        .sum()\n        .reset_index()\n    )\n    result.columns = [\"team_name\", \"half_number\", \"dominance\"]\n    result = result.sort_values(by=[\"team_name\", \"half_number\"])\n    return result\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3388, "slug": "count-beautiful-splits-in-an-array", "solutions": ["class Solution:\n    def beautifulSplits(self, nums: List[int]) -> int:\n        n = len(nums)\n        lcp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n - 1, -1, -1):\n            for j in range(n - 1, i - 1, -1):\n                if nums[i] == nums[j]:\n                    lcp[i][j] = lcp[i + 1][j + 1] + 1\n        ans = 0\n        for i in range(1, n - 1):\n            for j in range(i + 1, n):\n                a = i <= j - i and lcp[0][i] >= i\n                b = j - i <= n - j and lcp[i][j] >= j - i\n                ans += int(a or b)\n        return ans\n", "class Solution:\n  def beautifulSplits(self, nums: list[int]) -> int:\n    n = len(nums)\n    # z[start][i] := the z array of nums[i..n) with respect to nums[start..n)\n    z = [self._zFunction(nums, start)\n         for start in range(n)]\n    # nums1 | nums2 | nums3 = nums[0..i] | nums[i + 1..j] | nums[j + 1..n - 1]\n    return sum((j - i >= i + 1 and z[0][i + 1] >= i + 1)  # nums1 is a prefix of nums2\n               or z[i + 1][j + 1] >= j - i  # nums2 is a suffix of nums3.\n               for i in range(n - 2)\n               for j in range(i + 1, n - 1))\n\n  def _zFunction(self, nums: list[int], start: int) -> list[int]:\n    \"\"\"\n    Returns the z array, where z[i] is the length of the longest prefix of\n    nums[i..n) which is also a prefix of nums[start..n).\n    \"\"\"\n    n = len(nums)\n    z = [0] * n\n    l = start\n    r = start\n    for i in range(1 + start, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l + start])\n      while i + z[i] < n and nums[z[i] + start] == nums[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n    return z\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3303, "slug": "find-the-occurrence-of-first-almost-equal-substring", "solutions": ["class Solution:\n  def minStartingIndex(self, s: str, pattern: str) -> int:\n    z1 = self._zFunction(pattern + s)\n    z2 = self._zFunction(pattern[::-1] + s[::-1])\n\n    # Match s[i..i + len(pattern) - 1] with `pattern` from both the prefix and\n    # the suffix.\n    for i in range(len(s) - len(pattern) + 1):\n      if z1[len(pattern) + i] + z2[len(s) - i] >= len(pattern) - 1:\n        return i\n\n    return -1\n\n  def _zFunction(self, s: str) -> list[int]:\n    \"\"\"\n    Returns the z array, where z[i] is the length of the longest prefix of\n    s[i..n) which is also a prefix of s.\n\n    https://cp-algorithms.com/string/z-function.html#implementation\n    \"\"\"\n    n = len(s)\n    z = [0] * n\n    l = 0\n    r = 0\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n    return z\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3395, "slug": "subsequences-with-a-unique-middle-mode-i", "solutions": ["class Solution:\n  def __init__(self):\n    self.MOD = 1_000_000_007\n\n  def subsequencesWithMiddleMode(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = 0\n    left = collections.Counter()\n    right = collections.Counter()\n\n    for i in range(2):\n      left[nums[i]] += 1\n\n    for i in range(2, n):\n      right[nums[i]] += 1\n\n    for i in range(2, n - 2):\n      num = nums[i]\n      right[num] -= 1\n      if right[num] == 0:\n        del right[num]\n\n      leftCount = left[num]\n      rightCount = right[num]\n      leftOther = i - leftCount\n      rightOther = n - 1 - i - rightCount\n\n      # count[mode] = 5 -- [a a] a [a a]\n      ans += math.comb(leftCount, 2) * math.comb(rightCount, 2)\n\n      # count[mode] = 4 -- [a a] a [a ?]\n      ans += math.comb(leftCount, 2) * rightCount * rightOther\n\n      # count[mode] = 4 -- [a ?] a [a a]\n      ans += leftCount * leftOther * math.comb(rightCount, 2)\n\n      # count[mode] = 3 -- [a a] a [? ?]\n      ans += math.comb(leftCount, 2) * math.comb(rightOther, 2)\n\n      # count[mode] = 3 -- [? ?] a [a a]\n      ans += math.comb(leftOther, 2) * math.comb(rightCount, 2)\n\n      # count[mode] = 3 -- [a ?] a [a ?]\n      ans += leftCount * leftOther * rightCount * rightOther\n\n      # count[mode] = 2 -- [a ?] a [? ?]\n      ans += leftCount * self._calc(num, leftOther, rightOther, left, right)\n\n      # count[mode] = 2 -- [? ?] a [a ?]\n      ans += rightCount * self._calc(num, rightOther, leftOther, right, left)\n\n      ans %= self.MOD\n      left[num] += 1\n\n    return ans\n\n  def _calc(\n      self,\n      a: int,\n      other1: int,\n      other2: int,\n      count1: dict[int, int],\n      count2: dict[int, int]\n  ) -> int:\n    \"\"\"\n    Returns the count of subsequences that have `a` as the middle number, where\n    invalid subsequences are excluded.\n    \"\"\"\n    # [a ?] a [? ?]\n    res = (other1 * math.comb(other2, 2)) % self.MOD\n\n    for b, b1 in count1.items():\n      if b == a:\n        continue\n      b2 = count2[b]\n      # Exclude triples -- [a b] a [b b].\n      res = (res - b1 * math.comb(b2, 2)) % self.MOD\n      # Exclude doubles -- [a b] a [b ?].\n      res = (res - b1 * b2 * (other2 - b2)) % self.MOD\n\n    for b, b2 in count2.items():\n      if b == a:\n        continue\n      b1 = count1[b]\n      # Exclude doubles -- [a ?] a [b b].\n      res = (res - (other1 - b1) * math.comb(b2, 2)) % self.MOD\n\n    return (res + self.MOD) % self.MOD\n", "# Recall from solution 1 that after counting all the subsequences with `a` as\n# the middle mode number, we need to subtract the cases where `a` is not a\n# unique mode or not a mode.\n#\n# To avoid the need of looping through all numbers that are not `a`, we can\n# maintain the sums that are not related to `a` in the loop.\n#\n# So, during the simplification of the formula, keep the running sums of\n# pss, spp, pp, ss, and ps as the first item.\n# (for cleaner notation, abbreviate p[b] and s[b] to just p and s)\n#\n#   sum(b != a) (p[a] * p * s) * (r - s[a] - s)\n#             + (s[a] * s * p) * (l - p[a] - p)\n#             + (p, 2) * s[a] * (r - s[a])\n#             + (s, 2) * p[a] * (l - p[a])\n#\n#   sum(b != a) (p * s) * (p[a] * (r - s[a])) + (p * s^2) * (-p[a])\n#             + (s * p) * (s[a] * (l - p[a])) + (s * p^2) * (-s[a])\n#             + (p^2 - p) * (s[a] * (r - s[a]) / 2)\n#             + (s^2 - s) * (p[a] * (l - p[a]) / 2)\n\n\nclass Solution:\n  def subsequencesWithMiddleMode(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    p = collections.Counter()  # prefix counter\n    s = collections.Counter(nums)  # suffix counter\n\n    def nC2(n: int) -> int:\n      return n * (n - 1) // 2\n\n    pss = 0\n    spp = 0\n    pp = 0\n    ss = sum(freq**2 for freq in s.values())\n    ps = 0\n\n    for i, a in enumerate(nums):\n      # Update running sums after decrementing s[a].\n      pss += p[a] * (-s[a]**2 + (s[a] - 1)**2)\n      spp += -p[a]**2  # (-s[a] + (s[a] - 1)) * p[a]**2\n      ss += -s[a]**2 + (s[a] - 1)**2\n      ps += -p[a]  # -p[a] * (-s[a] + (s[a] - 1))\n\n      s[a] -= 1\n\n      l = i\n      r = len(nums) - i - 1\n\n      # Start with all possible subsequences with `a` as the middle number.\n      ans += nC2(l) * nC2(r)\n\n      # Minus the cases where the frequency of `a` is 1, so it's not a mode.\n      ans -= nC2(l - p[a]) * nC2(r - s[a])\n\n      # Minus the values where `b != a`.\n      pss_ = pss - p[a] * s[a]**2\n      spp_ = spp - s[a] * p[a]**2\n      pp_ = pp - p[a]**2\n      ss_ = ss - s[a]**2\n      ps_ = ps - p[a] * s[a]\n      p_ = l - p[a]\n      s_ = r - s[a]\n\n      # Minus the cases where the `a` is not a \"unique\" mode or not a mode.\n      ans -= ps_ * (p[a] * (r - s[a])) + pss_ * (-p[a])\n      ans -= ps_ * (s[a] * (l - p[a])) + spp_ * (-s[a])\n      ans -= (pp_ - p_) * s[a] * (r - s[a]) // 2\n      ans -= (ss_ - s_) * p[a] * (l - p[a]) // 2\n      ans %= MOD\n\n      # Update running sums after incrementing p[a].\n      pss += s[a]**2  # (-p[a] + (p[a] + 1)) * s[a]**2\n      spp += s[a] * (-p[a]**2 + (p[a] + 1)**2)\n      pp += -p[a]**2 + (p[a] + 1)**2\n      ps += s[a]  # (-p[a] + (p[a] + 1)) * s[a]\n\n      p[a] += 1\n\n    return ans\n", "class Solution:\n  def subsequencesWithMiddleMode(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    p = collections.Counter()  # prefix counter\n    s = collections.Counter(nums)  # suffix counter\n\n    def nC2(n: int) -> int:\n      return n * (n - 1) // 2\n\n    for i, a in enumerate(nums):\n      s[a] -= 1\n\n      l = i\n      r = len(nums) - i - 1\n\n      # Start with all possible subsequences with `a` as the middle number.\n      ans += nC2(l) * nC2(r)\n\n      # Minus the cases where the frequency of `a` is 1, so it's not a mode.\n      ans -= nC2(l - p[a]) * nC2(r - s[a])\n\n      for b in p | s:\n        if b == a:\n          continue\n\n        # Minus the cases where the middle number is not a \"unique\" mode.\n        ans -= p[a] * p[b] * s[b] * (r - s[a] - s[b])  # [a b] a [b c]\n        ans -= s[a] * s[b] * p[b] * (l - p[a] - p[b])  # [b c] a [a b]\n        ans -= nC2(p[b]) * s[a] * (r - s[a] - s[b])  # [b b] a [a c]\n        ans -= nC2(s[b]) * p[a] * (l - p[a] - p[b])  # [a c] a [b b]\n\n        # Minus the cases where the middle number is not a mode.\n        ans -= nC2(p[b]) * s[a] * s[b]  # [b b] a [a b]\n        ans -= nC2(s[b]) * p[a] * p[b]  # [a b] a [b b]\n\n      ans %= MOD\n      p[a] += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3315, "slug": "construct-the-minimum-bitwise-array-ii", "solutions": ["class Solution:\n    def minBitwiseArray(self, nums: List[int]) -> List[int]:\n        ans = []\n        for x in nums:\n            if x == 2:\n                ans.append(-1)\n            else:\n                for i in range(1, 32):\n                    if x >> i & 1 ^ 1:\n                        ans.append(x ^ 1 << (i - 1))\n                        break\n        return ans\n", "class Solution:\n  # Same as 3314. Construct the Minimum Bitwise Array I\n  def minBitwiseArray(self, nums: list[int]) -> list[int]:\n    return [-1 if num == 2 else num - self._getLeadingOneOfLastGroupOfOnes(num)\n            for num in nums]\n\n  def _getLeadingOneOfLastGroupOfOnes(self, num: int) -> int:\n    \"\"\"\n    Returns the leading one of the last group of 1s in the binary\n    representation of num. For example, if num = 0b10111, the leading one of\n    the last group of 1s is 0b100.\n    \"\"\"\n    leadingOne = 1\n    while (num & leadingOne) > 0:\n      leadingOne <<= 1\n    return leadingOne >> 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3326, "slug": "minimum-division-operations-to-make-array-non-decreasing", "solutions": ["mx = 10**6 + 1\nlpf = [0] * (mx + 1)\nfor i in range(2, mx + 1):\n    if lpf[i] == 0:\n        for j in range(i, mx + 1, i):\n            if lpf[j] == 0:\n                lpf[j] = i\n\n\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        for i in range(len(nums) - 2, -1, -1):\n            if nums[i] > nums[i + 1]:\n                nums[i] = lpf[nums[i]]\n                if nums[i] > nums[i + 1]:\n                    return -1\n                ans += 1\n        return ans\n", "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    ans = 0\n\n    for i in range(len(nums) - 2, -1, -1):\n      if nums[i] > nums[i + 1]:\n        minDivisor = self._getMinDivisor(nums[i])\n        if minDivisor > nums[i + 1]:\n          return -1\n        nums[i] = minDivisor\n        ans += 1\n\n    return ans\n\n  def _getMinDivisor(self, num: int) -> int:\n    for divisor in range(2, math.isqrt(num) + 1):\n      if num % divisor == 0:\n        return divisor\n    return num\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3380, "slug": "maximum-area-rectangle-with-point-constraints-i", "solutions": ["class Solution:\n    def maxRectangleArea(self, points: List[List[int]]) -> int:\n        def check(x1: int, y1: int, x2: int, y2: int) -> bool:\n            cnt = 0\n            for x, y in points:\n                if x < x1 or x > x2 or y < y1 or y > y2:\n                    continue\n                if (x == x1 or x == x2) and (y == y1 or y == y2):\n                    cnt += 1\n                    continue\n                return False\n            return cnt == 4\n\n        ans = -1\n        for i, (x1, y1) in enumerate(points):\n            for x2, y2 in points[:i]:\n                x3, y3 = min(x1, x2), min(y1, y2)\n                x4, y4 = max(x1, x2), max(y1, y2)\n                if check(x3, y3, x4, y4):\n                    ans = max(ans, (x4 - x3) * (y4 - y3))\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3353, "slug": "minimum-total-operations", "solutions": ["class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        return sum(x != y for x, y in pairwise(nums))\n", "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    return sum(a != b for a, b in itertools.pairwise(nums))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3335, "slug": "total-characters-in-string-after-transformations-i", "solutions": ["class Solution:\n  def lengthAfterTransformations(self, s: str, t: int) -> int:\n    MOD = 1_000_000_007\n    count = [0] * 26\n\n    for c in s:\n      count[ord(c) - ord('a')] += 1\n\n    for _ in range(t):\n      newCount = [0] * 26\n      # 'a' -> 'b', 'b' -> 'c', ..., 'y' -> 'z'\n      for i in range(25):\n        newCount[i + 1] = count[i]\n      # 'z' -> 'ab'\n      newCount[0] = count[25]\n      newCount[1] = (newCount[1] + count[25]) % MOD\n      count = newCount\n\n    return sum(count) % MOD\n", "class Solution:\n  def lengthAfterTransformations(self, s: str, t: int) -> int:\n    MOD = 1_000_000_007\n\n    def matrixMult(A: list[list[int]], B: list[list[int]]) -> list[list[int]]:\n      \"\"\"Returns A * B.\"\"\"\n      sz = len(A)\n      C = [[0] * sz for _ in range(sz)]\n      for i in range(sz):\n        for j in range(sz):\n          for k in range(sz):\n            C[i][j] += A[i][k] * B[k][j]\n            C[i][j] %= MOD\n      return C\n\n    def matrixPow(M: list[list[int]], n: int) -> list[list[int]]:\n      \"\"\"Returns M^n.\"\"\"\n      if n == 0:\n        return [[1 if i == j else 0  # identity matrix\n                for j in range(len(M))]\n                for i in range(len(M))]\n      if n % 2 == 1:\n        return matrixMult(M, matrixPow(M, n - 1))\n      return matrixPow(matrixMult(M, M), n // 2)\n\n    # T[i][j] := the number of ways to transform ('a' + i) to ('a' + j)\n    T = self._getTransformationMatrix()\n    poweredT = matrixPow(T, t)\n    count = [0] * 26\n    lengths = [0] * 26\n\n    for c in s:\n      count[ord(c) - ord('a')] += 1\n\n    for i in range(26):\n      for j in range(26):\n        lengths[j] += count[i] * poweredT[i][j]\n        lengths[j] %= MOD\n\n    return sum(lengths) % MOD\n\n  def _getTransformationMatrix(self) -> list[list[int]]:\n    T = [[0] * 26 for _ in range(26)]\n    # 'z' -> 'ab'\n    T[25][0] = 1\n    T[25][1] = 1\n    # 'a' -> 'b', 'b' -> 'c', ..., 'y' -> 'z'\n    for i in range(25):\n      T[i][i + 1] = 1\n    return T\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3325, "slug": "count-substrings-with-k-frequency-characters-i", "solutions": ["class Solution:\n    def numberOfSubstrings(self, s: str, k: int) -> int:\n        cnt = Counter()\n        ans = l = 0\n        for c in s:\n            cnt[c] += 1\n            while cnt[c] >= k:\n                cnt[s[l]] -= 1\n                l += 1\n            ans += l\n        return ans\n", "class Solution:\n  def numberOfSubstrings(self, s: str, k: int) -> int:\n    n = len(s)\n    ans = n * (n + 1) // 2\n    count = collections.Counter()\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] += 1\n      while count[c] == k:\n        count[s[l]] -= 1\n        l += 1\n      ans -= r - l + 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 3357, "slug": "minimize-the-maximum-adjacent-element-difference", "solutions": ["class Solution:\n  def minDifference(self, nums: list[int]) -> int:\n    maxPositiveGap = 0\n    mn = 1_000_000_000\n    mx = 0\n\n    for a, b in itertools.pairwise(nums):\n      if (a == -1) != (b == -1):\n        positive = max(a, b)\n        mn = min(mn, positive)\n        mx = max(mx, positive)\n      else:\n        maxPositiveGap = max(maxPositiveGap, abs(a - b))\n\n    l = maxPositiveGap\n    r = (mx - mn + 1) // 2\n    return bisect.bisect_left(\n        range(l, r), True,\n        key=lambda m: self._check(nums, m, mn + m, mx - m)) + l\n\n  def _check(self, nums: list[int], m: int, x: int, y: int) -> bool:\n    \"\"\"\n    Returns True if it's possible have `m` as maximum absolute difference\n    between adjacent numbers, where -1s are replaced with `x` or `y`.\n    \"\"\"\n    gapLength = 0\n    prev = 0\n\n    for num in nums:\n      if num == -1:\n        gapLength += 1\n        continue\n      if prev > 0 and gapLength > 0:\n        if gapLength == 1 and not self._checkSingleGap(prev, num, m, x, y):\n          return False\n        if gapLength > 1 and not self._checkMultipleGaps(prev, num, m, x, y):\n          return False\n      prev = num\n      gapLength = 0\n\n    # Check leading gaps\n    if nums[0] == -1:\n      num = next((num for num in nums if num != -1), -1)\n      if num != -1 and not self._checkBoundaryGaps(num, m, x, y):\n        return False\n\n    # Check trailing gaps\n    if nums[-1] == -1:\n      num = next((num for num in reversed(nums) if num != -1), -1)\n      if num != -1 and not self._checkBoundaryGaps(num, m, x, y):\n        return False\n\n    return True\n\n  def _checkSingleGap(self, a: int, b: int, m: int, x: int, y: int) -> bool:\n    \"\"\"\n    Returns true if it's possible to have at most `m` as the minimized maximum\n    difference for a sequence with a single -1 between two numbers.\n    e.g. [a, -1, b] can be filled with either x or y.\n    \"\"\"\n    gapWithX = max(abs(a - x), abs(b - x))  # [a, x, b]\n    gapWithY = max(abs(a - y), abs(b - y))  # [a, y, b]\n    return min(gapWithX, gapWithY) <= m\n\n  def _checkMultipleGaps(self, a: int, b: int, m: int, x: int, y: int) -> bool:\n    \"\"\"\n    Returns true if it's possible to have at most `m` as the minimized maximum\n    difference for a sequence with multiple -1s between two numbers.\n    e.g. [a, -1, -1, ..., -1, b] can be filled with x and y.\n    \"\"\"\n    ax = abs(a - x)\n    ay = abs(a - y)\n    bx = abs(b - x)\n    by = abs(b - y)\n    xy = abs(x - y)\n    gapAllX = max(ax, bx)  # [a, x, x, ..., x, b]\n    gapAllY = max(ay, by)  # [a, y, y, ..., y, b]\n    gapXToY = max(ax, xy, by)  # [a, x, ..., y, b]\n    gapYToX = max(ay, xy, bx)  # [a, y, ..., x, b]\n    return min(gapAllX, gapAllY, gapXToY, gapYToX) <= m\n\n  def _checkBoundaryGaps(self, a: int, m: int, x: int, y: int) -> bool:\n    \"\"\"\n    Returns true if it's possible to have at most `m` as the minimized maximum\n    difference for a boundary sequence starting or ending with -1s.\n    e.g. [a, -1, -1, ...] or [..., -1, -1, a].\n    \"\"\"\n    gapAllX = abs(a - x)  # [x, x, ..., x, a]\n    gapAllY = abs(a - y)  # [y, y, ..., y, a]\n    return min(gapAllX, gapAllY) <= m\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2857, "slug": "count-pairs-of-points-with-distance-k", "solutions": ["class Solution:\n    def countPairs(self, coordinates: List[List[int]], k: int) -> int:\n        cnt = Counter()\n        ans = 0\n        for x2, y2 in coordinates:\n            for a in range(k + 1):\n                b = k - a\n                x1, y1 = a ^ x2, b ^ y2\n                ans += cnt[(x1, y1)]\n            cnt[(x2, y2)] += 1\n        return ans\n", "class Solution:\n  def countPairs(self, coordinates: list[list[int]], k: int) -> int:\n    ans = 0\n\n    for x in range(k + 1):\n      y = k - x\n      count = collections.Counter()\n      for xi, yi in coordinates:\n        ans += count[(xi ^ x, yi ^ y)]\n        count[(xi, yi)] += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2836, "slug": "maximize-value-of-function-in-a-ball-passing-game", "solutions": ["class Solution:\n    def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:\n        n, m = len(receiver), k.bit_length()\n        f = [[0] * m for _ in range(n)]\n        g = [[0] * m for _ in range(n)]\n        for i, x in enumerate(receiver):\n            f[i][0] = x\n            g[i][0] = i\n        for j in range(1, m):\n            for i in range(n):\n                f[i][j] = f[f[i][j - 1]][j - 1]\n                g[i][j] = g[i][j - 1] + g[f[i][j - 1]][j - 1]\n        ans = 0\n        for i in range(n):\n            p, t = i, 0\n            for j in range(m):\n                if k >> j & 1:\n                    t += g[p][j]\n                    p = f[p][j]\n            ans = max(ans, t + p)\n        return ans\n", "class Solution:\n  def getMaxFunctionValue(self, receiver: list[int], k: int) -> int:\n    n = len(receiver)\n    m = int(math.log2(k)) + 1\n    ans = 0\n    # jump[i][j] := the the node you reach after jumping 2^j steps from i\n    jump = [[0] * m for _ in range(n)]\n    # summ[i][j] := the sum of the first 2^j nodes you reach when jumping from i\n    summ = [[0] * m for _ in range(n)]\n\n    for i in range(n):\n      jump[i][0] = receiver[i]\n      summ[i][0] = receiver[i]\n\n    # Calculate binary lifting.\n    for j in range(1, m):\n      for i in range(n):\n        midNode = jump[i][j - 1]\n        #   the the node you reach after jumping 2^j steps from i\n        # = the node you reach after jumping 2^(j - 1) steps from i\n        # + the node you reach after jumping another 2^(j - 1) steps\n        jump[i][j] = jump[midNode][j - 1]\n        #   the sum of the first 2^j nodes you reach when jumping from i\n        # = the sum of the first 2^(j - 1) nodes you reach when jumping from i\n        # + the sum of another 2^(j - 1) nodes you reach\n        summ[i][j] = summ[i][j - 1] + summ[midNode][j - 1]\n\n    for i in range(n):\n      currSum = i\n      currPos = i\n      for j in range(m):\n        if (k >> j) & 1 == 1:\n          currSum += summ[currPos][j]\n          currPos = jump[currPos][j]\n      ans = max(ans, currSum)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2800, "slug": "shortest-string-that-contains-three-strings", "solutions": ["class Solution:\n    def minimumString(self, a: str, b: str, c: str) -> str:\n        def f(s: str, t: str) -> str:\n            if s in t:\n                return t\n            if t in s:\n                return s\n            m, n = len(s), len(t)\n            for i in range(min(m, n), 0, -1):\n                if s[-i:] == t[:i]:\n                    return s + t[i:]\n            return s + t\n\n        ans = \"\"\n        for a, b, c in permutations((a, b, c)):\n            s = f(f(a, b), c)\n            if ans == \"\" or len(s) < len(ans) or (len(s) == len(ans) and s < ans):\n                ans = s\n        return ans\n", "class Solution:\n  def minimumString(self, a: str, b: str, c: str) -> str:\n    def merge(a: str, b: str) -> str:\n      \"\"\"Merges a and b.\"\"\"\n      if a in b:  # a is a substring of b.\n        return b\n      for i in range(len(a)):\n        aSuffix = a[i:]\n        bPrefix = b[:len(aSuffix)]\n        if aSuffix == bPrefix:\n          return a + b[len(bPrefix):]\n      return a + b\n\n    abc = merge(a, merge(b, c))\n    acb = merge(a, merge(c, b))\n    bac = merge(b, merge(a, c))\n    bca = merge(b, merge(c, a))\n    cab = merge(c, merge(a, b))\n    cba = merge(c, merge(b, a))\n    return self._getMin([abc, acb, bac, bca, cab, cba])\n\n  def _getMin(self, words: list[str]) -> str:\n    \"\"\"Returns the lexicographically smallest string.\"\"\"\n\n    def getMin(a: str, b: str) -> str:\n      \"\"\"Returns the lexicographically smaller string.\"\"\"\n      return a if len(a) < len(b) or (len(a) == len(b) and a < b) else b\n\n    res = words[0]\n    for i in range(1, len(words)):\n      res = getMin(res, words[i])\n    return res\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2847, "slug": "smallest-number-with-given-digit-product", "solutions": ["class Solution:\n    def smallestNumber(self, n: int) -> str:\n        cnt = [0] * 10\n        for i in range(9, 1, -1):\n            while n % i == 0:\n                n //= i\n                cnt[i] += 1\n        if n > 1:\n            return \"-1\"\n        ans = \"\".join(str(i) * cnt[i] for i in range(2, 10))\n        return ans if ans else \"1\"\n", "class Solution:\n  def smallestNumber(self, n: int) -> str:\n    if n <= 9:\n      return str(n)\n\n    ans = []\n\n    for divisor in range(9, 1, -1):\n      while n % divisor == 0:\n        ans.append(str(divisor))\n        n //= divisor\n\n    return '-1' if n > 1 else ''.join(reversed(ans))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2880, "slug": "select-data", "solutions": ["import pandas as pd\n\n\ndef selectData(students: pd.DataFrame) -> pd.DataFrame:\n    return students[students['student_id'] == 101][['name', 'age']]\n", "import pandas as pd\n\n\ndef selectData(students: pd.DataFrame) -> pd.DataFrame:\n  return students.loc[students['student_id'] == 101, ['name', 'age']]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2823, "slug": "deep-object-filter", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2863, "slug": "maximum-length-of-semi-decreasing-subarrays", "solutions": ["class Solution:\n    def maxSubarrayLength(self, nums: List[int]) -> int:\n        d = defaultdict(list)\n        for i, x in enumerate(nums):\n            d[x].append(i)\n        ans, k = 0, inf\n        for x in sorted(d, reverse=True):\n            ans = max(ans, d[x][-1] - k + 1)\n            k = min(k, d[x][0])\n        return ans\n", "class Solution:\n  def maxSubarrayLength(self, nums: list[int]) -> int:\n    ans = 0\n    stack = []\n\n    for i in range(len(nums) - 1, -1, -1):\n      # If nums[stack[-1]] <= nums[i], stack[-1] is better than i.\n      # So, no need to append it.\n      if not stack or nums[stack[-1]] > nums[i]:\n        stack.append(i)\n\n    for i, num in enumerate(nums):\n      while stack and num > nums[stack[-1]]:\n        ans = max(ans, stack.pop() - i + 1)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2884, "slug": "modify-columns", "solutions": ["import pandas as pd\n\n\ndef modifySalaryColumn(employees: pd.DataFrame) -> pd.DataFrame:\n    employees['salary'] *= 2\n    return employees\n", "import pandas as pd\n\n\ndef modifySalaryColumn(employees: pd.DataFrame) -> pd.DataFrame:\n  employees['salary'] = employees['salary'] * 2\n  return employees\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2853, "slug": "highest-salaries-difference", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2815, "slug": "max-pair-sum-in-an-array", "solutions": ["class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        ans = -1\n        for i, x in enumerate(nums):\n            for y in nums[i + 1 :]:\n                v = x + y\n                if ans < v and max(str(x)) == max(str(y)):\n                    ans = v\n        return ans\n", "class Solution:\n  def maxSum(self, nums: list[int]) -> int:\n    ans = 0\n    # maxNum[i] := the maximum num we met so far with the maximum digit i\n    maxNum = [0] * 10\n\n    def getMaxDigit(num: int) -> int:\n      maxDigit = 0\n      while num > 0:\n        maxDigit = max(maxDigit, num % 10)\n        num //= 10\n      return maxDigit\n\n    for num in nums:\n      d = getMaxDigit(num)\n      if maxNum[d] > 0:\n        ans = max(ans, num + maxNum[d])\n      maxNum[d] = max(maxNum[d], num)\n\n    return -1 if ans == 0 else ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2875, "slug": "minimum-size-subarray-in-infinite-array", "solutions": ["class Solution:\n    def minSizeSubarray(self, nums: List[int], target: int) -> int:\n        s = sum(nums)\n        n = len(nums)\n        a = 0\n        if target > s:\n            a = n * (target // s)\n            target -= target // s * s\n        if target == s:\n            return n\n        pos = {0: -1}\n        pre = 0\n        b = inf\n        for i, x in enumerate(nums):\n            pre += x\n            if (t := pre - target) in pos:\n                b = min(b, i - pos[t])\n            if (t := pre - (s - target)) in pos:\n                b = min(b, n - (i - pos[t]))\n            pos[pre] = i\n        return -1 if b == inf else a + b\n", "class Solution:\n  def minSizeSubarray(self, nums: list[int], target: int) -> int:\n    summ = sum(nums)\n    n = len(nums)\n    remainingTarget = target % summ\n    repeatLength = (target // summ) * n\n    if remainingTarget == 0:\n      return repeatLength\n\n    suffixPlusPrefixLength = n\n    prefix = 0\n    prefixToIndex = {0: -1}\n\n    for i in range(2 * n):\n      prefix += nums[i % n]\n      if prefix - remainingTarget in prefixToIndex:\n        suffixPlusPrefixLength = min(\n            suffixPlusPrefixLength,\n            i - prefixToIndex[prefix - remainingTarget])\n      prefixToIndex[prefix] = i\n\n    return -1 if suffixPlusPrefixLength == n else suffixPlusPrefixLength + repeatLength\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2801, "slug": "count-stepping-numbers-in-range", "solutions": ["class Solution:\n    def countSteppingNumbers(self, low: str, high: str) -> int:\n        @cache\n        def dfs(pos: int, pre: int, lead: bool, limit: bool) -> int:\n            if pos >= len(num):\n                return int(not lead)\n            up = int(num[pos]) if limit else 9\n            ans = 0\n            for i in range(up + 1):\n                if i == 0 and lead:\n                    ans += dfs(pos + 1, pre, True, limit and i == up)\n                elif pre == -1 or abs(i - pre) == 1:\n                    ans += dfs(pos + 1, i, False, limit and i == up)\n            return ans % mod\n\n        mod = 10**9 + 7\n        num = high\n        a = dfs(0, -1, True, True)\n        dfs.cache_clear()\n        num = str(int(low) - 1)\n        b = dfs(0, -1, True, True)\n        return (a - b) % mod\n", "class Solution:\n  def countSteppingNumbers(self, low: str, high: str) -> int:\n    MOD = 1_000_000_007\n    low = '0' * (len(high) - len(low)) + low\n\n    @functools.lru_cache(None)\n    def dp(\n        i: int,\n        prevDigit: int,\n        isLeadingZero: bool,\n        isTight1: bool,\n        isTight2: bool,\n    ) -> int:\n      \"\"\"\n      Returns the number of valid integers, considering the i-th digit, where\n      `prevDigit` is the previous digit, `isTight1` indicates if the current\n      digit is tightly bound for `low`, and `isTight2` indicates if the current\n      digit is tightly bound for `high`.\n      \"\"\"\n      if i == len(high):\n        return 1\n\n      res = 0\n      minDigit = int(low[i]) if isTight1 else 0\n      maxDigit = int(high[i]) if isTight2 else 9\n\n      for d in range(minDigit, maxDigit + 1):\n        nextIsTight1 = isTight1 and (d == minDigit)\n        nextIsTight2 = isTight2 and (d == maxDigit)\n        if isLeadingZero:\n          # Can place any digit in [minDigit, maxDigit].\n          res += dp(i + 1, d, isLeadingZero and d ==\n                    0, nextIsTight1, nextIsTight2)\n        elif abs(d - prevDigit) == 1:\n          res += dp(i + 1, d, False, nextIsTight1, nextIsTight2)\n        res %= MOD\n\n      return res\n\n    return dp(0, -1, True, True, True)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2837, "slug": "total-traveled-distance", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2855, "slug": "minimum-right-shifts-to-sort-the-array", "solutions": ["class Solution:\n    def minimumRightShifts(self, nums: List[int]) -> int:\n        n = len(nums)\n        i = 1\n        while i < n and nums[i - 1] < nums[i]:\n            i += 1\n        k = i + 1\n        while k < n and nums[k - 1] < nums[k] < nums[0]:\n            k += 1\n        return -1 if k < n else n - i\n", "class Solution:\n  def minimumRightShifts(self, nums: list[int]) -> int:\n    count = 0\n\n    for i, (a, b) in enumerate(itertools.pairwise(nums)):\n      if a > b:\n        count += 1\n        pivot = i\n\n    if count == 0:\n      return 0\n    if count > 1 or nums[-1] > nums[0]:\n      return -1\n    return len(nums) - pivot - 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2879, "slug": "display-the-first-three-rows", "solutions": ["import pandas as pd\n\n\ndef selectFirstRows(employees: pd.DataFrame) -> pd.DataFrame:\n    return employees.head(3)\n", "import pandas as pd\n\n\ndef selectFirstRows(employees: pd.DataFrame) -> pd.DataFrame:\n  return employees.head(3)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2895, "slug": "minimum-processing-time", "solutions": ["class Solution:\n    def minProcessingTime(self, processorTime: List[int], tasks: List[int]) -> int:\n        processorTime.sort()\n        tasks.sort()\n        ans = 0\n        i = len(tasks) - 1\n        for t in processorTime:\n            ans = max(ans, t + tasks[i])\n            i -= 4\n        return ans\n", "class Solution:\n  def minProcessingTime(\n      self,\n      processorTime: list[int],\n      tasks: list[int],\n  ) -> int:\n    return max(time + task\n               for (time, task) in zip(\n                   sorted(processorTime),\n                   sorted(tasks)[:: -4]))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2889, "slug": "reshape-data-pivot", "solutions": ["import pandas as pd\n\n\ndef pivotTable(weather: pd.DataFrame) -> pd.DataFrame:\n    return weather.pivot(index='month', columns='city', values='temperature')\n", "import pandas as pd\n\n\ndef pivotTable(weather: pd.DataFrame) -> pd.DataFrame:\n  return weather.pivot_table(\n      index='month',\n      columns='city',\n      values='temperature',\n      aggfunc='max',\n  )\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2898, "slug": "maximum-linear-stock-score", "solutions": ["class Solution:\n    def maxScore(self, prices: List[int]) -> int:\n        cnt = Counter()\n        for i, x in enumerate(prices):\n            cnt[x - i] += x\n        return max(cnt.values())\n", "class Solution:\n  def maxScore(self, prices: list[int]) -> int:\n    groupIdToSum = collections.defaultdict(int)\n\n    for i, price in enumerate(prices):\n      groupIdToSum[price - i] += price\n\n    return max(groupIdToSum.values())\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2878, "slug": "get-the-size-of-a-dataframe", "solutions": ["import pandas as pd\n\n\ndef getDataframeSize(players: pd.DataFrame) -> List[int]:\n    return list(players.shape)\n", "import pandas as pd\n\n\ndef getDataframeSize(players: pd.DataFrame) -> list[int]:\n  return [*players.shape]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2877, "slug": "create-a-dataframe-from-list", "solutions": ["import pandas as pd\n\n\ndef createDataframe(student_data: List[List[int]]) -> pd.DataFrame:\n    return pd.DataFrame(student_data, columns=['student_id', 'age'])\n", "import pandas as pd\n\n\ndef createDataframe(student_data: list[list[int]]) -> pd.DataFrame:\n  return pd.DataFrame(student_data, columns=['student_id', 'age'])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2833, "slug": "furthest-point-from-origin", "solutions": ["class Solution:\n    def furthestDistanceFromOrigin(self, moves: str) -> int:\n        return abs(moves.count(\"L\") - moves.count(\"R\")) + moves.count(\"_\")\n", "class Solution:\n  def furthestDistanceFromOrigin(self, moves: str) -> int:\n    return abs(moves.count('L') - moves.count('R')) + moves.count('_')\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2813, "slug": "maximum-elegance-of-a-k-length-subsequence", "solutions": ["class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        items.sort(key=lambda x: -x[0])\n        tot = 0\n        vis = set()\n        dup = []\n        for p, c in items[:k]:\n            tot += p\n            if c not in vis:\n                vis.add(c)\n            else:\n                dup.append(p)\n        ans = tot + len(vis) ** 2\n        for p, c in items[k:]:\n            if c in vis or not dup:\n                continue\n            vis.add(c)\n            tot += p - dup.pop()\n            ans = max(ans, tot + len(vis) ** 2)\n        return ans\n", "class Solution:\n  def findMaximumElegance(self, items: list[list[int]], k: int) -> int:\n    ans = 0\n    totalProfit = 0\n    seenCategories = set()\n    decreasingDuplicateProfits = []\n\n    items.sort(reverse=True)\n\n    for i in range(k):\n      profit, category = items[i]\n      totalProfit += profit\n      if category in seenCategories:\n        decreasingDuplicateProfits.append(profit)\n      else:\n        seenCategories.add(category)\n\n    ans = totalProfit + len(seenCategories)**2\n\n    for i in range(k, len(items)):\n      profit, category = items[i]\n      if category not in seenCategories and decreasingDuplicateProfits:\n        # If this is a new category we haven't seen before, it's worth\n        # considering taking it and replacing the one with the least profit\n        # since it will increase the distinct_categories and potentially result\n        # in a larger total_profit + distinct_categories^2.\n        totalProfit -= decreasingDuplicateProfits.pop()\n        totalProfit += profit\n        seenCategories.add(category)\n        ans = max(ans, totalProfit + len(seenCategories)**2)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2816, "slug": "double-a-number-represented-as-a-linked-list", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        def reverse(head):\n            dummy = ListNode()\n            cur = head\n            while cur:\n                next = cur.next\n                cur.next = dummy.next\n                dummy.next = cur\n                cur = next\n            return dummy.next\n\n        head = reverse(head)\n        dummy = cur = ListNode()\n        mul, carry = 2, 0\n        while head:\n            x = head.val * mul + carry\n            carry = x // 10\n            cur.next = ListNode(x % 10)\n            cur = cur.next\n            head = head.next\n        if carry:\n            cur.next = ListNode(carry)\n        return reverse(dummy.next)\n", "class Solution:\n  def doubleIt(self, head: ListNode | None) -> ListNode | None:\n    if head.val >= 5:\n      head = ListNode(0, head)\n\n    curr = head\n\n    while curr:\n      curr.val *= 2\n      curr.val %= 10\n      if curr.next and curr.next.val >= 5:\n        curr.val += 1\n      curr = curr.next\n\n    return head\n", "class Solution:\n  def doubleIt(self, head: ListNode | None) -> ListNode | None:\n    def getCarry(node: ListNode | None) -> ListNode | None:\n      val = node.val * 2\n      if node.next:\n        val += getCarry(node.next)\n      node.val = val % 10\n      return val // 10\n\n    if getCarry(head) == 1:\n      return ListNode(1, head)\n    return head\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2862, "slug": "maximum-element-sum-of-a-complete-subset-of-indices", "solutions": ["class Solution:\n    def maximumSum(self, nums: List[int]) -> int:\n        n = len(nums)\n        ans = 0\n        for k in range(1, n + 1):\n            t = 0\n            j = 1\n            while k * j * j <= n:\n                t += nums[k * j * j - 1]\n                j += 1\n            ans = max(ans, t)\n        return ans\n", "class Solution:\n  def maximumSum(self, nums: list[int]) -> int:\n    ans = 0\n\n    for oddPower in range(1, len(nums) + 1):\n      summ = 0\n      for num in range(1, len(nums) + 1):\n        if num * num * oddPower > len(nums):\n          break\n        summ += nums[oddPower * num * num - 1]\n      ans = max(ans, summ)\n\n    return ans\n", "class Solution:\n  def maximumSum(self, nums: list[int]) -> int:\n    ans = 0\n    oddPowerToSum = collections.Counter()\n\n    def divideSquares(val: int) -> int:\n      for num in range(2, val + 1):\n        while val % (num * num) == 0:\n          val //= (num * num)\n      return val\n\n    for i, num in enumerate(nums):\n      oddPower = divideSquares(i + 1)\n      oddPowerToSum[oddPower] += num\n      ans = max(ans, oddPowerToSum[oddPower])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2868, "slug": "the-wording-game", "solutions": ["class Solution:\n    def canAliceWin(self, a: List[str], b: List[str]) -> bool:\n        i, j, k = 1, 0, 1\n        w = a[0]\n        while 1:\n            if k:\n                if j == len(b):\n                    return True\n                if (b[j][0] == w[0] and b[j] > w) or ord(b[j][0]) - ord(w[0]) == 1:\n                    w = b[j]\n                    k ^= 1\n                j += 1\n            else:\n                if i == len(a):\n                    return False\n                if (a[i][0] == w[0] and a[i] > w) or ord(a[i][0]) - ord(w[0]) == 1:\n                    w = a[i]\n                    k ^= 1\n                i += 1\n", "class Solution:\n  def canAliceWin(self, a: list[str], b: list[str]) -> bool:\n    # words[0][i] := the biggest word starting with ('a' + i) for Alice\n    # words[1][i] := the biggest word starting with ('a' + i) for Bob\n    words = [[''] * 26 for _ in range(2)]\n\n    # For each letter, only the biggest word is useful.\n    for word in a:\n      words[0][ord(word[0]) - ord('a')] = word\n\n    for word in b:\n      words[1][ord(word[0]) - ord('a')] = word\n\n    # Find Alice's smallest word.\n    i = 0\n    while not words[0][i]:\n      i += 1\n\n    # 0 := Alice, 1 := Bob\n    # Start with Alice, so it's Bob's turn now.\n    turn = 1\n\n    # Iterate through each letter until we find a winner.\n    while True:\n      # If the current player has a word that having the letter that is greater\n      # than the opponent's word, choose it.\n      if words[turn][i] and words[turn][i] > words[1 - turn][i]:\n        # Choose the current words[turn][i].\n        pass\n      elif words[turn][i + 1]:\n        # Choose the next words[turn][i + 1].\n        i += 1\n      else:\n        # Game over. If it's Bob's turn, Alice wins, and vice versa.\n        return turn == 1\n      turn = 1 - turn\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2845, "slug": "count-of-interesting-subarrays", "solutions": ["class Solution:\n    def countInterestingSubarrays(self, nums: List[int], modulo: int, k: int) -> int:\n        arr = [int(x % modulo == k) for x in nums]\n        cnt = Counter()\n        cnt[0] = 1\n        ans = s = 0\n        for x in arr:\n            s += x\n            ans += cnt[(s - k) % modulo]\n            cnt[s % modulo] += 1\n        return ans\n", "class Solution:\n  def countInterestingSubarrays(\n      self,\n      nums: list[int],\n      modulo: int,\n      k: int,\n  ) -> int:\n    ans = 0\n    prefix = 0  # (number of nums[i] % modulo == k so far) % modulo\n    prefixCount = collections.Counter({0: 1})\n\n    for num in nums:\n      if num % modulo == k:\n        prefix = (prefix + 1) % modulo\n      ans += prefixCount[(prefix - k + modulo) % modulo]\n      prefixCount[prefix] += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2803, "slug": "factorial-generator", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2872, "slug": "maximum-number-of-k-divisible-components", "solutions": ["class Solution:\n    def maxKDivisibleComponents(\n        self, n: int, edges: List[List[int]], values: List[int], k: int\n    ) -> int:\n        def dfs(i: int, fa: int) -> int:\n            s = values[i]\n            for j in g[i]:\n                if j != fa:\n                    s += dfs(j, i)\n            nonlocal ans\n            ans += s % k == 0\n            return s\n\n        g = [[] for _ in range(n)]\n        for a, b in edges:\n            g[a].append(b)\n            g[b].append(a)\n        ans = 0\n        dfs(0, -1)\n        return ans\n", "class Solution:\n  def maxKDivisibleComponents(\n      self,\n      n: int,\n      edges: list[list[int]],\n      values: list[int],\n      k: int,\n  ) -> int:\n    ans = 0\n    graph = [[] for _ in range(n)]\n\n    def dfs(u: int, prev: int) -> int:\n      nonlocal ans\n      treeSum = values[u]\n\n      for v in graph[u]:\n        if v != prev:\n          treeSum += dfs(v, u)\n\n      if treeSum % k == 0:\n        ans += 1\n      return treeSum\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    dfs(0, -1)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2890, "slug": "reshape-data-melt", "solutions": ["import pandas as pd\n\n\ndef meltTable(report: pd.DataFrame) -> pd.DataFrame:\n    return pd.melt(report, id_vars=['product'], var_name='quarter', value_name='sales')\n", "import pandas as pd\n\n\ndef meltTable(report: pd.DataFrame) -> pd.DataFrame:\n  return pd.melt(\n      report,\n      id_vars=['product'],\n      var_name='quarter',\n      value_name='sales',\n  )\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2888, "slug": "reshape-data-concatenate", "solutions": ["import pandas as pd\n\n\ndef concatenateTables(df1: pd.DataFrame, df2: pd.DataFrame) -> pd.DataFrame:\n    return pd.concat([df1, df2], ignore_index=True)\n", "import pandas as pd\n\n\ndef concatenateTables(df1: pd.DataFrame, df2: pd.DataFrame) -> pd.DataFrame:\n  return pd.concat([df1, df2], axis=0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2842, "slug": "count-k-subsequences-of-a-string-with-maximum-beauty", "solutions": ["class Solution:\n    def countKSubsequencesWithMaxBeauty(self, s: str, k: int) -> int:\n        f = Counter(s)\n        if len(f) < k:\n            return 0\n        mod = 10**9 + 7\n        vs = sorted(f.values(), reverse=True)\n        val = vs[k - 1]\n        x = vs.count(val)\n        ans = 1\n        for v in vs:\n            if v == val:\n                break\n            k -= 1\n            ans = ans * v % mod\n        ans = ans * comb(x, k) * pow(val, k, mod) % mod\n        return ans\n", "class Solution:\n  def countKSubsequencesWithMaxBeauty(self, s: str, k: int) -> int:\n    MOD = 1_000_000_007\n    count = collections.Counter(s)\n    if len(count) < k:\n      return 0\n\n    ans = 1\n    # freqCount := (f(c), # of chars with f(c))\n    freqCount = collections.Counter(count.values())\n\n    for fc, numOfChars in list(sorted(freqCount.items(), reverse=True)):\n      if numOfChars >= k:\n        ans *= math.comb(numOfChars, k) * pow(fc, k, MOD)\n        return ans % MOD\n      ans *= pow(fc, numOfChars, MOD)\n      ans %= MOD\n      k -= numOfChars\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2810, "slug": "faulty-keyboard", "solutions": ["class Solution:\n    def finalString(self, s: str) -> str:\n        t = []\n        for c in s:\n            if c == \"i\":\n                t = t[::-1]\n            else:\n                t.append(c)\n        return \"\".join(t)\n", "class Solution:\n  def finalString(self, s: str) -> str:\n    dq = collections.deque()\n    inversed = False\n\n    for c in s:\n      if c == 'i':\n        inversed = not inversed\n      elif inversed:\n        dq.appendleft(c)\n      else:\n        dq.append(c)\n\n    return ''.join(reversed(dq)) if inversed else ''.join(dq)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2871, "slug": "split-array-into-maximum-number-of-subarrays", "solutions": ["class Solution:\n    def maxSubarrays(self, nums: List[int]) -> int:\n        score, ans = -1, 1\n        for num in nums:\n            score &= num\n            if score == 0:\n                score = -1\n                ans += 1\n        return 1 if ans == 1 else ans - 1\n", "class Solution:\n  def maxSubarrays(self, nums: list[int]) -> int:\n    ans = 0\n    score = 0\n\n    for num in nums:\n      score = num if score == 0 else score & num\n      if score == 0:\n        ans += 1\n\n    return max(1, ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2846, "slug": "minimum-edge-weight-equilibrium-queries-in-a-tree", "solutions": ["class Solution:\n    def minOperationsQueries(\n        self, n: int, edges: List[List[int]], queries: List[List[int]]\n    ) -> List[int]:\n        m = n.bit_length()\n        g = [[] for _ in range(n)]\n        f = [[0] * m for _ in range(n)]\n        p = [0] * n\n        cnt = [None] * n\n        depth = [0] * n\n        for u, v, w in edges:\n            g[u].append((v, w - 1))\n            g[v].append((u, w - 1))\n        cnt[0] = [0] * 26\n        q = deque([0])\n        while q:\n            i = q.popleft()\n            f[i][0] = p[i]\n            for j in range(1, m):\n                f[i][j] = f[f[i][j - 1]][j - 1]\n            for j, w in g[i]:\n                if j != p[i]:\n                    p[j] = i\n                    cnt[j] = cnt[i][:]\n                    cnt[j][w] += 1\n                    depth[j] = depth[i] + 1\n                    q.append(j)\n        ans = []\n        for u, v in queries:\n            x, y = u, v\n            if depth[x] < depth[y]:\n                x, y = y, x\n            for j in reversed(range(m)):\n                if depth[x] - depth[y] >= (1 << j):\n                    x = f[x][j]\n            for j in reversed(range(m)):\n                if f[x][j] != f[y][j]:\n                    x, y = f[x][j], f[y][j]\n            if x != y:\n                x = p[x]\n            mx = max(cnt[u][j] + cnt[v][j] - 2 * cnt[x][j] for j in range(26))\n            ans.append(depth[u] + depth[v] - 2 * depth[x] - mx)\n        return ans\n", "class Solution:\n  def minOperationsQueries(\n      self,\n      n: int,\n      edges: list[list[int]],\n      queries: list[list[int]],\n  ) -> list[int]:\n    MAX = 26\n    m = int(math.log2(n)) + 1\n    ans = []\n    graph = [[] for _ in range(n)]\n    # jump[i][j] := the node you reach after jumping 2^j from i\n    jump = [[0] * m for _ in range(n)]\n    # count[i][j] := the count of j from root to i, where 1 <= j <= 26\n    count = [[] for _ in range(n)]\n    # depth[i] := the depth of i\n    depth = [0] * n\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    def dfs(u: int, prev: int, d: int):\n      if prev != -1:\n        jump[u][0] = prev\n      depth[u] = d\n      for v, w in graph[u]:\n        if v == prev:\n          continue\n        # Inherit the count from the parent.\n        count[v] = count[u][:]\n        # Add one to this edge.\n        count[v][w] += 1\n        dfs(v, u, d + 1)\n\n    count[0] = [0] * (MAX + 1)\n    dfs(0, -1, 0)\n\n    # Calculate binary lifting.\n    for j in range(1, m):\n      for i in range(n):\n        jump[i][j] = jump[jump[i][j - 1]][j - 1]\n\n    def getLCA(u: int, v: int) -> int:\n      \"\"\"Returns the lca(u, v) via Calculate binary lifting.\"\"\"\n      # v is always deeper than u.\n      if depth[u] > depth[v]:\n        return getLCA(v, u)\n      # Jump v to the same height of u.\n      for j in range(m):\n        if depth[v] - depth[u] >> j & 1:\n          v = jump[v][j]\n      if u == v:\n        return u\n      # Jump u and v to the node right below the lca.\n      for j in range(m - 1, -1, -1):\n        if jump[u][j] != jump[v][j]:\n          u = jump[u][j]\n          v = jump[v][j]\n      return jump[v][0]\n\n    for u, v in queries:\n      lca = getLCA(u, v)\n      # the number of edges between (u, v).\n      numEdges = depth[u] + depth[v] - 2 * depth[lca]\n      # the maximum frequency of edges between (u, v)\n      maxFreq = max(count[u][j] + count[v][j] - 2 * count[lca][j]\n                    for j in range(1, MAX + 1))\n      ans.append(numEdges - maxFreq)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2881, "slug": "create-a-new-column", "solutions": ["import pandas as pd\n\n\ndef createBonusColumn(employees: pd.DataFrame) -> pd.DataFrame:\n    employees['bonus'] = employees['salary'] * 2\n    return employees\n", "import pandas as pd\n\n\ndef createBonusColumn(employees: pd.DataFrame) -> pd.DataFrame:\n  employees['bonus'] = employees['salary'] * 2\n  return employees\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2825, "slug": "make-string-a-subsequence-using-cyclic-increments", "solutions": ["class Solution:\n    def canMakeSubsequence(self, str1: str, str2: str) -> bool:\n        i = 0\n        for c in str1:\n            d = \"a\" if c == \"z\" else chr(ord(c) + 1)\n            if i < len(str2) and str2[i] in (c, d):\n                i += 1\n        return i == len(str2)\n", "class Solution:\n  def canMakeSubsequence(self, str1: str, str2: str) -> bool:\n    i = 0  # str2's index\n\n    for c in str1:\n      if c == str2[i] or chr(\n              ord('a') + (ord(c) - ord('a') + 1) % 26) == str2[i]:\n        i += 1\n        if i == len(str2):\n          return True\n\n    return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2812, "slug": "find-the-safest-path-in-a-grid", "solutions": ["class UnionFind:\n    def __init__(self, n):\n        self.p = list(range(n))\n        self.size = [1] * n\n\n    def find(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n\n    def union(self, a, b):\n        pa, pb = self.find(a), self.find(b)\n        if pa == pb:\n            return False\n        if self.size[pa] > self.size[pb]:\n            self.p[pb] = pa\n            self.size[pa] += self.size[pb]\n        else:\n            self.p[pa] = pb\n            self.size[pb] += self.size[pa]\n        return True\n\n\nclass Solution:\n    def maximumSafenessFactor(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        if grid[0][0] or grid[n - 1][n - 1]:\n            return 0\n        q = deque()\n        dist = [[inf] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if grid[i][j]:\n                    q.append((i, j))\n                    dist[i][j] = 0\n        dirs = (-1, 0, 1, 0, -1)\n        while q:\n            i, j = q.popleft()\n            for a, b in pairwise(dirs):\n                x, y = i + a, j + b\n                if 0 <= x < n and 0 <= y < n and dist[x][y] == inf:\n                    dist[x][y] = dist[i][j] + 1\n                    q.append((x, y))\n\n        q = ((dist[i][j], i, j) for i in range(n) for j in range(n))\n        q = sorted(q, reverse=True)\n        uf = UnionFind(n * n)\n        for d, i, j in q:\n            for a, b in pairwise(dirs):\n                x, y = i + a, j + b\n                if 0 <= x < n and 0 <= y < n and dist[x][y] >= d:\n                    uf.union(i * n + j, x * n + y)\n            if uf.find(0) == uf.find(n * n - 1):\n                return int(d)\n        return 0\n", "class Solution:\n  def maximumSafenessFactor(self, grid: list[list[int]]) -> int:\n    self.DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    n = len(grid)\n    distToThief = self._getDistToThief(grid)\n\n    def hasValidPath(safeness: int) -> bool:\n      if distToThief[0][0] < safeness:\n        return False\n\n      q = collections.deque([(0, 0)])\n      seen = {(0, 0)}\n\n      while q:\n        i, j = q.popleft()\n        if distToThief[i][j] < safeness:\n          continue\n        if i == n - 1 and j == n - 1:\n          return True\n        for dx, dy in self.DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == n or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n\n      return False\n\n    return bisect.bisect_left(range(n * 2), True,\n                              key=lambda m: not hasValidPath(m)) - 1\n\n  def _getDistToThief(self, grid: list[list[int]]) -> list[list[int]]:\n    n = len(grid)\n    distToThief = [[0] * n for _ in range(n)]\n    q = collections.deque()\n    seen = set()\n\n    for i in range(n):\n      for j in range(n):\n        if grid[i][j] == 1:\n          q.append((i, j))\n          seen.add((i, j))\n\n    dist = 0\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        distToThief[i][j] = dist\n        for dx, dy in self.DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == n or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n      dist += 1\n\n    return distToThief\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2829, "slug": "determine-the-minimum-sum-of-a-k-avoiding-array", "solutions": ["class Solution:\n    def minimumSum(self, n: int, k: int) -> int:\n        s, i = 0, 1\n        vis = set()\n        for _ in range(n):\n            while i in vis:\n                i += 1\n            vis.add(k - i)\n            s += i\n            i += 1\n        return s\n", "class Solution:\n  def minimumSum(self, n: int, k: int) -> int:\n    # These are the unique pairs that sum up to k:\n    # (1, k - 1), (2, k - 2), ..., (ceil(k // 2), floor(k // 2)).\n    # Our optimal strategy is to select 1, 2, ..., floor(k // 2), and then\n    # choose k, k + 1, ... if necessary, as selecting any number in the range\n    # [ceil(k // 2), k - 1] will result in a pair summing up to k.\n\n    def trapezoid(a: int, b: int) -> int:\n      \"\"\"Returns sum(a..b).\"\"\"\n      return (a + b) * (b - a + 1) // 2\n\n    mid = k // 2  # floor(k // 2)\n    if n <= mid:\n      return trapezoid(1, n)\n    return trapezoid(1, mid) + trapezoid(k, k + (n - mid - 1))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2887, "slug": "fill-missing-data", "solutions": ["import pandas as pd\n\n\ndef fillMissingValues(products: pd.DataFrame) -> pd.DataFrame:\n    products['quantity'] = products['quantity'].fillna(0)\n    return products\n", "import pandas as pd\n\n\ndef fillMissingValues(products: pd.DataFrame) -> pd.DataFrame:\n  products['quantity'].fillna(0, inplace=True)\n  return products\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2893, "slug": "calculate-orders-within-each-interval", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2806, "slug": "account-balance-after-rounded-purchase", "solutions": ["class Solution:\n    def accountBalanceAfterPurchase(self, purchaseAmount: int) -> int:\n        diff, x = 100, 0\n        for y in range(100, -1, -10):\n            if (t := abs(y - purchaseAmount)) < diff:\n                diff = t\n                x = y\n        return 100 - x\n", "class Solution:\n  def accountBalanceAfterPurchase(self, purchaseAmount: int) -> int:\n    return 100 - ((purchaseAmount + 5) // 10) * 10\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2844, "slug": "minimum-operations-to-make-a-special-number", "solutions": ["class Solution:\n    def minimumOperations(self, num: str) -> int:\n        @cache\n        def dfs(i: int, k: int) -> int:\n            if i == n:\n                return 0 if k == 0 else n\n            ans = dfs(i + 1, k) + 1\n            ans = min(ans, dfs(i + 1, (k * 10 + int(num[i])) % 25))\n            return ans\n\n        n = len(num)\n        return dfs(0, 0)\n", "class Solution:\n  def minimumOperations(self, num: str) -> int:\n    n = len(num)\n    seenFive = False\n    seenZero = False\n\n    for i in range(n - 1, -1, -1):\n      if seenZero and num[i] == '0':  # '00'\n        return n - i - 2\n      if seenZero and num[i] == '5':  # '50'\n        return n - i - 2\n      if seenFive and num[i] == '2':  # '25'\n        return n - i - 2\n      if seenFive and num[i] == '7':  # '75'\n        return n - i - 2\n      seenZero = seenZero or num[i] == '0'\n      seenFive = seenFive or num[i] == '5'\n\n    return n - 1 if seenZero else n\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2859, "slug": "sum-of-values-at-indices-with-k-set-bits", "solutions": ["class Solution:\n    def sumIndicesWithKSetBits(self, nums: List[int], k: int) -> int:\n        return sum(x for i, x in enumerate(nums) if i.bit_count() == k)\n", "class Solution:\n  def sumIndicesWithKSetBits(self, nums: list[int], k: int) -> int:\n    return sum(num for i, num in enumerate(nums)\n               if i.bit_count() == k)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2860, "slug": "happy-students", "solutions": ["class Solution:\n    def countWays(self, nums: List[int]) -> int:\n        nums.sort()\n        n = len(nums)\n        ans = 0\n        for i in range(n + 1):\n            if i and nums[i - 1] >= i:\n                continue\n            if i < n and nums[i] <= i:\n                continue\n            ans += 1\n        return ans\n", "class Solution:\n  def countWays(self, nums: list[int]) -> int:\n    return sum(a < i < b\n               for i, (a, b) in  # i := the number of the selected numbers\n               enumerate(itertools.pairwise([-1] + sorted(nums) + [math.inf])))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2886, "slug": "change-data-type", "solutions": ["import pandas as pd\n\n\ndef changeDatatype(students: pd.DataFrame) -> pd.DataFrame:\n    students['grade'] = students['grade'].astype(int)\n    return students\n", "import pandas as pd\n\n\ndef changeDatatype(students: pd.DataFrame) -> pd.DataFrame:\n  return students.astype({'grade': int})\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2819, "slug": "minimum-relative-loss-after-buying-chocolates", "solutions": ["class Solution:\n    def minimumRelativeLosses(\n        self, prices: List[int], queries: List[List[int]]\n    ) -> List[int]:\n        def f(k: int, m: int) -> int:\n            l, r = 0, min(m, bisect_right(prices, k))\n            while l < r:\n                mid = (l + r) >> 1\n                right = m - mid\n                if prices[mid] < 2 * k - prices[n - right]:\n                    l = mid + 1\n                else:\n                    r = mid\n            return l\n\n        prices.sort()\n        s = list(accumulate(prices, initial=0))\n        ans = []\n        n = len(prices)\n        for k, m in queries:\n            l = f(k, m)\n            r = m - l\n            loss = s[l] + 2 * k * r - (s[n] - s[n - r])\n            ans.append(loss)\n        return ans\n", "class Solution:\n  def minimumRelativeLosses(\n      self,\n      prices: list[int],\n      queries: list[list[int]],\n  ) -> list[int]:\n    ans = []\n\n    prices.sort()\n\n    prefix = list(itertools.accumulate(prices, initial=0))\n\n    for k, m in queries:\n      countFront = self._getCountFront(k, m, prices)\n      countBack = m - countFront\n      ans.append(self._getRelativeLoss(countFront, countBack, k, prefix))\n\n    return ans\n\n  def _getCountFront(\n      self,\n      k: int,\n      m: int,\n      prices: list[int],\n  ) -> int:\n    \"\"\"Returns `countFront` for query (k, m).\n\n    Returns `countFront` for query (k, m) s.t. picking the first `countFront`\n    and the last `m - countFront` chocolates is optimal.\n\n    Define loss[i] := the relative loss of picking `prices[i]`.\n    1. For prices[i] <= k, Bob pays prices[i] while Alice pays 0.\n       Thus, loss[i] = prices[i] - 0 = prices[i].\n    2. For prices[i] > k, Bob pays k while Alice pays prices[i] - k.\n       Thus, loss[i] = k - (prices[i] - k) = 2 * k - prices[i].\n    By observation, we deduce that it is always better to pick from the front\n    or the back since loss[i] is increasing for 1. and is decreasing for 2.\n\n    Assume that picking `left` chocolates from the left and `right = m - left`\n    chocolates from the right is optimal. Therefore, we are selecting\n    chocolates from `prices[0..left - 1]` and `prices[n - right..n - 1]`.\n\n    To determine the optimal `left` in each iteration, we simply compare\n    `loss[left]` with `loss[n - right]` if `loss[left] < loss[n - right]`,\n    it's worth increasing `left`.\n    \"\"\"\n    n = len(prices)\n    countNoGreaterThanK = bisect.bisect_right(prices, k)\n    l = 0\n    r = min(countNoGreaterThanK, m)\n\n    while l < r:\n      mid = (l + r) // 2\n      right = m - mid\n      # Picking prices[mid] is better than picking prices[n - right].\n      if prices[mid] < 2 * k - prices[n - right]:\n        l = mid + 1\n      else:\n        r = mid\n\n    return l\n\n  def _getRelativeLoss(\n      self,\n      countFront: int,\n      countBack: int,\n      k: int,\n      prefix: list[int],\n  ) -> int:\n    \"\"\"\n    Returns the relative loss of picking `countFront` and `countBack` \n    chocolates.\n    \"\"\"\n    lossFront = prefix[countFront]\n    lossBack = 2 * k * countBack - (prefix[-1] - prefix[-countBack - 1])\n    return lossFront + lossBack\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2822, "slug": "inversion-of-object", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2882, "slug": "drop-duplicate-rows", "solutions": ["import pandas as pd\n\n\ndef dropDuplicateEmails(customers: pd.DataFrame) -> pd.DataFrame:\n    return customers.drop_duplicates(subset=['email'])\n", "import pandas as pd\n\n\ndef dropDuplicateEmails(customers: pd.DataFrame) -> pd.DataFrame:\n  customers.drop_duplicates(subset='email', keep='first', inplace=True)\n  return customers\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2834, "slug": "find-the-minimum-possible-sum-of-a-beautiful-array", "solutions": ["class Solution:\n    def minimumPossibleSum(self, n: int, target: int) -> int:\n        mod = 10**9 + 7\n        m = target // 2\n        if n <= m:\n            return ((1 + n) * n // 2) % mod\n        return ((1 + m) * m // 2 + (target + target + n - m - 1) * (n - m) // 2) % mod\n", "class Solution:\n  # Same as 2829. Determine the Minimum Sum of a k-avoiding Array\n  def minimumPossibleSum(self, n: int, target: int) -> int:\n    # These are the unique pairs that sum up to k (target):\n    # (1, k - 1), (2, k - 2), ..., (ceil(k // 2), floor(k // 2)).\n    # Our optimal strategy is to select 1, 2, ..., floor(k // 2), and then\n    # choose k, k + 1, ... if necessary, as selecting any number in the range\n    # [ceil(k // 2), k - 1] will result in a pair summing up to k.\n    MOD = 1_000_000_007\n\n    def trapezoid(a: int, b: int) -> int:\n      \"\"\"Returns sum(a..b).\"\"\"\n      return (a + b) * (b - a + 1) // 2\n\n    mid = target // 2  # floor(k // 2)\n    if n <= mid:\n      return trapezoid(1, n)\n    return (trapezoid(1, mid) + trapezoid(target, target + (n - mid - 1))) % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2852, "slug": "sum-of-remoteness-of-all-cells", "solutions": ["class Solution:\n    def sumRemoteness(self, grid: List[List[int]]) -> int:\n        def dfs(i: int, j: int) -> (int, int):\n            s, t = grid[i][j], 1\n            grid[i][j] = 0\n            for a, b in pairwise(dirs):\n                x, y = i + a, j + b\n                if 0 <= x < n and 0 <= y < n and grid[x][y] > 0:\n                    s1, t1 = dfs(x, y)\n                    s, t = s + s1, t + t1\n            return s, t\n\n        n = len(grid)\n        dirs = (-1, 0, 1, 0, -1)\n        cnt = sum(x > 0 for row in grid for x in row)\n        ans = 0\n        for i, row in enumerate(grid):\n            for j, x in enumerate(row):\n                if x > 0:\n                    s, t = dfs(i, j)\n                    ans += (cnt - t) * s\n        return ans\n", "class Solution:\n  def sumRemoteness(self, grid: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    n = len(grid)\n    summ = sum(max(0, cell) for row in grid for cell in row)\n    ans = 0\n\n    def dfs(i: int, j: int) -> tuple[int, int]:\n      \"\"\"\n      Returns the (count, componentSum) of the connected component that contains\n      (x, y).\n      \"\"\"\n      if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]):\n        return (0, 0)\n      if grid[i][j] == -1:\n        return (0, 0)\n\n      count = 1\n      componentSum = grid[i][j]\n      grid[i][j] = -1  # Mark as visited.\n\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        nextCount, nextComponentSum = dfs(x, y)\n        count += nextCount\n        componentSum += nextComponentSum\n\n      return (count, componentSum)\n\n    for i in range(n):\n      for j in range(n):\n        if grid[i][j] > 0:\n          count, componentSum = dfs(i, j)\n          ans += (summ - componentSum) * count\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2883, "slug": "drop-missing-data", "solutions": ["import pandas as pd\n\n\ndef dropMissingData(students: pd.DataFrame) -> pd.DataFrame:\n    return students[students['name'].notnull()]\n", "import pandas as pd\n\n\ndef dropMissingData(students: pd.DataFrame) -> pd.DataFrame:\n  students.dropna(subset=['name'], inplace=True)\n  return students\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2874, "slug": "maximum-value-of-an-ordered-triplet-ii", "solutions": ["class Solution:\n    def maximumTripletValue(self, nums: List[int]) -> int:\n        ans = mx = mx_diff = 0\n        for x in nums:\n            ans = max(ans, mx_diff * x)\n            mx_diff = max(mx_diff, mx - x)\n            mx = max(mx, x)\n        return ans\n", "class Solution:\n  # Same as 2873. Maximum Value of an Ordered Triplet I\n  def maximumTripletValue(self, nums: list[int]) -> int:\n    ans = 0\n    maxDiff = 0  # max(nums[i] - nums[j])\n    maxNum = 0   # max(nums[i])\n\n    for num in nums:\n      ans = max(ans, maxDiff * num)         # num := nums[k]\n      maxDiff = max(maxDiff, maxNum - num)  # num := nums[j]\n      maxNum = max(maxNum, num)             # num := nums[i]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2804, "slug": "array-prototype-foreach", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2869, "slug": "minimum-operations-to-collect-elements", "solutions": ["class Solution:\n    def minOperations(self, nums: List[int], k: int) -> int:\n        is_added = [False] * k\n        count = 0\n        n = len(nums)\n        for i in range(n - 1, -1, -1):\n            if nums[i] > k or is_added[nums[i] - 1]:\n                continue\n            is_added[nums[i] - 1] = True\n            count += 1\n            if count == k:\n                return n - i\n", "class Solution:\n  def minOperations(self, nums: list[int], k: int) -> int:\n    seen = set()\n\n    for i, num in enumerate(reversed(nums)):\n      if num > k:\n        continue\n      seen.add(num)\n      if len(seen) == k:\n        return i + 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2840, "slug": "check-if-strings-can-be-made-equal-with-operations-ii", "solutions": ["class Solution:\n    def checkStrings(self, s1: str, s2: str) -> bool:\n        return sorted(s1[::2]) == sorted(s2[::2]) and sorted(s1[1::2]) == sorted(\n            s2[1::2]\n        )\n", "class Solution:\n  def checkStrings(self, s1: str, s2: str) -> bool:\n    count = [collections.Counter() for _ in range(2)]\n\n    for i, (a, b) in enumerate(zip(s1, s2)):\n      count[i % 2][a] += 1\n      count[i % 2][b] -= 1\n\n    return (all(freq == 0 for freq in count[0].values()) and\n            all(freq == 0 for freq in count[1].values()))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2817, "slug": "minimum-absolute-difference-between-elements-with-constraint", "solutions": ["class Solution:\n    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n        sl = SortedList()\n        ans = inf\n        for i in range(x, len(nums)):\n            sl.add(nums[i - x])\n            j = bisect_left(sl, nums[i])\n            if j < len(sl):\n                ans = min(ans, sl[j] - nums[i])\n            if j:\n                ans = min(ans, nums[i] - sl[j - 1])\n        return ans\n", "from sortedcontainers import SortedSet\n\n\nclass Solution:\n  def minAbsoluteDifference(self, nums: list[int], x: int) -> int:\n    ans = math.inf\n    seen = SortedSet()\n\n    for i in range(x, len(nums)):\n      seen.add(nums[i - x])\n      it = seen.bisect_left(nums[i])\n      if it != len(seen):\n        ans = min(ans, seen[it] - nums[i])\n      if it != 0:\n        ans = min(ans, nums[i] - seen[it - 1])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2891, "slug": "method-chaining", "solutions": ["import pandas as pd\n\n\ndef findHeavyAnimals(animals: pd.DataFrame) -> pd.DataFrame:\n    return animals[animals['weight'] > 100].sort_values('weight', ascending=False)[\n        ['name']\n    ]\n", "import pandas as pd\n\n\ndef findHeavyAnimals(animals: pd.DataFrame) -> pd.DataFrame:\n  return animals[animals['weight'] > 100].sort_values(\n      by='weight',\n      ascending=False\n  )[['name']]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2805, "slug": "custom-interval", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2807, "slug": "insert-greatest-common-divisors-in-linked-list", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def insertGreatestCommonDivisors(\n        self, head: Optional[ListNode]\n    ) -> Optional[ListNode]:\n        pre, cur = head, head.next\n        while cur:\n            x = gcd(pre.val, cur.val)\n            pre.next = ListNode(x, cur)\n            pre, cur = cur, cur.next\n        return head\n", "class Solution:\n  def insertGreatestCommonDivisors(\n      self, head: ListNode | None\n  ) -> ListNode | None:\n    curr = head\n    while curr.next:\n      inserted = ListNode(math.gcd(curr.val, curr.next.val), curr.next)\n      curr.next = inserted\n      curr = inserted.next\n    return head\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2843, "slug": "count-symmetric-integers", "solutions": ["class Solution:\n    def countSymmetricIntegers(self, low: int, high: int) -> int:\n        def f(x: int) -> bool:\n            s = str(x)\n            if len(s) & 1:\n                return False\n            n = len(s) // 2\n            return sum(map(int, s[:n])) == sum(map(int, s[n:]))\n\n        return sum(f(x) for x in range(low, high + 1))\n", "class Solution:\n  def countSymmetricIntegers(self, low: int, high: int) -> int:\n    def isSymmetricInteger(num: int) -> bool:\n      if num >= 10 and num <= 99:\n        return num // 10 == num % 10\n      if num >= 1000 and num <= 9999:\n        left = num // 100\n        right = num % 100\n        return left // 10 + left % 10 == right // 10 + right % 10\n      return False\n\n    return sum(isSymmetricInteger(num) for num in range(low, high + 1))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2808, "slug": "minimum-seconds-to-equalize-a-circular-array", "solutions": ["class Solution:\n    def minimumSeconds(self, nums: List[int]) -> int:\n        d = defaultdict(list)\n        for i, x in enumerate(nums):\n            d[x].append(i)\n        ans = inf\n        n = len(nums)\n        for idx in d.values():\n            t = idx[0] + n - idx[-1]\n            for i, j in pairwise(idx):\n                t = max(t, j - i)\n            ans = min(ans, t // 2)\n        return ans\n", "class Solution:\n  def minimumSeconds(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = n\n    numToIndices = collections.defaultdict(list)\n\n    for i, num in enumerate(nums):\n      numToIndices[num].append(i)\n\n    def getSeconds(i: int, j: int) -> int:\n      \"\"\"Returns the number of seconds required to make nums[i..j] the same.\"\"\"\n      return (i - j) // 2\n\n    for indices in numToIndices.values():\n      seconds = getSeconds(indices[0] + n, indices[-1])\n      for i in range(1, len(indices)):\n        seconds = max(seconds, getSeconds(indices[i], indices[i - 1]))\n      ans = min(ans, seconds)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2831, "slug": "find-the-longest-equal-subarray", "solutions": ["class Solution:\n    def longestEqualSubarray(self, nums: List[int], k: int) -> int:\n        cnt = Counter()\n        l = 0\n        mx = 0\n        for r, x in enumerate(nums):\n            cnt[x] += 1\n            mx = max(mx, cnt[x])\n            if r - l + 1 - mx > k:\n                cnt[nums[l]] -= 1\n                l += 1\n        return mx\n", "class Solution:\n  def longestEqualSubarray(self, nums: list[int], k: int) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    # l and r track the maximum window instead of the valid window.\n    l = 0\n    for r, num in enumerate(nums):\n      count[num] += 1\n      ans = max(ans, count[num])\n      if r - l + 1 - k > ans:\n        count[nums[l]] -= 1\n        l += 1\n\n    return ans\n", "class Solution:\n  def longestEqualSubarray(self, nums: list[int], k: int) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, num in enumerate(nums):\n      count[num] += 1\n      ans = max(ans, count[num])\n      while r - l + 1 - k > ans:\n        count[nums[l]] -= 1\n        l += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2839, "slug": "check-if-strings-can-be-made-equal-with-operations-i", "solutions": ["class Solution:\n    def canBeEqual(self, s1: str, s2: str) -> bool:\n        return sorted(s1[::2]) == sorted(s2[::2]) and sorted(s1[1::2]) == sorted(\n            s2[1::2]\n        )\n", "class Solution:\n  def canBeEqual(self, s1: str, s2: str) -> bool:\n    def swappedStrings(s: str) -> list[str]:\n      chars = list(s)\n      return [chars,\n              ''.join([chars[2], chars[1], chars[0], chars[3]]),\n              ''.join([chars[0], chars[3], chars[2], chars[1]]),\n              ''.join([chars[2], chars[3], chars[0], chars[1]])]\n\n    return any(a == b\n               for a in swappedStrings(s1)\n               for b in swappedStrings(s2))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2870, "slug": "minimum-number-of-operations-to-make-array-empty", "solutions": ["class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        count = Counter(nums)\n        ans = 0\n        for c in count.values():\n            if c == 1:\n                return -1\n            ans += (c + 2) // 3\n        return ans\n", "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    count = collections.Counter(nums)\n    if 1 in count.values():\n      return -1\n    return sum((freq + 2) // 3 for freq in count.values())\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2865, "slug": "beautiful-towers-i", "solutions": ["class Solution:\n    def maximumSumOfHeights(self, maxHeights: List[int]) -> int:\n        ans, n = 0, len(maxHeights)\n        for i, x in enumerate(maxHeights):\n            y = t = x\n            for j in range(i - 1, -1, -1):\n                y = min(y, maxHeights[j])\n                t += y\n            y = x\n            for j in range(i + 1, n):\n                y = min(y, maxHeights[j])\n                t += y\n            ans = max(ans, t)\n        return ans\n", "class Solution:\n  def maximumSumOfHeights(self, maxHeights: list[int]) -> int:\n    n = len(maxHeights)\n    maxSum = [0] * n  # maxSum[i] := the maximum sum with peak i\n\n    def process(stack: list[int], i: int, summ: int) -> int:\n      while len(stack) > 1 and maxHeights[stack[-1]] > maxHeights[i]:\n        j = stack.pop()\n        # The last abs(j - stack[-1]) heights are maxHeights[j].\n        summ -= abs(j - stack[-1]) * maxHeights[j]\n      # Put abs(i - stack[-1]) `maxHeight` in heights.\n      summ += abs(i - stack[-1]) * maxHeights[i]\n      stack.append(i)\n      return summ\n\n    stack = [-1]\n    summ = 0\n    for i in range(len(maxHeights)):\n      summ = process(stack, i, summ)\n      maxSum[i] = summ\n\n    stack = [n]\n    summ = 0\n    for i in range(n - 1, -1, -1):\n      summ = process(stack, i, summ)\n      maxSum[i] += summ - maxHeights[i]\n\n    return max(maxSum)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2899, "slug": "last-visited-integers", "solutions": ["class Solution:\n    def lastVisitedIntegers(self, words: List[str]) -> List[int]:\n        nums = []\n        ans = []\n        k = 0\n        for w in words:\n            if w == \"prev\":\n                k += 1\n                i = len(nums) - k\n                ans.append(-1 if i < 0 else nums[i])\n            else:\n                k = 0\n                nums.append(int(w))\n        return ans\n", "class Solution:\n  def lastVisitedIntegers(self, words: list[str]) -> list[int]:\n    ans = []\n    nums = []\n    k = 0\n\n    for word in words:\n      if word == 'prev':\n        k += 1\n        ans.append(-1 if k > len(nums) else nums[-k])\n      else:\n        k = 0\n        nums.append(int(word))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2848, "slug": "points-that-intersect-with-cars", "solutions": ["class Solution:\n    def numberOfPoints(self, nums: List[List[int]]) -> int:\n        m = 102\n        d = [0] * m\n        for start, end in nums:\n            d[start] += 1\n            d[end + 1] -= 1\n        return sum(s > 0 for s in accumulate(d))\n", "class Solution:\n  def numberOfPoints(self, nums: list[list[int]]) -> int:\n    MAX = 100\n    ans = 0\n    runningSum = 0\n    count = [0] * (MAX + 2)\n\n    for start, end in nums:\n      count[start] += 1\n      count[end + 1] -= 1\n\n    for i in range(1, MAX + 1):\n      runningSum += count[i]\n      if runningSum > 0:\n        ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2873, "slug": "maximum-value-of-an-ordered-triplet-i", "solutions": ["class Solution:\n    def maximumTripletValue(self, nums: List[int]) -> int:\n        ans = mx = mx_diff = 0\n        for x in nums:\n            ans = max(ans, mx_diff * x)\n            mx_diff = max(mx_diff, mx - x)\n            mx = max(mx, x)\n        return ans\n", "class Solution:\n  def maximumTripletValue(self, nums: list[int]) -> int:\n    ans = 0\n    maxDiff = 0  # max(nums[i] - nums[j])\n    maxNum = 0   # max(nums[i])\n\n    for num in nums:\n      ans = max(ans, maxDiff * num)         # num := nums[k]\n      maxDiff = max(maxDiff, maxNum - num)  # num := nums[j]\n      maxNum = max(maxNum, num)             # num := nums[i]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2828, "slug": "check-if-a-string-is-an-acronym-of-words", "solutions": ["class Solution:\n    def isAcronym(self, words: List[str], s: str) -> bool:\n        return \"\".join(w[0] for w in words) == s\n", "class Solution:\n  def isAcronym(self, words: list[str], s: str) -> bool:\n    return (len(words) == len(s) and\n            all(word[0] == c for word, c in zip(words, s)))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2885, "slug": "rename-columns", "solutions": ["import pandas as pd\n\n\ndef renameColumns(students: pd.DataFrame) -> pd.DataFrame:\n    students.rename(\n        columns={\n            'id': 'student_id',\n            'first': 'first_name',\n            'last': 'last_name',\n            'age': 'age_in_years',\n        },\n        inplace=True,\n    )\n    return students\n", "import pandas as pd\n\n\ndef renameColumns(students: pd.DataFrame) -> pd.DataFrame:\n  return students.rename(\n      columns={\n          \"id\": \"student_id\",\n          \"first\": \"first_name\",\n          \"last\": \"last_name\",\n          \"age\": \"age_in_years\",\n      }\n  )\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2827, "slug": "number-of-beautiful-integers-in-the-range", "solutions": ["class Solution:\n    def numberOfBeautifulIntegers(self, low: int, high: int, k: int) -> int:\n        @cache\n        def dfs(pos: int, mod: int, diff: int, lead: int, limit: int) -> int:\n            if pos >= len(s):\n                return mod == 0 and diff == 10\n            up = int(s[pos]) if limit else 9\n            ans = 0\n            for i in range(up + 1):\n                if i == 0 and lead:\n                    ans += dfs(pos + 1, mod, diff, 1, limit and i == up)\n                else:\n                    nxt = diff + (1 if i % 2 == 1 else -1)\n                    ans += dfs(pos + 1, (mod * 10 + i) % k, nxt, 0, limit and i == up)\n            return ans\n\n        s = str(high)\n        a = dfs(0, 0, 10, 1, 1)\n        dfs.cache_clear()\n        s = str(low - 1)\n        b = dfs(0, 0, 10, 1, 1)\n        return a - b\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2864, "slug": "maximum-odd-binary-number", "solutions": ["class Solution:\n    def maximumOddBinaryNumber(self, s: str) -> str:\n        cnt = s.count(\"1\")\n        return \"1\" * (cnt - 1) + (len(s) - cnt) * \"0\" + \"1\"\n", "class Solution:\n  def maximumOddBinaryNumber(self, s: str) -> str:\n    return '1' * (s.count('1') - 1) + '0' * s.count('0') + '1'\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2826, "slug": "sorting-three-groups", "solutions": ["class Solution:\n    def minimumOperations(self, nums: List[int]) -> int:\n        f = [0] * 3\n        for x in nums:\n            g = [0] * 3\n            if x == 1:\n                g[0] = f[0]\n                g[1] = min(f[:2]) + 1\n                g[2] = min(f) + 1\n            elif x == 2:\n                g[0] = f[0] + 1\n                g[1] = min(f[:2])\n                g[2] = min(f) + 1\n            else:\n                g[0] = f[0] + 1\n                g[1] = min(f[:2]) + 1\n                g[2] = min(f)\n            f = g\n        return min(f)\n", "class Solution:\n  def minimumOperations(self, nums: list[int]) -> int:\n    # dp[i] := the longest non-decreasing subsequence so far with numbers in [1..i]\n    dp = [0] * 4\n\n    for num in nums:\n      dp[num] += 1  # Append num to the sequence so far.\n      dp[2] = max(dp[2], dp[1])\n      dp[3] = max(dp[3], dp[2])\n\n    return len(nums) - dp[3]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2820, "slug": "election-results", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2838, "slug": "maximum-coins-heroes-can-collect", "solutions": ["class Solution:\n    def maximumCoins(\n        self, heroes: List[int], monsters: List[int], coins: List[int]\n    ) -> List[int]:\n        m = len(monsters)\n        idx = sorted(range(m), key=lambda i: monsters[i])\n        s = list(accumulate((coins[i] for i in idx), initial=0))\n        ans = []\n        for h in heroes:\n            i = bisect_right(idx, h, key=lambda i: monsters[i])\n            ans.append(s[i])\n        return ans\n", "class Solution:\n  def maximumCoins(\n      self,\n      heroes: list[int],\n      monsters: list[int],\n      coins: list[int]\n  ) -> list[int]:\n    monsterAndCoins = sorted(list(zip(monsters, coins)))\n    coinsPrefix = list(itertools.accumulate(\n        (coin for _, coin in monsterAndCoins),\n        initial=0))\n    return [coinsPrefix[self._firstGreaterEqual(monsterAndCoins, hero)]\n            for hero in heroes]\n\n  def _firstGreaterEqual(\n      self,\n      monsterAndCoins: list[tuple[int, int]],\n      hero: int,\n  ) -> int:\n    l, r = 0, len(monsterAndCoins)\n    while l < r:\n      m = (l + r) // 2\n      if monsterAndCoins[m][0] > hero:\n        r = m\n      else:\n        l = m + 1\n    return l\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2858, "slug": "minimum-edge-reversals-so-every-node-is-reachable", "solutions": ["class Solution:\n    def minEdgeReversals(self, n: int, edges: List[List[int]]) -> List[int]:\n        ans = [0] * n\n        g = [[] for _ in range(n)]\n        for x, y in edges:\n            g[x].append((y, 1))\n            g[y].append((x, -1))\n\n        def dfs(i: int, fa: int):\n            for j, k in g[i]:\n                if j != fa:\n                    ans[0] += int(k < 0)\n                    dfs(j, i)\n\n        dfs(0, -1)\n\n        def dfs2(i: int, fa: int):\n            for j, k in g[i]:\n                if j != fa:\n                    ans[j] = ans[i] + k\n                    dfs2(j, i)\n\n        dfs2(0, -1)\n        return ans\n", "class Solution:\n  def minEdgeReversals(self, n: int, edges: list[list[int]]) -> list[int]:\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append((v, True))  # 1 means (u -> v)\n      graph[v].append((u, False))  # 0 means (v <- u)\n\n    seen = {0}\n\n    @functools.lru_cache(None)\n    def dp(u: int) -> int:\n      \"\"\"\n      Returns the minimum number of edge reversals so node u can reach every\n      node in its subtree.\n      \"\"\"\n      res = 0\n      for v, isForward in graph[u]:\n        if v in seen:\n          continue\n        seen.add(v)\n        res += dp(v) + (0 if isForward else 1)\n      return res\n\n    ans = [0] * n\n    ans[0] = dp(0)\n\n    def dfs(u: int) -> None:\n      for v, isForward in graph[u]:\n        if v in seen:\n          continue\n        seen.add(v)\n        ans[v] = ans[u] + (1 if isForward else -1)\n        dfs(v)\n\n    seen = {0}\n    dfs(0)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2832, "slug": "maximal-range-that-each-element-is-maximum-in-it", "solutions": ["class Solution:\n    def maximumLengthOfRanges(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        left = [-1] * n\n        right = [n] * n\n        stk = []\n        for i, x in enumerate(nums):\n            while stk and nums[stk[-1]] <= x:\n                stk.pop()\n            if stk:\n                left[i] = stk[-1]\n            stk.append(i)\n        stk = []\n        for i in range(n - 1, -1, -1):\n            while stk and nums[stk[-1]] <= nums[i]:\n                stk.pop()\n            if stk:\n                right[i] = stk[-1]\n            stk.append(i)\n        return [r - l - 1 for l, r in zip(left, right)]\n", "class Solution:\n  def maximumLengthOfRanges(self, nums: list[int]) -> list[int]:\n    ans = [0] * len(nums)\n    stack = []  # a decreasing stack\n\n    for i in range(len(nums) + 1):\n      while stack and (i == len(nums) or nums[stack[-1]] < nums[i]):\n        index = stack.pop()\n        left = stack[-1] if stack else -1\n        ans[index] = i - left - 1\n      stack.append(i)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2809, "slug": "minimum-time-to-make-array-sum-at-most-x", "solutions": ["class Solution:\n    def minimumTime(self, nums1: List[int], nums2: List[int], x: int) -> int:\n        n = len(nums1)\n        f = [[0] * (n + 1) for _ in range(n + 1)]\n        for i, (a, b) in enumerate(sorted(zip(nums1, nums2), key=lambda z: z[1]), 1):\n            for j in range(n + 1):\n                f[i][j] = f[i - 1][j]\n                if j > 0:\n                    f[i][j] = max(f[i][j], f[i - 1][j - 1] + a + b * j)\n        s1 = sum(nums1)\n        s2 = sum(nums2)\n        for j in range(n + 1):\n            if s1 + s2 * j - f[n][j] <= x:\n                return j\n        return -1\n", "class Solution:\n  def minimumTime(self, nums1: list[int], nums2: list[int], x: int) -> int:\n    n = len(nums1)\n    # dp[j] := the maximum reduced value if we do j operations on the numbers\n    # so far\n    dp = [0] * (n + 1)\n    sum1 = sum(nums1)\n    sum2 = sum(nums2)\n\n    for i, (num2, num1) in enumerate(sorted(zip(nums2, nums1)), 1):\n      for j in range(i, 0, -1):\n        dp[j] = max(\n            # the maximum reduced value if we do j operations on the first\n            # i - 1 numbers\n            dp[j],\n            # the maximum reduced value if we do j - 1 operations on the first\n            # i - 1 numbers + making the i-th number of `nums1` to 0 at the\n            # j-th operation\n            dp[j - 1] + num2 * j + num1\n        )\n\n    for op in range(n + 1):\n      if sum1 + sum2 * op - dp[op] <= x:\n        return op\n\n    return -1\n", "class Solution:\n  def minimumTime(self, nums1: list[int], nums2: list[int], x: int) -> int:\n    n = len(nums1)\n    # dp[i][j] := the maximum reduced value if we do j operations on the first\n    # i numbers\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    sum1 = sum(nums1)\n    sum2 = sum(nums2)\n\n    for i, (num2, num1) in enumerate(sorted(zip(nums2, nums1)), 1):\n      for j in range(1, i + 1):\n        dp[i][j] = max(\n            # the maximum reduced value if we do j operations on the first\n            # i - 1 numbers\n            dp[i - 1][j],\n            # the maximum reduced value if we do j - 1 operations on the first\n            # i - 1 numbers + making the i-th number of `nums1` to 0 at the\n            # j-th operation\n            dp[i - 1][j - 1] + num2 * j + num1\n        )\n\n    for op in range(n + 1):\n      if sum1 + sum2 * op - dp[n][op] <= x:\n        return op\n\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2876, "slug": "count-visited-nodes-in-a-directed-graph", "solutions": ["class Solution:\n    def countVisitedNodes(self, edges: List[int]) -> List[int]:\n        n = len(edges)\n        ans = [0] * n\n        vis = [0] * n\n        for i in range(n):\n            if not ans[i]:\n                cnt, j = 0, i\n                while not vis[j]:\n                    cnt += 1\n                    vis[j] = cnt\n                    j = edges[j]\n                cycle, total = 0, cnt + ans[j]\n                if not ans[j]:\n                    cycle = cnt - vis[j] + 1\n                    total = cnt\n                j = i\n                while not ans[j]:\n                    ans[j] = max(total, cycle)\n                    total -= 1\n                    j = edges[j]\n        return ans\n", "class Solution:\n  def countVisitedNodes(self, edges: list[int]) -> list[int]:\n    n = len(edges)\n    ans = [0] * n\n    inDegrees = [0] * n\n    seen = [False] * n\n    stack = []\n\n    for v in edges:\n      inDegrees[v] += 1\n\n    # Perform topological sorting.\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    # Push non-cyclic nodes to stack.\n    while q:\n      u = q.popleft()\n      inDegrees[edges[u]] -= 1\n      if inDegrees[edges[u]] == 0:\n        q.append(edges[u])\n      stack.append(u)\n      seen[u] = True\n\n    # Fill the length of cyclic nodes.\n    for i in range(n):\n      if not seen[i]:\n        self._fillCycle(edges, i, seen, ans)\n\n    # Fill the length of non-cyclic nodes.\n    while stack:\n      u = stack.pop()\n      ans[u] = ans[edges[u]] + 1\n\n    return ans\n\n  def _fillCycle(\n      self,\n      edges: list[int],\n      start: int,\n      seen: list[bool],\n      ans: list[int],\n  ) -> None:\n    cycleLength = 0\n    u = start\n    while not seen[u]:\n      cycleLength += 1\n      seen[u] = True\n      u = edges[u]\n    ans[start] = cycleLength\n    u = edges[start]\n    while u != start:\n      ans[u] = cycleLength\n      u = edges[u]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2814, "slug": "minimum-time-takes-to-reach-destination-without-drowning", "solutions": ["class Solution:\n    def minimumSeconds(self, land: List[List[str]]) -> int:\n        m, n = len(land), len(land[0])\n        vis = [[False] * n for _ in range(m)]\n        g = [[inf] * n for _ in range(m)]\n        q = deque()\n        si = sj = 0\n        for i, row in enumerate(land):\n            for j, c in enumerate(row):\n                match c:\n                    case \"*\":\n                        q.append((i, j))\n                    case \"S\":\n                        si, sj = i, j\n        dirs = (-1, 0, 1, 0, -1)\n        t = 0\n        while q:\n            for _ in range(len(q)):\n                i, j = q.popleft()\n                g[i][j] = t\n                for a, b in pairwise(dirs):\n                    x, y = i + a, j + b\n                    if (\n                        0 <= x < m\n                        and 0 <= y < n\n                        and not vis[x][y]\n                        and land[x][y] in \".S\"\n                    ):\n                        vis[x][y] = True\n                        q.append((x, y))\n            t += 1\n        t = 0\n        q = deque([(si, sj)])\n        vis = [[False] * n for _ in range(m)]\n        vis[si][sj] = True\n        while q:\n            for _ in range(len(q)):\n                i, j = q.popleft()\n                if land[i][j] == \"D\":\n                    return t\n                for a, b in pairwise(dirs):\n                    x, y = i + a, j + b\n                    if (\n                        0 <= x < m\n                        and 0 <= y < n\n                        and g[x][y] > t + 1\n                        and not vis[x][y]\n                        and land[x][y] in \".D\"\n                    ):\n                        vis[x][y] = True\n                        q.append((x, y))\n            t += 1\n        return -1\n", "class Solution:\n  def minimumSeconds(self, land: list[list[str]]) -> int:\n    self.DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(land)\n    n = len(land[0])\n    floodDist = self._getFloodDist(land)\n    startPos = self._getStartPos(land, 'S')\n\n    q = collections.deque([startPos])\n    seen = {startPos}\n\n    step = 1\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in self.DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if land[x][y] == 'D':\n            return step\n          if floodDist[x][y] <= step or land[x][y] == 'X' or (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n      step += 1\n\n    return -1\n\n  def _getFloodDist(self, land: list[list[str]]) -> list[list[int]]:\n    m = len(land)\n    n = len(land[0])\n    dist = [[math.inf] * n for _ in range(m)]\n    q = collections.deque()\n    seen = set()\n\n    for i, row in enumerate(land):\n      for j, cell in enumerate(row):\n        if cell == '*':\n          q.append((i, j))\n          seen.add((i, j))\n\n    d = 0\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        dist[i][j] = d\n        for dx, dy in self.DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if land[x][y] in 'XD' or (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n      d += 1\n\n    return dist\n\n  def _getStartPos(self, land: list[list[str]], c: str) -> tuple[int, int]:\n    for i, row in enumerate(land):\n      for j, cell in enumerate(row):\n        if cell == c:\n          return i, j\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2894, "slug": "divisible-and-non-divisible-sums-difference", "solutions": ["class Solution:\n    def differenceOfSums(self, n: int, m: int) -> int:\n        return sum(i if i % m else -i for i in range(1, n + 1))\n", "class Solution:\n  def differenceOfSums(self, n: int, m: int) -> int:\n    summ = (1 + n) * n // 2\n    num2 = self._getDivisibleSum(n, m)\n    num1 = summ - num2\n    return num1 - num2\n\n  def _getDivisibleSum(self, n: int, m: int) -> int:\n    \"\"\"Returns the sum of all the integers in [1, n] that are divisible by m.\"\"\"\n    last = n // m * m\n    if last == 0:\n      return 0\n    first = m\n    count = (last - first) // m + 1\n    return (first + last) * count // 2\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2856, "slug": "minimum-array-length-after-pair-removals", "solutions": ["class Solution:\n    def minLengthAfterRemovals(self, nums: List[int]) -> int:\n        cnt = Counter(nums)\n        pq = [-x for x in cnt.values()]\n        heapify(pq)\n        ans = len(nums)\n        while len(pq) > 1:\n            x, y = -heappop(pq), -heappop(pq)\n            x -= 1\n            y -= 1\n            if x > 0:\n                heappush(pq, -x)\n            if y > 0:\n                heappush(pq, -y)\n            ans -= 2\n        return ans\n", "class Solution:\n  def minLengthAfterRemovals(self, nums: list[int]) -> int:\n    n = len(nums)\n    count = collections.Counter(nums)\n    maxFreq = max(count.values())\n\n    # The number with the maximum frequency cancel all the other numbers.\n    if maxFreq <= n / 2:\n      return n % 2\n    # The number with the maximum frequency cancel all the remaining numbers.\n    return maxFreq - (n - maxFreq)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2867, "slug": "count-valid-paths-in-a-tree", "solutions": ["class UnionFind:\n    def __init__(self, n):\n        self.p = list(range(n))\n        self.size = [1] * n\n\n    def find(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n\n    def union(self, a, b):\n        pa, pb = self.find(a), self.find(b)\n        if pa == pb:\n            return False\n        if self.size[pa] > self.size[pb]:\n            self.p[pb] = pa\n            self.size[pa] += self.size[pb]\n        else:\n            self.p[pa] = pb\n            self.size[pb] += self.size[pa]\n        return True\n\n\nmx = 10**5 + 10\nprime = [True] * (mx + 1)\nprime[0] = prime[1] = False\nfor i in range(2, mx + 1):\n    if prime[i]:\n        for j in range(i * i, mx + 1, i):\n            prime[j] = False\n\n\nclass Solution:\n    def countPaths(self, n: int, edges: List[List[int]]) -> int:\n        g = [[] for _ in range(n + 1)]\n        uf = UnionFind(n + 1)\n        for u, v in edges:\n            g[u].append(v)\n            g[v].append(u)\n            if prime[u] + prime[v] == 0:\n                uf.union(u, v)\n\n        ans = 0\n        for i in range(1, n + 1):\n            if prime[i]:\n                t = 0\n                for j in g[i]:\n                    if not prime[j]:\n                        cnt = uf.size[uf.find(j)]\n                        ans += cnt\n                        ans += t * cnt\n                        t += cnt\n        return ans\n", "class Solution:\n  def countPaths(self, n: int, edges: list[list[int]]) -> int:\n    ans = 0\n    isPrime = self._sieveEratosthenes(n + 1)\n    graph = [[] for _ in range(n + 1)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    def dfs(u: int, prev: int) -> tuple[int, int]:\n      nonlocal ans\n      countZeroPrimePath = int(not isPrime[u])\n      countOnePrimePath = int(isPrime[u])\n\n      for v in graph[u]:\n        if v == prev:\n          continue\n        countZeroPrimeChildPath, countOnePrimeChildPath = dfs(v, u)\n        ans += (countZeroPrimePath * countOnePrimeChildPath +\n                countOnePrimePath * countZeroPrimeChildPath)\n        if isPrime[u]:\n          countOnePrimePath += countZeroPrimeChildPath\n        else:\n          countZeroPrimePath += countZeroPrimeChildPath\n          countOnePrimePath += countOnePrimeChildPath\n\n      return countZeroPrimePath, countOnePrimePath\n\n    dfs(1, -1)\n    return ans\n\n  def _sieveEratosthenes(self, n: int) -> list[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2802, "slug": "find-the-k-th-lucky-number", "solutions": ["class Solution:\n    def kthLuckyNumber(self, k: int) -> str:\n        n = 1\n        while k > 1 << n:\n            k -= 1 << n\n            n += 1\n        ans = []\n        while n:\n            n -= 1\n            if k <= 1 << n:\n                ans.append(\"4\")\n            else:\n                ans.append(\"7\")\n                k -= 1 << n\n        return \"\".join(ans)\n", "class Solution:\n  def kthLuckyNumber(self, k: int) -> str:\n    return bin(k + 1)[3:].replace('0', '4').replace('1', '7')\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2824, "slug": "count-pairs-whose-sum-is-less-than-target", "solutions": ["class Solution:\n    def countPairs(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        ans = 0\n        for j, x in enumerate(nums):\n            i = bisect_left(nums, target - x, hi=j)\n            ans += i\n        return ans\n", "class Solution:\n  def countPairs(self, nums: list[int], target: int) -> int:\n    return sum(nums[i] + nums[j] < target\n               for i in range(len(nums))\n               for j in range(i + 1, len(nums)))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2896, "slug": "apply-operations-to-make-two-strings-equal", "solutions": ["class Solution:\n    def minOperations(self, s1: str, s2: str, x: int) -> int:\n        @cache\n        def dfs(i: int, j: int) -> int:\n            if i > j:\n                return 0\n            a = dfs(i + 1, j - 1) + x\n            b = dfs(i + 2, j) + idx[i + 1] - idx[i]\n            c = dfs(i, j - 2) + idx[j] - idx[j - 1]\n            return min(a, b, c)\n\n        n = len(s1)\n        idx = [i for i in range(n) if s1[i] != s2[i]]\n        m = len(idx)\n        if m & 1:\n            return -1\n        return dfs(0, m - 1)\n", "class Solution:\n  def minOperations(self, s1: str, s2: str, x: int) -> int:\n    diffIndices = [i for i, (a, b) in enumerate(zip(s1, s2))\n                   if a != b]\n    if not diffIndices:\n      return 0\n    # It's impossible to make two strings equal if there are odd number of\n    # differences.\n    if len(diffIndices) & 1:\n      return -1\n\n    @functools.lru_cache(None)\n    def dp(i: int) -> int:\n      \"\"\"Returns the minimum cost to correct diffIndices[i..n).\"\"\"\n      if i == len(diffIndices):\n        return 0\n      if i == len(diffIndices) - 1:\n        return x / 2\n      return min(dp(i + 1) + x / 2,\n                 dp(i + 2) + diffIndices[i + 1] - diffIndices[i])\n\n    return int(dp(0))\n", "class Solution:\n  def minOperations(self, s1: str, s2: str, x: int) -> int:\n    diffIndices = [i for i, (a, b) in enumerate(zip(s1, s2))\n                   if a != b]\n    if not diffIndices:\n      return 0\n    # It's impossible to make two strings equal if there are odd number of\n    # differences.\n    if len(diffIndices) & 1:\n      return -1\n\n    #         dp := the minimum cost to correct diffIndices[i:]\n    #     dpNext := the minimum cost to correct diffIndices[i + 1:]\n    # dpNextNext := the minimum cost to correct diffIndices[i + 2:]\n    dpNext = x / 2\n    dpNextNext = 0\n\n    for i in reversed(range(len(diffIndices) - 1)):\n      dp = min(dpNext + x / 2,\n               dpNextNext + diffIndices[i + 1] - diffIndices[i])\n      dpNextNext = dpNext\n      dpNext = dp\n\n    return int(dp)\n", "class Solution:\n  def minOperations(self, s1: str, s2: str, x: int) -> int:\n    diffIndices = [i for i, (a, b) in enumerate(zip(s1, s2))\n                   if a != b]\n    if not diffIndices:\n      return 0\n    # It's impossible to make two strings equal if there are odd number of\n    # differences.\n    if len(diffIndices) & 1:\n      return -1\n\n    # dp[i] := the minimum cost to correct diffIndices[i:]\n    dp = [math.inf] * len(diffIndices) + [0]\n    dp[-2] = x / 2\n\n    for i in reversed(range(len(diffIndices) - 1)):\n      dp[i] = min(dp[i + 1] + x / 2,\n                  dp[i + 2] + diffIndices[i + 1] - diffIndices[i])\n\n    return int(dp[0])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2841, "slug": "maximum-sum-of-almost-unique-subarray", "solutions": ["class Solution:\n    def maxSum(self, nums: List[int], m: int, k: int) -> int:\n        cnt = Counter(nums[:k])\n        s = sum(nums[:k])\n        ans = s if len(cnt) >= m else 0\n        for i in range(k, len(nums)):\n            cnt[nums[i]] += 1\n            cnt[nums[i - k]] -= 1\n            s += nums[i] - nums[i - k]\n            if cnt[nums[i - k]] == 0:\n                cnt.pop(nums[i - k])\n            if len(cnt) >= m:\n                ans = max(ans, s)\n        return ans\n", "class Solution:\n  def maxSum(self, nums: list[int], m: int, k: int) -> int:\n    ans = 0\n    summ = 0\n    count = collections.Counter()\n\n    for i, num in enumerate(nums):\n      summ += num\n      count[num] += 1\n      if i >= k:\n        numToRemove = nums[i - k]\n        summ -= numToRemove\n        count[numToRemove] -= 1\n        if count[numToRemove] == 0:\n          del count[numToRemove]\n      if len(count) >= m:\n        ans = max(ans, summ)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2850, "slug": "minimum-moves-to-spread-stones-over-grid", "solutions": ["class Solution:\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        q = deque([tuple(tuple(row) for row in grid)])\n        vis = set(q)\n        ans = 0\n        dirs = (-1, 0, 1, 0, -1)\n        while 1:\n            for _ in range(len(q)):\n                cur = q.popleft()\n                if all(x for row in cur for x in row):\n                    return ans\n                for i in range(3):\n                    for j in range(3):\n                        if cur[i][j] > 1:\n                            for a, b in pairwise(dirs):\n                                x, y = i + a, j + b\n                                if 0 <= x < 3 and 0 <= y < 3 and cur[x][y] < 2:\n                                    nxt = [list(row) for row in cur]\n                                    nxt[i][j] -= 1\n                                    nxt[x][y] += 1\n                                    nxt = tuple(tuple(row) for row in nxt)\n                                    if nxt not in vis:\n                                        vis.add(nxt)\n                                        q.append(nxt)\n            ans += 1\n", "class Solution:\n  def minimumMoves(self, grid: list[list[int]]) -> int:\n    if sum(row.count(0) for row in grid) == 0:\n      return 0\n\n    ans = math.inf\n\n    for i in range(3):\n      for j in range(3):\n        if grid[i][j] == 0:\n          for x in range(3):\n            for y in range(3):\n              if grid[x][y] > 1:\n                grid[x][y] -= 1\n                grid[i][j] += 1\n                ans = min(ans, abs(x - i) + abs(y - j) +\n                          self.minimumMoves(grid))\n                grid[x][y] += 1\n                grid[i][j] -= 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2835, "slug": "minimum-operations-to-form-subsequence-with-target-sum", "solutions": ["class Solution:\n    def minOperations(self, nums: List[int], target: int) -> int:\n        s = sum(nums)\n        if s < target:\n            return -1\n        cnt = [0] * 32\n        for x in nums:\n            for i in range(32):\n                if x >> i & 1:\n                    cnt[i] += 1\n        i = j = 0\n        ans = 0\n        while 1:\n            while i < 32 and (target >> i & 1) == 0:\n                i += 1\n            if i == 32:\n                break\n            while j < i:\n                cnt[j + 1] += cnt[j] // 2\n                cnt[j] %= 2\n                j += 1\n            while cnt[j] == 0:\n                cnt[j] = 1\n                j += 1\n            ans += j - i\n            cnt[j] -= 1\n            j = i\n            i += 1\n        return ans\n", "class Solution:\n  def minOperations(self, nums: list[int], target: int) -> int:\n    NO_MISSING_BIT = 31\n    maxBit = 31\n    ans = 0\n    minMissingBit = NO_MISSING_BIT\n    # count[i] := the number of occurrences of 2^i\n    count = collections.Counter(int(math.log2(num)) for num in nums)\n\n    for bit in range(maxBit):\n      # Check if `bit` is in the target.\n      if target >> bit & 1:\n        # If there are available bits, use one bit.\n        if count[bit] > 0:\n          count[bit] -= 1\n        else:\n          minMissingBit = min(minMissingBit, bit)\n      # If we previously missed a bit and there are available bits.\n      if minMissingBit != NO_MISSING_BIT and count[bit] > 0:\n        count[bit] -= 1\n        # Count the operations to break `bit` into `minMissingBit`.\n        ans += bit - minMissingBit\n        minMissingBit = NO_MISSING_BIT  # Set it to an the invalid value.\n      # Combining smaller numbers costs nothing.\n      count[bit + 1] += count[bit] // 2\n\n    # Check if all target bits have been covered, otherwise return -1.\n    return ans if minMissingBit == maxBit else -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2854, "slug": "rolling-average-steps", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2821, "slug": "delay-the-resolution-of-each-promise", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2866, "slug": "beautiful-towers-ii", "solutions": ["class Solution:\n    def maximumSumOfHeights(self, maxHeights: List[int]) -> int:\n        n = len(maxHeights)\n        stk = []\n        left = [-1] * n\n        for i, x in enumerate(maxHeights):\n            while stk and maxHeights[stk[-1]] > x:\n                stk.pop()\n            if stk:\n                left[i] = stk[-1]\n            stk.append(i)\n        stk = []\n        right = [n] * n\n        for i in range(n - 1, -1, -1):\n            x = maxHeights[i]\n            while stk and maxHeights[stk[-1]] >= x:\n                stk.pop()\n            if stk:\n                right[i] = stk[-1]\n            stk.append(i)\n        f = [0] * n\n        for i, x in enumerate(maxHeights):\n            if i and x >= maxHeights[i - 1]:\n                f[i] = f[i - 1] + x\n            else:\n                j = left[i]\n                f[i] = x * (i - j) + (f[j] if j != -1 else 0)\n        g = [0] * n\n        for i in range(n - 1, -1, -1):\n            if i < n - 1 and maxHeights[i] >= maxHeights[i + 1]:\n                g[i] = g[i + 1] + maxHeights[i]\n            else:\n                j = right[i]\n                g[i] = maxHeights[i] * (j - i) + (g[j] if j != n else 0)\n        return max(a + b - c for a, b, c in zip(f, g, maxHeights))\n", "class Solution:\n  # Same as 2865. Beautiful Towers I\n  def maximumSumOfHeights(self, maxHeights: list[int]) -> int:\n    n = len(maxHeights)\n    maxSum = [0] * n  # maxSum[i] := the maximum sum with peak i\n\n    def process(stack: list[int], i: int, summ: int) -> int:\n      while len(stack) > 1 and maxHeights[stack[-1]] > maxHeights[i]:\n        j = stack.pop()\n        # The last abs(j - stack[-1]) heights are maxHeights[j].\n        summ -= abs(j - stack[-1]) * maxHeights[j]\n      # Put abs(i - stack[-1]) `maxHeight` in heights.\n      summ += abs(i - stack[-1]) * maxHeights[i]\n      stack.append(i)\n      return summ\n\n    stack = [-1]\n    summ = 0\n    for i in range(len(maxHeights)):\n      summ = process(stack, i, summ)\n      maxSum[i] = summ\n\n    stack = [n]\n    summ = 0\n    for i in range(n - 1, -1, -1):\n      summ = process(stack, i, summ)\n      maxSum[i] += summ - maxHeights[i]\n\n    return max(maxSum)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2811, "slug": "check-if-it-is-possible-to-split-array", "solutions": ["class Solution:\n    def canSplitArray(self, nums: List[int], m: int) -> bool:\n        @cache\n        def dfs(i: int, j: int) -> bool:\n            if i == j:\n                return True\n            for k in range(i, j):\n                a = k == i or s[k + 1] - s[i] >= m\n                b = k == j - 1 or s[j + 1] - s[k + 1] >= m\n                if a and b and dfs(i, k) and dfs(k + 1, j):\n                    return True\n            return False\n\n        s = list(accumulate(nums, initial=0))\n        return dfs(0, len(nums) - 1)\n", "class Solution:\n  def canSplitArray(self, nums: list[int], m: int) -> bool:\n    return len(nums) < 3 or any(a + b >= m for a, b in itertools.pairwise(nums))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2861, "slug": "maximum-number-of-alloys", "solutions": ["class Solution:\n    def maxNumberOfAlloys(\n        self,\n        n: int,\n        k: int,\n        budget: int,\n        composition: List[List[int]],\n        stock: List[int],\n        cost: List[int],\n    ) -> int:\n        ans = 0\n        for c in composition:\n            l, r = 0, budget + stock[0]\n            while l < r:\n                mid = (l + r + 1) >> 1\n                s = sum(max(0, mid * x - y) * z for x, y, z in zip(c, stock, cost))\n                if s <= budget:\n                    l = mid\n                else:\n                    r = mid - 1\n            ans = max(ans, l)\n        return ans\n", "class Solution:\n  def maxNumberOfAlloys(self, n: int, k: int, budget: int,\n                        composition: list[list[int]], stock: list[int],\n                        costs: list[int]) -> int:\n    l = 1\n    r = 1_000_000_000\n\n    def isPossible(m: int) -> bool:\n      \"\"\"Returns True if it's possible to create `m` alloys by using any machine.\"\"\"\n      # Try all the possible machines.\n      for machine in composition:\n        requiredMoney = 0\n        for j in range(n):\n          requiredUnits = max(0, machine[j] * m - stock[j])\n          requiredMoney += requiredUnits * costs[j]\n        if requiredMoney <= budget:\n          return True\n      return False\n\n    while l < r:\n      m = (l + r) // 2\n      if isPossible(m):\n        l = m + 1\n      else:\n        r = m\n\n    return l - 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2818, "slug": "apply-operations-to-maximize-score", "solutions": ["def primeFactors(n):\n    i = 2\n    ans = set()\n    while i * i <= n:\n        while n % i == 0:\n            ans.add(i)\n            n //= i\n        i += 1\n    if n > 1:\n        ans.add(n)\n    return len(ans)\n\n\nclass Solution:\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        mod = 10**9 + 7\n        arr = [(i, primeFactors(x), x) for i, x in enumerate(nums)]\n        n = len(nums)\n\n        left = [-1] * n\n        right = [n] * n\n        stk = []\n        for i, f, x in arr:\n            while stk and stk[-1][0] < f:\n                stk.pop()\n            if stk:\n                left[i] = stk[-1][1]\n            stk.append((f, i))\n\n        stk = []\n        for i, f, x in arr[::-1]:\n            while stk and stk[-1][0] <= f:\n                stk.pop()\n            if stk:\n                right[i] = stk[-1][1]\n            stk.append((f, i))\n\n        arr.sort(key=lambda x: -x[2])\n        ans = 1\n        for i, f, x in arr:\n            l, r = left[i], right[i]\n            cnt = (i - l) * (r - i)\n            if cnt <= k:\n                ans = ans * pow(x, cnt, mod) % mod\n                k -= cnt\n            else:\n                ans = ans * pow(x, k, mod) % mod\n                break\n        return ans\n", "class Solution:\n  def maximumScore(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    n = len(nums)\n    ans = 1\n    minPrimeFactors = self._sieveEratosthenes(max(nums) + 1)\n    primeScores = [self._getPrimeScore(num, minPrimeFactors) for num in nums]\n    # left[i] := the next index on the left (if any)\n    #            s.t. primeScores[left[i]] >= primeScores[i]\n    left = [-1] * n\n    # right[i] := the next index on the right (if any)\n    #             s.t. primeScores[right[i]] > primeScores[i]\n    right = [n] * n\n    stack = []\n\n    # Find the next indices on the left where `primeScores` are greater or equal.\n    for i in reversed(range(n)):\n      while stack and primeScores[stack[-1]] <= primeScores[i]:\n        left[stack.pop()] = i\n      stack.append(i)\n\n    stack = []\n\n    # Find the next indices on the right where `primeScores` are greater.\n    for i in range(n):\n      while stack and primeScores[stack[-1]] < primeScores[i]:\n        right[stack.pop()] = i\n      stack.append(i)\n\n    numAndIndexes = [(num, i) for i, num in enumerate(nums)]\n\n    def modPow(x: int, n: int) -> int:\n      if n == 0:\n        return 1\n      if n % 2 == 1:\n        return x * modPow(x, n - 1) % MOD\n      return modPow(x * x % MOD, n // 2)\n\n    for num, i in sorted(numAndIndexes, key=lambda x: (-x[0], x[1])):\n      # nums[i] is the maximum value in the range [left[i] + 1, right[i] - 1]\n      # So, there are (i - left[i]) * (right[i] - 1) ranges where nums[i] will\n      # be chosen.\n      rangeCount = (i - left[i]) * (right[i] - i)\n      actualCount = min(rangeCount, k)\n      k -= actualCount\n      ans *= modPow(num, actualCount)\n      ans %= MOD\n\n    return ans\n\n  def _sieveEratosthenes(self, n: int) -> list[int]:\n    \"\"\"Gets the minimum prime factor of i, where 2 <= i <= n.\"\"\"\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:  # `i` is prime.\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeScore(self, num: int, minPrimeFactors: list[int]) -> int:\n    primeFactors = set()\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.add(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return len(primeFactors)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2897, "slug": "apply-operations-on-array-to-maximize-sum-of-squares", "solutions": ["class Solution:\n    def maxSum(self, nums: List[int], k: int) -> int:\n        mod = 10**9 + 7\n        cnt = [0] * 31\n        for x in nums:\n            for i in range(31):\n                if x >> i & 1:\n                    cnt[i] += 1\n        ans = 0\n        for _ in range(k):\n            x = 0\n            for i in range(31):\n                if cnt[i]:\n                    x |= 1 << i\n                    cnt[i] -= 1\n            ans = (ans + x * x) % mod\n        return ans\n", "class Solution:\n  def maxSum(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    MAX_BIT = 30\n    ans = 0\n    # minIndices[i] := the minimum index in `optimalNums` that the i-th bit\n    # should be moved to\n    minIndices = [0] * MAX_BIT\n    optimalNums = [0] * len(nums)\n\n    for num in nums:\n      for i in range(MAX_BIT):\n        if num >> i & 1:\n          optimalNums[minIndices[i]] |= 1 << i\n          minIndices[i] += 1\n\n    for i in range(k):\n      ans += optimalNums[i]**2\n      ans %= MOD\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2851, "slug": "string-transformation", "solutions": ["\"\"\"\nDP, Z-algorithm, Fast mod.\nApproach\nHow to represent a string?\nEach operation is just a rotation. Each result string can be represented by an integer from 0 to n - 1. Namely, it's just the new index of s[0].\nHow to find the integer(s) that can represent string t?\nCreate a new string s + t + t (length = 3 * n).\nUse Z-algorithm (or KMP), for each n <= index < 2 * n, calculate the maximum prefix length that each substring starts from index can match, if the length >= n, then (index - n) is a valid integer representation.\nHow to get the result?\nIt's a very obvious DP.\nIf we use an integer to represent a string, we only need to consider the transition from zero to non-zero and from non-zero to zero. In other words, all the non-zero strings should have the same result.\nSo let dp[t][i = 0/1] be the number of ways to get the zero/nonzero string\nafter excatly t steps.\nThen\ndp[t][0] = dp[t - 1][1] * (n - 1).\nAll the non zero strings can make it.\ndp[t][1] = dp[t - 1][0] + dp[t - 1] * (n - 2).\nFor a particular non zero string, all the other non zero strings and zero string can make it.\nWe have dp[0][0] = 1 and dp[0][1] = 0\nUse matrix multiplication.\nHow to calculate dp[k][x = 0, 1] faster?\nUse matrix multiplication\nvector (dp[t - 1][0], dp[t - 1][1])\nmultiplies matrix\n[0 1]\n[n - 1 n - 2]\n== vector (dp[t][0], dp[t - 1][1]).\nSo we just need to calculate the kth power of the matrix which can be done by fast power algorith.\nComplexity\nTime complexity:\nO(n + logk)\nSpace complexity:\nO(n)\n\"\"\"\n\n\nclass Solution:\n    M: int = 1000000007\n\n    def add(self, x: int, y: int) -> int:\n        x += y\n        if x >= self.M:\n            x -= self.M\n        return x\n\n    def mul(self, x: int, y: int) -> int:\n        return int(x * y % self.M)\n\n    def getZ(self, s: str) -> List[int]:\n        n = len(s)\n        z = [0] * n\n        left = right = 0\n        for i in range(1, n):\n            if i <= right and z[i - left] <= right - i:\n                z[i] = z[i - left]\n            else:\n                z_i = max(0, right - i + 1)\n                while i + z_i < n and s[i + z_i] == s[z_i]:\n                    z_i += 1\n                z[i] = z_i\n            if i + z[i] - 1 > right:\n                left = i\n                right = i + z[i] - 1\n        return z\n\n    def matrixMultiply(self, a: List[List[int]], b: List[List[int]]) -> List[List[int]]:\n        m = len(a)\n        n = len(a[0])\n        p = len(b[0])\n        r = [[0] * p for _ in range(m)]\n        for i in range(m):\n            for j in range(p):\n                for k in range(n):\n                    r[i][j] = self.add(r[i][j], self.mul(a[i][k], b[k][j]))\n        return r\n\n    def matrixPower(self, a: List[List[int]], y: int) -> List[List[int]]:\n        n = len(a)\n        r = [[0] * n for _ in range(n)]\n        for i in range(n):\n            r[i][i] = 1\n        x = [a[i][:] for i in range(n)]\n        while y > 0:\n            if y & 1:\n                r = self.matrixMultiply(r, x)\n            x = self.matrixMultiply(x, x)\n            y >>= 1\n        return r\n\n    def numberOfWays(self, s: str, t: str, k: int) -> int:\n        n = len(s)\n        dp = self.matrixPower([[0, 1], [n - 1, n - 2]], k)[0]\n        s += t + t\n        z = self.getZ(s)\n        m = n + n\n        result = 0\n        for i in range(n, m):\n            if z[i] >= n:\n                result = self.add(result, dp[0] if i - n == 0 else dp[1])\n        return result\n", "class Solution:\n  # This dynamic programming table dp[k][i] represents the number of ways to\n  # rearrange the String s after k steps such that it starts with s[i].\n  # A String can be rotated from 1 to n - 1 times. The transition rule is\n  # dp[k][i] = sum(dp[k - 1][j]) for all j != i. For example, when n = 4 and\n  # k = 3, the table looks like this:\n  #\n  # -----------------------------------------------------------\n  # |       | i = 0 | i = 1 | i = 2 | i = 3 | sum = (n - 1)^k |\n  # -----------------------------------------------------------\n  # | k = 0 |   1   |   0   |   0   |   0   |        1        |\n  # | k = 1 |   0   |   1   |   1   |   1   |        3        |\n  # | k = 2 |   3   |   2   |   2   |   2   |        9        |\n  # | k = 3 |   6   |   7   |   7   |   7   |       27        |\n  # -----------------------------------------------------------\n  #\n  # By observation, we have\n  #   * dp[k][!0] = ((n - 1)^k - (-1)^k) / n\n  #   * dp[k][0] = dp[k][!0] + (-1)^k\n  def numberOfWays(self, s: str, t: str, k: int) -> int:\n    MOD = 1_000_000_007\n    n = len(s)\n    negOnePowK = 1 if k % 2 == 0 else -1  # (-1)^k\n    z = self._zFunction(s + t + t)\n    # indices in `s` s.t. for each `i` in the returned indices,\n    # `s[i..n) + s[0..i) = t`.\n    indices = [i - n for i in range(n, n + n) if z[i] >= n]\n    dp = [0] * 2  # dp[0] := dp[k][0]; dp[1] := dp[k][!0]\n    dp[1] = (pow(n - 1, k, MOD) - negOnePowK) * pow(n, MOD - 2, MOD)\n    dp[0] = dp[1] + negOnePowK\n    return sum(dp[0] if index == 0 else dp[1] for index in indices) % MOD\n\n  def _zFunction(self, s: str) -> list[int]:\n    \"\"\"\n    Returns the z array, where z[i] is the length of the longest prefix of\n    s[i..n) which is also a prefix of s.\n\n    https://cp-algorithms.com/string/z-function.html#implementation\n    \"\"\"\n    n = len(s)\n    z = [0] * n\n    l = 0\n    r = 0\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n    return z\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2849, "slug": "determine-if-a-cell-is-reachable-at-a-given-time", "solutions": ["class Solution:\n    def isReachableAtTime(self, sx: int, sy: int, fx: int, fy: int, t: int) -> bool:\n        if sx == fx and sy == fy:\n            return t != 1\n        dx = abs(sx - fx)\n        dy = abs(sy - fy)\n        return max(dx, dy) <= t\n", "class Solution:\n  def isReachableAtTime(\n      self,\n      sx: int,\n      sy: int,\n      fx: int,\n      fy: int,\n      t: int,\n  ) -> bool:\n    minStep = max(abs(sx - fx), abs(sy - fy))\n    return t != 1 if minStep == 0 else minStep <= t\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2892, "slug": "minimizing-array-after-replacing-pairs-with-their-product", "solutions": ["class Solution:\n    def minArrayLength(self, nums: List[int], k: int) -> int:\n        ans, y = 1, nums[0]\n        for x in nums[1:]:\n            if x == 0:\n                return 1\n            if x * y <= k:\n                y *= x\n            else:\n                y = x\n                ans += 1\n        return ans\n", "class Solution:\n  def minArrayLength(self, nums: list[int], k: int) -> int:\n    count = 0\n    prod = -1\n\n    for num in nums:\n      if num == 0:\n        return 1\n      if prod != -1 and prod * num <= k:\n        prod *= num\n      else:\n        prod = num\n        count += 1\n\n    return count\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2830, "slug": "maximize-the-profit-as-the-salesman", "solutions": ["class Solution:\n    def maximizeTheProfit(self, n: int, offers: List[List[int]]) -> int:\n        offers.sort(key=lambda x: x[1])\n        f = [0] * (len(offers) + 1)\n        g = [x[1] for x in offers]\n        for i, (s, _, v) in enumerate(offers, 1):\n            j = bisect_left(g, s)\n            f[i] = max(f[i - 1], f[j] + v)\n        return f[-1]\n", "class Solution:\n  def maximizeTheProfit(self, n: int, offers: list[list[int]]) -> int:\n    # dp[i] := the maximum amount of gold of selling the first i houses\n    dp = [0] * (n + 1)\n    endToStartAndGolds = [[] for _ in range(n)]\n\n    for start, end, gold in offers:\n      endToStartAndGolds[end].append((start, gold))\n\n    for end in range(1, n + 1):\n      # Get at least the same gold as selling the first `end - 1` houses.\n      dp[end] = dp[end - 1]\n      for start, gold in endToStartAndGolds[end - 1]:\n        dp[end] = max(dp[end], dp[start] + gold)\n\n    return dp[n]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2699, "slug": "modify-graph-edge-weights", "solutions": ["class Solution:\n    def modifiedGraphEdges(\n        self, n: int, edges: List[List[int]], source: int, destination: int, target: int\n    ) -> List[List[int]]:\n        def dijkstra(edges: List[List[int]]) -> int:\n            g = [[inf] * n for _ in range(n)]\n            for a, b, w in edges:\n                if w == -1:\n                    continue\n                g[a][b] = g[b][a] = w\n            dist = [inf] * n\n            dist[source] = 0\n            vis = [False] * n\n            for _ in range(n):\n                k = -1\n                for j in range(n):\n                    if not vis[j] and (k == -1 or dist[k] > dist[j]):\n                        k = j\n                vis[k] = True\n                for j in range(n):\n                    dist[j] = min(dist[j], dist[k] + g[k][j])\n            return dist[destination]\n\n        inf = 2 * 10**9\n        d = dijkstra(edges)\n        if d < target:\n            return []\n        ok = d == target\n        for e in edges:\n            if e[2] > 0:\n                continue\n            if ok:\n                e[2] = inf\n                continue\n            e[2] = 1\n            d = dijkstra(edges)\n            if d <= target:\n                ok = True\n                e[2] += target - d\n        return edges if ok else []\n", "class Solution:\n  def modifiedGraphEdges(self, n: int, edges: list[list[int]], source: int, destination: int, target: int) -> list[list[int]]:\n    MAX = 2_000_000_000\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      if w == -1:\n        continue\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    distToDestination = self._dijkstra(graph, source, destination)\n    if distToDestination < target:\n      return []\n    if distToDestination == target:\n      # Change the weights of negative edges to an impossible value.\n      for edge in edges:\n        if edge[2] == -1:\n          edge[2] = MAX\n      return edges\n\n    for i, (u, v, w) in enumerate(edges):\n      if w != -1:\n        continue\n      edges[i][2] = 1\n      graph[u].append((v, 1))\n      graph[v].append((u, 1))\n      distToDestination = self._dijkstra(graph, source, destination)\n      if distToDestination <= target:\n        edges[i][2] += target - distToDestination\n        # Change the weights of negative edges to an impossible value.\n        for j in range(i + 1, len(edges)):\n          if edges[j][2] == -1:\n            edges[j][2] = MAX\n        return edges\n\n    return []\n\n  def _dijkstra(self, graph: list[list[int]], src: int, dst: int) -> int:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist[dst]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2608, "slug": "shortest-cycle-in-a-graph", "solutions": ["class Solution:\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\n        def bfs(u: int, v: int) -> int:\n            dist = [inf] * n\n            dist[u] = 0\n            q = deque([u])\n            while q:\n                i = q.popleft()\n                for j in g[i]:\n                    if (i, j) != (u, v) and (j, i) != (u, v) and dist[j] == inf:\n                        dist[j] = dist[i] + 1\n                        q.append(j)\n            return dist[v] + 1\n\n        g = defaultdict(set)\n        for u, v in edges:\n            g[u].add(v)\n            g[v].add(u)\n        ans = min(bfs(u, v) for u, v in edges)\n        return ans if ans < inf else -1\n", "class Solution:\n  def findShortestCycle(self, n: int, edges: list[list[int]]) -> int:\n    INF = 1001\n    ans = INF\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    def bfs(i: int) -> int:\n      \"\"\"Returns the length of the minimum cycle by starting BFS from node `i`.\n\n      Returns `INF` if there's no cycle.\n      \"\"\"\n      dist = [INF] * n\n      q = collections.deque([i])\n      dist[i] = 0\n      while q:\n        u = q.popleft()\n        for v in graph[u]:\n          if dist[v] == INF:\n            dist[v] = dist[u] + 1\n            q.append(v)\n          elif dist[v] + 1 != dist[u]:   # v is not a parent u.\n            return dist[v] + dist[u] + 1\n      return INF\n\n    ans = min(map(bfs, range(n)))\n    return -1 if ans == INF else ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2657, "slug": "find-the-prefix-common-array-of-two-arrays", "solutions": ["class Solution:\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\n        ans = []\n        cnt1 = Counter()\n        cnt2 = Counter()\n        for a, b in zip(A, B):\n            cnt1[a] += 1\n            cnt2[b] += 1\n            t = sum(min(v, cnt2[x]) for x, v in cnt1.items())\n            ans.append(t)\n        return ans\n", "class Solution:\n  def findThePrefixCommonArray(self, A: list[int], B: list[int]) -> list[int]:\n    n = len(A)\n    prefixCommon = 0\n    ans = []\n    count = [0] * (n + 1)\n\n    for a, b in zip(A, B):\n      count[a] += 1\n      if count[a] == 2:\n        prefixCommon += 1\n      count[b] += 1\n      if count[b] == 2:\n        prefixCommon += 1\n      ans.append(prefixCommon)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2661, "slug": "first-completely-painted-row-or-column", "solutions": ["class Solution:\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\n        m, n = len(mat), len(mat[0])\n        idx = {}\n        for i in range(m):\n            for j in range(n):\n                idx[mat[i][j]] = (i, j)\n        row = [0] * m\n        col = [0] * n\n        for k in range(len(arr)):\n            i, j = idx[arr[k]]\n            row[i] += 1\n            col[j] += 1\n            if row[i] == n or col[j] == m:\n                return k\n", "class Solution:\n  def firstCompleteIndex(self, arr: list[int], mat: list[list[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    # rows[i] := the number of painted grid in the i-th row\n    rows = [0] * m\n    # cols[j] := the number of painted grid in the j-th column\n    cols = [0] * n\n    # numToRow[num] := the i-th row of `num` in `mat`\n    numToRow = [0] * (m * n + 1)\n    # numToCol[num] := the j-th column of `num` in `mat`\n    numToCol = [0] * (m * n + 1)\n\n    for i, row in enumerate(mat):\n      for j, num in enumerate(row):\n        numToRow[num] = i\n        numToCol[num] = j\n\n    for i, a in enumerate(arr):\n      rows[numToRow[a]] += 1\n      if rows[numToRow[a]] == n:\n        return i\n      cols[numToCol[a]] += 1\n      if cols[numToCol[a]] == m:\n        return i\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2692, "slug": "make-object-immutable", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2644, "slug": "find-the-maximum-divisibility-score", "solutions": ["class Solution:\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\n        ans, mx = divisors[0], 0\n        for div in divisors:\n            cnt = sum(x % div == 0 for x in nums)\n            if mx < cnt:\n                mx, ans = cnt, div\n            elif mx == cnt and ans > div:\n                ans = div\n        return ans\n", "class Solution:\n  def maxDivScore(self, nums: list[int], divisors: list[int]) -> int:\n    ans = -1\n    maxScore = -1\n\n    for divisor in divisors:\n      score = sum([1 for num in nums if num % divisor == 0])\n      if score > maxScore:\n        ans = divisor\n        maxScore = score\n      elif score == maxScore:\n        ans = min(ans, divisor)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2643, "slug": "row-with-maximum-ones", "solutions": ["class Solution:\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\n        ans = [0, 0]\n        for i, row in enumerate(mat):\n            cnt = sum(row)\n            if ans[1] < cnt:\n                ans = [i, cnt]\n        return ans\n", "class Solution:\n  def rowAndMaximumOnes(self, mat: list[list[int]]) -> list[int]:\n    ans = [0, 0]\n\n    for i, row in enumerate(mat):\n      ones = row.count(1)\n      if ones > ans[1]:\n        ans[0] = i\n        ans[1] = ones\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2659, "slug": "make-array-empty", "solutions": ["class Solution:\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\n        pos = {x: i for i, x in enumerate(nums)}\n        nums.sort()\n        sl = SortedList()\n        ans = pos[nums[0]] + 1\n        n = len(nums)\n        for k, (a, b) in enumerate(pairwise(nums)):\n            i, j = pos[a], pos[b]\n            d = j - i - sl.bisect(j) + sl.bisect(i)\n            ans += d + (n - k) * int(i > j)\n            sl.add(i)\n        return ans\n", "class Solution:\n  def countOperationsToEmptyArray(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = n\n    numToIndex = {}\n\n    for i, num in enumerate(nums):\n      numToIndex[num] = i\n\n    nums.sort()\n\n    for i in range(1, n):\n      # On the i-th step we've already removed the i - 1 smallest numbers and\n      # can ignore them. If an element nums[i] has smaller index in origin\n      # array than nums[i - 1], we should rotate the whole left array n - i\n      # times to set nums[i] element on the first position.\n      if numToIndex[nums[i]] < numToIndex[nums[i - 1]]:\n        ans += n - i\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2673, "slug": "make-costs-of-paths-equal-in-a-binary-tree", "solutions": ["class Solution:\n    def minIncrements(self, n: int, cost: List[int]) -> int:\n        ans = 0\n        for i in range(n >> 1, 0, -1):\n            l, r = i << 1, i << 1 | 1\n            ans += abs(cost[l - 1] - cost[r - 1])\n            cost[i - 1] += max(cost[l - 1], cost[r - 1])\n        return ans\n", "class Solution:\n  def minIncrements(self, n: int, cost: list[int]) -> int:\n    ans = 0\n\n    for i in range(n // 2 - 1, -1, -1):\n      l = i * 2 + 1\n      r = i * 2 + 2\n      ans += abs(cost[l] - cost[r])\n      # Record the information in the parent from the children. So, there's need to actually\n      # update the values in the children.\n      cost[i] += max(cost[l], cost[r])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2665, "slug": "counter-ii", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2666, "slug": "allow-one-function-call", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2683, "slug": "neighboring-bitwise-xor", "solutions": ["class Solution:\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\n        return reduce(xor, derived) == 0\n", "class Solution:\n  def doesValidArrayExist(self, derived: list[int]) -> bool:\n    return functools.reduce(operator.xor, derived) == 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2618, "slug": "check-if-object-instance-of-class", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2622, "slug": "cache-with-time-limit", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2675, "slug": "array-of-objects-to-matrix", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2656, "slug": "maximum-sum-with-exactly-k-elements", "solutions": ["class Solution:\n    def maximizeSum(self, nums: List[int], k: int) -> int:\n        x = max(nums)\n        return k * x + k * (k - 1) // 2\n", "class Solution:\n  def maximizeSum(self, nums: list[int], k: int) -> int:\n    return max(nums) * k + k * (k - 1) // 2\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2680, "slug": "maximum-or", "solutions": ["class Solution:\n    def maximumOr(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        suf = [0] * (n + 1)\n        for i in range(n - 1, -1, -1):\n            suf[i] = suf[i + 1] | nums[i]\n        ans = pre = 0\n        for i, x in enumerate(nums):\n            ans = max(ans, pre | (x << k) | suf[i + 1])\n            pre |= x\n        return ans\n", "class Solution:\n  def maximumOr(self, nums: list[int], k: int) -> int:\n    n = len(nums)\n    # prefix[i] := nums[0] | nums[1] | ... | nums[i - 1]\n    prefix = [0] * n\n    # suffix[i] := nums[i + 1] | nums[i + 2] | ... nums[n - 1]\n    suffix = [0] * n\n\n    for i in range(1, n):\n      prefix[i] = prefix[i - 1] | nums[i - 1]\n\n    for i in range(n - 2, -1, -1):\n      suffix[i] = suffix[i + 1] | nums[i + 1]\n\n    # For each num, greedily shift it left by k bits.\n    return max(p | num << k | s for num, p, s in zip(nums, prefix, suffix))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2697, "slug": "lexicographically-smallest-palindrome", "solutions": ["class Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        cs = list(s)\n        i, j = 0, len(s) - 1\n        while i < j:\n            cs[i] = cs[j] = min(cs[i], cs[j])\n            i, j = i + 1, j - 1\n        return \"\".join(cs)\n", "class Solution:\n  def makeSmallestPalindrome(self, s: str) -> str:\n    chars = list(s)\n    i = 0\n    j = len(s) - 1\n\n    while i < j:\n      minChar = min(chars[i], chars[j])\n      chars[i] = minChar\n      chars[j] = minChar\n      i += 1\n      j -= 1\n\n    return ''.join(chars)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2631, "slug": "group-by", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2668, "slug": "find-latest-salaries", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2690, "slug": "infinite-method-object", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2604, "slug": "minimum-time-to-eat-all-grains", "solutions": ["class Solution:\n    def minimumTime(self, hens: List[int], grains: List[int]) -> int:\n        def check(t):\n            j = 0\n            for x in hens:\n                if j == m:\n                    return True\n                y = grains[j]\n                if y <= x:\n                    d = x - y\n                    if d > t:\n                        return False\n                    while j < m and grains[j] <= x:\n                        j += 1\n                    while j < m and min(d, grains[j] - x) + grains[j] - y <= t:\n                        j += 1\n                else:\n                    while j < m and grains[j] - x <= t:\n                        j += 1\n            return j == m\n\n        hens.sort()\n        grains.sort()\n        m = len(grains)\n        r = abs(hens[0] - grains[0]) + grains[-1] - grains[0] + 1\n        return bisect_left(range(r), True, key=check)\n", "class Solution:\n  def minimumTime(self, hens: list[int], grains: list[int]) -> int:\n    hens.sort()\n    grains.sort()\n\n    def canEat(time: int) -> bool:\n      \"\"\"Returns True if `hens` can eat all `grains` within `time`.\"\"\"\n      i = 0  # grains[i] := next grain to be ate\n      for hen in hens:\n        rightMoves = time\n        if grains[i] < hen:\n          # `hen` needs go back to eat `grains[i]`.\n          leftMoves = hen - grains[i]\n          if leftMoves > time:\n            return False\n          leftThenRight = time - 2 * leftMoves\n          rightThenLeft = (time - leftMoves) // 2\n          rightMoves = max(0, leftThenRight, rightThenLeft)\n        i = bisect.bisect_right(grains, hen + rightMoves)\n        if i == len(grains):\n          return True\n      return False\n\n    maxMoves = int(1.5 * (max(hens + grains) - min(hens + grains)))\n    return bisect.bisect_left(range(maxMoves), True, key=canEat)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2602, "slug": "minimum-operations-to-make-all-array-elements-equal", "solutions": ["class Solution:\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\n        nums.sort()\n        s = list(accumulate(nums, initial=0))\n        ans = []\n        for x in queries:\n            i = bisect_left(nums, x + 1)\n            t = s[-1] - s[i] - (len(nums) - i) * x\n            i = bisect_left(nums, x)\n            t += x * i - s[i]\n            ans.append(t)\n        return ans\n", "class Solution:\n  def minOperations(self, nums: list[int], queries: list[int]) -> list[int]:\n    n = len(nums)\n    nums.sort()\n    prefix = list(itertools.accumulate(nums, initial=0))\n    splits = [(query, bisect.bisect_right(nums, query)) for query in queries]\n    return [(query * i - prefix[i]) +\n            (prefix[-1] - prefix[i] - query * (n - i))\n            for query, i in splits]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2691, "slug": "immutability-helper", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2672, "slug": "number-of-adjacent-elements-with-the-same-color", "solutions": ["class Solution:\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\n        nums = [0] * n\n        ans = [0] * len(queries)\n        x = 0\n        for k, (i, c) in enumerate(queries):\n            if i > 0 and nums[i] and nums[i - 1] == nums[i]:\n                x -= 1\n            if i < n - 1 and nums[i] and nums[i + 1] == nums[i]:\n                x -= 1\n            if i > 0 and nums[i - 1] == c:\n                x += 1\n            if i < n - 1 and nums[i + 1] == c:\n                x += 1\n            ans[k] = x\n            nums[i] = c\n        return ans\n", "class Solution:\n  def colorTheArray(self, n: int, queries: list[list[int]]) -> list[int]:\n    ans = []\n    arr = [0] * n\n    sameColors = 0\n\n    for i, color in queries:\n      if i + 1 < n:\n        if arr[i + 1] > 0 and arr[i + 1] == arr[i]:\n          sameColors -= 1\n        if arr[i + 1] == color:\n          sameColors += 1\n      if i > 0:\n        if arr[i - 1] > 0 and arr[i - 1] == arr[i]:\n          sameColors -= 1\n        if arr[i - 1] == color:\n          sameColors += 1\n      arr[i] = color\n      ans.append(sameColors)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2693, "slug": "call-function-with-custom-context", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2676, "slug": "throttle", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2652, "slug": "sum-multiples", "solutions": ["class Solution:\n    def sumOfMultiples(self, n: int) -> int:\n        return sum(x for x in range(1, n + 1) if x % 3 == 0 or x % 5 == 0 or x % 7 == 0)\n", "class Solution:\n  def sumOfMultiples(self, n: int) -> int:\n    ans = 0\n    for i in range(1, n + 1):\n      if i % 3 == 0 or i % 5 == 0 or i % 7 == 0:\n        ans += i\n    return ans\n", "class Solution:\n  def sumOfMultiples(self, n: int) -> int:\n    def sumOfMultiples(value: int) -> int:\n      \"\"\"Returns the sum of multiples of value in [1, n].\"\"\"\n      lo = value\n      hi = (n // value) * value\n      count = (hi - lo) // value + 1\n      return (lo + hi) * count // 2\n\n    return (sumOfMultiples(3) + sumOfMultiples(5) + sumOfMultiples(7) -\n            (sumOfMultiples(15) + sumOfMultiples(21) + sumOfMultiples(35)) +\n            sumOfMultiples(105))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2607, "slug": "make-k-subarray-sums-equal", "solutions": ["class Solution:\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n        g = gcd(n, k)\n        ans = 0\n        for i in range(g):\n            t = sorted(arr[i:n:g])\n            mid = t[len(t) >> 1]\n            ans += sum(abs(x - mid) for x in t)\n        return ans\n", "class Solution:\n  def makeSubKSumEqual(self, arr: list[int], k: int) -> int:\n    # If the sum of each subarray of length k is equal, then `arr` must have a\n    # repeated pattern of size k. e.g. arr = [1, 2, 3, ...] and k = 3, to have\n    # sum([1, 2, 3)] == sum([2, 3, x]), x must be 1. Therefore, arr[i] ==\n    # arr[(i + k) % n] for every i.\n    n = len(arr)\n    ans = 0\n    seen = [0] * n\n\n    for i in range(n):\n      groups = []\n      j = i\n      while not seen[j]:\n        groups.append(arr[j])\n        seen[j] = True\n        j = (j + k) % n\n      groups.sort()\n      for num in groups:\n        ans += abs(num - groups[len(groups) // 2])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2641, "slug": "cousins-in-binary-tree-ii", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        def dfs1(root: Optional[TreeNode], depth: int):\n            if root is None:\n                return\n            if len(s) <= depth:\n                s.append(0)\n            s[depth] += root.val\n            dfs1(root.left, depth + 1)\n            dfs1(root.right, depth + 1)\n\n        def dfs2(root: Optional[TreeNode], depth: int):\n            sub = (root.left.val if root.left else 0) + (\n                root.right.val if root.right else 0\n            )\n            depth += 1\n            if root.left:\n                root.left.val = s[depth] - sub\n                dfs2(root.left, depth)\n            if root.right:\n                root.right.val = s[depth] - sub\n                dfs2(root.right, depth)\n\n        s = []\n        dfs1(root, 0)\n        root.val = 0\n        dfs2(root, 0)\n        return root\n", "class Solution:\n  def replaceValueInTree(self, root: TreeNode | None) -> TreeNode | None:\n    levelSums = []\n\n    def dfs(root: TreeNode | None, level: int) -> None:\n      if not root:\n        return\n      if len(levelSums) == level:\n        levelSums.append(0)\n      levelSums[level] += root.val\n      dfs(root.left, level + 1)\n      dfs(root.right, level + 1)\n\n    def replace(\n        root: TreeNode | None,\n        level: int, curr: TreeNode | None,\n    ) -> TreeNode | None:\n      nextLevel = level + 1\n      nextLevelCousinsSum = (\n          (levelSums[nextLevel] if nextLevel < len(levelSums) else 0) -\n          (root.left.val if root.left else 0) -\n          (root.right.val if root.right else 0))\n      if root.left:\n        curr.left = TreeNode(nextLevelCousinsSum)\n        replace(root.left, level + 1, curr.left)\n      if root.right:\n        curr.right = TreeNode(nextLevelCousinsSum)\n        replace(root.right, level + 1, curr.right)\n      return curr\n\n    dfs(root, 0)\n    return replace(root, 0, TreeNode(0))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2698, "slug": "find-the-punishment-number-of-an-integer", "solutions": ["class Solution:\n    def punishmentNumber(self, n: int) -> int:\n        def check(s: str, i: int, x: int) -> bool:\n            m = len(s)\n            if i >= m:\n                return x == 0\n            y = 0\n            for j in range(i, m):\n                y = y * 10 + int(s[j])\n                if y > x:\n                    break\n                if check(s, j + 1, x - y):\n                    return True\n            return False\n\n        ans = 0\n        for i in range(1, n + 1):\n            x = i * i\n            if check(str(x), 0, i):\n                ans += x\n        return ans\n", "class Solution:\n  def punishmentNumber(self, n: int) -> int:\n    def isPossible(\n            accumulate: int, running: int, numChars: list[str],\n            s: int, target: int) -> bool:\n      \"\"\"\n      Returns True if the sum of any split of `numChars` equals to the target.\n      \"\"\"\n      if s == len(numChars):\n        return target == accumulate + running\n      d = int(numChars[s])\n      return (\n          # Keep growing `running`.\n          isPossible(accumulate, running * 10 + d, numChars, s + 1, target) or\n          # Start a new `running`.\n          isPossible(accumulate + running, d, numChars, s + 1, target)\n      )\n\n    return sum(i * i\n               for i in range(1, n + 1)\n               if isPossible(0, 0, str(i * i), 0, i))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2621, "slug": "sleep", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2674, "slug": "split-a-circular-linked-list", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def splitCircularLinkedList(\n        self, list: Optional[ListNode]\n    ) -> List[Optional[ListNode]]:\n        a = b = list\n        while b.next != list and b.next.next != list:\n            a = a.next\n            b = b.next.next\n        if b.next != list:\n            b = b.next\n        list2 = a.next\n        b.next = list2\n        a.next = list\n        return [list, list2]\n", "class Solution:\n  def splitCircularLinkedList(self, list: ListNode | None) -> list[ListNode | None]:\n    slow = list\n    fast = list\n\n    # Point `slow` to the last node in the first half.\n    while fast.next != list and fast.next.next != list:\n      slow = slow.next\n      fast = fast.next.next\n\n    # Circle back the second half.\n    secondHead = slow.next\n    if fast.next == list:\n      fast.next = secondHead\n    else:\n      fast.next.next = secondHead\n\n    # Circle back the first half.\n    slow.next = list\n\n    return [list, secondHead]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2679, "slug": "sum-in-a-matrix", "solutions": ["class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        for row in nums:\n            row.sort()\n        return sum(map(max, zip(*nums)))\n", "class Solution:\n  def matrixSum(self, nums: list[list[int]]) -> int:\n    for row in nums:\n      row.sort()\n\n    return sum(max(col) for col in zip(*nums))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2628, "slug": "json-deep-equal", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2616, "slug": "minimize-the-maximum-difference-of-pairs", "solutions": ["class Solution:\n    def minimizeMax(self, nums: List[int], p: int) -> int:\n        def check(diff: int) -> bool:\n            cnt = i = 0\n            while i < len(nums) - 1:\n                if nums[i + 1] - nums[i] <= diff:\n                    cnt += 1\n                    i += 2\n                else:\n                    i += 1\n            return cnt >= p\n\n        nums.sort()\n        return bisect_left(range(nums[-1] - nums[0] + 1), True, key=check)\n", "class Solution:\n  def minimizeMax(self, nums: list[int], p: int) -> int:\n    nums.sort()\n\n    def numPairs(maxDiff: int) -> int:\n      \"\"\"\n      Returns the number of pairs that can be obtained if the difference between\n      each pair <= `maxDiff`.\n      \"\"\"\n      pairs = 0\n      i = 1\n      while i < len(nums):\n        # Greedily pair nums[i] with nums[i - 1].\n        if nums[i] - nums[i - 1] <= maxDiff:\n          pairs += 1\n          i += 2\n        else:\n          i += 1\n      return pairs\n\n    return bisect.bisect_left(range(nums[-1] - nums[0]), p, key=numPairs)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2640, "slug": "find-the-score-of-all-prefixes-of-an-array", "solutions": ["class Solution:\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        ans = [0] * n\n        mx = 0\n        for i, x in enumerate(nums):\n            mx = max(mx, x)\n            ans[i] = x + mx + (0 if i == 0 else ans[i - 1])\n        return ans\n", "class Solution:\n  def findPrefixScore(self, nums: list[int]) -> list[int]:\n    conver = []\n    mx = 0\n\n    for num in nums:\n      mx = max(mx, num)\n      conver.append(num + mx)\n\n    return itertools.accumulate(conver)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2605, "slug": "form-smallest-number-from-two-digit-arrays", "solutions": ["class Solution:\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\n        ans = 100\n        for a in nums1:\n            for b in nums2:\n                if a == b:\n                    ans = min(ans, a)\n                else:\n                    ans = min(ans, 10 * a + b, 10 * b + a)\n        return ans\n", "class Solution:\n  def minNumber(self, nums1: list[int], nums2: list[int]) -> int:\n    return min(a if a == b else min(a, b) * 10 + max(a, b)\n               for a in nums1\n               for b in nums2)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2620, "slug": "counter", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2647, "slug": "color-the-triangle-red", "solutions": ["class Solution:\n    def colorRed(self, n: int) -> List[List[int]]:\n        ans = [[1, 1]]\n        k = 0\n        for i in range(n, 1, -1):\n            if k == 0:\n                for j in range(1, i << 1, 2):\n                    ans.append([i, j])\n            elif k == 1:\n                ans.append([i, 2])\n            elif k == 2:\n                for j in range(3, i << 1, 2):\n                    ans.append([i, j])\n            else:\n                ans.append([i, 1])\n            k = (k + 1) % 4\n        return ans\n", "class Solution:\n  def colorRed(self, n: int) -> list[list[int]]:\n    ans = []\n    tipSize = n % 4\n\n    # The tip of the triangle is always painted red.\n    if tipSize >= 1:\n      ans.append([1, 1])\n\n    # Pamost right and most left elements at the following rows.\n    for i in range(2, tipSize + 1):\n      ans.append([i, 1])\n      ans.append([i, 2 * i - 1])\n\n    # Pa4-row chunks.\n    for i in range(tipSize + 1, n, 4):\n      # Fill the first row of the chunk.\n      ans.append([i, 1])\n      # Fill the second row.\n      for j in range(1, i + 1):\n        ans.append([i + 1, 2 * j + 1])\n      # Fill the third row.\n      ans.append([i + 2, 2])\n      # Fill the fourth row.\n      for j in range(i + 2 + 1):\n        ans.append([i + 3, 2 * j + 1])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2623, "slug": "memoize", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2667, "slug": "create-hello-world-function", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2662, "slug": "minimum-cost-of-a-path-with-special-roads", "solutions": ["class Solution:\n    def minimumCost(\n        self, start: List[int], target: List[int], specialRoads: List[List[int]]\n    ) -> int:\n        def dist(x1: int, y1: int, x2: int, y2: int) -> int:\n            return abs(x1 - x2) + abs(y1 - y2)\n\n        q = [(0, start[0], start[1])]\n        vis = set()\n        ans = inf\n        while q:\n            d, x, y = heappop(q)\n            if (x, y) in vis:\n                continue\n            vis.add((x, y))\n            ans = min(ans, d + dist(x, y, *target))\n            for x1, y1, x2, y2, cost in specialRoads:\n                heappush(q, (d + dist(x, y, x1, y1) + cost, x2, y2))\n        return ans\n", "class Solution:\n  def minimumCost(\n      self,\n      start: list[int],\n      target: list[int],\n      specialRoads: list[list[int]],\n  ) -> int:\n    return self.dijkstra(specialRoads, *start, *target)\n\n  def dijkstra(\n      self,\n      specialRoads: list[list[int]],\n      srcX: int,\n      srcY: int,\n      dstX: int,\n      dstY: int,\n  ) -> int:\n    n = len(specialRoads)\n    # dist[i] := the minimum distance of (srcX, srcY) to specialRoads[i](x2, y2)\n    dist = [math.inf] * n\n    minHeap = []  # (d, u), where u := the i-th specialRoads\n\n    # (srcX, srcY) -> (x1, y1) to cost -> (x2, y2)\n    for u, (x1, y1, _, _, cost) in enumerate(specialRoads):\n      d = abs(x1 - srcX) + abs(y1 - srcY) + cost\n      dist[u] = d\n      heapq.heappush(minHeap, (dist[u], u))\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      _, _, ux2, uy2, _ = specialRoads[u]\n      for v in range(n):\n        if v == u:\n          continue\n        vx1, vy1, _, _, vcost = specialRoads[v]\n        # (ux2, uy2) -> (vx1, vy1) to vcost -> (vx2, vy2)\n        newDist = d + abs(vx1 - ux2) + abs(vy1 - uy2) + vcost\n        if newDist < dist[v]:\n          dist[v] = newDist\n          heapq.heappush(minHeap, (dist[v], v))\n\n    ans = abs(dstX - srcX) + abs(dstY - srcY)\n    for u in range(n):\n      _, _, x2, y2, _ = specialRoads[u]\n      # (srcX, srcY) -> (x2, y2) -> (dstX, dstY).\n      ans = min(ans, dist[u] + abs(dstX - x2) + abs(dstY - y2))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2682, "slug": "find-the-losers-of-the-circular-game", "solutions": ["class Solution:\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\n        vis = [False] * n\n        i, p = 0, 1\n        while not vis[i]:\n            vis[i] = True\n            i = (i + p * k) % n\n            p += 1\n        return [i + 1 for i in range(n) if not vis[i]]\n", "class Solution:\n  def circularGameLosers(self, n: int, k: int) -> list[int]:\n    seen = [False] * n\n    friendIndex = 0\n    turn = 1\n\n    while not seen[friendIndex]:\n      seen[friendIndex] = True\n      friendIndex += turn * k\n      friendIndex %= n\n      turn += 1\n\n    return [friendIndex + 1\n            for friendIndex in range(n)\n            if not seen[friendIndex]]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2681, "slug": "power-of-heroes", "solutions": ["class Solution:\n    def sumOfPower(self, nums: List[int]) -> int:\n        mod = 10**9 + 7\n        nums.sort()\n        ans = 0\n        p = 0\n        for x in nums[::-1]:\n            ans = (ans + (x * x % mod) * x) % mod\n            ans = (ans + x * p) % mod\n            p = (p * 2 + x * x) % mod\n        return ans\n", "class Solution:\n  def sumOfPower(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    summ = 0\n\n    for num in sorted(nums):\n      ans += (num + summ) * num**2\n      ans %= MOD\n      summ = (summ * 2 + num) % MOD\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2685, "slug": "count-the-number-of-complete-components", "solutions": ["class Solution:\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\n        def dfs(i: int) -> (int, int):\n            vis[i] = True\n            x, y = 1, len(g[i])\n            for j in g[i]:\n                if not vis[j]:\n                    a, b = dfs(j)\n                    x += a\n                    y += b\n            return x, y\n\n        g = defaultdict(list)\n        for a, b in edges:\n            g[a].append(b)\n            g[b].append(a)\n        vis = [False] * n\n        ans = 0\n        for i in range(n):\n            if not vis[i]:\n                a, b = dfs(i)\n                ans += a * (a - 1) == b\n        return ans\n", "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n    self.nodeCount = [1] * n\n    self.edgeCount = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    self.edgeCount[i] += 1\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n      self.edgeCount[j] += self.edgeCount[i]\n      self.nodeCount[j] += self.nodeCount[i]\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n      self.edgeCount[i] += self.edgeCount[j]\n      self.nodeCount[i] += self.nodeCount[j]\n    else:\n      self.id[i] = j\n      self.edgeCount[j] += self.edgeCount[i]\n      self.nodeCount[j] += self.nodeCount[i]\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n  def isComplete(self, u):\n    return self.nodeCount[u] * (self.nodeCount[u] - 1) // 2 == self.edgeCount[u]\n\n\nclass Solution:\n  def countCompleteComponents(self, n: int, edges: list[list[int]]) -> int:\n    ans = 0\n    uf = UnionFind(n)\n    parents = set()\n\n    for u, v in edges:\n      uf.unionByRank(u, v)\n\n    for i in range(n):\n      parent = uf.find(i)\n      if parent not in parents and uf.isComplete(parent):\n        ans += 1\n        parents.add(parent)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2615, "slug": "sum-of-distances", "solutions": ["class Solution:\n    def distance(self, nums: List[int]) -> List[int]:\n        d = defaultdict(list)\n        for i, x in enumerate(nums):\n            d[x].append(i)\n        ans = [0] * len(nums)\n        for idx in d.values():\n            left, right = 0, sum(idx) - len(idx) * idx[0]\n            for i in range(len(idx)):\n                ans[idx[i]] = left + right\n                if i + 1 < len(idx):\n                    left += (idx[i + 1] - idx[i]) * (i + 1)\n                    right -= (idx[i + 1] - idx[i]) * (len(idx) - i - 1)\n        return ans\n", "class Solution:\n  def distance(self, nums: list[int]) -> list[int]:\n    ans = [0] * len(nums)\n    numToIndices = collections.defaultdict(list)\n\n    for i, num in enumerate(nums):\n      numToIndices[num].append(i)\n\n    for indices in numToIndices.values():\n      n = len(indices)\n      if n == 1:\n        continue\n      sumSoFar = sum(indices)\n      prevIndex = 0\n      for i in range(n):\n        sumSoFar += (i - 1) * (indices[i] - prevIndex)\n        sumSoFar -= (n - 1 - i) * (indices[i] - prevIndex)\n        ans[indices[i]] = sumSoFar\n        prevIndex = indices[i]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2600, "slug": "k-items-with-the-maximum-sum", "solutions": ["class Solution:\n    def kItemsWithMaximumSum(\n        self, numOnes: int, numZeros: int, numNegOnes: int, k: int\n    ) -> int:\n        if numOnes >= k:\n            return k\n        if numZeros >= k - numOnes:\n            return numOnes\n        return numOnes - (k - numOnes - numZeros)\n", "class Solution:\n  def kItemsWithMaximumSum(\n      self,\n      numOnes: int,\n      numZeros: int,\n      numNegOnes: int,\n      k: int,\n  ) -> int:\n    if k <= numOnes:\n      return k\n    if k <= numOnes + numZeros:\n      return numOnes\n    return numOnes - (k - numOnes - numZeros)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2633, "slug": "convert-object-to-json-string", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2611, "slug": "mice-and-cheese", "solutions": ["class Solution:\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\n        n = len(reward1)\n        idx = sorted(range(n), key=lambda i: reward1[i] - reward2[i], reverse=True)\n        return sum(reward1[i] for i in idx[:k]) + sum(reward2[i] for i in idx[k:])\n", "class Solution:\n  def miceAndCheese(\n      self,\n      reward1: list[int],\n      reward2: list[int],\n      k: int,\n  ) -> int:\n    return (sum(reward2) +\n            sum(heapq.nlargest(k, (a - b for a, b in zip(reward1, reward2)))))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2638, "slug": "count-the-number-of-k-free-subsets", "solutions": ["class Solution:\n    def countTheNumOfKFreeSubsets(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        g = defaultdict(list)\n        for x in nums:\n            g[x % k].append(x)\n        ans = 1\n        for arr in g.values():\n            m = len(arr)\n            f = [0] * (m + 1)\n            f[0] = 1\n            f[1] = 2\n            for i in range(2, m + 1):\n                if arr[i - 1] - arr[i - 2] == k:\n                    f[i] = f[i - 1] + f[i - 2]\n                else:\n                    f[i] = f[i - 1] * 2\n            ans *= f[m]\n        return ans\n", "class Solution:\n  def countTheNumOfKFreeSubsets(self, nums: list[int], k: int) -> int:\n    modToSubset = collections.defaultdict(set)\n\n    for num in nums:\n      modToSubset[num % k].add(num)\n\n    prevNum = -k\n    skip = 0\n    pick = 0\n\n    for subset in modToSubset.values():\n      for num in sorted(subset):\n        skip, pick = (skip + pick,\n                      1 + skip + (0 if num - prevNum == k else pick))\n        prevNum = num\n\n    return 1 + skip + pick\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2645, "slug": "minimum-additions-to-make-valid-string", "solutions": ["class Solution:\n    def addMinimum(self, word: str) -> int:\n        s = 'abc'\n        ans, n = 0, len(word)\n        i = j = 0\n        while j < n:\n            if word[j] != s[i]:\n                ans += 1\n            else:\n                j += 1\n            i = (i + 1) % 3\n        if word[-1] != 'c':\n            ans += 1 if word[-1] == 'b' else 2\n        return ans\n", "class Solution:\n  def addMinimum(self, word: str) -> int:\n    letters = ['a', 'b', 'c']\n    ans = 0\n    i = 0\n\n    while i < len(word):\n      for c in letters:\n        if i < len(word) and word[i] == c:\n          i += 1\n        else:\n          ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2655, "slug": "find-maximal-uncovered-ranges", "solutions": ["class Solution:\n    def findMaximalUncoveredRanges(\n        self, n: int, ranges: List[List[int]]\n    ) -> List[List[int]]:\n        ranges.sort()\n        last = -1\n        ans = []\n        for l, r in ranges:\n            if last + 1 < l:\n                ans.append([last + 1, l - 1])\n            last = max(last, r)\n        if last + 1 < n:\n            ans.append([last + 1, n - 1])\n        return ans\n", "class Solution:\n  def findMaximalUncoveredRanges(self, n: int, ranges: list[list[int]]) -> list[list[int]]:\n    ans = []\n    start = 0\n\n    for l, r in sorted(ranges):\n      if start < l:\n        ans.append([start, l - 1])\n      if start <= r:\n        start = r + 1\n\n    if start < n:\n      ans.append([start, n - 1])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2626, "slug": "array-reduce-transformation", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2650, "slug": "design-cancellable-function", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2614, "slug": "prime-in-diagonal", "solutions": ["class Solution:\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\n        def is_prime(x: int) -> bool:\n            if x < 2:\n                return False\n            return all(x % i for i in range(2, int(sqrt(x)) + 1))\n\n        n = len(nums)\n        ans = 0\n        for i, row in enumerate(nums):\n            if is_prime(row[i]):\n                ans = max(ans, row[i])\n            if is_prime(row[n - i - 1]):\n                ans = max(ans, row[n - i - 1])\n        return ans\n", "class Solution:\n  def diagonalPrime(self, nums: list[list[int]]) -> int:\n    def isPrime(n: int) -> bool:\n      if n <= 1:\n        return False\n      for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n          return False\n      return True\n\n    primes1 = [row[i]\n               for i, row in enumerate(nums) if isPrime(row[i])]\n    primes2 = [row[-1 - i]\n               for i, row in enumerate(nums) if isPrime(row[-1 - i])]\n    return max(max(primes1) if primes1 else 0,\n               max(primes2) if primes2 else 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2663, "slug": "lexicographically-smallest-beautiful-string", "solutions": ["class Solution:\n    def smallestBeautifulString(self, s: str, k: int) -> str:\n        n = len(s)\n        cs = list(s)\n        for i in range(n - 1, -1, -1):\n            p = ord(cs[i]) - ord('a') + 1\n            for j in range(p, k):\n                c = chr(ord('a') + j)\n                if (i > 0 and cs[i - 1] == c) or (i > 1 and cs[i - 2] == c):\n                    continue\n                cs[i] = c\n                for l in range(i + 1, n):\n                    for m in range(k):\n                        c = chr(ord('a') + m)\n                        if (l > 0 and cs[l - 1] == c) or (l > 1 and cs[l - 2] == c):\n                            continue\n                        cs[l] = c\n                        break\n                return ''.join(cs)\n        return ''\n", "class Solution:\n  def smallestBeautifulString(self, s: str, k: int) -> str:\n    chars = list(s)\n\n    for i in reversed(range(len(chars))):\n      chars[i] = chr(ord(chars[i]) + 1)\n      while self._containsPalindrome(chars, i):\n        chars[i] = chr(ord(chars[i]) + 1)\n      if chars[i] < chr(ord('a') + k):\n        # If s[i] is among the first k letters, then change the letters after\n        # s[i] to the smallest ones that don't form any palindrome substring.\n        return self._changeSuffix(chars, i + 1)\n\n    return ''\n\n  def _containsPalindrome(self, chars: list[str], i: int) -> bool:\n    \"\"\"Returns True if chars[0..i] contains palindrome.\"\"\"\n    return ((i > 0 and chars[i] == chars[i - 1]) or\n            (i > 1 and chars[i] == chars[i - 2]))\n\n  def _changeSuffix(self, chars: list[str], i: int) -> str:\n    \"\"\"\n    Returns a string, where replacing sb[i..n) with the smallest possible\n    letters don't form any palindrome substring.\n    \"\"\"\n    for j in range(i, len(chars)):\n      chars[j] = 'a'\n      while self._containsPalindrome(chars, j):\n        chars[j] = chr(ord(chars[j]) + 1)\n    return ''.join(chars)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2694, "slug": "event-emitter", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2649, "slug": "nested-array-generator", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2610, "slug": "convert-an-array-into-a-2d-array-with-conditions", "solutions": ["class Solution:\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\n        cnt = Counter(nums)\n        ans = []\n        for x, v in cnt.items():\n            for i in range(v):\n                if len(ans) <= i:\n                    ans.append([])\n                ans[i].append(x)\n        return ans\n", "class Solution:\n  def findMatrix(self, nums: list[int]) -> list[list[int]]:\n    # The number of rows we need equals the maximum frequency.\n    ans = []\n    count = [0] * (len(nums) + 1)\n\n    for num in nums:\n      count[num] += 1\n      # Construct `ans` on demand.\n      if count[num] > len(ans):\n        ans.append([])\n      ans[count[num] - 1].append(num)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2670, "slug": "find-the-distinct-difference-array", "solutions": ["class Solution:\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        suf = [0] * (n + 1)\n        s = set()\n        for i in range(n - 1, -1, -1):\n            s.add(nums[i])\n            suf[i] = len(s)\n        s.clear()\n        ans = [0] * n\n        for i, x in enumerate(nums):\n            s.add(x)\n            ans[i] = len(s) - suf[i + 1]\n        return ans\n", "class Solution:\n  def distinctDifferenceArray(self, nums: list[int]) -> list[int]:\n    MAX = 50\n    ans = []\n    prefixCount = [0] * (MAX + 1)\n    suffixCount = [0] * (MAX + 1)\n    distinctPrefix = 0\n    distinctSuffix = 0\n\n    for num in nums:\n      if suffixCount[num] == 0:\n        distinctSuffix += 1\n      suffixCount[num] += 1\n\n    for num in nums:\n      if prefixCount[num] == 0:\n        distinctPrefix += 1\n      prefixCount[num] += 1\n      if suffixCount[num] == 1:\n        distinctSuffix -= 1\n      suffixCount[num] -= 1\n      ans.append(distinctPrefix - distinctSuffix)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2678, "slug": "number-of-senior-citizens", "solutions": ["class Solution:\n    def countSeniors(self, details: List[str]) -> int:\n        return sum(int(x[11:13]) > 60 for x in details)\n", "class Solution:\n  def countSeniors(self, details: list[str]) -> int:\n    return sum(int(detail[11:13]) > 60 for detail in details)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2606, "slug": "find-the-substring-with-maximum-cost", "solutions": ["class Solution:\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\n        d = {c: v for c, v in zip(chars, vals)}\n        ans = tot = mi = 0\n        for c in s:\n            v = d.get(c, ord(c) - ord('a') + 1)\n            tot += v\n            ans = max(ans, tot - mi)\n            mi = min(mi, tot)\n        return ans\n", "class Solution:\n  def maximumCostSubstring(self, s: str, chars: str, vals: list[int]) -> int:\n    ans = 0\n    cost = 0\n    costs = [i for i in range(1, 27)]  # costs[i] := the cost of 'a' + i\n\n    for c, val in zip(chars, vals):\n      costs[ord(c) - ord('a')] = val\n\n    for c in s:\n      cost = max(0, cost + costs[ord(c) - ord('a')])\n      ans = max(ans, cost)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2639, "slug": "find-the-width-of-columns-of-a-grid", "solutions": ["class Solution:\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\n        return [max(len(str(x)) for x in col) for col in zip(*grid)]\n", "class Solution:\n  def findColumnWidth(self, grid: list[list[int]]) -> list[int]:\n    return [max(map(len, map(str, col))) for col in zip(*grid)]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2664, "slug": "the-knights-tour", "solutions": ["class Solution:\n    def tourOfKnight(self, m: int, n: int, r: int, c: int) -> List[List[int]]:\n        def dfs(i: int, j: int):\n            nonlocal ok\n            if g[i][j] == m * n - 1:\n                ok = True\n                return\n            for a, b in pairwise((-2, -1, 2, 1, -2, 1, 2, -1, -2)):\n                x, y = i + a, j + b\n                if 0 <= x < m and 0 <= y < n and g[x][y] == -1:\n                    g[x][y] = g[i][j] + 1\n                    dfs(x, y)\n                    if ok:\n                        return\n                    g[x][y] = -1\n\n        g = [[-1] * n for _ in range(m)]\n        g[r][c] = 0\n        ok = False\n        dfs(r, c)\n        return g\n", "class Solution:\n  def tourOfKnight(self, m: int, n: int, r: int, c: int) -> list[list[int]]:\n    DIRS = ((1, 2), (2, 1), (2, -1), (1, -2),\n            (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n    ans = [[-1] * n for _ in range(m)]\n\n    def dfs(i: int, j: int, step: int) -> bool:\n      if step == m * n:\n        return True\n      if i < 0 or i >= m or j < 0 or j >= n:\n        return False\n      if ans[i][j] != -1:\n        return False\n      ans[i][j] = step\n      for dx, dy in DIRS:\n        if dfs(i + dx, j + dy, step + 1):\n          return True\n      ans[i][j] = -1\n      return False\n\n    dfs(r, c, 0)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2634, "slug": "filter-elements-from-array", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2671, "slug": "frequency-tracker", "solutions": ["class FrequencyTracker:\n    def __init__(self):\n        self.cnt = defaultdict(int)\n        self.freq = defaultdict(int)\n\n    def add(self, number: int) -> None:\n        self.freq[self.cnt[number]] -= 1\n        self.cnt[number] += 1\n        self.freq[self.cnt[number]] += 1\n\n    def deleteOne(self, number: int) -> None:\n        if self.cnt[number]:\n            self.freq[self.cnt[number]] -= 1\n            self.cnt[number] -= 1\n            self.freq[self.cnt[number]] += 1\n\n    def hasFrequency(self, frequency: int) -> bool:\n        return self.freq[frequency] > 0\n\n\n# Your FrequencyTracker object will be instantiated and called as such:\n# obj = FrequencyTracker()\n# obj.add(number)\n# obj.deleteOne(number)\n# param_3 = obj.hasFrequency(frequency)\n", "class FrequencyTracker:\n  def __init__(self):\n    self.count = collections.Counter()\n    self.freqCount = collections.Counter()\n\n  def add(self, number: int) -> None:\n    if self.count[number] > 0:\n      self.freqCount[self.count[number]] -= 1\n    self.count[number] += 1\n    self.freqCount[self.count[number]] += 1\n\n  def deleteOne(self, number: int) -> None:\n    if self.count[number] == 0:\n      return\n    self.freqCount[self.count[number]] -= 1\n    self.count[number] -= 1\n    self.freqCount[self.count[number]] += 1\n\n  def hasFrequency(self, frequency: int) -> bool:\n    return self.freqCount[frequency] > 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2619, "slug": "array-prototype-last", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2646, "slug": "minimize-the-total-price-of-the-trips", "solutions": ["class Solution:\n    def minimumTotalPrice(\n        self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]\n    ) -> int:\n        def dfs(i: int, fa: int, k: int) -> bool:\n            cnt[i] += 1\n            if i == k:\n                return True\n            ok = any(j != fa and dfs(j, i, k) for j in g[i])\n            if not ok:\n                cnt[i] -= 1\n            return ok\n\n        def dfs2(i: int, fa: int) -> (int, int):\n            a = cnt[i] * price[i]\n            b = a // 2\n            for j in g[i]:\n                if j != fa:\n                    x, y = dfs2(j, i)\n                    a += min(x, y)\n                    b += x\n            return a, b\n\n        g = [[] for _ in range(n)]\n        for a, b in edges:\n            g[a].append(b)\n            g[b].append(a)\n        cnt = Counter()\n        for start, end in trips:\n            dfs(start, -1, end)\n        return min(dfs2(0, -1))\n", "class Solution:\n  def minimumTotalPrice(self, n: int, edges: list[list[int]], price: list[int],\n                        trips: list[list[int]]) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    # count[i] := the number of times i is traversed\n    count = [0] * n\n\n    def dfsCount(u: int, prev: int, end: int, path: list[int]) -> None:\n      path.append(u)\n      if u == end:\n        for i in path:\n          count[i] += 1\n        return\n      for v in graph[u]:\n        if v != prev:\n          dfsCount(v, u, end,  path)\n      path.pop()\n\n    for start, end in trips:\n      dfsCount(start, -1, end, [])\n\n    @functools.lru_cache(None)\n    def dfs(u: int, prev: int, parentHalved: bool) -> int:\n      \"\"\"\n      Returns the minimum price sum for the i-th node, where its parent is\n      halved parent or not halved not.\n      \"\"\"\n      sumWithFullNode = price[u] * count[u] + sum(dfs(v, u, False)\n                                                  for v in graph[u]\n                                                  if v != prev)\n      if parentHalved:  # Can't halve this node if its parent was halved.\n        return sumWithFullNode\n      sumWithHalvedNode = (price[u] // 2) * count[u] + sum(dfs(v, u, True)\n                                                           for v in graph[u]\n                                                           if v != prev)\n      return min(sumWithFullNode, sumWithHalvedNode)\n\n    return dfs(0, -1, False)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2653, "slug": "sliding-subarray-beauty", "solutions": ["class Solution:\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\n        def f(x: int) -> int:\n            s = 0\n            for i in range(50):\n                s += cnt[i]\n                if s >= x:\n                    return i - 50\n            return 0\n\n        cnt = [0] * 101\n        for v in nums[:k]:\n            cnt[v + 50] += 1\n        ans = [f(x)]\n        for i in range(k, len(nums)):\n            cnt[nums[i] + 50] += 1\n            cnt[nums[i - k] + 50] -= 1\n            ans.append(f(x))\n        return ans\n", "class Solution:\n  def getSubarrayBeauty(self, nums: list[int], k: int, x: int) -> list[int]:\n    ans = []\n    count = [0] * 50  # count[i] := the frequency of (i + 50)\n\n    for i, num in enumerate(nums):\n      if num < 0:\n        count[num + 50] += 1\n      if i - k >= 0 and nums[i - k] < 0:\n        count[nums[i - k] + 50] -= 1\n      if i + 1 >= k:\n        ans.append(self._getXthSmallestNum(count, x))\n\n    return ans\n\n  def _getXthSmallestNum(self, count: list[int], x: int) -> int:\n    prefix = 0\n    for i in range(50):\n      prefix += count[i]\n      if prefix >= x:\n        return i - 50\n    return 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2627, "slug": "debounce", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2695, "slug": "array-wrapper", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2632, "slug": "curry", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2613, "slug": "beautiful-pairs", "solutions": ["class Solution:\n    def beautifulPair(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        def dist(x1: int, y1: int, x2: int, y2: int) -> int:\n            return abs(x1 - x2) + abs(y1 - y2)\n\n        def dfs(l: int, r: int):\n            if l >= r:\n                return inf, -1, -1\n            m = (l + r) >> 1\n            x = points[m][0]\n            d1, pi1, pj1 = dfs(l, m)\n            d2, pi2, pj2 = dfs(m + 1, r)\n            if d1 > d2 or (d1 == d2 and (pi1 > pi2 or (pi1 == pi2 and pj1 > pj2))):\n                d1, pi1, pj1 = d2, pi2, pj2\n            t = [p for p in points[l : r + 1] if abs(p[0] - x) <= d1]\n            t.sort(key=lambda x: x[1])\n            for i in range(len(t)):\n                for j in range(i + 1, len(t)):\n                    if t[j][1] - t[i][1] > d1:\n                        break\n                    pi, pj = sorted([t[i][2], t[j][2]])\n                    d = dist(t[i][0], t[i][1], t[j][0], t[j][1])\n                    if d < d1 or (d == d1 and (pi < pi1 or (pi == pi1 and pj < pj1))):\n                        d1, pi1, pj1 = d, pi, pj\n            return d1, pi1, pj1\n\n        pl = defaultdict(list)\n        for i, (x, y) in enumerate(zip(nums1, nums2)):\n            pl[(x, y)].append(i)\n        points = []\n        for i, (x, y) in enumerate(zip(nums1, nums2)):\n            if len(pl[(x, y)]) > 1:\n                return [i, pl[(x, y)][1]]\n            points.append((x, y, i))\n        points.sort()\n        _, pi, pj = dfs(0, len(points) - 1)\n        return [pi, pj]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2642, "slug": "design-graph-with-shortest-path-calculator", "solutions": ["class Graph:\n    def __init__(self, n: int, edges: List[List[int]]):\n        self.n = n\n        self.g = [[inf] * n for _ in range(n)]\n        for f, t, c in edges:\n            self.g[f][t] = c\n\n    def addEdge(self, edge: List[int]) -> None:\n        f, t, c = edge\n        self.g[f][t] = c\n\n    def shortestPath(self, node1: int, node2: int) -> int:\n        dist = [inf] * self.n\n        dist[node1] = 0\n        vis = [False] * self.n\n        for _ in range(self.n):\n            t = -1\n            for j in range(self.n):\n                if not vis[j] and (t == -1 or dist[t] > dist[j]):\n                    t = j\n            vis[t] = True\n            for j in range(self.n):\n                dist[j] = min(dist[j], dist[t] + self.g[t][j])\n        return -1 if dist[node2] == inf else dist[node2]\n\n\n# Your Graph object will be instantiated and called as such:\n# obj = Graph(n, edges)\n# obj.addEdge(edge)\n# param_2 = obj.shortestPath(node1,node2)\n", "class Graph:\n  def __init__(self, n: int, edges: list[list[int]]):\n    self.graph = [[] for _ in range(n)]\n    for edge in edges:\n      self.addEdge(edge)\n\n  def addEdge(self, edge: list[int]):\n    u, v, w = edge\n    self.graph[u].append((v, w))\n\n  def shortestPath(self, node1: int, node2: int) -> int:\n    dist = [math.inf] * len(self.graph)\n\n    dist[node1] = 0\n    minHeap = [(dist[node1], node1)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if u == node2:\n        return d\n      for v, w in self.graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2687, "slug": "bikes-last-time-used", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2629, "slug": "function-composition", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2688, "slug": "find-active-users", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2609, "slug": "find-the-longest-balanced-substring-of-a-binary-string", "solutions": ["class Solution:\n    def findTheLongestBalancedSubstring(self, s: str) -> int:\n        def check(i, j):\n            cnt = 0\n            for k in range(i, j + 1):\n                if s[k] == '1':\n                    cnt += 1\n                elif cnt:\n                    return False\n            return cnt * 2 == (j - i + 1)\n\n        n = len(s)\n        ans = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if check(i, j):\n                    ans = max(ans, j - i + 1)\n        return ans\n", "class Solution:\n  def findTheLongestBalancedSubstring(self, s: str) -> int:\n    ans = 0\n\n    i = 0\n    while i < len(s):\n      zeros = 0\n      ones = 0\n      while i < len(s) and s[i] == '0':\n        zeros += 1\n        i += 1\n      while i < len(s) and s[i] == '1':\n        ones += 1\n        i += 1\n      ans = max(ans, min(zeros, ones))\n\n    return ans * 2\n", "class Solution:\n  def findTheLongestBalancedSubstring(self, s: str) -> int:\n    ans = 0\n    zeros = 0\n    ones = 0\n\n    for c in s:\n      if c == '0':\n        zeros = 1 if ones > 0 else zeros + 1\n        ones = 0\n      else:  # c == '1'\n        ones += 1\n      if zeros >= ones:\n        ans = max(ans, ones)\n\n    return ans * 2\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2617, "slug": "minimum-number-of-visited-cells-in-a-grid", "solutions": ["class Solution:\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        dist = [[-1] * n for _ in range(m)]\n        dist[0][0] = 1\n        row = [[] for _ in range(m)]\n        col = [[] for _ in range(n)]\n        for i in range(m):\n            for j in range(n):\n                while row[i] and grid[i][row[i][0][1]] + row[i][0][1] < j:\n                    heappop(row[i])\n                if row[i] and (dist[i][j] == -1 or dist[i][j] > row[i][0][0] + 1):\n                    dist[i][j] = row[i][0][0] + 1\n                while col[j] and grid[col[j][0][1]][j] + col[j][0][1] < i:\n                    heappop(col[j])\n                if col[j] and (dist[i][j] == -1 or dist[i][j] > col[j][0][0] + 1):\n                    dist[i][j] = col[j][0][0] + 1\n                if dist[i][j] != -1:\n                    heappush(row[i], (dist[i][j], j))\n                    heappush(col[j], (dist[i][j], i))\n        return dist[-1][-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2625, "slug": "flatten-deeply-nested-array", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2696, "slug": "minimum-string-length-after-removing-substrings", "solutions": ["class Solution:\n    def minLength(self, s: str) -> int:\n        stk = [\"\"]\n        for c in s:\n            if (c == \"B\" and stk[-1] == \"A\") or (c == \"D\" and stk[-1] == \"C\"):\n                stk.pop()\n            else:\n                stk.append(c)\n        return len(stk) - 1\n", "class Solution:\n  def minLength(self, s: str) -> int:\n    stack = []\n\n    def match(c: str) -> bool:\n      return stack and stack[-1] == c\n\n    for c in s:\n      if c == 'B' and match('A'):\n        stack.pop()\n      elif c == 'D' and match('C'):\n        stack.pop()\n      else:\n        stack.append(c)\n\n    return len(stack)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2686, "slug": "immediate-food-delivery-iii", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2684, "slug": "maximum-number-of-moves-in-a-grid", "solutions": ["class Solution:\n    def maxMoves(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        q = set(range(m))\n        for j in range(n - 1):\n            t = set()\n            for i in q:\n                for k in range(i - 1, i + 2):\n                    if 0 <= k < m and grid[i][j] < grid[k][j + 1]:\n                        t.add(k)\n            if not t:\n                return j\n            q = t\n        return n - 1\n", "class Solution:\n  def maxMoves(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    # dp[i][j] := the maximum number of moves you can perform from (i, j)\n    dp = [[0] * n for _ in range(m)]\n\n    for j in range(n - 2, -1, -1):\n      for i in range(m):\n        if grid[i][j + 1] > grid[i][j]:\n          dp[i][j] = 1 + dp[i][j + 1]\n        if i > 0 and grid[i - 1][j + 1] > grid[i][j]:\n          dp[i][j] = max(dp[i][j], 1 + dp[i - 1][j + 1])\n        if i + 1 < m and grid[i + 1][j + 1] > grid[i][j]:\n          dp[i][j] = max(dp[i][j], 1 + dp[i + 1][j + 1])\n\n    return max(dp[i][0] for i in range(m))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2654, "slug": "minimum-number-of-operations-to-make-all-array-elements-equal-to-1", "solutions": ["class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        n = len(nums)\n        cnt = nums.count(1)\n        if cnt:\n            return n - cnt\n        mi = n + 1\n        for i in range(n):\n            g = 0\n            for j in range(i, n):\n                g = gcd(g, nums[j])\n                if g == 1:\n                    mi = min(mi, j - i + 1)\n        return -1 if mi > n else n - 1 + mi - 1\n", "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    n = len(nums)\n    ones = nums.count(1)\n    if ones > 0:\n      return n - ones\n\n    # the minimum operations to make the shortest subarray with a gcd == 1\n    minOps = math.inf\n\n    for i, g in enumerate(nums):\n      for j in range(i + 1, n):\n        g = math.gcd(g, nums[j])\n        if g == 1:   # gcd(nums[i..j]:== 1\n          minOps = min(minOps, j - i)\n          break\n\n    # After making the shortest subarray with `minOps`, need additional n - 1\n    # operations to make the other numbers to 1.\n    return -1 if minOps == math.inf else minOps + n - 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2669, "slug": "count-artist-occurrences-on-spotify-ranking-list", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2648, "slug": "generate-fibonacci-sequence", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2612, "slug": "minimum-reverse-operations", "solutions": ["class Solution:\n    def minReverseOperations(\n        self, n: int, p: int, banned: List[int], k: int\n    ) -> List[int]:\n        ans = [-1] * n\n        ans[p] = 0\n        ts = [SortedSet() for _ in range(2)]\n        for i in range(n):\n            ts[i % 2].add(i)\n        ts[p % 2].remove(p)\n        for i in banned:\n            ts[i % 2].remove(i)\n        ts[0].add(n)\n        ts[1].add(n)\n        q = deque([p])\n        while q:\n            i = q.popleft()\n            mi = max(i - k + 1, k - i - 1)\n            mx = min(i + k - 1, n * 2 - k - i - 1)\n            s = ts[mi % 2]\n            j = s.bisect_left(mi)\n            while s[j] <= mx:\n                q.append(s[j])\n                ans[s[j]] = ans[i] + 1\n                s.remove(s[j])\n                j = s.bisect_left(mi)\n        return ans\n", "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def minReverseOperations(\n      self,\n      n: int,\n      p: int,\n      banned: list[int],\n      k: int,\n  ) -> list[int]:\n    bannedSet = set(banned)\n    ans = [-1] * n\n    # unseen[i] := the unseen numbers that % 2 == i\n    unseen = [SortedList(), SortedList()]\n\n    for num in range(n):\n      if num != p and num not in bannedSet:\n        unseen[num % 2].add(num)\n\n    # Perform BFS from `p`.\n    q = collections.deque([p])\n    ans[p] = 0\n\n    while q:\n      u = q.popleft()\n      lo = max(u - k + 1, k - 1 - u)\n      hi = min(u + k - 1, n - 1 - (u - (n - k)))\n      # Choose the correct set of numbers.\n      nums = unseen[lo % 2]\n      i = nums.bisect_left(lo)\n      while i < len(nums) and nums[i] <= hi:\n        num = nums[i]\n        ans[num] = ans[u] + 1\n        q.append(num)\n        nums.pop(i)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2630, "slug": "memoize-ii", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2677, "slug": "chunk-array", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2624, "slug": "snail-traversal", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2601, "slug": "prime-subtraction-operation", "solutions": ["class Solution:\n    def primeSubOperation(self, nums: List[int]) -> bool:\n        p = []\n        for i in range(2, max(nums)):\n            for j in p:\n                if i % j == 0:\n                    break\n            else:\n                p.append(i)\n\n        n = len(nums)\n        for i in range(n - 2, -1, -1):\n            if nums[i] < nums[i + 1]:\n                continue\n            j = bisect_right(p, nums[i] - nums[i + 1])\n            if j == len(p) or p[j] >= nums[i]:\n                return False\n            nums[i] -= p[j]\n        return True\n", "class Solution:\n  def primeSubOperation(self, nums: list[int]) -> bool:\n    MAX = 1000\n    primes = self._sieveEratosthenes(MAX)\n\n    prevNum = 0\n    for num in nums:\n      # Make nums[i] the smallest as possible and still > nums[i - 1].\n      i = bisect.bisect_left(primes, num - prevNum)\n      if i > 0:\n        num -= primes[i - 1]\n      if num <= prevNum:\n        return False\n      prevNum = num\n\n    return True\n\n  def _sieveEratosthenes(self, n: int) -> list[int]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return [i for i in range(n) if isPrime[i]]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2658, "slug": "maximum-number-of-fish-in-a-grid", "solutions": ["class Solution:\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        def dfs(i: int, j: int) -> int:\n            cnt = grid[i][j]\n            grid[i][j] = 0\n            for a, b in pairwise((-1, 0, 1, 0, -1)):\n                x, y = i + a, j + b\n                if 0 <= x < m and 0 <= y < n and grid[x][y]:\n                    cnt += dfs(x, y)\n            return cnt\n\n        m, n = len(grid), len(grid[0])\n        ans = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]:\n                    ans = max(ans, dfs(i, j))\n        return ans\n", "class Solution:\n  def findMaxFish(self, grid: list[list[int]]) -> int:\n    def dfs(i: int, j: int) -> int:\n      if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]):\n        return 0\n      if grid[i][j] == 0:\n        return 0\n      caughtFish = grid[i][j]\n      grid[i][j] = 0  # Mark 0 as visited\n      return (caughtFish +\n              dfs(i + 1, j) + dfs(i - 1, j) +\n              dfs(i, j + 1) + dfs(i, j - 1))\n\n    return max(dfs(i, j)\n               for i in range(len(grid))\n               for j in range(len(grid[0])))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2660, "slug": "determine-the-winner-of-a-bowling-game", "solutions": ["class Solution:\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\n        def f(arr: List[int]) -> int:\n            s = 0\n            for i, x in enumerate(arr):\n                k = 2 if (i and arr[i - 1] == 10) or (i > 1 and arr[i - 2] == 10) else 1\n                s += k * x\n            return s\n\n        a, b = f(player1), f(player2)\n        return 1 if a > b else (2 if b > a else 0)\n", "class Solution:\n  def isWinner(self, player1: list[int], player2: list[int]) -> int:\n    def getScore(player: list[int]) -> int:\n      INVALID = -3\n      score = 0\n      last10 = INVALID\n      for i, p in enumerate(player):\n        score += p if i - last10 > 2 else p * 2\n        if p == 10:\n          last10 = i\n      return score\n\n    score1 = getScore(player1)\n    score2 = getScore(player2)\n    if score1 > score2:\n      return 1\n    if score2 > score1:\n      return 2\n    return 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2635, "slug": "apply-transform-over-each-element-in-array", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2637, "slug": "promise-time-limit", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2689, "slug": "extract-kth-character-from-the-rope-tree", "solutions": ["# Definition for a rope tree node.\n# class RopeTreeNode(object):\n#     def __init__(self, len=0, val=\"\", left=None, right=None):\n#         self.len = len\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def getKthCharacter(self, root: Optional[object], k: int) -> str:\n        def dfs(root):\n            if root is None:\n                return \"\"\n            if root.len == 0:\n                return root.val\n            return dfs(root.left) + dfs(root.right)\n\n        return dfs(root)[k - 1]\n", "class Solution:\n  def getKthCharacter(self, root: object | None, k: int) -> str:\n    \"\"\":type root: RopeTreeNode | None\"\"\"\n    while root.len > 0:\n      leftLen = (0 if not root.left\n                 else max(root.left.len, len(root.left.val)))\n      if leftLen >= k:\n        root = root.left\n      else:\n        root = root.right\n        k -= leftLen\n    return root.val[k - 1]\n", "class Solution:\n  def getKthCharacter(self, root: object | None, k: int) -> str:\n    \"\"\":type root: RopeTreeNode | None\"\"\"\n    if root.len == 0:\n      return root.val[k - 1]\n    leftLen = (0 if not root.left\n               else max(root.left.len, len(root.left.val)))\n    if leftLen >= k:\n      return self.getKthCharacter(root.left, k)\n    return self.getKthCharacter(root.right, k - leftLen)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2651, "slug": "calculate-delayed-arrival-time", "solutions": ["class Solution:\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\n        return (arrivalTime + delayedTime) % 24\n", "class Solution:\n  def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\n    return (arrivalTime + delayedTime) % 24\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2603, "slug": "collect-coins-in-a-tree", "solutions": ["class Solution:\n    def collectTheCoins(self, coins: List[int], edges: List[List[int]]) -> int:\n        g = defaultdict(set)\n        for a, b in edges:\n            g[a].add(b)\n            g[b].add(a)\n        n = len(coins)\n        q = deque(i for i in range(n) if len(g[i]) == 1 and coins[i] == 0)\n        while q:\n            i = q.popleft()\n            for j in g[i]:\n                g[j].remove(i)\n                if coins[j] == 0 and len(g[j]) == 1:\n                    q.append(j)\n            g[i].clear()\n        for k in range(2):\n            q = [i for i in range(n) if len(g[i]) == 1]\n            for i in q:\n                for j in g[i]:\n                    g[j].remove(i)\n                g[i].clear()\n        return sum(len(g[a]) > 0 and len(g[b]) > 0 for a, b in edges) * 2\n", "class Solution:\n  def collectTheCoins(self, coins: list[int], edges: list[list[int]]) -> int:\n    n = len(coins)\n    tree = [set() for _ in range(n)]\n    leavesToBeRemoved = collections.deque()\n\n    for u, v in edges:\n      tree[u].add(v)\n      tree[v].add(u)\n\n    for u in range(n):\n      # Remove the leaves that don't have coins.\n      while len(tree[u]) == 1 and coins[u] == 0:\n        v = tree[u].pop()\n        tree[v].remove(u)\n        u = v  # Walk up to its parent.\n      # After trimming leaves without coins, leaves with coins may satisfy\n      # `leavesToBeRemoved`.\n      if len(tree[u]) == 1:  # coins[u] must be 1.\n        leavesToBeRemoved.append(u)\n\n    # Remove each remaining leaf node and its parent. The remaining nodes are\n    # the ones that must be visited.\n    for _ in range(2):\n      for _ in range(len(leavesToBeRemoved)):\n        u = leavesToBeRemoved.popleft()\n        if tree[u]:\n          v = tree[u].pop()\n          tree[v].remove(u)\n          if len(tree[v]) == 1:  # It's a leaf.\n            leavesToBeRemoved.append(v)\n\n    return sum(len(children) for children in tree)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 2636, "slug": "promise-pool", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 400, "slug": "nth-digit", "solutions": ["class Solution:\n    def findNthDigit(self, n: int) -> int:\n        k, cnt = 1, 9\n        while k * cnt < n:\n            n -= k * cnt\n            k += 1\n            cnt *= 10\n        num = 10 ** (k - 1) + (n - 1) // k\n        idx = (n - 1) % k\n        return int(str(num)[idx])\n", "class Solution:\n  def findNthDigit(self, n: int) -> int:\n    def getDigit(num: int, pos: int, digitSize: int):\n      if pos == 0:\n        return num % 10\n      for _ in range(digitSize - pos):\n        num //= 10\n      return num % 10\n\n    digitSize = 1\n    startNum = 1\n    count = 9\n\n    while digitSize * count < n:\n      n -= digitSize * count\n      digitSize += 1\n      startNum *= 10\n      count *= 10\n\n    targetNum = startNum + (n - 1) // digitSize\n    pos = n % digitSize\n\n    return getDigit(targetNum, pos, digitSize)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 438, "slug": "find-all-anagrams-in-a-string", "solutions": ["class Solution:\n    def findAnagrams(self, s: str, p: str) -> List[int]:\n        m, n = len(s), len(p)\n        ans = []\n        if m < n:\n            return ans\n        cnt1 = Counter(p)\n        cnt2 = Counter(s[: n - 1])\n        for i in range(n - 1, m):\n            cnt2[s[i]] += 1\n            if cnt1 == cnt2:\n                ans.append(i - n + 1)\n            cnt2[s[i - n + 1]] -= 1\n        return ans\n", "class Solution:\n  def findAnagrams(self, s: str, p: str) -> list[int]:\n    ans = []\n    count = collections.Counter(p)\n    required = len(p)\n\n    for r, c in enumerate(s):\n      count[c] -= 1\n      if count[c] >= 0:\n        required -= 1\n      if r >= len(p):\n        count[s[r - len(p)]] += 1\n        if count[s[r - len(p)]] > 0:\n          required += 1\n      if required == 0:\n        ans.append(r - len(p) + 1)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 414, "slug": "third-maximum-number", "solutions": ["class Solution:\n    def thirdMax(self, nums: List[int]) -> int:\n        m1 = m2 = m3 = -inf\n        for num in nums:\n            if num in [m1, m2, m3]:\n                continue\n            if num > m1:\n                m3, m2, m1 = m2, m1, num\n            elif num > m2:\n                m3, m2 = m2, num\n            elif num > m3:\n                m3 = num\n        return m3 if m3 != -inf else m1\n", "class Solution:\n  def thirdMax(self, nums: list[int]) -> int:\n    max1 = -math.inf  # the maximum\n    max2 = -math.inf  # the second maximum\n    max3 = -math.inf  # the third maximum\n\n    for num in nums:\n      if num > max1:\n        max3 = max2\n        max2 = max1\n        max1 = num\n      elif max1 > num and num > max2:\n        max3 = max2\n        max2 = num\n      elif max2 > num and num > max3:\n        max3 = num\n\n    return max1 if max3 == -math.inf else max3\n", "class Solution:\n  def thirdMax(self, nums: list[int]) -> int:\n    minHeap = []\n    seen = set()\n\n    for num in nums:\n      if num not in seen:\n        seen.add(num)\n        heapq.heappush(minHeap, num)\n        if len(minHeap) > 3:\n          heapq.heappop(minHeap)\n\n    if len(minHeap) == 2:\n      heapq.heappop(minHeap)\n\n    return minHeap[0]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 459, "slug": "repeated-substring-pattern", "solutions": ["class Solution:\n    def repeatedSubstringPattern(self, s: str) -> bool:\n        return (s + s).index(s, 1) < len(s)\n", "class Solution:\n  def repeatedSubstringPattern(self, s: str) -> bool:\n    return s in (s + s)[1:-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 430, "slug": "flatten-a-multilevel-doubly-linked-list", "solutions": ["\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val, prev, next, child):\n        self.val = val\n        self.prev = prev\n        self.next = next\n        self.child = child\n\"\"\"\n\n\nclass Solution:\n    def flatten(self, head: 'Node') -> 'Node':\n        def preorder(pre, cur):\n            if cur is None:\n                return pre\n            cur.prev = pre\n            pre.next = cur\n\n            t = cur.next\n            tail = preorder(cur, cur.child)\n            cur.child = None\n            return preorder(tail, t)\n\n        if head is None:\n            return None\n        dummy = Node(0, None, head, None)\n        preorder(dummy, head)\n        dummy.next.prev = None\n        return dummy.next\n", "class Solution:\n  def flatten(self, head: 'Node') -> 'Node':\n    def flatten(head: 'Node', rest: 'Node') -> 'Node':\n      if not head:\n        return rest\n\n      head.next = flatten(head.child, flatten(head.next, rest))\n      if head.next:\n        head.next.prev = head\n      head.child = None\n      return head\n\n    return flatten(head, None)\n", "class Solution:\n  def flatten(self, head: 'Node') -> 'Node':\n    curr = head\n\n    while curr:\n      if curr.child:\n        cachedNext = curr.next\n        curr.next = curr.child\n        curr.child.prev = curr\n        curr.child = None\n        tail = curr.next\n        while tail.next:\n          tail = tail.next\n        tail.next = cachedNext\n        if cachedNext:\n          cachedNext.prev = tail\n      curr = curr.next\n\n    return head\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 489, "slug": "robot-room-cleaner", "solutions": ["# \"\"\"\n# This is the robot's control interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# class Robot:\n#    def move(self):\n#        \"\"\"\n#        Returns true if the cell in front is open and robot moves into the cell.\n#        Returns false if the cell in front is blocked and robot stays in the current cell.\n#        :rtype bool\n#        \"\"\"\n#\n#    def turnLeft(self):\n#        \"\"\"\n#        Robot will stay in the same cell after calling turnLeft/turnRight.\n#        Each turn will be 90 degrees.\n#        :rtype void\n#        \"\"\"\n#\n#    def turnRight(self):\n#        \"\"\"\n#        Robot will stay in the same cell after calling turnLeft/turnRight.\n#        Each turn will be 90 degrees.\n#        :rtype void\n#        \"\"\"\n#\n#    def clean(self):\n#        \"\"\"\n#        Clean the current cell.\n#        :rtype void\n#        \"\"\"\n\n\nclass Solution:\n    def cleanRoom(self, robot):\n        \"\"\"\n        :type robot: Robot\n        :rtype: None\n        \"\"\"\n\n        def dfs(i, j, d):\n            vis.add((i, j))\n            robot.clean()\n            for k in range(4):\n                nd = (d + k) % 4\n                x, y = i + dirs[nd], j + dirs[nd + 1]\n                if (x, y) not in vis and robot.move():\n                    dfs(x, y, nd)\n                    robot.turnRight()\n                    robot.turnRight()\n                    robot.move()\n                    robot.turnRight()\n                    robot.turnRight()\n                robot.turnRight()\n\n        dirs = (-1, 0, 1, 0, -1)\n        vis = set()\n        dfs(0, 0, 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 427, "slug": "construct-quad-tree", "solutions": ["\"\"\"\n# Definition for a QuadTree node.\nclass Node:\n    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):\n        self.val = val\n        self.isLeaf = isLeaf\n        self.topLeft = topLeft\n        self.topRight = topRight\n        self.bottomLeft = bottomLeft\n        self.bottomRight = bottomRight\n\"\"\"\n\n\nclass Solution:\n    def construct(self, grid: List[List[int]]) -> 'Node':\n        def dfs(a, b, c, d):\n            zero = one = 0\n            for i in range(a, c + 1):\n                for j in range(b, d + 1):\n                    if grid[i][j] == 0:\n                        zero = 1\n                    else:\n                        one = 1\n            isLeaf = zero + one == 1\n            val = isLeaf and one\n            if isLeaf:\n                return Node(grid[a][b], True)\n            topLeft = dfs(a, b, (a + c) // 2, (b + d) // 2)\n            topRight = dfs(a, (b + d) // 2 + 1, (a + c) // 2, d)\n            bottomLeft = dfs((a + c) // 2 + 1, b, c, (b + d) // 2)\n            bottomRight = dfs((a + c) // 2 + 1, (b + d) // 2 + 1, c, d)\n            return Node(val, isLeaf, topLeft, topRight, bottomLeft, bottomRight)\n\n        return dfs(0, 0, len(grid) - 1, len(grid[0]) - 1)\n", "class Solution:\n  def construct(self, grid: list[list[int]]) -> 'Node':\n    return self._helper(grid, 0, 0, len(grid))\n\n  def _helper(self, grid: list[list[int]], i: int, j: int, w: int) -> 'Node':\n    if self._allSame(grid, i, j, w):\n      return Node(grid[i][j] == 1, True)\n    half = w // 2\n    return Node(True, False,\n                self._helper(grid, i, j, half),\n                self._helper(grid, i, j + half, half),\n                self._helper(grid, i + half, j, half),\n                self._helper(grid, i + half, j + half, half))\n\n  def _allSame(self, grid: list[list[int]], i: int, j: int, w: int) -> bool:\n    return all(grid[x][y] == grid[i][j]\n               for x in range(i, i + w)\n               for y in range(j, j + w))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 487, "slug": "max-consecutive-ones-ii", "solutions": ["class Solution:\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\n        l = cnt = 0\n        for x in nums:\n            cnt += x ^ 1\n            if cnt > 1:\n                cnt -= nums[l] ^ 1\n                l += 1\n        return len(nums) - l\n", "class Solution:\n  def findMaxConsecutiveOnes(self, nums: list[int]) -> int:\n    ans = 0\n    zeros = 0\n\n    l = 0\n    for r, num in enumerate(nums):\n      if num == 0:\n        zeros += 1\n      while zeros == 2:\n        if nums[l] == 0:\n          zeros -= 1\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans\n", "class Solution:\n  def findMaxConsecutiveOnes(self, nums: list[int]) -> int:\n    ans = 0\n    lastZeroIndex = -1\n\n    l = 0\n    for r, num in enumerate(nums):\n      if num == 0:\n        l = lastZeroIndex + 1\n        lastZeroIndex = r\n      ans = max(ans, r - l + 1)\n\n    return ans\n", "class Solution:\n  def findMaxConsecutiveOnes(self, nums: list[int]) -> int:\n    maxZeros = 1\n    ans = 0\n    q = collections.deque()  # Store indices of zero.\n\n    l = 0\n    for r, num in enumerate(nums):\n      if num == 0:\n        q.append(r)\n      if len(q) > maxZeros:\n        l = q.popleft() + 1\n      ans = max(ans, r - l + 1)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 460, "slug": "lfu-cache", "solutions": ["class Node:\n    def __init__(self, key: int, value: int) -> None:\n        self.key = key\n        self.value = value\n        self.freq = 1\n        self.prev = None\n        self.next = None\n\n\nclass DoublyLinkedList:\n    def __init__(self) -> None:\n        self.head = Node(-1, -1)\n        self.tail = Node(-1, -1)\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def add_first(self, node: Node) -> None:\n        node.prev = self.head\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n\n    def remove(self, node: Node) -> Node:\n        node.next.prev = node.prev\n        node.prev.next = node.next\n        node.next, node.prev = None, None\n        return node\n\n    def remove_last(self) -> Node:\n        return self.remove(self.tail.prev)\n\n    def is_empty(self) -> bool:\n        return self.head.next == self.tail\n\n\nclass LFUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.min_freq = 0\n        self.map = defaultdict(Node)\n        self.freq_map = defaultdict(DoublyLinkedList)\n\n    def get(self, key: int) -> int:\n        if self.capacity == 0 or key not in self.map:\n            return -1\n        node = self.map[key]\n        self.incr_freq(node)\n        return node.value\n\n    def put(self, key: int, value: int) -> None:\n        if self.capacity == 0:\n            return\n        if key in self.map:\n            node = self.map[key]\n            node.value = value\n            self.incr_freq(node)\n            return\n        if len(self.map) == self.capacity:\n            ls = self.freq_map[self.min_freq]\n            node = ls.remove_last()\n            self.map.pop(node.key)\n        node = Node(key, value)\n        self.add_node(node)\n        self.map[key] = node\n        self.min_freq = 1\n\n    def incr_freq(self, node: Node) -> None:\n        freq = node.freq\n        ls = self.freq_map[freq]\n        ls.remove(node)\n        if ls.is_empty():\n            self.freq_map.pop(freq)\n            if freq == self.min_freq:\n                self.min_freq += 1\n        node.freq += 1\n        self.add_node(node)\n\n    def add_node(self, node: Node) -> None:\n        freq = node.freq\n        ls = self.freq_map[freq]\n        ls.add_first(node)\n        self.freq_map[freq] = ls\n\n\n# Your LFUCache object will be instantiated and called as such:\n# obj = LFUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 431, "slug": "encode-n-ary-tree-to-binary-tree", "solutions": ["\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val: Optional[int] = None, children: Optional[List['Node']] = None):\n        self.val = val\n        self.children = children\n\"\"\"\n\n\"\"\"\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\"\"\"\n\n\nclass Codec:\n    # Encodes an n-ary tree to a binary tree.\n    def encode(self, root: \"Optional[Node]\") -> Optional[TreeNode]:\n        if root is None:\n            return None\n        node = TreeNode(root.val)\n        if not root.children:\n            return node\n        left = self.encode(root.children[0])\n        node.left = left\n        for child in root.children[1:]:\n            left.right = self.encode(child)\n            left = left.right\n        return node\n\n    # Decodes your binary tree to an n-ary tree.\n    def decode(self, data: Optional[TreeNode]) -> \"Optional[Node]\":\n        if data is None:\n            return None\n        node = Node(data.val, [])\n        if data.left is None:\n            return node\n        left = data.left\n        while left:\n            node.children.append(self.decode(left))\n            left = left.right\n        return node\n\n\n# Your Codec object will be instantiated and called as such:\n# codec = Codec()\n# codec.decode(codec.encode(root))\n", "class Codec:\n  # Encodes an n-ary tree to a binary tree.\n  def encode(self, root: 'Node') -> TreeNode | None:\n    if not root:\n      return None\n\n    rootTreeNode = TreeNode(root.val)\n    q = collections.deque([(root, rootTreeNode)])\n\n    while q:\n      parentNode, parentTreeNode = q.popleft()\n      prevTreeNode = None\n      headTreeNode = None\n      for child in parentNode.children:\n        currTreeNode = TreeNode(child.val)\n        if prevTreeNode:\n          prevTreeNode.right = currTreeNode\n        else:\n          headTreeNode = currTreeNode\n        prevTreeNode = currTreeNode\n        q.append((child, currTreeNode))\n      parentTreeNode.left = headTreeNode\n\n    return rootTreeNode\n\n  # Decodes your binary tree to an n-ary tree.\n  def decode(self, root: TreeNode | None) -> 'Node':\n    if not root:\n      return None\n\n    rootNode = Node(root.val, [])\n    q = collections.deque([(rootNode, root)])\n\n    while q:\n      parentNode, parentTreeNode = q.popleft()\n      sibling = parentTreeNode.left\n      while sibling:\n        currNode = Node(sibling.val, [])\n        parentNode.children.append(currNode)\n        q.append((currNode, sibling))\n        sibling = sibling.right\n\n    return rootNode\n", "class Codec:\n  # Encodes an n-ary tree to a binary tree.\n  def encode(self, root: 'Node') -> TreeNode | None:\n    if not root:\n      return None\n\n    rootTreeNode = TreeNode(root.val)\n    if root.children:\n      rootTreeNode.left = self.encode(root.children[0])\n\n    # The parent for the rest of the children\n    currTreeNode = rootTreeNode.left\n\n    # Encode the rest of the children\n    for i in range(1, len(root.children)):\n      currTreeNode.right = self.encode(root.children[i])\n      currTreeNode = currTreeNode.right\n\n    return rootTreeNode\n\n  # Decodes your binary tree to an n-ary tree.\n  def decode(self, root: TreeNode | None) -> 'Node':\n    if not root:\n      return None\n\n    rootNode = Node(root.val, [])\n    currTreeNode = root.left\n\n    while currTreeNode:\n      rootNode.children.append(self.decode(currTreeNode))\n      currTreeNode = currTreeNode.right\n\n    return rootNode\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 462, "slug": "minimum-moves-to-equal-array-elements-ii", "solutions": ["class Solution:\n    def minMoves2(self, nums: List[int]) -> int:\n        nums.sort()\n        k = nums[len(nums) >> 1]\n        return sum(abs(v - k) for v in nums)\n", "import statistics\n\n\nclass Solution:\n  def minMoves2(self, nums: list[int]) -> int:\n    median = int(statistics.median(nums))\n    return sum(abs(num - median) for num in nums)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 440, "slug": "k-th-smallest-in-lexicographical-order", "solutions": ["class Solution:\n    def findKthNumber(self, n: int, k: int) -> int:\n        def count(curr):\n            next, cnt = curr + 1, 0\n            while curr <= n:\n                cnt += min(n - curr + 1, next - curr)\n                next, curr = next * 10, curr * 10\n            return cnt\n\n        curr = 1\n        k -= 1\n        while k:\n            cnt = count(curr)\n            if k >= cnt:\n                k -= cnt\n                curr += 1\n            else:\n                k -= 1\n                curr *= 10\n        return curr\n", "class Solution:\n  def findKthNumber(self, n: int, k: int) -> int:\n    ans = 1\n\n    i = 1\n    while i < k:\n      gap = self._getGap(ans, ans + 1, n)\n      if i + gap <= k:\n        i += gap\n        ans += 1\n      else:\n        i += 1\n        ans *= 10\n\n    return ans\n\n  def _getGap(self, a: int, b: int, n: int) -> int:\n    gap = 0\n    while a <= n:\n      gap += min(n + 1, b) - a\n      a *= 10\n      b *= 10\n    return gap\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 483, "slug": "smallest-good-base", "solutions": ["class Solution:\n    def smallestGoodBase(self, n: str) -> str:\n        def cal(k, m):\n            p = s = 1\n            for i in range(m):\n                p *= k\n                s += p\n            return s\n\n        num = int(n)\n        for m in range(63, 1, -1):\n            l, r = 2, num - 1\n            while l < r:\n                mid = (l + r) >> 1\n                if cal(mid, m) >= num:\n                    r = mid\n                else:\n                    l = mid + 1\n            if cal(l, m) == num:\n                return str(l)\n        return str(num - 1)\n", "class Solution:\n  def smallestGoodBase(self, n: str) -> str:\n    n = int(n)\n\n    for m in range(int(math.log(n, 2)), 1, -1):\n      k = int(n**m**-1)\n      if (k**(m + 1) - 1) // (k - 1) == n:\n        return str(k)\n\n    return str(n - 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 445, "slug": "add-two-numbers-ii", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def addTwoNumbers(\n        self, l1: Optional[ListNode], l2: Optional[ListNode]\n    ) -> Optional[ListNode]:\n        s1, s2 = [], []\n        while l1:\n            s1.append(l1.val)\n            l1 = l1.next\n        while l2:\n            s2.append(l2.val)\n            l2 = l2.next\n        dummy = ListNode()\n        carry = 0\n        while s1 or s2 or carry:\n            s = (0 if not s1 else s1.pop()) + (0 if not s2 else s2.pop()) + carry\n            carry, val = divmod(s, 10)\n            # node = ListNode(val, dummy.next)\n            # dummy.next = node\n            dummy.next = ListNode(val, dummy.next)\n        return dummy.next\n", "class Solution:\n  def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n    stack1 = []\n    stack2 = []\n\n    while l1:\n      stack1.append(l1)\n      l1 = l1.next\n\n    while l2:\n      stack2.append(l2)\n      l2 = l2.next\n\n    head = None\n    carry = 0\n\n    while carry or stack1 or stack2:\n      if stack1:\n        carry += stack1.pop().val\n      if stack2:\n        carry += stack2.pop().val\n      node = ListNode(carry % 10)\n      node.next = head\n      head = node\n      carry //= 10\n\n    return head\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 410, "slug": "split-array-largest-sum", "solutions": ["class Solution:\n    def splitArray(self, nums: List[int], k: int) -> int:\n        def check(mx):\n            s, cnt = inf, 0\n            for x in nums:\n                s += x\n                if s > mx:\n                    s = x\n                    cnt += 1\n            return cnt <= k\n\n        left, right = max(nums), sum(nums)\n        return left + bisect_left(range(left, right + 1), True, key=check)\n", "class Solution:\n  def splitArray(self, nums: list[int], k: int) -> int:\n    prefix = list(itertools.accumulate(nums, initial=0))\n\n    @functools.lru_cache(None)\n    def dp(i: int, k: int) -> int:\n      \"\"\"\n      Returns the minimum of the maximum sum to split the first i numbers into\n      k groups.\n      \"\"\"\n      if k == 1:\n        return prefix[i]\n      return min(max(dp(j, k - 1), prefix[i] - prefix[j])\n                 for j in range(k - 1, i))\n\n    return dp(len(nums), k)\n", "class Solution:\n  def splitArray(self, nums: list[int], k: int) -> int:\n    n = len(nums)\n    # dp[i][k] := the minimum of the maximum sum to split the first i numbers\n    # into k groups\n    dp = [[math.inf] * (k + 1) for _ in range(n + 1)]\n    prefix = list(itertools.accumulate(nums, initial=0))\n\n    for i in range(1, n + 1):\n      dp[i][1] = prefix[i]\n\n    for l in range(2, k + 1):\n      for i in range(l, n + 1):\n        for j in range(l - 1, i):\n          dp[i][l] = min(dp[i][l], max(dp[j][l - 1], prefix[i] - prefix[j]))\n\n    return dp[n][k]\n", "class Solution:\n  def splitArray(self, nums: list[int], k: int) -> int:\n    l = max(nums)\n    r = sum(nums) + 1\n\n    def numGroups(maxSumInGroup: int) -> int:\n      groupCount = 1\n      sumInGroup = 0\n\n      for num in nums:\n        if sumInGroup + num <= maxSumInGroup:\n          sumInGroup += num\n        else:\n          groupCount += 1\n          sumInGroup = num\n\n      return groupCount\n\n    while l < r:\n      m = (l + r) // 2\n      if numGroups(m) > k:\n        l = m + 1\n      else:\n        r = m\n\n    return l\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 422, "slug": "valid-word-square", "solutions": ["class Solution:\n    def validWordSquare(self, words: List[str]) -> bool:\n        m = len(words)\n        for i, w in enumerate(words):\n            for j, c in enumerate(w):\n                if j >= m or i >= len(words[j]) or c != words[j][i]:\n                    return False\n        return True\n", "class Solution:\n  def validWordSquare(self, words: list[str]) -> bool:\n    for i, word in enumerate(words):\n      for j, c in enumerate(word):\n        if len(words) <= j or len(words[j]) <= i:  # out-of-bounds\n          return False\n        if c != words[j][i]:\n          return False\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 454, "slug": "4sum-ii", "solutions": ["class Solution:\n    def fourSumCount(\n        self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]\n    ) -> int:\n        cnt = Counter(a + b for a in nums1 for b in nums2)\n        return sum(cnt[-(c + d)] for c in nums3 for d in nums4)\n", "class Solution:\n  def fourSumCount(self, nums1: list[int], nums2: list[int],\n                   nums3: list[int], nums4: list[int]) -> int:\n    count = collections.Counter(a + b for a in nums1 for b in nums2)\n    return sum(count[-c - d] for c in nums3 for d in nums4)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 417, "slug": "pacific-atlantic-water-flow", "solutions": ["class Solution:\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\n        def bfs(q, vis):\n            while q:\n                for _ in range(len(q)):\n                    i, j = q.popleft()\n                    for a, b in [[0, -1], [0, 1], [1, 0], [-1, 0]]:\n                        x, y = i + a, j + b\n                        if (\n                            0 <= x < m\n                            and 0 <= y < n\n                            and (x, y) not in vis\n                            and heights[x][y] >= heights[i][j]\n                        ):\n                            vis.add((x, y))\n                            q.append((x, y))\n\n        m, n = len(heights), len(heights[0])\n        vis1, vis2 = set(), set()\n        q1 = deque()\n        q2 = deque()\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or j == 0:\n                    vis1.add((i, j))\n                    q1.append((i, j))\n                if i == m - 1 or j == n - 1:\n                    vis2.add((i, j))\n                    q2.append((i, j))\n        bfs(q1, vis1)\n        bfs(q2, vis2)\n        return [\n            (i, j)\n            for i in range(m)\n            for j in range(n)\n            if (i, j) in vis1 and (i, j) in vis2\n        ]\n", "class Solution:\n  def pacificAtlantic(self, heights: list[list[int]]) -> list[list[int]]:\n    m = len(heights)\n    n = len(heights[0])\n    seenP = [[False] * n for _ in range(m)]\n    seenA = [[False] * n for _ in range(m)]\n\n    def dfs(i: int, j: int, h: int, seen: list[list[bool]]) -> None:\n      if i < 0 or i == m or j < 0 or j == n:\n        return\n      if seen[i][j] or heights[i][j] < h:\n        return\n\n      seen[i][j] = True\n      dfs(i + 1, j, heights[i][j], seen)\n      dfs(i - 1, j, heights[i][j], seen)\n      dfs(i, j + 1, heights[i][j], seen)\n      dfs(i, j - 1, heights[i][j], seen)\n\n    for i in range(m):\n      dfs(i, 0, 0, seenP)\n      dfs(i, n - 1, 0, seenA)\n\n    for j in range(n):\n      dfs(0, j, 0, seenP)\n      dfs(m - 1, j, 0, seenA)\n\n    return [[i, j]\n            for i in range(m)\n            for j in range(n)\n            if seenP[i][j] and seenA[i][j]]\n", "class Solution:\n  def pacificAtlantic(self, heights: list[list[int]]) -> list[list[int]]:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(heights)\n    n = len(heights[0])\n    qP = collections.deque()\n    qA = collections.deque()\n    seenP = [[False] * n for _ in range(m)]\n    seenA = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      qP.append((i, 0))\n      qA.append((i, n - 1))\n      seenP[i][0] = True\n      seenA[i][n - 1] = True\n\n    for j in range(n):\n      qP.append((0, j))\n      qA.append((m - 1, j))\n      seenP[0][j] = True\n      seenA[m - 1][j] = True\n\n    def bfs(q: deque, seen: list[list[bool]]):\n      while q:\n        i, j = q.popleft()\n        h = heights[i][j]\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if seen[x][y] or heights[x][y] < h:\n            continue\n          q.append((x, y))\n          seen[x][y] = True\n\n    bfs(qP, seenP)\n    bfs(qA, seenA)\n\n    return [[i, j] for i in range(m) for j in range(n) if seenP[i][j] and seenA[i][j]]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 401, "slug": "binary-watch", "solutions": ["class Solution:\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\n        return [\n            '{:d}:{:02d}'.format(i, j)\n            for i in range(12)\n            for j in range(60)\n            if (bin(i) + bin(j)).count('1') == turnedOn\n        ]\n", "class Solution:\n  def readBinaryWatch(self, turnedOn: int) -> list[str]:\n    ans = []\n    hours = [1, 2, 4, 8]\n    minutes = [1, 2, 4, 8, 16, 32]\n\n    def dfs(turnedOn: int, s: int, h: int, m: int) -> None:\n      if turnedOn == 0:\n        time = str(h) + \":\" + (str(m).zfill(2))\n        ans.append(time)\n        return\n\n      for i in range(s, len(hours) + len(minutes)):\n        if i < 4 and h + hours[i] < 12:\n          dfs(turnedOn - 1, i + 1, h + hours[i], m)\n        elif i >= 4 and m + minutes[i - 4] < 60:\n          dfs(turnedOn - 1, i + 1, h, m + minutes[i - 4])\n\n    dfs(turnedOn, 0, 0, 0)\n    return ans\n", "class Solution:\n  def readBinaryWatch(self, turnedOn: int) -> list[str]:\n    ans = []\n\n    for h in range(12):\n      for m in range(60):\n        if h.bit_count() + m.bit_count() == turnedOn:\n          ans.append(f'{h}:{m:02d}')\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 419, "slug": "battleships-in-a-board", "solutions": ["class Solution:\n    def countBattleships(self, board: List[List[str]]) -> int:\n        m, n = len(board), len(board[0])\n        ans = 0\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == '.':\n                    continue\n                if i > 0 and board[i - 1][j] == 'X':\n                    continue\n                if j > 0 and board[i][j - 1] == 'X':\n                    continue\n                ans += 1\n        return ans\n", "class Solution:\n  def countBattleships(self, board: list[list[str]]) -> int:\n    ans = 0\n\n    for i, row in enumerate(board):\n      for j, cell in enumerate(row):\n        if cell == '.':\n          continue\n        if i > 0 and board[i - 1][j] == 'X':\n          continue\n        if j > 0 and board[i][j - 1] == 'X':\n          continue\n        ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 469, "slug": "convex-polygon", "solutions": ["class Solution:\n    def isConvex(self, points: List[List[int]]) -> bool:\n        n = len(points)\n        pre = cur = 0\n        for i in range(n):\n            x1 = points[(i + 1) % n][0] - points[i][0]\n            y1 = points[(i + 1) % n][1] - points[i][1]\n            x2 = points[(i + 2) % n][0] - points[i][0]\n            y2 = points[(i + 2) % n][1] - points[i][1]\n            cur = x1 * y2 - x2 * y1\n            if cur != 0:\n                if cur * pre < 0:\n                    return False\n                pre = cur\n        return True\n", "class Solution:\n  def isConvex(self, points: list[list[int]]) -> bool:\n    def getCross(p: list[int], q: list[int], r: list[int]):\n      \"\"\"Returns pq x qr.\"\"\"\n      return (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])\n\n    sign = 0\n    for i in range(len(points)):\n      cross = getCross(points[i - 2], points[i - 1], points[i])\n      if cross == 0:  # p, q, r are collinear.\n        continue\n      if sign == 0:  # Find the first cross that's not 0.\n        sign = cross\n      elif cross * sign < 0:\n        return False\n\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 425, "slug": "word-squares", "solutions": ["class Trie:\n    def __init__(self):\n        self.children = [None] * 26\n        self.v = []\n\n    def insert(self, w, i):\n        node = self\n        for c in w:\n            idx = ord(c) - ord('a')\n            if node.children[idx] is None:\n                node.children[idx] = Trie()\n            node = node.children[idx]\n            node.v.append(i)\n\n    def search(self, w):\n        node = self\n        for c in w:\n            idx = ord(c) - ord('a')\n            if node.children[idx] is None:\n                return []\n            node = node.children[idx]\n        return node.v\n\n\nclass Solution:\n    def wordSquares(self, words: List[str]) -> List[List[str]]:\n        def dfs(t):\n            if len(t) == len(words[0]):\n                ans.append(t[:])\n                return\n            idx = len(t)\n            pref = [v[idx] for v in t]\n            indexes = trie.search(''.join(pref))\n            for i in indexes:\n                t.append(words[i])\n                dfs(t)\n                t.pop()\n\n        trie = Trie()\n        ans = []\n        for i, w in enumerate(words):\n            trie.insert(w, i)\n        for w in words:\n            dfs([w])\n        return ans\n", "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = collections.defaultdict(TrieNode)\n    self.startsWith: list[str] = []\n\n\nclass Trie:\n  def __init__(self, words: list[str]):\n    self.root = TrieNode()\n    for word in words:\n      self._insert(word)\n\n  def findBy(self, prefix: str) -> list[str]:\n    node = self.root\n    for c in prefix:\n      if c not in node.children:\n        return []\n      node = node.children[c]\n    return node.startsWith\n\n  def _insert(self, word: str) -> None:\n    node = self.root\n    for c in word:\n      node = node.children.setdefault(c, TrieNode())\n      node.startsWith.append(word)\n\n\nclass Solution:\n  def wordSquares(self, words: list[str]) -> list[list[str]]:\n    if not words:\n      return []\n\n    n = len(words[0])\n    ans = []\n    path = []\n    trie = Trie(words)\n\n    for word in words:\n      path.append(word)\n      self._dfs(trie, n, path, ans)\n      path.pop()\n\n    return ans\n\n  def _dfs(self, trie: Trie, n: int, path: list[str], ans: list[list[str]]):\n    if len(path) == n:\n      ans.append(path.copy())\n      return\n\n    prefix = self._getPrefix(path)\n\n    for s in trie.findBy(prefix):\n      path.append(s)\n      self.dfs(trie, n, path, ans)\n      path.pop()\n\n  def _getPrefix(self, path: list[str]) -> str:\n    \"\"\"\n    e.g. path = [\"wall\",\n                 \"area\"]\n       prefix =  \"le..\"\n    \"\"\"\n    prefix = []\n    index = len(path)\n    for s in path:\n      prefix.append(s[index])\n    return ''.join(prefix)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 409, "slug": "longest-palindrome", "solutions": ["class Solution:\n    def longestPalindrome(self, s: str) -> int:\n        cnt = Counter(s)\n        ans = sum(v // 2 * 2 for v in cnt.values())\n        ans += int(ans < len(s))\n        return ans\n", "class Solution:\n  def longestPalindrome(self, s: str) -> int:\n    ans = 0\n    count = collections.Counter(s)\n\n    for c in count.values():\n      ans += c if c % 2 == 0 else c - 1\n\n    hasOddCount = any(c % 2 == 1 for c in count.values())\n    return ans + hasOddCount\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 424, "slug": "longest-repeating-character-replacement", "solutions": ["class Solution:\n    def characterReplacement(self, s: str, k: int) -> int:\n        cnt = Counter()\n        l = mx = 0\n        for r, c in enumerate(s):\n            cnt[c] += 1\n            mx = max(mx, cnt[c])\n            if r - l + 1 - mx > k:\n                cnt[s[l]] -= 1\n                l += 1\n        return len(s) - l\n", "class Solution:\n  def characterReplacement(self, s: str, k: int) -> int:\n    ans = 0\n    maxCount = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] += 1\n      maxCount = max(maxCount, count[c])\n      while maxCount + k < r - l + 1:\n        count[s[l]] -= 1\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans\n", "class Solution:\n  def characterReplacement(self, s: str, k: int) -> int:\n    maxCount = 0\n    count = collections.Counter()\n\n    # l and r track the maximum window instead of the valid window.\n    l = 0\n    for r, c in enumerate(s):\n      count[c] += 1\n      maxCount = max(maxCount, count[c])\n      while maxCount + k < r - l + 1:\n        count[s[l]] -= 1\n        l += 1\n\n    return r - l + 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 498, "slug": "diagonal-traverse", "solutions": ["class Solution:\n    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:\n        m, n = len(mat), len(mat[0])\n        ans = []\n        for k in range(m + n - 1):\n            t = []\n            i = 0 if k < n else k - n + 1\n            j = k if k < n else n - 1\n            while i < m and j >= 0:\n                t.append(mat[i][j])\n                i += 1\n                j -= 1\n            if k % 2 == 0:\n                t = t[::-1]\n            ans.extend(t)\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 407, "slug": "trapping-rain-water-ii", "solutions": ["class Solution:\n    def trapRainWater(self, heightMap: List[List[int]]) -> int:\n        m, n = len(heightMap), len(heightMap[0])\n        vis = [[False] * n for _ in range(m)]\n        pq = []\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m - 1 or j == 0 or j == n - 1:\n                    heappush(pq, (heightMap[i][j], i, j))\n                    vis[i][j] = True\n        ans = 0\n        dirs = (-1, 0, 1, 0, -1)\n        while pq:\n            h, i, j = heappop(pq)\n            for a, b in pairwise(dirs):\n                x, y = i + a, j + b\n                if x >= 0 and x < m and y >= 0 and y < n and not vis[x][y]:\n                    ans += max(0, h - heightMap[x][y])\n                    vis[x][y] = True\n                    heappush(pq, (max(h, heightMap[x][y]), x, y))\n        return ans\n", "class Solution:\n  def trapRainWater(self, heightMap: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(heightMap)\n    n = len(heightMap[0])\n    ans = 0\n    minHeap = []\n    seen = set()\n\n    for i in range(m):\n      heapq.heappush(minHeap, (heightMap[i][0], i, 0))\n      heapq.heappush(minHeap, (heightMap[i][n - 1], i, n - 1))\n      seen.add((i, 0))\n      seen.add((i, n - 1))\n\n    for j in range(1, n - 1):\n      heapq.heappush(minHeap, (heightMap[0][j], 0, j))\n      heapq.heappush(minHeap, (heightMap[m - 1][j], m - 1, j))\n      seen.add((0, j))\n      seen.add((m - 1, j))\n\n    while minHeap:\n      h, i, j = heapq.heappop(minHeap)\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if (x, y) in seen:\n          continue\n        if heightMap[x][y] < h:\n          ans += h - heightMap[x][y]\n          # Fill water in grid[x][y].\n          heapq.heappush(minHeap, (h, x, y))\n        else:\n          heapq.heappush(minHeap, (heightMap[x][y], x, y))\n        seen.add((x, y))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 479, "slug": "largest-palindrome-product", "solutions": ["class Solution:\n    def largestPalindrome(self, n: int) -> int:\n        mx = 10**n - 1\n        for a in range(mx, mx // 10, -1):\n            b = x = a\n            while b:\n                x = x * 10 + b % 10\n                b //= 10\n            t = mx\n            while t * t >= x:\n                if x % t == 0:\n                    return x % 1337\n                t -= 1\n        return 9\n", "class Solution:\n  def largestPalindrome(self, n: int) -> int:\n    if n == 1:\n      return 9\n\n    MOD = 1337\n    upper = pow(10, n) - 1\n    lower = pow(10, n - 1) - 1\n\n    for i in range(upper, lower, -1):\n      cand = int(str(i) + str(i)[::-1])\n      j = upper\n      while j * j >= cand:\n        if cand % j == 0:\n          return cand % MOD\n        j -= 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 406, "slug": "queue-reconstruction-by-height", "solutions": ["class Solution:\n    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:\n        people.sort(key=lambda x: (-x[0], x[1]))\n        ans = []\n        for p in people:\n            ans.insert(p[1], p)\n        return ans\n", "class Solution:\n  def reconstructQueue(self, people: list[list[int]]) -> list[list[int]]:\n    ans = []\n\n    people.sort(key=lambda x: (-x[0], x[1]))\n\n    for p in people:\n      ans.insert(p[1], p)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 490, "slug": "the-maze", "solutions": ["class Solution:\n    def hasPath(\n        self, maze: List[List[int]], start: List[int], destination: List[int]\n    ) -> bool:\n        def dfs(i, j):\n            if vis[i][j]:\n                return\n            vis[i][j] = True\n            if [i, j] == destination:\n                return\n            for a, b in [[0, -1], [0, 1], [1, 0], [-1, 0]]:\n                x, y = i, j\n                while 0 <= x + a < m and 0 <= y + b < n and maze[x + a][y + b] == 0:\n                    x, y = x + a, y + b\n                dfs(x, y)\n\n        m, n = len(maze), len(maze[0])\n        vis = [[False] * n for _ in range(m)]\n        dfs(start[0], start[1])\n        return vis[destination[0]][destination[1]]\n", "class Solution:\n  def hasPath(\n      self,\n      maze: list[list[int]],\n      start: list[int],\n      destination: list[int],\n  ) -> bool:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(maze)\n    n = len(maze[0])\n\n    seen = set()\n\n    def isValid(x: int, y: int) -> bool:\n      return 0 <= x < m and 0 <= y < n and maze[x][y] == 0\n\n    def dfs(i: int, j: int) -> bool:\n      if [i, j] == destination:\n        return True\n      if (i, j) in seen:\n        return False\n\n      seen.add((i, j))\n\n      for dx, dy in DIRS:\n        x = i\n        y = j\n        while isValid(x + dx, y + dy):\n          x += dx\n          y += dy\n        if dfs(x, y):\n          return True\n\n      return False\n\n    return dfs(start[0], start[1])\n", "class Solution:\n  def hasPath(\n      self,\n      maze: list[list[int]],\n      start: list[int],\n      destination: list[int],\n  ) -> bool:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(maze)\n    n = len(maze[0])\n    q = collections.deque([(start[0], start[1])])\n    seen = {(start[0], start[1])}\n\n    def isValid(x: int, y: int) -> bool:\n      return 0 <= x < m and 0 <= y < n and maze[x][y] == 0\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in DIRS:\n        x = i\n        y = j\n        while isValid(x + dx, y + dy):\n          x += dx\n          y += dy\n        if [x, y] == destination:\n          return True\n        if (x, y) in seen:\n          continue\n        q.append((x, y))\n        seen.add((x, y))\n\n    return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 475, "slug": "heaters", "solutions": ["class Solution:\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\n        houses.sort()\n        heaters.sort()\n\n        def check(r):\n            m, n = len(houses), len(heaters)\n            i = j = 0\n            while i < m:\n                if j >= n:\n                    return False\n                mi = heaters[j] - r\n                mx = heaters[j] + r\n                if houses[i] < mi:\n                    return False\n                if houses[i] > mx:\n                    j += 1\n                else:\n                    i += 1\n            return True\n\n        left, right = 0, int(1e9)\n        while left < right:\n            mid = (left + right) >> 1\n            if check(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 477, "slug": "total-hamming-distance", "solutions": ["class Solution:\n    def totalHammingDistance(self, nums: List[int]) -> int:\n        ans, n = 0, len(nums)\n        for i in range(32):\n            a = sum(x >> i & 1 for x in nums)\n            b = n - a\n            ans += a * b\n        return ans\n", "class Solution:\n  def totalHammingDistance(self, nums: list[int]) -> int:\n    MAX_BIT = 30\n    ans = 0\n\n    for i in range(MAX_BIT):\n      ones = sum(num & (1 << i) > 0 for num in nums)\n      zeros = len(nums) - ones\n      ans += ones * zeros\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 465, "slug": "optimal-account-balancing", "solutions": ["class Solution:\n    def minTransfers(self, transactions: List[List[int]]) -> int:\n        g = defaultdict(int)\n        for f, t, x in transactions:\n            g[f] -= x\n            g[t] += x\n        nums = [x for x in g.values() if x]\n        m = len(nums)\n        f = [inf] * (1 << m)\n        f[0] = 0\n        for i in range(1, 1 << m):\n            s = 0\n            for j, x in enumerate(nums):\n                if i >> j & 1:\n                    s += x\n            if s == 0:\n                f[i] = i.bit_count() - 1\n                j = (i - 1) & i\n                while j > 0:\n                    f[i] = min(f[i], f[j] + f[i ^ j])\n                    j = (j - 1) & i\n        return f[-1]\n", "class Solution:\n  def minTransfers(self, transactions: list[list[int]]) -> int:\n    balance = [0] * 21\n\n    for u, v, amount in transactions:\n      balance[u] -= amount\n      balance[v] += amount\n\n    debts = [b for b in balance if b]\n\n    def dfs(s: int) -> int:\n      while s < len(debts) and not debts[s]:\n        s += 1\n      if s == len(debts):\n        return 0\n\n      ans = math.inf\n\n      for i in range(s + 1, len(debts)):\n        if debts[i] * debts[s] < 0:\n          debts[i] += debts[s]  # `debts[s]` is settled.\n          ans = min(ans, 1 + dfs(s + 1))\n          debts[i] -= debts[s]  # Backtrack.\n\n      return ans\n\n    return dfs(0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 471, "slug": "encode-string-with-shortest-length", "solutions": ["class Solution:\n    def encode(self, s: str) -> str:\n        def g(i: int, j: int) -> str:\n            t = s[i : j + 1]\n            if len(t) < 5:\n                return t\n            k = (t + t).index(t, 1)\n            if k < len(t):\n                cnt = len(t) // k\n                return f\"{cnt}[{f[i][i + k - 1]}]\"\n            return t\n\n        n = len(s)\n        f = [[None] * n for _ in range(n)]\n        for i in range(n - 1, -1, -1):\n            for j in range(i, n):\n                f[i][j] = g(i, j)\n                if j - i + 1 > 4:\n                    for k in range(i, j):\n                        t = f[i][k] + f[k + 1][j]\n                        if len(f[i][j]) > len(t):\n                            f[i][j] = t\n        return f[0][-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 481, "slug": "magical-string", "solutions": ["class Solution:\n    def magicalString(self, n: int) -> int:\n        s = [1, 2, 2]\n        i = 2\n        while len(s) < n:\n            pre = s[-1]\n            cur = 3 - pre\n            s += [cur] * s[i]\n            i += 1\n        return s[:n].count(1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 426, "slug": "convert-binary-search-tree-to-sorted-doubly-linked-list", "solutions": ["\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\"\"\"\n\n\nclass Solution:\n    def treeToDoublyList(self, root: 'Optional[Node]') -> 'Optional[Node]':\n        def dfs(root):\n            if root is None:\n                return\n            nonlocal prev, head\n            dfs(root.left)\n            if prev:\n                prev.right = root\n                root.left = prev\n            else:\n                head = root\n            prev = root\n            dfs(root.right)\n\n        if root is None:\n            return None\n        head = prev = None\n        dfs(root)\n        prev.right = head\n        head.left = prev\n        return head\n", "class Solution:\n  def treeToDoublyList(self, root: 'Node | None') -> 'Node | None':\n    if not root:\n      return None\n\n    stack = []\n    first = None\n    pred = None\n\n    while root or stack:\n      while root:\n        stack.append(root)\n        root = root.left\n      root = stack.pop()\n      if not first:\n        first = root\n      if pred:\n        pred.right = root\n        root.left = pred\n      pred = root\n      root = root.right\n\n    pred.right = first\n    first.left = pred\n    return first\n", "class Solution:\n  def treeToDoublyList(self, root: 'Node | None') -> 'Node | None':\n    if not root:\n      return None\n    leftHead = self.treeToDoublyList(root.left)\n    rightHead = self.treeToDoublyList(root.right)\n    root.left = root\n    root.right = root\n    return self._connect(self._connect(leftHead, root), rightHead)\n\n  def _connect(self, node1: 'Node | None', node2: 'Node | None') -> 'Node | None':\n    if not node1:\n      return node2\n    if not node2:\n      return node1\n\n    tail1 = node1.left\n    tail2 = node2.left\n\n    # Connect node1's tail with node2.\n    tail1.right = node2\n    node2.left = tail1\n\n    # Connect node2's tail with node1.\n    tail2.right = node1\n    node1.left = tail2\n    return node1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 478, "slug": "generate-random-point-in-a-circle", "solutions": ["class Solution:\n    def __init__(self, radius: float, x_center: float, y_center: float):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self) -> List[float]:\n        length = math.sqrt(random.uniform(0, self.radius**2))\n        degree = random.uniform(0, 1) * 2 * math.pi\n        x = self.x_center + length * math.cos(degree)\n        y = self.y_center + length * math.sin(degree)\n        return [x, y]\n", "class Solution:\n  def __init__(self, radius: float, x_center: float, y_center: float):\n    self.radius = radius\n    self.x_center = x_center\n    self.y_center = y_center\n\n  def randPoint(self) -> list[float]:\n    length = math.sqrt(random.uniform(0, 1)) * self.radius\n    degree = random.uniform(0, 1) * 2 * math.pi\n    x = self.x_center + length * math.cos(degree)\n    y = self.y_center + length * math.sin(degree)\n    return [x, y]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 476, "slug": "number-complement", "solutions": ["class Solution:\n    def findComplement(self, num: int) -> int:\n        return num ^ ((1 << num.bit_length()) - 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 468, "slug": "validate-ip-address", "solutions": ["class Solution:\n    def validIPAddress(self, queryIP: str) -> str:\n        def is_ipv4(s: str) -> bool:\n            ss = s.split(\".\")\n            if len(ss) != 4:\n                return False\n            for t in ss:\n                if len(t) > 1 and t[0] == \"0\":\n                    return False\n                if not t.isdigit() or not 0 <= int(t) <= 255:\n                    return False\n            return True\n\n        def is_ipv6(s: str) -> bool:\n            ss = s.split(\":\")\n            if len(ss) != 8:\n                return False\n            for t in ss:\n                if not 1 <= len(t) <= 4:\n                    return False\n                if not all(c in \"0123456789abcdefABCDEF\" for c in t):\n                    return False\n            return True\n\n        if is_ipv4(queryIP):\n            return \"IPv4\"\n        if is_ipv6(queryIP):\n            return \"IPv6\"\n        return \"Neither\"\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 411, "slug": "minimum-unique-word-abbreviation", "solutions": ["class Solution:\n  def minAbbreviation(self, target: str, dictionary: list[str]) -> str:\n    m = len(target)\n\n    def getMask(word: str) -> int:\n      # mask[i] = 0 := target[i] == word[i]\n      # mask[i] = 1 := target[i] != word[i]\n      # e.g. target = \"apple\"\n      #        word = \"blade\"\n      #        mask =  11110\n      mask = 0\n      for i, c in enumerate(word):\n        if c != target[i]:\n          mask |= 1 << m - 1 - i\n      return mask\n\n    masks = [getMask(word) for word in dictionary if len(word) == m]\n    if not masks:\n      return str(m)\n\n    abbrs = []\n\n    def getAbbr(cand: int) -> str:\n      abbr = []\n      replacedCount = 0\n      for i, c in enumerate(target):\n        if cand >> m - 1 - i & 1:\n          # If cand[i] = 1, `abbr` should show the original character.\n          if replacedCount:\n            abbr += str(replacedCount)\n          abbr.append(c)\n          replacedCount = 0\n        else:\n          # If cand[i] = 0, `abbr` can be replaced.\n          replacedCount += 1\n      if replacedCount:\n        abbr.append(str(replacedCount))\n      return ''.join(abbr)\n\n    # all the candidate representation of the target\n    for cand in range(2**m):\n      # All the masks have at lease one bit different from the candidate.\n      if all(cand & mask for mask in masks):\n        abbr = getAbbr(cand)\n        abbrs.append(abbr)\n\n    def getAbbrLen(abbr: str) -> int:\n      abbrLen = 0\n      i = 0\n      j = 0\n      while i < len(abbr):\n        if abbr[j].isalpha():\n          j += 1\n        else:\n          while j < len(abbr) and abbr[j].isdigit():\n            j += 1\n        abbrLen += 1\n        i = j\n      return abbrLen\n\n    return min(abbrs, key=lambda x: getAbbrLen(x))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 432, "slug": "all-oone-data-structure", "solutions": ["class Node:\n    def __init__(self, key='', cnt=0):\n        self.prev = None\n        self.next = None\n        self.cnt = cnt\n        self.keys = {key}\n\n    def insert(self, node):\n        node.prev = self\n        node.next = self.next\n        node.prev.next = node\n        node.next.prev = node\n        return node\n\n    def remove(self):\n        self.prev.next = self.next\n        self.next.prev = self.prev\n\n\nclass AllOne:\n    def __init__(self):\n        self.root = Node()\n        self.root.next = self.root\n        self.root.prev = self.root\n        self.nodes = {}\n\n    def inc(self, key: str) -> None:\n        root, nodes = self.root, self.nodes\n        if key not in nodes:\n            if root.next == root or root.next.cnt > 1:\n                nodes[key] = root.insert(Node(key, 1))\n            else:\n                root.next.keys.add(key)\n                nodes[key] = root.next\n        else:\n            curr = nodes[key]\n            next = curr.next\n            if next == root or next.cnt > curr.cnt + 1:\n                nodes[key] = curr.insert(Node(key, curr.cnt + 1))\n            else:\n                next.keys.add(key)\n                nodes[key] = next\n            curr.keys.discard(key)\n            if not curr.keys:\n                curr.remove()\n\n    def dec(self, key: str) -> None:\n        root, nodes = self.root, self.nodes\n        curr = nodes[key]\n        if curr.cnt == 1:\n            nodes.pop(key)\n        else:\n            prev = curr.prev\n            if prev == root or prev.cnt < curr.cnt - 1:\n                nodes[key] = prev.insert(Node(key, curr.cnt - 1))\n            else:\n                prev.keys.add(key)\n                nodes[key] = prev\n        curr.keys.discard(key)\n        if not curr.keys:\n            curr.remove()\n\n    def getMaxKey(self) -> str:\n        return next(iter(self.root.prev.keys))\n\n    def getMinKey(self) -> str:\n        return next(iter(self.root.next.keys))\n\n\n# Your AllOne object will be instantiated and called as such:\n# obj = AllOne()\n# obj.inc(key)\n# obj.dec(key)\n# param_3 = obj.getMaxKey()\n# param_4 = obj.getMinKey()\n", "from dataclasses import dataclass\n\n\n@dataclass\nclass Node:\n  def __init__(self, count: int, key: str | None = None):\n    self.count = count\n    self.keys: set[str] = {key} if key else set()\n    self.prev: Node | None = None\n    self.next: Node | None = None\n\n  def __eq__(self, other) -> bool:\n    if not isinstance(other, Node):\n      return NotImplemented\n    return self.count == other.count and self.keys == other.keys\n\n\nclass AllOne:\n  def __init__(self):\n    self.keyToNode: dict[str, Node] = {}\n    self.head = Node(0)\n    self.tail = Node(0)\n    self.head.next = self.tail\n    self.tail.prev = self.head\n\n  def inc(self, key: str) -> None:\n    if key in self.keyToNode:\n      self._incrementExistingKey(key)\n    else:\n      self._addNewKey(key)\n\n  def dec(self, key: str) -> None:\n    # It is guaranteed that key exists in the data structure before the\n    # decrement.\n    self._decrementExistingKey(key)\n\n  def getMaxKey(self) -> str:\n    return '' if self.tail.prev == self.head \\\n        else next(iter(self.tail.prev.keys))\n\n  def getMinKey(self) -> str:\n    return '' if self.head.next == self.tail \\\n        else next(iter(self.head.next.keys))\n\n  def _addNewKey(self, key: str) -> None:\n    \"\"\"Adds a new node with frequency 1.\"\"\"\n    if self.head.next.count == 1:\n      self.head.next.keys.add(key)\n    else:\n      self._insertAfter(self.head, Node(1, key))\n    self.keyToNode[key] = self.head.next\n\n  def _incrementExistingKey(self, key: str) -> None:\n    \"\"\"Increments the frequency of the key by 1.\"\"\"\n    node = self.keyToNode[key]\n    node.keys.remove(key)\n    if node.next == self.tail or node.next.count > node.count + 1:\n      self._insertAfter(node, Node(node.count + 1))\n    node.next.keys.add(key)\n    self.keyToNode[key] = node.next\n    if not node.keys:\n      self._remove(node)\n\n  def _decrementExistingKey(self, key: str) -> None:\n    \"\"\"Decrements the count of the key by 1.\"\"\"\n    node = self.keyToNode[key]\n    node.keys.remove(key)\n    if node.count > 1:\n      if node.prev == self.head or node.prev.count != node.count - 1:\n        self._insertAfter(node.prev, Node(node.count - 1))\n      node.prev.keys.add(key)\n      self.keyToNode[key] = node.prev\n    else:\n      del self.keyToNode[key]\n    if not node.keys:\n      self._remove(node)\n\n  def _insertAfter(self, node: Node, newNode: Node) -> None:\n    newNode.prev = node\n    newNode.next = node.next\n    node.next.prev = newNode\n    node.next = newNode\n\n  def _remove(self, node: Node) -> None:\n    node.prev.next = node.next\n    node.next.prev = node.prev\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 463, "slug": "island-perimeter", "solutions": ["class Solution:\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        ans = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    ans += 4\n                    if i < m - 1 and grid[i + 1][j] == 1:\n                        ans -= 2\n                    if j < n - 1 and grid[i][j + 1] == 1:\n                        ans -= 2\n        return ans\n", "class Solution:\n  def islandPerimeter(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    islands = 0\n    neighbors = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1:\n          islands += 1\n          if i + 1 < m and grid[i + 1][j] == 1:\n            neighbors += 1\n          if j + 1 < n and grid[i][j + 1] == 1:\n            neighbors += 1\n\n    return islands * 4 - neighbors * 2\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 466, "slug": "count-the-repetitions", "solutions": ["class Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n        n = len(s2)\n        d = {}\n        for i in range(n):\n            cnt = 0\n            j = i\n            for c in s1:\n                if c == s2[j]:\n                    j += 1\n                if j == n:\n                    cnt += 1\n                    j = 0\n            d[i] = (cnt, j)\n\n        ans = 0\n        j = 0\n        for _ in range(n1):\n            cnt, j = d[j]\n            ans += cnt\n        return ans // n2\n", "from dataclasses import dataclass\n\n\n@dataclass\nclass Record:\n  count: int\n  nextIndex: int\n\n\nclass Solution:\n  def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n    # records[i].count := the number of times that s2 starting from index i has\n    # been fully matched with s1\n    # records[i].nextIndex := the next index in s2 to be matched after\n    # completing a full match starting from index i\n    records = []\n\n    for nextIndex in range(len(s2)):\n      count = 0\n      for c in s1:\n        if s2[nextIndex] == c:\n          nextIndex += 1\n          if nextIndex == len(s2):  # There's a match.\n            count += 1\n            nextIndex = 0\n      records.append(Record(count, nextIndex))\n\n    matches = 0  # the number of matches between `s1` x n1 and `s2`\n    i = 0  # the index in `s2` to start matching\n\n    for _ in range(n1):\n      matches += records[i].count\n      i = records[i].nextIndex\n\n    return matches // n2\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 499, "slug": "the-maze-iii", "solutions": ["class Solution:\n    def findShortestWay(\n        self, maze: List[List[int]], ball: List[int], hole: List[int]\n    ) -> str:\n        m, n = len(maze), len(maze[0])\n        r, c = ball\n        rh, ch = hole\n        q = deque([(r, c)])\n        dist = [[inf] * n for _ in range(m)]\n        dist[r][c] = 0\n        path = [[None] * n for _ in range(m)]\n        path[r][c] = ''\n        while q:\n            i, j = q.popleft()\n            for a, b, d in [(-1, 0, 'u'), (1, 0, 'd'), (0, -1, 'l'), (0, 1, 'r')]:\n                x, y, step = i, j, dist[i][j]\n                while (\n                    0 <= x + a < m\n                    and 0 <= y + b < n\n                    and maze[x + a][y + b] == 0\n                    and (x != rh or y != ch)\n                ):\n                    x, y = x + a, y + b\n                    step += 1\n                if dist[x][y] > step or (\n                    dist[x][y] == step and path[i][j] + d < path[x][y]\n                ):\n                    dist[x][y] = step\n                    path[x][y] = path[i][j] + d\n                    if x != rh or y != ch:\n                        q.append((x, y))\n        return path[rh][ch] or 'impossible'\n", "class Solution:\n  def findShortestWay(\n      self,\n      maze: list[list[int]],\n      ball: list[int],\n      hole: list[int],\n  ) -> str:\n    ans = 'impossible'\n    minSteps = math.inf\n\n    def dfs(i: int, j: int, dx: int, dy: int, steps: int, path: str):\n      nonlocal ans\n      nonlocal minSteps\n      if steps >= minSteps:\n        return\n\n      if dx != 0 or dy != 0:  # Both are zeros for the initial ball position.\n        while (0 <= i + dx < len(maze) and 0 <= j + dy < len(maze[0]) and\n               maze[i + dx][j + dy] != 1):\n          i += dx\n          j += dy\n          steps += 1\n          if i == hole[0] and j == hole[1] and steps < minSteps:\n            minSteps = steps\n            ans = path\n\n      if maze[i][j] == 0 or steps + 2 < maze[i][j]:\n        maze[i][j] = steps + 2  # +2 because maze[i][j] == 0 || 1.\n        if dx == 0:\n          dfs(i, j, 1, 0, steps, path + 'd')\n        if dy == 0:\n          dfs(i, j, 0, -1, steps, path + 'l')\n        if dy == 0:\n          dfs(i, j, 0, 1, steps, path + 'r')\n        if dx == 0:\n          dfs(i, j, -1, 0, steps, path + 'u')\n\n    dfs(ball[0], ball[1], 0, 0, 0, '')\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 436, "slug": "find-right-interval", "solutions": ["class Solution:\n    def findRightInterval(self, intervals: List[List[int]]) -> List[int]:\n        n = len(intervals)\n        ans = [-1] * n\n        arr = sorted((st, i) for i, (st, _) in enumerate(intervals))\n        for i, (_, ed) in enumerate(intervals):\n            j = bisect_left(arr, (ed, -inf))\n            if j < n:\n                ans[i] = arr[j][1]\n        return ans\n", "from sortedcontainers import SortedDict\n\n\nclass Solution:\n  def findRightInterval(self, intervals: list[list[int]]) -> list[int]:\n    ans = []\n    startToIndex = SortedDict()\n\n    for i, (start, end) in enumerate(intervals):\n      startToIndex[start] = i\n\n    for start, end in intervals:\n      i = startToIndex.bisect_left(end)\n      ans.append(-1 if i == len(startToIndex) else startToIndex.peekitem(i)[1])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 484, "slug": "find-permutation", "solutions": ["class Solution:\n    def findPermutation(self, s: str) -> List[int]:\n        n = len(s)\n        ans = list(range(1, n + 2))\n        i = 0\n        while i < n:\n            j = i\n            while j < n and s[j] == 'D':\n                j += 1\n            ans[i : j + 1] = ans[i : j + 1][::-1]\n            i = max(i + 1, j)\n        return ans\n", "class Solution:\n  def findPermutation(self, s: str) -> list[int]:\n    ans = [i for i in range(1, len(s) + 2)]\n\n    # For each D* group (s[i..j]), reverse ans[i..j + 1].\n    i = -1\n    j = -1\n\n    def getNextIndex(c: str, start: int) -> int:\n      for i in range(start, len(s)):\n        if s[i] == c:\n          return i\n      return len(s)\n\n    while True:\n      i = getNextIndex('D', j + 1)\n      if i == len(s):\n        break\n      j = getNextIndex('I', i + 1)\n      ans[i:j + 1] = ans[i:j + 1][::-1]\n\n    return ans\n", "class Solution:\n  def findPermutation(self, s: str) -> list[int]:\n    ans = []\n    stack = []\n\n    for i, c in enumerate(s):\n      stack.append(i + 1)\n      if c == 'I':\n        while stack:  # Consume all decreasings\n          ans.append(stack.pop())\n    stack.append(len(s) + 1)\n\n    while stack:\n      ans.append(stack.pop())\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 452, "slug": "minimum-number-of-arrows-to-burst-balloons", "solutions": ["class Solution:\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\n        ans, last = 0, -inf\n        for a, b in sorted(points, key=lambda x: x[1]):\n            if a > last:\n                ans += 1\n                last = b\n        return ans\n", "class Solution:\n  def findMinArrowShots(self, points: list[list[int]]) -> int:\n    ans = 0\n    arrowX = -math.inf\n\n    for point in sorted(points, key=lambda x: x[1]):\n      if point[0] > arrowX:\n        ans += 1\n        arrowX = point[1]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 403, "slug": "frog-jump", "solutions": ["class Solution:\n    def canCross(self, stones: List[int]) -> bool:\n        @cache\n        def dfs(i, k):\n            if i == n - 1:\n                return True\n            for j in range(k - 1, k + 2):\n                if j > 0 and stones[i] + j in pos and dfs(pos[stones[i] + j], j):\n                    return True\n            return False\n\n        n = len(stones)\n        pos = {s: i for i, s in enumerate(stones)}\n        return dfs(0, 0)\n", "class Solution:\n  def canCross(self, stones: list[int]) -> bool:\n    n = len(stones)\n    # dp[i][j] := True if a frog can make a size j jump from stones[i]\n    dp = [[False] * (n + 1) for _ in range(n)]\n    dp[0][1] = True\n\n    for i in range(1, n):\n      for j in range(i):\n        k = stones[i] - stones[j]\n        if k <= n and dp[j][k]:\n          dp[i][k - 1] = True\n          dp[i][k] = True\n          dp[i][k + 1] = True\n\n    return any(dp[-1])\n", "class Solution:\n  def canCross(self, stones: list[int]) -> bool:\n    n = len(stones)\n    # dp[i][j] := True if a frog can make a size j jump to stones[i]\n    dp = [[False] * (n + 1) for _ in range(n)]\n    dp[0][0] = True\n\n    for i in range(1, n):\n      for j in range(i):\n        k = stones[i] - stones[j]\n        if k > n:\n          continue\n        for x in (k - 1, k, k + 1):\n          if 0 <= x <= n:\n            dp[i][k] |= dp[j][x]\n\n    return any(dp[-1])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 495, "slug": "teemo-attacking", "solutions": ["class Solution:\n    def findPoisonedDuration(self, timeSeries: List[int], duration: int) -> int:\n        ans = duration\n        for a, b in pairwise(timeSeries):\n            ans += min(duration, b - a)\n        return ans\n", "class Solution:\n  def findPoisonedDuration(self, timeSeries: list[int], duration: int) -> int:\n    if duration == 0:\n      return 0\n\n    ans = 0\n\n    for i in range(0, len(timeSeries) - 1):\n      ans += min(timeSeries[i + 1] - timeSeries[i], duration)\n\n    return ans + duration\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 472, "slug": "concatenated-words", "solutions": ["class Trie:\n    def __init__(self):\n        self.children = [None] * 26\n        self.is_end = False\n\n    def insert(self, w):\n        node = self\n        for c in w:\n            idx = ord(c) - ord('a')\n            if node.children[idx] is None:\n                node.children[idx] = Trie()\n            node = node.children[idx]\n        node.is_end = True\n\n\nclass Solution:\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\n        def dfs(w):\n            if not w:\n                return True\n            node = trie\n            for i, c in enumerate(w):\n                idx = ord(c) - ord('a')\n                if node.children[idx] is None:\n                    return False\n                node = node.children[idx]\n                if node.is_end and dfs(w[i + 1 :]):\n                    return True\n            return False\n\n        trie = Trie()\n        ans = []\n        words.sort(key=lambda x: len(x))\n        for w in words:\n            if dfs(w):\n                ans.append(w)\n            else:\n                trie.insert(w)\n        return ans\n", "class Solution:\n  def findAllConcatenatedWordsInADict(self, words: list[str]) -> list[str]:\n    wordSet = set(words)\n\n    @functools.lru_cache(None)\n    def isConcat(word: str) -> bool:\n      for i in range(1, len(word)):\n        prefix = word[:i]\n        suffix = word[i:]\n        if prefix in wordSet and (suffix in wordSet or isConcat(suffix)):\n          return True\n\n      return False\n\n    return [word for word in words if isConcat(word)]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 413, "slug": "arithmetic-slices", "solutions": ["class Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        ans = cnt = 0\n        d = 3000\n        for a, b in pairwise(nums):\n            if b - a == d:\n                cnt += 1\n            else:\n                d = b - a\n                cnt = 0\n            ans += cnt\n        return ans\n", "class Solution:\n  def numberOfArithmeticSlices(self, nums: list[int]) -> int:\n    ans = 0\n    dp = 0\n\n    for i in range(2, len(nums)):\n      if nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]:\n        dp += 1\n        ans += dp\n      else:\n        dp = 0\n\n    return ans\n", "class Solution:\n  def numberOfArithmeticSlices(self, nums: list[int]) -> int:\n    n = len(nums)\n    if n < 3:\n      return 0\n\n    dp = [0] * n  # dp[i] := the number of arithmetic slices ending in index i\n\n    for i in range(2, len(nums)):\n      if nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]:\n        dp[i] = dp[i - 1] + 1\n\n    return sum(dp)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 461, "slug": "hamming-distance", "solutions": ["class Solution:\n    def hammingDistance(self, x: int, y: int) -> int:\n        return (x ^ y).bit_count()\n", "class Solution:\n  def hammingDistance(self, x: int, y: int) -> int:\n    ans = 0\n\n    while x > 0 or y > 0:\n      ans += (x & 1) ^ (y & 1)\n      x >>= 1\n      y >>= 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 480, "slug": "sliding-window-median", "solutions": ["class MedianFinder:\n    def __init__(self, k: int):\n        self.k = k\n        self.small = []\n        self.large = []\n        self.delayed = defaultdict(int)\n        self.small_size = 0\n        self.large_size = 0\n\n    def add_num(self, num: int):\n        if not self.small or num <= -self.small[0]:\n            heappush(self.small, -num)\n            self.small_size += 1\n        else:\n            heappush(self.large, num)\n            self.large_size += 1\n        self.rebalance()\n\n    def find_median(self) -> float:\n        return -self.small[0] if self.k & 1 else (-self.small[0] + self.large[0]) / 2\n\n    def remove_num(self, num: int):\n        self.delayed[num] += 1\n        if num <= -self.small[0]:\n            self.small_size -= 1\n            if num == -self.small[0]:\n                self.prune(self.small)\n        else:\n            self.large_size -= 1\n            if num == self.large[0]:\n                self.prune(self.large)\n        self.rebalance()\n\n    def prune(self, pq: List[int]):\n        sign = -1 if pq is self.small else 1\n        while pq and sign * pq[0] in self.delayed:\n            self.delayed[sign * pq[0]] -= 1\n            if self.delayed[sign * pq[0]] == 0:\n                self.delayed.pop(sign * pq[0])\n            heappop(pq)\n\n    def rebalance(self):\n        if self.small_size > self.large_size + 1:\n            heappush(self.large, -heappop(self.small))\n            self.small_size -= 1\n            self.large_size += 1\n            self.prune(self.small)\n        elif self.small_size < self.large_size:\n            heappush(self.small, -heappop(self.large))\n            self.large_size -= 1\n            self.small_size += 1\n            self.prune(self.large)\n\n\nclass Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        finder = MedianFinder(k)\n        for x in nums[:k]:\n            finder.add_num(x)\n        ans = [finder.find_median()]\n        for i in range(k, len(nums)):\n            finder.add_num(nums[i])\n            finder.remove_num(nums[i - k])\n            ans.append(finder.find_median())\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 420, "slug": "strong-password-checker", "solutions": ["class Solution:\n    def strongPasswordChecker(self, password: str) -> int:\n        def countTypes(s):\n            a = b = c = 0\n            for ch in s:\n                if ch.islower():\n                    a = 1\n                elif ch.isupper():\n                    b = 1\n                elif ch.isdigit():\n                    c = 1\n            return a + b + c\n\n        types = countTypes(password)\n        n = len(password)\n        if n < 6:\n            return max(6 - n, 3 - types)\n        if n <= 20:\n            replace = cnt = 0\n            prev = '~'\n            for curr in password:\n                if curr == prev:\n                    cnt += 1\n                else:\n                    replace += cnt // 3\n                    cnt = 1\n                    prev = curr\n            replace += cnt // 3\n            return max(replace, 3 - types)\n        replace = cnt = 0\n        remove, remove2 = n - 20, 0\n        prev = '~'\n        for curr in password:\n            if curr == prev:\n                cnt += 1\n            else:\n                if remove > 0 and cnt >= 3:\n                    if cnt % 3 == 0:\n                        remove -= 1\n                        replace -= 1\n                    elif cnt % 3 == 1:\n                        remove2 += 1\n                replace += cnt // 3\n                cnt = 1\n                prev = curr\n        if remove > 0 and cnt >= 3:\n            if cnt % 3 == 0:\n                remove -= 1\n                replace -= 1\n            elif cnt % 3 == 1:\n                remove2 += 1\n        replace += cnt // 3\n        use2 = min(replace, remove2, remove // 2)\n        replace -= use2\n        remove -= use2 * 2\n\n        use3 = min(replace, remove // 3)\n        replace -= use3\n        remove -= use3 * 3\n        return n - 20 + max(replace, 3 - types)\n", "class Solution:\n  def strongPasswordChecker(self, password: str) -> int:\n    n = len(password)\n    missing = self._getMissing(password)\n    # the number of replacements to deal with 3 repeating characters\n    replaces = 0\n    # the number of sequences that can be substituted with 1 deletions,\n    # (3k)-seqs\n    oneSeq = 0\n    # the number of sequences that can be substituted with 2 deletions,\n    # (3k + 1)-seqs\n    twoSeq = 0\n\n    i = 2\n    while i < n:\n      if password[i] == password[i - 1] and password[i - 1] == password[i - 2]:\n        length = 2  # the length of the repeating password\n        while i < n and password[i] == password[i - 1]:\n          length += 1\n          i += 1\n        replaces += length // 3  # 'aaaaaaa' -> 'aaxaaxa'\n        if length % 3 == 0:\n          oneSeq += 1\n        if length % 3 == 1:\n          twoSeq += 1\n      else:\n        i += 1\n\n    if n < 6:\n      return max(6 - n, missing)\n    if n <= 20:\n      return max(replaces, missing)\n\n    deletes = n - 20\n    # Each replacement in (3k)-seqs can be substituted with 1 deletions.\n    replaces -= min(oneSeq, deletes)\n    # Each replacement in (3k + 1)-seqs can be substituted with 2 deletions.\n    replaces -= min(max(deletes - oneSeq, 0), twoSeq * 2) // 2\n    # Each replacement in other seqs can be substituted with 3 deletions.\n    replaces -= max(deletes - oneSeq - twoSeq * 2, 0) // 3\n    return deletes + max(replaces, missing)\n\n  def _getMissing(self, password: str) -> int:\n    return (3\n            - any(c.isupper() for c in password)\n            - any(c.islower() for c in password)\n            - any(c.isdigit() for c in password))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 416, "slug": "partition-equal-subset-sum", "solutions": ["class Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n        m, mod = divmod(sum(nums), 2)\n        if mod:\n            return False\n        n = len(nums)\n        f = [[False] * (m + 1) for _ in range(n + 1)]\n        f[0][0] = True\n        for i, x in enumerate(nums, 1):\n            for j in range(m + 1):\n                f[i][j] = f[i - 1][j] or (j >= x and f[i - 1][j - x])\n        return f[n][m]\n", "class Solution:\n  def canPartition(self, nums: list[int]) -> bool:\n    summ = sum(nums)\n    if summ % 2 == 1:\n      return False\n    return self.knapsack_(nums, summ // 2)\n\n  def knapsack_(self, nums: list[int], subsetSum: int) -> bool:\n    n = len(nums)\n    # dp[i][j] := True if j can be formed by nums[0..i)\n    dp = [[False] * (subsetSum + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n      num = nums[i - 1]\n      for j in range(subsetSum + 1):\n        if j < num:\n          dp[i][j] = dp[i - 1][j]\n        else:\n          dp[i][j] = dp[i - 1][j] or dp[i - 1][j - num]\n\n    return dp[n][subsetSum]\n", "class Solution:\n  def canPartition(self, nums: list[int]) -> bool:\n    summ = sum(nums)\n    if summ % 2 == 1:\n      return False\n    return self.knapsack_(nums, summ // 2)\n\n  def knapsack_(self, nums: list[int], subsetSum: int) -> bool:\n    # dp[i] := True if i can be formed by nums so far\n    dp = [False] * (subsetSum + 1)\n    dp[0] = True\n\n    for num in nums:\n      for i in range(subsetSum, num - 1, -1):\n        dp[i] = dp[i] or dp[i - num]\n\n    return dp[subsetSum]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 496, "slug": "next-greater-element-i", "solutions": ["class Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        stk = []\n        d = {}\n        for x in nums2[::-1]:\n            while stk and stk[-1] < x:\n                stk.pop()\n            if stk:\n                d[x] = stk[-1]\n            stk.append(x)\n        return [d.get(x, -1) for x in nums1]\n", "class Solution:\n  def nextGreaterElement(self, nums1: list[int], nums2: list[int]) -> list[int]:\n    numToNextGreater = {}\n    stack = []  # a decreasing stack\n\n    for num in nums2:\n      while stack and stack[-1] < num:\n        numToNextGreater[stack.pop()] = num\n      stack.append(num)\n\n    return [numToNextGreater.get(num, -1) for num in nums1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 464, "slug": "can-i-win", "solutions": ["class Solution:\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\n        @cache\n        def dfs(mask: int, s: int) -> bool:\n            for i in range(1, maxChoosableInteger + 1):\n                if mask >> i & 1 ^ 1:\n                    if s + i >= desiredTotal or not dfs(mask | 1 << i, s + i):\n                        return True\n            return False\n\n        if (1 + maxChoosableInteger) * maxChoosableInteger // 2 < desiredTotal:\n            return False\n        return dfs(0, 0)\n", "class Solution:\n  def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\n    if desiredTotal <= 0:\n      return True\n\n    totalSum = maxChoosableInteger * (maxChoosableInteger + 1) // 2\n    if totalSum < desiredTotal:\n      return False\n\n    @functools.lru_cache(None)\n    def dp(total: int, used: int) -> bool:\n      \"\"\"\n      Returns true if the first player can we, where `used` represents the use\n      numbers.\n      \"\"\"\n      if total <= 0:\n        return False\n      return any((used >> i & 1) == 0\n                 and not dp(total - i, used | 1 << i)\n                 for i in range(1, maxChoosableInteger + 1))\n\n    return dp(desiredTotal, 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 456, "slug": "132-pattern", "solutions": ["class Solution:\n    def find132pattern(self, nums: List[int]) -> bool:\n        vk = -inf\n        stk = []\n        for x in nums[::-1]:\n            if x < vk:\n                return True\n            while stk and stk[-1] < x:\n                vk = stk.pop()\n            stk.append(x)\n        return False\n", "class Solution:\n  def find132pattern(self, nums: list[int]) -> bool:\n    stack = []  # a decreasing stack\n    ak = -math.inf  # Find a seq, where ai < ak < aj.\n\n    for num in reversed(nums):\n      # If ai < ak, done because ai must < aj.\n      if num < ak:\n        return True\n      while stack and stack[-1] < num:\n        ak = stack[-1]\n        stack.pop()\n      stack.append(num)  # `nums[i]` is a candidate of aj.\n\n    return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 448, "slug": "find-all-numbers-disappeared-in-an-array", "solutions": ["class Solution:\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\n        s = set(nums)\n        return [x for x in range(1, len(nums) + 1) if x not in s]\n", "class Solution:\n  def findDisappearedNumbers(self, nums: list[int]) -> list[int]:\n    for num in nums:\n      index = abs(num) - 1\n      nums[index] = -abs(nums[index])\n\n    return [i + 1 for i, num in enumerate(nums) if num > 0]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 457, "slug": "circular-array-loop", "solutions": ["class Solution:\n    def circularArrayLoop(self, nums: List[int]) -> bool:\n        n = len(nums)\n\n        def next(i):\n            return (i + nums[i] % n + n) % n\n\n        for i in range(n):\n            if nums[i] == 0:\n                continue\n            slow, fast = i, next(i)\n            while nums[slow] * nums[fast] > 0 and nums[slow] * nums[next(fast)] > 0:\n                if slow == fast:\n                    if slow != next(slow):\n                        return True\n                    break\n                slow, fast = next(slow), next(next(fast))\n            j = i\n            while nums[j] * nums[next(j)] > 0:\n                nums[j] = 0\n                j = next(j)\n        return False\n", "class Solution:\n  def circularArrayLoop(self, nums: list[int]) -> bool:\n    def advance(i: int) -> int:\n      return (i + nums[i]) % len(nums)\n\n    if len(nums) < 2:\n      return False\n\n    for i, num in enumerate(nums):\n      if num == 0:\n        continue\n\n      slow = i\n      fast = advance(slow)\n      while num * nums[fast] > 0 and num * nums[advance(fast)] > 0:\n        if slow == fast:\n          if slow == advance(slow):\n            break\n          return True\n        slow = advance(slow)\n        fast = advance(advance(fast))\n\n      slow = i\n      sign = num\n      while sign * nums[slow] > 0:\n        next = advance(slow)\n        nums[slow] = 0\n        slow = next\n\n    return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 493, "slug": "reverse-pairs", "solutions": ["class Solution:\n    def reversePairs(self, nums: List[int]) -> int:\n        def merge_sort(l, r):\n            if l >= r:\n                return 0\n            mid = (l + r) >> 1\n            ans = merge_sort(l, mid) + merge_sort(mid + 1, r)\n            t = []\n            i, j = l, mid + 1\n            while i <= mid and j <= r:\n                if nums[i] <= 2 * nums[j]:\n                    i += 1\n                else:\n                    ans += mid - i + 1\n                    j += 1\n            i, j = l, mid + 1\n            while i <= mid and j <= r:\n                if nums[i] <= nums[j]:\n                    t.append(nums[i])\n                    i += 1\n                else:\n                    t.append(nums[j])\n                    j += 1\n            t.extend(nums[i : mid + 1])\n            t.extend(nums[j : r + 1])\n            nums[l : r + 1] = t\n            return ans\n\n        return merge_sort(0, len(nums) - 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 491, "slug": "non-decreasing-subsequences", "solutions": ["class Solution:\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\n        def dfs(u, last, t):\n            if u == len(nums):\n                if len(t) > 1:\n                    ans.append(t[:])\n                return\n            if nums[u] >= last:\n                t.append(nums[u])\n                dfs(u + 1, nums[u], t)\n                t.pop()\n            if nums[u] != last:\n                dfs(u + 1, last, t)\n\n        ans = []\n        dfs(0, -1000, [])\n        return ans\n", "class Solution:\n  def findSubsequences(self, nums: list[int]) -> list[list[int]]:\n    ans = []\n\n    def dfs(s: int, path: list[int]) -> None:\n      if len(path) > 1:\n        ans.append(path)\n\n      used = set()\n\n      for i in range(s, len(nums)):\n        if nums[i] in used:\n          continue\n        if not path or nums[i] >= path[-1]:\n          used.add(nums[i])\n          dfs(i + 1, path + [nums[i]])\n\n    dfs(0, [])\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 474, "slug": "ones-and-zeroes", "solutions": ["class Solution:\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\n        sz = len(strs)\n        f = [[[0] * (n + 1) for _ in range(m + 1)] for _ in range(sz + 1)]\n        for i, s in enumerate(strs, 1):\n            a, b = s.count(\"0\"), s.count(\"1\")\n            for j in range(m + 1):\n                for k in range(n + 1):\n                    f[i][j][k] = f[i - 1][j][k]\n                    if j >= a and k >= b:\n                        f[i][j][k] = max(f[i][j][k], f[i - 1][j - a][k - b] + 1)\n        return f[sz][m][n]\n", "class Solution:\n  def findMaxForm(self, strs: list[str], m: int, n: int) -> int:\n    # dp[i][j] := the maximum size of the subset given i 0s and j 1s are\n    # available\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for s in strs:\n      zeros = s.count('0')\n      ones = len(s) - zeros\n      for i in range(m, zeros - 1, -1):\n        for j in range(n, ones - 1, -1):\n          dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)\n\n    return dp[m][n]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 494, "slug": "target-sum", "solutions": ["class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        s = sum(nums)\n        if s < target or (s - target) % 2:\n            return 0\n        m, n = len(nums), (s - target) // 2\n        f = [[0] * (n + 1) for _ in range(m + 1)]\n        f[0][0] = 1\n        for i, x in enumerate(nums, 1):\n            for j in range(n + 1):\n                f[i][j] = f[i - 1][j]\n                if j >= x:\n                    f[i][j] += f[i - 1][j - x]\n        return f[m][n]\n", "class Solution:\n  def findTargetSumWays(self, nums: list[int], target: int) -> int:\n    summ = sum(nums)\n    if summ < abs(target) or (summ + target) % 2 == 1:\n      return 0\n\n    def knapsack(target: int) -> int:\n      # dp[i] := the number of ways to sum to i by nums so far\n      dp = [1] + [0] * summ\n\n      for num in nums:\n        for j in range(summ, num - 1, -1):\n          dp[j] += dp[j - num]\n\n      return dp[target]\n\n    return knapsack((summ + target) // 2)\n", "class Solution:\n  def findTargetSumWays(self, nums: list[int], target: int) -> int:\n    summ = sum(nums)\n    if summ < abs(target) or (summ + target) % 2 == 1:\n      return 0\n\n    def knapsack(nums: list[int], target: int) -> int:\n      # dp[i] := the number of ways to sum to i by nums so far\n      dp = [0] * (target + 1)\n      dp[0] = 1\n\n      for num in nums:\n        for i in range(target, num - 1, -1):\n          dp[i] += dp[i - num]\n\n      return dp[target]\n\n    return knapsack(nums, (summ + target) // 2)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 415, "slug": "add-strings", "solutions": ["class Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        i, j = len(num1) - 1, len(num2) - 1\n        ans = []\n        c = 0\n        while i >= 0 or j >= 0 or c:\n            a = 0 if i < 0 else int(num1[i])\n            b = 0 if j < 0 else int(num2[j])\n            c, v = divmod(a + b + c, 10)\n            ans.append(str(v))\n            i, j = i - 1, j - 1\n        return \"\".join(ans[::-1])\n\n    def subStrings(self, num1: str, num2: str) -> str:\n        m, n = len(num1), len(num2)\n        neg = m < n or (m == n and num1 < num2)\n        if neg:\n            num1, num2 = num2, num1\n        i, j = len(num1) - 1, len(num2) - 1\n        ans = []\n        c = 0\n        while i >= 0:\n            c = int(num1[i]) - c - (0 if j < 0 else int(num2[j]))\n            ans.append(str((c + 10) % 10))\n            c = 1 if c < 0 else 0\n            i, j = i - 1, j - 1\n        while len(ans) > 1 and ans[-1] == '0':\n            ans.pop()\n        if neg:\n            ans.append('-')\n        return ''.join(ans[::-1])\n", "class Solution:\n  def addStrings(self, num1: str, num2: str) -> str:\n    ans = []\n    carry = 0\n    i = len(num1) - 1\n    j = len(num2) - 1\n\n    while i >= 0 or j >= 0 or carry:\n      if i >= 0:\n        carry += int(num1[i])\n      if j >= 0:\n        carry += int(num2[j])\n      ans.append(str(carry % 10))\n      carry //= 10\n      i -= 1\n      j -= 1\n\n    return ''.join(reversed(ans))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 435, "slug": "non-overlapping-intervals", "solutions": ["class Solution:\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key=lambda x: x[1])\n        ans = len(intervals)\n        pre = -inf\n        for l, r in intervals:\n            if pre <= l:\n                ans -= 1\n                pre = r\n        return ans\n", "class Solution:\n  def eraseOverlapIntervals(self, intervals: list[list[int]]) -> int:\n    ans = 0\n    currentEnd = -math.inf\n\n    for interval in sorted(intervals, key=lambda x: x[1]):\n      if interval[0] >= currentEnd:\n        currentEnd = interval[1]\n      else:\n        ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 473, "slug": "matchsticks-to-square", "solutions": ["class Solution:\n    def makesquare(self, matchsticks: List[int]) -> bool:\n        def dfs(u):\n            if u == len(matchsticks):\n                return True\n            for i in range(4):\n                if i > 0 and edges[i - 1] == edges[i]:\n                    continue\n                edges[i] += matchsticks[u]\n                if edges[i] <= x and dfs(u + 1):\n                    return True\n                edges[i] -= matchsticks[u]\n            return False\n\n        x, mod = divmod(sum(matchsticks), 4)\n        if mod or x < max(matchsticks):\n            return False\n        edges = [0] * 4\n        matchsticks.sort(reverse=True)\n        return dfs(0)\n", "class Solution:\n  def makesquare(self, matchsticks: list[int]) -> bool:\n    if len(matchsticks) < 4:\n      return False\n\n    perimeter = sum(matchsticks)\n    if perimeter % 4 != 0:\n      return False\n\n    A = sorted(matchsticks)[::-1]\n\n    def dfs(selected: int, edges: list[int]) -> bool:\n      if selected == len(A):\n        return all(edge == edges[0] for edge in edges)\n\n      for i, edge in enumerate(edges):\n        if A[selected] > edge:\n          continue\n        edges[i] -= A[selected]\n        if dfs(selected + 1, edges):\n          return True\n        edges[i] += A[selected]\n\n      return False\n\n    return dfs(0, [perimeter // 4] * 4)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 442, "slug": "find-all-duplicates-in-an-array", "solutions": ["class Solution:\n    def findDuplicates(self, nums: List[int]) -> List[int]:\n        for i in range(len(nums)):\n            while nums[i] != nums[nums[i] - 1]:\n                nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n        return [v for i, v in enumerate(nums) if v != i + 1]\n", "class Solution:\n  def findDuplicates(self, nums: list[int]) -> list[int]:\n    ans = []\n\n    for num in nums:\n      nums[abs(num) - 1] *= -1\n      if nums[abs(num) - 1] > 0:\n        ans.append(abs(num))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 421, "slug": "maximum-xor-of-two-numbers-in-an-array", "solutions": ["class Trie:\n    __slots__ = (\"children\",)\n\n    def __init__(self):\n        self.children: List[Trie | None] = [None, None]\n\n    def insert(self, x: int):\n        node = self\n        for i in range(30, -1, -1):\n            v = x >> i & 1\n            if node.children[v] is None:\n                node.children[v] = Trie()\n            node = node.children[v]\n\n    def search(self, x: int) -> int:\n        node = self\n        ans = 0\n        for i in range(30, -1, -1):\n            v = x >> i & 1\n            if node.children[v ^ 1]:\n                ans |= 1 << i\n                node = node.children[v ^ 1]\n            else:\n                node = node.children[v]\n        return ans\n\n\nclass Solution:\n    def findMaximumXOR(self, nums: List[int]) -> int:\n        trie = Trie()\n        for x in nums:\n            trie.insert(x)\n        return max(trie.search(x) for x in nums)\n", "class Solution:\n  def findMaximumXOR(self, nums: list[int]) -> int:\n    maxNum = max(nums)\n    if maxNum == 0:\n      return 0\n    maxBit = int(math.log2(maxNum))\n    ans = 0\n    prefixMask = 0  # `prefixMask` grows like: 10000 -> 11000 -> ... -> 11111.\n\n    # If ans is 11100 when i = 2, it means that before we reach the last two\n    # bits, 11100 is the maximum XOR we have, and we're going to explore if we\n    # can get another two 1s and put them into `ans`.\n    for i in range(maxBit, -1, -1):\n      prefixMask |= 1 << i\n      # We only care about the left parts,\n      # If i = 2, nums = [1110, 1011, 0111]\n      #    -> prefixes = [1100, 1000, 0100]\n      prefixes = set([num & prefixMask for num in nums])\n      # If i = 1 and before this iteration, the ans is 10100, it means that we\n      # want to grow the ans to 10100 | 1 << 1 = 10110 and we're looking for\n      # XOR of two prefixes = candidate.\n      candidate = ans | 1 << i\n      for prefix in prefixes:\n        if prefix ^ candidate in prefixes:\n          ans = candidate\n          break\n\n    return ans\n", "class TrieNode:\n  def __init__(self):\n    self.children: list[TrieNode | None] = [None] * 2\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n\n  def getMaxXor(self, num: int) -> int:\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      toggleBit = bit ^ 1\n      if node.children[toggleBit]:\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:  # There's nothing in the Bit Trie.\n        return 0\n    return maxXor\n\n\nclass Solution:\n  def findMaximumXOR(self, nums: list[int]) -> int:\n    maxNum = max(nums)\n    if maxNum == 0:\n      return 0\n    maxBit = int(math.log2(maxNum))\n    ans = 0\n    bitTrie = BitTrie(maxBit)\n\n    for num in nums:\n      ans = max(ans, bitTrie.getMaxXor(num))\n      bitTrie.insert(num)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 418, "slug": "sentence-screen-fitting", "solutions": ["class Solution:\n    def wordsTyping(self, sentence: List[str], rows: int, cols: int) -> int:\n        s = \" \".join(sentence) + \" \"\n        m = len(s)\n        cur = 0\n        for _ in range(rows):\n            cur += cols\n            if s[cur % m] == \" \":\n                cur += 1\n            while cur and s[(cur - 1) % m] != \" \":\n                cur -= 1\n        return cur // m\n", "class Solution:\n  def wordsTyping(self, sentence: list[str], rows: int, cols: int) -> int:\n    combined = ' '.join(sentence) + ' '\n    n = len(combined)\n    i = 0\n\n    for _ in range(rows):\n      i += cols\n      if combined[i % n] == ' ':\n        i += 1\n      else:\n        while i > 0 and combined[(i - 1) % n] != ' ':\n          i -= 1\n\n    return i // n\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 458, "slug": "poor-pigs", "solutions": ["class Solution:\n    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:\n        base = minutesToTest // minutesToDie + 1\n        res, p = 0, 1\n        while p < buckets:\n            p *= base\n            res += 1\n        return res\n", "class Solution:\n  def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:\n    base = minutesToTest // minutesToDie + 1\n    ans = 0\n    x = 1\n    while x < buckets:\n      ans += 1\n      x *= base\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 455, "slug": "assign-cookies", "solutions": ["class Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n        g.sort()\n        s.sort()\n        j = 0\n        for i, x in enumerate(g):\n            while j < len(s) and s[j] < g[i]:\n                j += 1\n            if j >= len(s):\n                return i\n            j += 1\n        return len(g)\n", "class Solution:\n  def findContentChildren(self, g: list[int], s: list[int]) -> int:\n    g.sort()\n    s.sort()\n\n    i = 0\n    for cookie in s:\n      if i < len(g) and g[i] <= cookie:\n        i += 1\n\n    return i\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 404, "slug": "sum-of-left-leaves", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:\n        if root is None:\n            return 0\n        ans = self.sumOfLeftLeaves(root.right)\n        if root.left:\n            if root.left.left == root.left.right:\n                ans += root.left.val\n            else:\n                ans += self.sumOfLeftLeaves(root.left)\n        return ans\n", "class Solution:\n  def sumOfLeftLeaves(self, root: TreeNode | None) -> int:\n    if not root:\n      return 0\n\n    ans = 0\n\n    if root.left:\n      if not root.left.left and not root.left.right:\n        ans += root.left.val\n      else:\n        ans += self.sumOfLeftLeaves(root.left)\n    ans += self.sumOfLeftLeaves(root.right)\n\n    return ans\n", "class Solution:\n  def sumOfLeftLeaves(self, root: TreeNode | None) -> int:\n    if not root:\n      return 0\n\n    ans = 0\n    stack = [root]\n\n    while stack:\n      root = stack.pop()\n      if root.left:\n        if not root.left.left and not root.left.right:\n          ans += root.left.val\n        else:\n          stack.append(root.left)\n      if root.right:\n        stack.append(root.right)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 408, "slug": "valid-word-abbreviation", "solutions": ["class Solution:\n    def validWordAbbreviation(self, word: str, abbr: str) -> bool:\n        m, n = len(word), len(abbr)\n        i = j = x = 0\n        while i < m and j < n:\n            if abbr[j].isdigit():\n                if abbr[j] == \"0\" and x == 0:\n                    return False\n                x = x * 10 + int(abbr[j])\n            else:\n                i += x\n                x = 0\n                if i >= m or word[i] != abbr[j]:\n                    return False\n                i += 1\n            j += 1\n        return i + x == m and j == n\n", "class Solution:\n  def validWordAbbreviation(self, word: str, abbr: str) -> bool:\n    i = 0  # word's index\n    j = 0  # abbr's index\n\n    while i < len(word) and j < len(abbr):\n      if word[i] == abbr[j]:\n        i += 1\n        j += 1\n        continue\n      if not abbr[j].isdigit() or abbr[j] == '0':\n        return False\n      num = 0\n      while j < len(abbr) and abbr[j].isdigit():\n        num = num * 10 + int(abbr[j])\n        j += 1\n      i += num\n\n    return i == len(word) and j == len(abbr)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 449, "slug": "serialize-and-deserialize-bst", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\n\nclass Codec:\n    def serialize(self, root: Optional[TreeNode]) -> str:\n        \"\"\"Encodes a tree to a single string.\"\"\"\n\n        def dfs(root: Optional[TreeNode]):\n            if root is None:\n                return\n            nums.append(root.val)\n            dfs(root.left)\n            dfs(root.right)\n\n        nums = []\n        dfs(root)\n        return \" \".join(map(str, nums))\n\n    def deserialize(self, data: str) -> Optional[TreeNode]:\n        \"\"\"Decodes your encoded data to tree.\"\"\"\n\n        def dfs(mi: int, mx: int) -> Optional[TreeNode]:\n            nonlocal i\n            if i == len(nums) or not mi <= nums[i] <= mx:\n                return None\n            x = nums[i]\n            root = TreeNode(x)\n            i += 1\n            root.left = dfs(mi, x)\n            root.right = dfs(x, mx)\n            return root\n\n        nums = list(map(int, data.split()))\n        i = 0\n        return dfs(-inf, inf)\n\n\n# Your Codec object will be instantiated and called as such:\n# Your Codec object will be instantiated and called as such:\n# ser = Codec()\n# deser = Codec()\n# tree = ser.serialize(root)\n# ans = deser.deserialize(tree)\n# return ans\n", "class Codec:\n  def serialize(self, root: TreeNode | None) -> str:\n    \"\"\"Encodes a tree to a single string.\"\"\"\n    if not root:\n      return ''\n    chars = []\n    self._serialize(root, chars)\n    return ''.join(chars)\n\n  def deserialize(self, data: str) -> TreeNode | None:\n    \"\"\"Decodes your encoded data to tree.\"\"\"\n    if not data:\n      return None\n    q = collections.deque(int(val) for val in data.split())\n    return self._deserialize(-math.inf, math.inf, q)\n\n  def _serialize(self, root: TreeNode | None, chars: list[str]) -> None:\n    if not root:\n      return\n    chars.append(str(root.val))\n    chars.append(' ')\n    self._serialize(root.left, chars)\n    self._serialize(root.right, chars)\n\n  def _deserialize(\n      self,\n      mn: int,\n      mx: int,\n      q: collections.deque[int]\n  ) -> TreeNode | None:\n    if not q:\n      return None\n\n    val = q[0]\n    if val < mn or val > mx:\n      return None\n\n    q.popleft()\n    return TreeNode(val,\n                    self._deserialize(mn, val, q),\n                    self._deserialize(val, mx, q))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 453, "slug": "minimum-moves-to-equal-array-elements", "solutions": ["class Solution:\n    def minMoves(self, nums: List[int]) -> int:\n        return sum(nums) - min(nums) * len(nums)\n", "class Solution:\n  def minMoves(self, nums: list[int]) -> int:\n    mn = min(nums)\n    return sum(num - mn for num in nums)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 492, "slug": "construct-the-rectangle", "solutions": ["class Solution:\n    def constructRectangle(self, area: int) -> List[int]:\n        w = int(sqrt(area))\n        while area % w != 0:\n            w -= 1\n        return [area // w, w]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 447, "slug": "number-of-boomerangs", "solutions": ["class Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        ans = 0\n        for p1 in points:\n            cnt = Counter()\n            for p2 in points:\n                d = dist(p1, p2)\n                ans += cnt[d]\n                cnt[d] += 1\n        return ans << 1\n", "class Solution:\n  def numberOfBoomerangs(self, points: list[list[int]]) -> int:\n    ans = 0\n\n    for x1, y1 in points:\n      count = collections.Counter()\n      for x2, y2 in points:\n        ans += 2 * count[(x1 - x2)**2 + (y1 - y2)**2]\n        count[(x1 - x2)**2 + (y1 - y2)**2] += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 482, "slug": "license-key-formatting", "solutions": ["class Solution:\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\n        n = len(s)\n        cnt = (n - s.count(\"-\")) % k or k\n        ans = []\n        for i, c in enumerate(s):\n            if c == \"-\":\n                continue\n            ans.append(c.upper())\n            cnt -= 1\n            if cnt == 0:\n                cnt = k\n                if i != n - 1:\n                    ans.append(\"-\")\n        return \"\".join(ans).rstrip(\"-\")\n", "class Solution:\n  def licenseKeyFormatting(self, s: str, k: int) -> str:\n    ans = []\n    length = 0\n\n    for i in reversed(range(len(s))):\n      if s[i] == '-':\n        continue\n      if length > 0 and length % k == 0:\n        ans += '-'\n      ans += s[i].upper()\n      length += 1\n\n    return ''.join(reversed(ans))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 428, "slug": "serialize-and-deserialize-n-ary-tree", "solutions": ["class Codec:\n  def serialize(self, root: 'Node') -> str:\n    \"\"\"Encodes a tree to a single string.\"\"\"\n    if not root:\n      return ''\n\n    s = []\n    q = collections.deque([root])\n    s.append(str(root.val) + ' ')\n\n    while q:\n      for _ in range(len(q)):\n        node = q.popleft()\n        if not node.children:\n          s.append('n')\n        else:\n          for child in node.children:\n            q.append(child)\n            s.append(str(child.val) + '#')\n        s.append(' ')\n\n    return ''.join(s)\n\n  def deserialize(self, data: str) -> 'Node':\n    \"\"\"Decodes your encoded data to tree.\"\"\"\n    if not data:\n      return None\n\n    words = data.split()\n    root = Node(int(words[0]))\n    q = collections.deque([root])\n\n    for word in words[1:]:\n      parent = q.popleft()\n      children = []\n      for kid in word.split('#'):\n        if kid in ('', 'n'):\n          continue\n        child = Node(int(kid))\n        children.append(child)\n        q.append(child)\n      parent.children = children\n\n    return root\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 485, "slug": "max-consecutive-ones", "solutions": ["class Solution:\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\n        ans = cnt = 0\n        for x in nums:\n            if x:\n                cnt += 1\n                ans = max(ans, cnt)\n            else:\n                cnt = 0\n        return ans\n", "class Solution:\n  def findMaxConsecutiveOnes(self, nums: list[int]) -> int:\n    ans = 0\n    summ = 0\n\n    for num in nums:\n      if num == 0:\n        summ = 0\n      else:\n        summ += num\n        ans = max(ans, summ)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 450, "slug": "delete-node-in-a-bst", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:\n        if root is None:\n            return None\n        if root.val > key:\n            root.left = self.deleteNode(root.left, key)\n            return root\n        if root.val < key:\n            root.right = self.deleteNode(root.right, key)\n            return root\n        if root.left is None:\n            return root.right\n        if root.right is None:\n            return root.left\n        node = root.right\n        while node.left:\n            node = node.left\n        node.left = root.left\n        root = root.right\n        return root\n", "class Solution:\n  def deleteNode(self, root: TreeNode | None, key: int) -> TreeNode | None:\n    if not root:\n      return None\n    if root.val == key:\n      if not root.left:\n        return root.right\n      if not root.right:\n        return root.left\n      minNode = self._getMin(root.right)\n      root.right = self.deleteNode(root.right, minNode.val)\n      minNode.left = root.left\n      minNode.right = root.right\n      root = minNode\n    elif root.val < key:\n      root.right = self.deleteNode(root.right, key)\n    else:  # root.val > key\n      root.left = self.deleteNode(root.left, key)\n    return root\n\n  def _getMin(self, node: TreeNode | None) -> TreeNode | None:\n    while node.left:\n      node = node.left\n    return node\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 470, "slug": "implement-rand10-using-rand7", "solutions": ["# The rand7() API is already defined for you.\n# def rand7():\n# @return a random integer in the range 1 to 7\n\n\nclass Solution:\n    def rand10(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        while 1:\n            i = rand7() - 1\n            j = rand7()\n            x = i * 7 + j\n            if x <= 40:\n                return x % 10 + 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 423, "slug": "reconstruct-original-digits-from-english", "solutions": ["class Solution:\n    def originalDigits(self, s: str) -> str:\n        counter = Counter(s)\n        cnt = [0] * 10\n\n        cnt[0] = counter['z']\n        cnt[2] = counter['w']\n        cnt[4] = counter['u']\n        cnt[6] = counter['x']\n        cnt[8] = counter['g']\n\n        cnt[3] = counter['h'] - cnt[8]\n        cnt[5] = counter['f'] - cnt[4]\n        cnt[7] = counter['s'] - cnt[6]\n\n        cnt[1] = counter['o'] - cnt[0] - cnt[2] - cnt[4]\n        cnt[9] = counter['i'] - cnt[5] - cnt[6] - cnt[8]\n\n        return ''.join(cnt[i] * str(i) for i in range(10))\n", "class Solution:\n  def originalDigits(self, s: str) -> str:\n    count = [0] * 10\n\n    for c in s:\n      if c == 'z':\n        count[0] += 1\n      if c == 'o':\n        count[1] += 1\n      if c == 'w':\n        count[2] += 1\n      if c == 'h':\n        count[3] += 1\n      if c == 'u':\n        count[4] += 1\n      if c == 'f':\n        count[5] += 1\n      if c == 'x':\n        count[6] += 1\n      if c == 's':\n        count[7] += 1\n      if c == 'g':\n        count[8] += 1\n      if c == 'i':\n        count[9] += 1\n\n    count[1] -= count[0] + count[2] + count[4]\n    count[3] -= count[8]\n    count[5] -= count[4]\n    count[7] -= count[6]\n    count[9] -= count[5] + count[6] + count[8]\n    return ''.join(chr(i + ord('0')) for i, c in enumerate(count)\n                   for _ in range(c))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 429, "slug": "n-ary-tree-level-order-traversal", "solutions": ["\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\"\"\"\n\n\nclass Solution:\n    def levelOrder(self, root: 'Node') -> List[List[int]]:\n        ans = []\n        if root is None:\n            return ans\n        q = deque([root])\n        while q:\n            t = []\n            for _ in range(len(q)):\n                root = q.popleft()\n                t.append(root.val)\n                q.extend(root.children)\n            ans.append(t)\n        return ans\n", "class Solution:\n  def levelOrder(self, root: 'Node') -> list[list[int]]:\n    if not root:\n      return []\n\n    ans = []\n    q = collections.deque([root])\n\n    while q:\n      currLevel = []\n      for _ in range(len(q)):\n        node = q.popleft()\n        currLevel.append(node.val)\n        for child in node.children:\n          q.append(child)\n      ans.append(currLevel)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 437, "slug": "path-sum-iii", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:\n        def dfs(node, s):\n            if node is None:\n                return 0\n            s += node.val\n            ans = cnt[s - targetSum]\n            cnt[s] += 1\n            ans += dfs(node.left, s)\n            ans += dfs(node.right, s)\n            cnt[s] -= 1\n            return ans\n\n        cnt = Counter({0: 1})\n        return dfs(root, 0)\n", "class Solution:\n  def pathSum(self, root: TreeNode | None, summ: int) -> int:\n    if not root:\n      return 0\n\n    def dfs(root: TreeNode, summ: int) -> int:\n      if not root:\n        return 0\n      return (int(summ == root.val) +\n              dfs(root.left, summ - root.val) +\n              dfs(root.right, summ - root.val))\n\n    return (dfs(root, summ) +\n            self.pathSum(root.left, summ) +\n            self.pathSum(root.right, summ))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 446, "slug": "arithmetic-slices-ii-subsequence", "solutions": ["class Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        f = [defaultdict(int) for _ in nums]\n        ans = 0\n        for i, x in enumerate(nums):\n            for j, y in enumerate(nums[:i]):\n                d = x - y\n                ans += f[j][d]\n                f[i][d] += f[j][d] + 1\n        return ans\n", "class Solution:\n  def numberOfArithmeticSlices(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = 0\n    # dp[i][j] := the number of subsequences end in nums[j] nums[i]\n    dp = [[0] * n for _ in range(n)]\n    numToIndices = collections.defaultdict(list)\n\n    for i, num in enumerate(nums):\n      numToIndices[num].append(i)\n\n    for i in range(n):\n      for j in range(i):\n        target = nums[j] * 2 - nums[i]\n        if target in numToIndices:\n          for k in numToIndices[target]:\n            if k < j:\n              dp[i][j] += dp[j][k] + 1\n        ans += dp[i][j]\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 443, "slug": "string-compression", "solutions": ["class Solution:\n    def compress(self, chars: List[str]) -> int:\n        i, k, n = 0, 0, len(chars)\n        while i < n:\n            j = i + 1\n            while j < n and chars[j] == chars[i]:\n                j += 1\n            chars[k] = chars[i]\n            k += 1\n            if j - i > 1:\n                cnt = str(j - i)\n                for c in cnt:\n                    chars[k] = c\n                    k += 1\n            i = j\n        return k\n", "class Solution:\n  def compress(self, chars: list[str]) -> int:\n    ans = 0\n    i = 0\n\n    while i < len(chars):\n      letter = chars[i]\n      count = 0\n      while i < len(chars) and chars[i] == letter:\n        count += 1\n        i += 1\n      chars[ans] = letter\n      ans += 1\n      if count > 1:\n        for c in str(count):\n          chars[ans] = c\n          ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 441, "slug": "arranging-coins", "solutions": ["class Solution:\n    def arrangeCoins(self, n: int) -> int:\n        return int(math.sqrt(2) * math.sqrt(n + 0.125) - 0.5)\n", "class Solution:\n  def arrangeCoins(self, n: int) -> int:\n    return int((-1 + math.sqrt(8 * n + 1)) // 2)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 497, "slug": "random-point-in-non-overlapping-rectangles", "solutions": ["class Solution:\n    def __init__(self, rects: List[List[int]]):\n        self.rects = rects\n        self.s = [0] * len(rects)\n        for i, (x1, y1, x2, y2) in enumerate(rects):\n            self.s[i] = self.s[i - 1] + (x2 - x1 + 1) * (y2 - y1 + 1)\n\n    def pick(self) -> List[int]:\n        v = random.randint(1, self.s[-1])\n        idx = bisect_left(self.s, v)\n        x1, y1, x2, y2 = self.rects[idx]\n        return [random.randint(x1, x2), random.randint(y1, y2)]\n\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution(rects)\n# param_1 = obj.pick()\n", "class Solution:\n  def __init__(self, rects: list[list[int]]):\n    self.rects = rects\n    self.areas = list(itertools.accumulate(\n        [(x2 - x1 + 1) * (y2 - y1 + 1) for x1, y1, x2, y2 in rects]))\n\n  def pick(self) -> list[int]:\n    index = bisect_right(self.areas, random.randint(0, self.areas[-1] - 1))\n    x1, y1, x2, y2 = self.rects[index]\n    return [random.randint(x1, x2), random.randint(y1, y2)]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 402, "slug": "remove-k-digits", "solutions": ["class Solution:\n    def removeKdigits(self, num: str, k: int) -> str:\n        stk = []\n        remain = len(num) - k\n        for c in num:\n            while k and stk and stk[-1] > c:\n                stk.pop()\n                k -= 1\n            stk.append(c)\n        return ''.join(stk[:remain]).lstrip('0') or '0'\n", "class Solution:\n  def removeKdigits(self, num: str, k: int) -> str:\n    if len(num) == k:\n      return '0'\n\n    ans = []\n    stack = []\n\n    for i, digit in enumerate(num):\n      while k > 0 and stack and stack[-1] > digit:\n        stack.pop()\n        k -= 1\n      stack.append(digit)\n\n    for _ in range(k):\n      stack.pop()\n\n    for c in stack:\n      if c == '0' and not ans:\n        continue\n      ans.append(c)\n\n    return ''.join(ans) if ans else '0'\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 433, "slug": "minimum-genetic-mutation", "solutions": ["class Solution:\n    def minMutation(self, startGene: str, endGene: str, bank: List[str]) -> int:\n        q = deque([(startGene, 0)])\n        vis = {startGene}\n        while q:\n            gene, depth = q.popleft()\n            if gene == endGene:\n                return depth\n            for nxt in bank:\n                diff = sum(a != b for a, b in zip(gene, nxt))\n                if diff == 1 and nxt not in vis:\n                    q.append((nxt, depth + 1))\n                    vis.add(nxt)\n        return -1\n", "class Solution:\n  def minMutation(self, startGene: str, endGene: str, bank: list[str]) -> int:\n    bankSet = set(bank)\n    if endGene not in bankSet:\n      return -1\n\n    GENES = 'ACGT'\n    q = collections.deque([startGene])\n\n    step = 1\n    while q:\n      for _ in range(len(q)):\n        wordList = list(q.popleft())\n        for j, cache in enumerate(wordList):\n          for c in GENES:\n            wordList[j] = c\n            word = ''.join(wordList)\n            if word == endGene:\n              return step\n            if word in bankSet:\n              bankSet.remove(word)\n              q.append(word)\n          wordList[j] = cache\n      step += 1\n\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 439, "slug": "ternary-expression-parser", "solutions": ["class Solution:\n    def parseTernary(self, expression: str) -> str:\n        stk = []\n        cond = False\n        for c in expression[::-1]:\n            if c == ':':\n                continue\n            if c == '?':\n                cond = True\n            else:\n                if cond:\n                    if c == 'T':\n                        x = stk.pop()\n                        stk.pop()\n                        stk.append(x)\n                    else:\n                        stk.pop()\n                    cond = False\n                else:\n                    stk.append(c)\n        return stk[0]\n", "class Solution:\n  def parseTernary(self, expression: str) -> str:\n    c = expression[self.i]\n\n    if self.i + 1 == len(expression) or expression[self.i + 1] == ':':\n      self.i += 2\n      return str(c)\n\n    self.i += 2\n    first = self.parseTernary(expression)\n    second = self.parseTernary(expression)\n\n    return first if c == 'T' else second\n\n  i = 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 444, "slug": "sequence-reconstruction", "solutions": ["class Solution:\n    def sequenceReconstruction(\n        self, nums: List[int], sequences: List[List[int]]\n    ) -> bool:\n        n = len(nums)\n        g = [[] for _ in range(n)]\n        indeg = [0] * n\n        for seq in sequences:\n            for a, b in pairwise(seq):\n                a, b = a - 1, b - 1\n                g[a].append(b)\n                indeg[b] += 1\n        q = deque(i for i, x in enumerate(indeg) if x == 0)\n        while len(q) == 1:\n            i = q.popleft()\n            for j in g[i]:\n                indeg[j] -= 1\n                if indeg[j] == 0:\n                    q.append(j)\n        return len(q) == 0\n", "class Solution:\n  def sequenceReconstruction(\n      self,\n      org: list[int],\n      seqs: list[list[int]],\n  ) -> bool:\n    if not seqs:\n      return False\n\n    n = len(org)\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n\n    # Build the graph.\n    for seq in seqs:\n      if len(seq) == 1 and seq[0] < 1 or seq[0] > n:\n        return False\n      for u, v in zip(seq, seq[1:]):\n        if u < 1 or u > n or v < 1 or v > n:\n          return False\n        graph[u - 1].append(v - 1)\n        inDegrees[v - 1] += 1\n\n    # Perform topological sorting.\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n    i = 0  # org's index\n\n    while q:\n      if len(q) > 1:\n        return False\n      u = q.popleft()\n      if u != org[i] - 1:\n        return False\n      i += 1\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    return i == n\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 405, "slug": "convert-a-number-to-hexadecimal", "solutions": ["class Solution:\n    def toHex(self, num: int) -> str:\n        if num == 0:\n            return '0'\n        chars = '0123456789abcdef'\n        s = []\n        for i in range(7, -1, -1):\n            x = (num >> (4 * i)) & 0xF\n            if s or x != 0:\n                s.append(chars[x])\n        return ''.join(s)\n", "class Solution:\n  def toHex(self, num: int) -> str:\n    if num == 0:\n      return '0'\n\n    hex = '0123456789abcdef'\n    ans = []\n\n    # Handling negative numbers by using 32-bit unsigned representation Python's\n    # bitwise operation works on signed numbers, so we convert to 32-bit\n    # unsigned for negative numbers.\n    if num < 0:\n      num += 2**32\n\n    while num > 0:\n      ans.append(hex[num & 0xF])\n      num >>= 4\n\n    return ''.join(reversed(ans))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 486, "slug": "predict-the-winner", "solutions": ["class Solution:\n    def predictTheWinner(self, nums: List[int]) -> bool:\n        @cache\n        def dfs(i: int, j: int) -> int:\n            if i > j:\n                return 0\n            return max(nums[i] - dfs(i + 1, j), nums[j] - dfs(i, j - 1))\n\n        return dfs(0, len(nums) - 1) >= 0\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 451, "slug": "sort-characters-by-frequency", "solutions": ["class Solution:\n    def frequencySort(self, s: str) -> str:\n        cnt = Counter(s)\n        return ''.join(c * v for c, v in sorted(cnt.items(), key=lambda x: -x[1]))\n", "class Solution:\n  def frequencySort(self, s: str) -> str:\n    ans = []\n    buckets = [[] for _ in range(len(s) + 1)]\n\n    for c, freq in collections.Counter(s).items():\n      buckets[freq].append(c)\n\n    for freq in reversed(range(len(buckets))):\n      for c in buckets[freq]:\n        ans.append(c * freq)\n\n    return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 434, "slug": "number-of-segments-in-a-string", "solutions": ["class Solution:\n    def countSegments(self, s: str) -> int:\n        return len(s.split())\n", "class Solution:\n  def countSegments(self, s: str) -> int:\n    return len(s.split())\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 488, "slug": "zuma-game", "solutions": ["class Solution:\n    def findMinStep(self, board: str, hand: str) -> int:\n        def remove(s):\n            while len(s):\n                next = re.sub(r'B{3,}|G{3,}|R{3,}|W{3,}|Y{3,}', '', s)\n                if len(next) == len(s):\n                    break\n                s = next\n            return s\n\n        visited = set()\n        q = deque([(board, hand)])\n        while q:\n            state, balls = q.popleft()\n            if not state:\n                return len(hand) - len(balls)\n            for ball in set(balls):\n                b = balls.replace(ball, '', 1)\n                for i in range(1, len(state) + 1):\n                    s = state[:i] + ball + state[i:]\n                    s = remove(s)\n                    if s not in visited:\n                        visited.add(s)\n                        q.append((s, b))\n        return -1\n", "class Solution:\n  def findMinStep(self, board: str, hand: str) -> int:\n    def deDup(board):\n      start = 0  # the start index of a color sequenece\n      for i, c in enumerate(board):\n        if c != board[start]:\n          if i - start >= 3:\n            return deDup(board[:start] + board[i:])\n          start = i  # Meet a new sequence.\n      return board\n\n    @functools.lru_cache(None)\n    def dfs(board: str, hand: str):\n      board = deDup(board)\n      if board == '#':\n        return 0\n\n      boardSet = set(board)\n      # hand that is in board\n      hand = ''.join(h for h in hand if h in boardSet)\n      if not hand:  # infeasible\n        return math.inf\n\n      ans = math.inf\n\n      for i in range(len(board)):\n        for j, h in enumerate(hand):\n          # Place hs[j] in board[i].\n          newHand = hand[:j] + hand[j + 1:]\n          newBoard = board[:i] + h + board[i:]\n          ans = min(ans, 1 + dfs(newBoard, newHand))\n\n      return ans\n\n    ans = dfs(board + '#', hand)\n    return -1 if ans == math.inf else ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 467, "slug": "unique-substrings-in-wraparound-string", "solutions": ["class Solution:\n    def findSubstringInWraproundString(self, s: str) -> int:\n        f = defaultdict(int)\n        k = 0\n        for i, c in enumerate(s):\n            if i and (ord(c) - ord(s[i - 1])) % 26 == 1:\n                k += 1\n            else:\n                k = 1\n            f[c] = max(f[c], k)\n        return sum(f.values())\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 412, "slug": "fizz-buzz", "solutions": ["class Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        ans = []\n        for i in range(1, n + 1):\n            if i % 15 == 0:\n                ans.append('FizzBuzz')\n            elif i % 3 == 0:\n                ans.append('Fizz')\n            elif i % 5 == 0:\n                ans.append('Buzz')\n            else:\n                ans.append(str(i))\n        return ans\n", "class Solution:\n  def fizzBuzz(self, n: int) -> list[str]:\n    d = {3: 'Fizz', 5: 'Buzz'}\n    return [''.join([d[k] for k in d if i % k == 0]) or str(i) for i in range(1, n + 1)]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1437, "slug": "check-if-all-1s-are-at-least-length-k-places-away", "solutions": ["class Solution:\n    def kLengthApart(self, nums: List[int], k: int) -> bool:\n        j = -inf\n        for i, x in enumerate(nums):\n            if x:\n                if i - j - 1 < k:\n                    return False\n                j = i\n        return True\n", "class Solution:\n  def kLengthApart(self, nums: list[int], k: int) -> bool:\n    if k == 0:\n      return True\n\n    n = len(nums)\n    curr = 0\n    next = 1\n\n    while curr < n and next < n:\n      if nums[next] == 1:\n        if nums[curr] == 1 and next - curr <= k:\n          return False\n        curr = next\n      next += 1\n\n    return True\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1471, "slug": "the-k-strongest-values-in-an-array", "solutions": ["class Solution:\n    def getStrongest(self, arr: List[int], k: int) -> List[int]:\n        arr.sort()\n        m = arr[(len(arr) - 1) >> 1]\n        arr.sort(key=lambda x: (-abs(x - m), -x))\n        return arr[:k]\n", "class Solution:\n  def getStrongest(self, arr: list[int], k: int) -> list[int]:\n    arr.sort()\n\n    ans = []\n    median = arr[(len(arr) - 1) // 2]\n    l = 0\n    r = len(arr) - 1\n\n    for _ in range(k):\n      if median - arr[l] > arr[r] - median:\n        ans.append(arr[l])\n        l -= 1\n      else:\n        ans.append(arr[r])\n        r += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1494, "slug": "parallel-courses-ii", "solutions": ["class Solution:\n    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:\n        d = [0] * (n + 1)\n        for x, y in relations:\n            d[y] |= 1 << x\n        q = deque([(0, 0)])\n        vis = {0}\n        while q:\n            cur, t = q.popleft()\n            if cur == (1 << (n + 1)) - 2:\n                return t\n            nxt = 0\n            for i in range(1, n + 1):\n                if (cur & d[i]) == d[i]:\n                    nxt |= 1 << i\n            nxt ^= cur\n            if nxt.bit_count() <= k:\n                if (nxt | cur) not in vis:\n                    vis.add(nxt | cur)\n                    q.append((nxt | cur, t + 1))\n            else:\n                x = nxt\n                while nxt:\n                    if nxt.bit_count() == k and (nxt | cur) not in vis:\n                        vis.add(nxt | cur)\n                        q.append((nxt | cur, t + 1))\n                    nxt = (nxt - 1) & x\n", "class Solution:\n  def minNumberOfSemesters(\n      self,\n      n: int,\n      relations: list[list[int]],\n      k: int,\n  ) -> int:\n    # dp[i] := the minimum number of semesters to take the courses, where i is\n    # the bitmask of the taken courses\n    dp = [n] * (1 << n)\n    # prereq[i] := bitmask of all dependencies of course i\n    prereq = [0] * n\n\n    for prevCourse, nextCourse in relations:\n      prereq[nextCourse - 1] |= 1 << prevCourse - 1\n\n    dp[0] = 0  # Don't need time to finish 0 course.\n\n    for i in range(1 << n):\n      # the bitmask of all the courses can be taken\n      coursesCanBeTaken = 0\n      # Can take the j-th course if i contains all of j's prerequisites.\n      for j in range(n):\n        if (i & prereq[j]) == prereq[j]:\n          coursesCanBeTaken |= 1 << j\n      # Don't take any course which is already taken.\n      # (i represents set of courses that are already taken)\n      coursesCanBeTaken &= ~i\n      # Enumerate every bitmask subset of `coursesCanBeTaken`.\n      s = coursesCanBeTaken\n      while s:\n        if s.bit_count() <= k:\n          # Any combination of courses (if <= k) can be taken now.\n          # i | s := combining courses taken with courses can be taken.\n          dp[i | s] = min(dp[i | s], dp[i] + 1)\n        s = (s - 1) & coursesCanBeTaken\n\n    return dp[-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1468, "slug": "calculate-salaries", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1467, "slug": "probability-of-a-two-boxes-having-the-same-number-of-distinct-balls", "solutions": ["class Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        @cache\n        def dfs(i: int, j: int, diff: int) -> float:\n            if i >= k:\n                return 1 if j == 0 and diff == 0 else 0\n            if j < 0:\n                return 0\n            ans = 0\n            for x in range(balls[i] + 1):\n                y = 1 if x == balls[i] else (-1 if x == 0 else 0)\n                ans += dfs(i + 1, j - x, diff + y) * comb(balls[i], x)\n            return ans\n\n        n = sum(balls) >> 1\n        k = len(balls)\n        return dfs(0, n, 0) / comb(n << 1, n)\n", "from enum import Enum\n\n\nclass BoxCase(Enum):\n  EQUAL_DISTANT_BALLS = 0\n  EQUAL_BALLS = 1\n\n\nclass Solution:\n  def getProbability(self, balls: list[int]) -> float:\n    n = sum(balls) // 2\n    fact = [1, 1, 2, 6, 24, 120, 720]\n\n    def cases(\n            i: int,\n            ballsCountA: int,\n            ballsCountB: int,\n            colorsCountA: int,\n            colorsCountB,\n            boxCase: BoxCase) -> float:\n      if ballsCountA > n or ballsCountB > n:\n        return 0\n      if i == len(balls):\n        return (1 if boxCase == BoxCase.EQUAL_BALLS\n                else colorsCountA == colorsCountB)\n\n      ans = 0.0\n\n      # balls taken from A for `balls[i]`\n      for ballsTakenA in range(balls[i] + 1):\n        ballsTakenB = balls[i] - ballsTakenA\n        newcolorsCountA = colorsCountA + (ballsTakenA > 0)\n        newcolorsCountB = colorsCountB + (ballsTakenB > 0)\n        ans += (cases(i + 1,\n                      ballsCountA + ballsTakenA,\n                      ballsCountB + ballsTakenB,\n                      newcolorsCountA, newcolorsCountB, boxCase) /\n                (fact[ballsTakenA] * fact[ballsTakenB]))\n\n      return ans\n\n    return (cases(0, 0, 0, 0, 0, BoxCase.EQUAL_DISTANT_BALLS) /\n            cases(0, 0, 0, 0, 0, BoxCase.EQUAL_BALLS))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1417, "slug": "reformat-the-string", "solutions": ["class Solution:\n    def reformat(self, s: str) -> str:\n        a = [c for c in s if c.islower()]\n        b = [c for c in s if c.isdigit()]\n        if abs(len(a) - len(b)) > 1:\n            return ''\n        if len(a) < len(b):\n            a, b = b, a\n        ans = []\n        for x, y in zip(a, b):\n            ans.append(x + y)\n        if len(a) > len(b):\n            ans.append(a[-1])\n        return ''.join(ans)\n", "class Solution:\n  def reformat(self, s: str) -> str:\n    A = [c for c in s if c.isalpha()]\n    B = [c for c in s if c.isdigit()]\n\n    if len(A) < len(B):\n      A, B = B, A\n    if len(A) - len(B) > 1:\n      return ''\n\n    ans = []\n\n    for i in range(len(B)):\n      ans.append(A[i])\n      ans.append(B[i])\n\n    if len(A) == len(B) + 1:\n      ans.append(A[-1])\n    return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1452, "slug": "people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list", "solutions": ["class Solution:\n    def peopleIndexes(self, favoriteCompanies: List[List[str]]) -> List[int]:\n        idx = 0\n        d = {}\n        n = len(favoriteCompanies)\n        nums = [set() for _ in range(n)]\n        for i, ss in enumerate(favoriteCompanies):\n            for s in ss:\n                if s not in d:\n                    d[s] = idx\n                    idx += 1\n                nums[i].add(d[s])\n        ans = []\n        for i in range(n):\n            if not any(i != j and (nums[i] & nums[j]) == nums[i] for j in range(n)):\n                ans.append(i)\n        return ans\n", "class Solution:\n  def peopleIndexes(self, favoriteCompanies: list[list[str]]) -> list[int]:\n    ans = []\n    n = len(favoriteCompanies)\n    companies = [set(comp) for comp in favoriteCompanies]\n\n    for i in range(n):\n      find = False\n      for j in range(n):\n        if i == j:\n          continue\n        if companies[i].issubset(companies[j]):\n          find = True\n          break\n      if not find:\n        ans.append(i)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1407, "slug": "top-travellers", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1442, "slug": "count-triplets-that-can-form-two-arrays-of-equal-xor", "solutions": ["class Solution:\n    def countTriplets(self, arr: List[int]) -> int:\n        ans, n = 0, len(arr)\n        for i, x in enumerate(arr):\n            s = x\n            for k in range(i + 1, n):\n                s ^= arr[k]\n                if s == 0:\n                    ans += k - i\n        return ans\n", "class Solution:\n  def countTriplets(self, arr: list[int]) -> int:\n    ans = 0\n    xors = [0]\n    prefix = 0\n\n    for i, a in enumerate(arr):\n      prefix ^= a\n      xors.append(prefix)\n\n    for j in range(1, len(arr)):\n      for i in range(0, j):\n        xors_i = xors[j] ^ xors[i]\n        for k in range(j, len(arr)):\n          xors_k = xors[k + 1] ^ xors[j]\n          if xors_i == xors_k:\n            ans += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1440, "slug": "evaluate-boolean-expression", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1489, "slug": "find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree", "solutions": ["class UnionFind:\n    def __init__(self, n):\n        self.p = list(range(n))\n        self.n = n\n\n    def union(self, a, b):\n        if self.find(a) == self.find(b):\n            return False\n        self.p[self.find(a)] = self.find(b)\n        self.n -= 1\n        return True\n\n    def find(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n\n\nclass Solution:\n    def findCriticalAndPseudoCriticalEdges(\n        self, n: int, edges: List[List[int]]\n    ) -> List[List[int]]:\n        for i, e in enumerate(edges):\n            e.append(i)\n        edges.sort(key=lambda x: x[2])\n        uf = UnionFind(n)\n        v = sum(w for f, t, w, _ in edges if uf.union(f, t))\n        ans = [[], []]\n        for f, t, w, i in edges:\n            uf = UnionFind(n)\n            k = sum(z for x, y, z, j in edges if j != i and uf.union(x, y))\n            if uf.n > 1 or (uf.n == 1 and k > v):\n                ans[0].append(i)\n                continue\n\n            uf = UnionFind(n)\n            uf.union(f, t)\n            k = w + sum(z for x, y, z, j in edges if j != i and uf.union(x, y))\n            if k == v:\n                ans[1].append(i)\n        return ans\n", "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findCriticalAndPseudoCriticalEdges(self, n: int, edges: list[list[int]]) -> list[list[int]]:\n    criticalEdges = []\n    pseudoCriticalEdges = []\n\n    # Record the index information, so edges[i] := (u, v, weight, index).\n    for i in range(len(edges)):\n      edges[i].append(i)\n\n    # Sort by the weight.\n    edges.sort(key=lambda x: x[2])\n\n    def getMSTWeight(\n            firstEdge: list[int],\n            deletedEdgeIndex: int) -> int | float:\n      mstWeight = 0\n      uf = UnionFind(n)\n\n      if firstEdge:\n        uf.unionByRank(firstEdge[0], firstEdge[1])\n        mstWeight += firstEdge[2]\n\n      for u, v, weight, index in edges:\n        if index == deletedEdgeIndex:\n          continue\n        if uf.find(u) == uf.find(v):\n          continue\n        uf.unionByRank(u, v)\n        mstWeight += weight\n\n      root = uf.find(0)\n      if any(uf.find(i) != root for i in range(n)):\n        return math.inf\n\n      return mstWeight\n\n    mstWeight = getMSTWeight([], -1)\n\n    for edge in edges:\n      index = edge[3]\n      # Deleting the `edge` increases the weight of the MST or makes the MST\n      # invalid.\n      if getMSTWeight([], index) > mstWeight:\n        criticalEdges.append(index)\n      # If an edge can be in any MST, we can always add `edge` to the edge set.\n      elif getMSTWeight(edge, -1) == mstWeight:\n        pseudoCriticalEdges.append(index)\n\n    return [criticalEdges, pseudoCriticalEdges]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1479, "slug": "sales-by-day-of-the-week", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1492, "slug": "the-kth-factor-of-n", "solutions": ["class Solution:\n    def kthFactor(self, n: int, k: int) -> int:\n        for i in range(1, n + 1):\n            if n % i == 0:\n                k -= 1\n                if k == 0:\n                    return i\n        return -1\n", "class Solution:\n  def kthFactor(self, n: int, k: int) -> int:\n    # If i is a divisor of n, then n // i is also a divisor of n. So, we can\n    # find all the divisors of n by processing the numbers <= sqrt(n).\n    factor = 1\n    i = 0  # the i-th factor\n\n    while factor < math.isqrt(n):\n      if n % factor == 0:\n        i += 1\n        if i == k:\n          return factor\n      factor += 1\n\n    factor = n // factor\n    while factor >= 1:\n      if n % factor == 0:\n        i += 1\n        if i == k:\n          return n // factor\n      factor -= 1\n\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1447, "slug": "simplified-fractions", "solutions": ["class Solution:\n    def simplifiedFractions(self, n: int) -> List[str]:\n        return [\n            f'{i}/{j}'\n            for i in range(1, n)\n            for j in range(i + 1, n + 1)\n            if gcd(i, j) == 1\n        ]\n", "class Solution:\n  def simplifiedFractions(self, n: int) -> list[str]:\n    ans = []\n    for denominator in range(2, n + 1):\n      for numerator in range(1, denominator):\n        if math.gcd(denominator, numerator) == 1:\n          ans.append(str(numerator) + '/' + str(denominator))\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1476, "slug": "subrectangle-queries", "solutions": ["class SubrectangleQueries:\n    def __init__(self, rectangle: List[List[int]]):\n        self.g = rectangle\n        self.ops = []\n\n    def updateSubrectangle(\n        self, row1: int, col1: int, row2: int, col2: int, newValue: int\n    ) -> None:\n        self.ops.append((row1, col1, row2, col2, newValue))\n\n    def getValue(self, row: int, col: int) -> int:\n        for r1, c1, r2, c2, v in self.ops[::-1]:\n            if r1 <= row <= r2 and c1 <= col <= c2:\n                return v\n        return self.g[row][col]\n\n\n# Your SubrectangleQueries object will be instantiated and called as such:\n# obj = SubrectangleQueries(rectangle)\n# obj.updateSubrectangle(row1,col1,row2,col2,newValue)\n# param_2 = obj.getValue(row,col)\n", "class SubrectangleQueries:\n  def __init__(self, rectangle: list[list[int]]):\n    self.rectangle = rectangle\n    self.updates = []\n\n  def updateSubrectangle(self, row1: int, col1: int, row2: int, col2: int,\n                         newValue: int) -> None:\n    self.updates.append((row1, col1, row2, col2, newValue))\n\n  def getValue(self, row: int, col: int) -> int:\n    for r1, c1, r2, c2, v in reversed(self.updates):\n      if r1 <= row <= r2 and c1 <= col <= c2:\n        return v\n    return self.rectangle[row][col]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1454, "slug": "active-users", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1412, "slug": "find-the-quiet-students-in-all-exams", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1428, "slug": "leftmost-column-with-at-least-a-one", "solutions": ["# \"\"\"\n# This is BinaryMatrix's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# class BinaryMatrix(object):\n#    def get(self, row: int, col: int) -> int:\n#    def dimensions(self) -> list[]:\n\n\nclass Solution:\n    def leftMostColumnWithOne(self, binaryMatrix: \"BinaryMatrix\") -> int:\n        m, n = binaryMatrix.dimensions()\n        ans = n\n        for i in range(m):\n            j = bisect_left(range(n), 1, key=lambda k: binaryMatrix.get(i, k))\n            ans = min(ans, j)\n        return -1 if ans >= n else ans\n", "# \"\"\"\n# This is BinaryMatrix's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# Class BinaryMatrix(object):\n#   def get(self, row: int, col: int) -> int:\n#   def dimensions(self) -> list[int]:\n\nclass Solution:\n  def leftMostColumnWithOne(self, binaryMatrix: 'BinaryMatrix') -> int:\n    m, n = binaryMatrix.dimensions()\n    ans = -1\n    l = 0\n    r = n - 1\n\n    while l <= r:\n      mid = (l + r) // 2\n      if any(binaryMatrix.get(i, mid) for i in range(m)):\n        ans = mid\n        r = mid - 1\n      else:\n        l = mid + 1\n\n    return ans\n", "# \"\"\"\n# This is BinaryMatrix's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# Class BinaryMatrix(object):\n#   def get(self, row: int, col: int) -> int:\n#   def dimensions(self) -> list[int]:\n\nclass Solution:\n  def leftMostColumnWithOne(self, binaryMatrix: 'BinaryMatrix') -> int:\n    m, n = binaryMatrix.dimensions()\n    ans = -1\n    i = 0\n    j = n - 1\n\n    while i < m and j >= 0:\n      if binaryMatrix.get(i, j):\n        ans = j\n        j -= 1\n      else:\n        i += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1497, "slug": "check-if-array-pairs-are-divisible-by-k", "solutions": ["class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        cnt = Counter(x % k for x in arr)\n        return cnt[0] % 2 == 0 and all(cnt[i] == cnt[k - i] for i in range(1, k))\n", "class Solution:\n  def canArrange(self, arr: list[int], k: int) -> bool:\n    count = [0] * k\n\n    for a in arr:\n      a %= k\n      count[a if a >= 0 else a + k] += 1\n\n    return (count[0] % 2 == 0 and\n            all(count[i] == count[k - i]\n                for i in range(1, k // 2 + 1)))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1445, "slug": "apples-oranges", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1418, "slug": "display-table-of-food-orders-in-a-restaurant", "solutions": ["class Solution:\n    def displayTable(self, orders: List[List[str]]) -> List[List[str]]:\n        tables = defaultdict(list)\n        items = set()\n        for _, table, foodItem in orders:\n            tables[int(table)].append(foodItem)\n            items.add(foodItem)\n        sorted_items = sorted(items)\n        ans = [[\"Table\"] + sorted_items]\n        for table in sorted(tables):\n            cnt = Counter(tables[table])\n            row = [str(table)] + [str(cnt[item]) for item in sorted_items]\n            ans.append(row)\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1462, "slug": "course-schedule-iv", "solutions": ["class Solution:\n    def checkIfPrerequisite(\n        self, n: int, prerequisites: List[List[int]], queries: List[List[int]]\n    ) -> List[bool]:\n        f = [[False] * n for _ in range(n)]\n        for a, b in prerequisites:\n            f[a][b] = True\n        for k in range(n):\n            for i in range(n):\n                for j in range(n):\n                    if f[i][k] and f[k][j]:\n                        f[i][j] = True\n        return [f[a][b] for a, b in queries]\n", "class Solution:\n  def checkIfPrerequisite(\n      self,\n      numCourses: int,\n      prerequisites: list[list[int]],\n      queries: list[list[int]],\n  ) -> list[bool]:\n    # isPrerequisite[i][j] := True if course i is a prerequisite of course j.\n    isPrerequisite = [[False] * numCourses for _ in range(numCourses)]\n\n    for u, v in prerequisites:\n      isPrerequisite[u][v] = True\n\n    for k in range(numCourses):\n      for i in range(numCourses):\n        for j in range(numCourses):\n          isPrerequisite[i][j] = (isPrerequisite[i][j] or (\n              isPrerequisite[i][k] and isPrerequisite[k][j]))\n\n    return [isPrerequisite[u][v] for u, v in queries]\n", "class Solution:\n  def checkIfPrerequisite(\n      self,\n      numCourses: int,\n      prerequisites: list[list[int]],\n      queries: list[list[int]],\n  ) -> list[bool]:\n    graph = [[] for _ in range(numCourses)]\n    # isPrerequisite[i][j] := True if course i is a prerequisite of course j.\n    isPrerequisite = [[False] * numCourses for _ in range(numCourses)]\n\n    for u, v in prerequisites:\n      graph[u].append(v)\n\n    # DFS from every course.\n    for i in range(numCourses):\n      self._dfs(graph, i, isPrerequisite[i])\n\n    return [isPrerequisite[u][v] for u, v in queries]\n\n  def _dfs(self, graph: list[list[int]], u: int, used: list[bool]) -> None:\n    for v in graph[u]:\n      if used[v]:\n        continue\n      used[v] = True\n      self._dfs(graph, v, used)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1483, "slug": "kth-ancestor-of-a-tree-node", "solutions": ["class TreeAncestor:\n    def __init__(self, n: int, parent: List[int]):\n        self.p = [[-1] * 18 for _ in range(n)]\n        for i, fa in enumerate(parent):\n            self.p[i][0] = fa\n        for j in range(1, 18):\n            for i in range(n):\n                if self.p[i][j - 1] == -1:\n                    continue\n                self.p[i][j] = self.p[self.p[i][j - 1]][j - 1]\n\n    def getKthAncestor(self, node: int, k: int) -> int:\n        for i in range(17, -1, -1):\n            if k >> i & 1:\n                node = self.p[node][i]\n                if node == -1:\n                    break\n        return node\n\n\n# Your TreeAncestor object will be instantiated and called as such:\n# obj = TreeAncestor(n, parent)\n# param_1 = obj.getKthAncestor(node,k)\n", "class TreeAncestor:\n  def __init__(self, n: int, parent: list[int]):\n    self.maxLevel = n.bit_length()\n    # dp[i][j] := node i's 2^j-th ancestor\n    self.dp = [[0] * self.maxLevel for _ in range(n)]\n\n    # Node i's 2^0 ancestor is its direct parent\n    for i in range(n):\n      self.dp[i][0] = parent[i]\n\n    for j in range(1, self.maxLevel):\n      for i in range(n):\n        if self.dp[i][j - 1] == -1:  # There's no such ancestor\n          self.dp[i][j] = -1\n        else:  # A(i, 2^j) = A(A(i, 2^{j - 1}), 2^{j - 1})\n          self.dp[i][j] = self.dp[self.dp[i][j - 1]][j - 1]\n\n  def getKthAncestor(self, node: int, k: int) -> int:\n    for j in range(self.maxLevel):\n      if node == -1:\n        break\n      if k >> j & 1:\n        node = self.dp[node][j]\n    return node\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1449, "slug": "form-largest-integer-with-digits-that-add-up-to-target", "solutions": ["class Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        f = [[-inf] * (target + 1) for _ in range(10)]\n        f[0][0] = 0\n        g = [[0] * (target + 1) for _ in range(10)]\n        for i, c in enumerate(cost, 1):\n            for j in range(target + 1):\n                if j < c or f[i][j - c] + 1 < f[i - 1][j]:\n                    f[i][j] = f[i - 1][j]\n                    g[i][j] = j\n                else:\n                    f[i][j] = f[i][j - c] + 1\n                    g[i][j] = j - c\n        if f[9][target] < 0:\n            return \"0\"\n        ans = []\n        i, j = 9, target\n        while i:\n            if j == g[i][j]:\n                i -= 1\n            else:\n                ans.append(str(i))\n                j = g[i][j]\n        return \"\".join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1453, "slug": "maximum-number-of-darts-inside-of-a-circular-dartboard", "solutions": ["class Solution:\n    def numPoints(self, darts: list[list[int]], r: int) -> int:\n        def countDarts(x, y):\n            count = 0\n            for x1, y1 in darts:\n                if dist((x, y), (x1, y1)) <= r + 1e-7:\n                    count += 1\n            return count\n\n        def possibleCenters(x1, y1, x2, y2):\n            dx, dy = x2 - x1, y2 - y1\n            d = sqrt(dx * dx + dy * dy)\n            if d > 2 * r:\n                return []\n            mid_x, mid_y = (x1 + x2) / 2, (y1 + y2) / 2\n            dist_to_center = sqrt(r * r - (d / 2) * (d / 2))\n            offset_x = dist_to_center * dy / d\n            offset_y = dist_to_center * -dx / d\n            return [\n                (mid_x + offset_x, mid_y + offset_y),\n                (mid_x - offset_x, mid_y - offset_y),\n            ]\n\n        n = len(darts)\n        max_darts = 1\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                centers = possibleCenters(\n                    darts[i][0], darts[i][1], darts[j][0], darts[j][1]\n                )\n                for center in centers:\n                    max_darts = max(max_darts, countDarts(center[0], center[1]))\n\n        return max_darts\n", "class Point:\n  def __init__(self, x: float, y: float):\n    self.x = x\n    self.y = y\n\n\nclass Solution:\n  def numPoints(self, darts: list[list[int]], r: int) -> int:\n    ERR = 1e-6\n    ans = 1\n    points = [Point(x, y) for x, y in darts]\n\n    def dist(p: Point, q: Point) -> float:\n      return ((p.x - q.x)**2 + (p.y - q.y)**2)**0.5\n\n    def getCircles(p: Point, q: Point) -> list[Point]:\n      if dist(p, q) - 2.0 * r > ERR:\n        return []\n      m = Point((p.x + q.x) / 2, (p.y + q.y) / 2)\n      distCM = (r**2 - (dist(p, q) / 2)**2)**0.5\n      alpha = math.atan2(p.y - q.y, q.x - p.x)\n      return [Point(m.x - distCM * math.sin(alpha), m.y - distCM * math.cos(alpha)),\n              Point(m.x + distCM * math.sin(alpha), m.y + distCM * math.cos(alpha))]\n\n    for i in range(len(points)):\n      for j in range(i + 1, len(points)):\n        for c in getCircles(points[i], points[j]):\n          count = 0\n          for point in points:\n            if dist(c, point) - r <= ERR:\n              count += 1\n          ans = max(ans, count)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1406, "slug": "stone-game-iii", "solutions": ["class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        @cache\n        def dfs(i: int) -> int:\n            if i >= n:\n                return 0\n            ans, s = -inf, 0\n            for j in range(3):\n                if i + j >= n:\n                    break\n                s += stoneValue[i + j]\n                ans = max(ans, s - dfs(i + j + 1))\n            return ans\n\n        n = len(stoneValue)\n        ans = dfs(0)\n        if ans == 0:\n            return 'Tie'\n        return 'Alice' if ans > 0 else 'Bob'\n", "class Solution:\n  def stoneGameIII(self, stoneValue: list[int]) -> str:\n    n = len(stoneValue)\n    # dp[i] := the maximum relative score Alice can make with stoneValue[i..n)\n    dp = [-math.inf] * n + [0]\n\n    for i in reversed(range(n)):\n      summ = 0\n      for j in range(i, i + 3):\n        if j == n:\n          break\n        summ += stoneValue[j]\n        dp[i] = max(dp[i], summ - dp[j + 1])\n\n    score = dp[0]\n    if score == 0:\n      return 'Tie'\n    return 'Alice' if score > 0 else 'Bob'\n", "class Solution:\n  def stoneGameIII(self, stoneValue: list[int]) -> str:\n    @functools.lru_cache(None)\n    def dp(i: int) -> int:\n      \"\"\"\n      Returns the maximum relative score Alice can make with stoneValue[i..n).\n      \"\"\"\n      if i == len(stoneValue):\n        return 0\n\n      res = -math.inf\n      summ = 0\n\n      for j in range(i, i + 3):\n        if j == len(stoneValue):\n          break\n        summ += stoneValue[j]\n        res = max(res, summ - dp(j + 1))\n\n      return res\n\n    score = dp(0)\n    if score == 0:\n      return 'Tie'\n    return 'Alice' if score > 0 else 'Bob'\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1460, "slug": "make-two-arrays-equal-by-reversing-subarrays", "solutions": ["class Solution:\n    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:\n        return sorted(target) == sorted(arr)\n", "class Solution:\n  def canBeEqual(self, target: list[int], arr: list[int]) -> bool:\n    return collections.Counter(arr) == collections.Counter(target)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1408, "slug": "string-matching-in-an-array", "solutions": ["class Solution:\n    def stringMatching(self, words: List[str]) -> List[str]:\n        ans = []\n        for i, s in enumerate(words):\n            if any(i != j and s in t for j, t in enumerate(words)):\n                ans.append(s)\n        return ans\n", "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.count = 0\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, word: str) -> None:\n    node: TrieNode = self.root\n    for c in word:\n      node = node.children.setdefault(c, TrieNode())\n      node.count += 1\n\n  def search(self, word: str) -> bool:\n    node: TrieNode = self.root\n    for c in word:\n      if c not in node.children:\n        return False\n      node = node.children[c]\n    return node.count > 1\n\n\nclass Solution:\n  def stringMatching(self, words: list[str]) -> list[str]:\n    trie = Trie()\n\n    for word in words:\n      for i in range(len(word)):\n        trie.insert(word[i:])\n\n    return [word for word in words if trie.search(word)]\n", "class Solution:\n  def stringMatching(self, words: list[str]) -> list[str]:\n    ans = []\n    for a in words:\n      for b in words:\n        if len(a) < len(b) and b.find(a) != -1:\n          ans.append(a)\n          break\n    return ans\n", "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, word: str) -> None:\n    node: TrieNode = self.root\n    for c in word:\n      node = node.children.setdefault(c, TrieNode())\n\n  def search(self, word: str) -> bool:\n    node: TrieNode = self.root\n    for c in word:\n      if c not in node.children:\n        return False\n      node = node.children[c]\n    return True\n\n\nclass Solution:\n  def stringMatching(self, words: list[str]) -> list[str]:\n    ans = []\n    trie = Trie()\n\n    for word in sorted(words, key=lambda x: -len(x)):\n      if trie.search(word):\n        ans.append(word)\n      for i in range(len(word)):\n        trie.insert(word[i:])\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1416, "slug": "restore-the-array", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1457, "slug": "pseudo-palindromic-paths-in-a-binary-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def pseudoPalindromicPaths(self, root: Optional[TreeNode]) -> int:\n        def dfs(root: Optional[TreeNode], mask: int):\n            if root is None:\n                return 0\n            mask ^= 1 << root.val\n            if root.left is None and root.right is None:\n                return int((mask & (mask - 1)) == 0)\n            return dfs(root.left, mask) + dfs(root.right, mask)\n\n        return dfs(root, 0)\n", "class Solution:\n  def pseudoPalindromicPaths(self, root: TreeNode | None) -> int:\n    ans = 0\n\n    def dfs(root: TreeNode | None, path: int) -> None:\n      nonlocal ans\n      if not root:\n        return\n      if not root.left and not root.right:\n        path ^= 1 << root.val\n        if path & (path - 1) == 0:\n          ans += 1\n        return\n\n      dfs(root.left, path ^ 1 << root.val)\n      dfs(root.right, path ^ 1 << root.val)\n\n    dfs(root, 0)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1464, "slug": "maximum-product-of-two-elements-in-an-array", "solutions": ["class Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        ans = 0\n        for i, a in enumerate(nums):\n            for b in nums[i + 1 :]:\n                ans = max(ans, (a - 1) * (b - 1))\n        return ans\n", "class Solution:\n  def maxProduct(self, nums: list[int]) -> int:\n    max1 = 0\n    max2 = 0\n\n    for num in nums:\n      if num > max1:\n        max2, max1 = max1, num\n      elif num > max2:\n        max2 = num\n\n    return (max1 - 1) * (max2 - 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1499, "slug": "max-value-of-equation", "solutions": ["class Solution:\n    def findMaxValueOfEquation(self, points: List[List[int]], k: int) -> int:\n        ans = -inf\n        pq = []\n        for x, y in points:\n            while pq and x - pq[0][1] > k:\n                heappop(pq)\n            if pq:\n                ans = max(ans, x + y - pq[0][0])\n            heappush(pq, (x - y, x))\n        return ans\n", "class Solution:\n  def findMaxValueOfEquation(self, points: list[list[int]], k: int) -> int:\n    ans = -math.inf\n    maxQ = collections.deque()  # (y - x, x)\n\n    for x, y in points:\n      # Remove the invalid points, xj - xi > k\n      while maxQ and x - maxQ[0][1] > k:\n        maxQ.popleft()\n      if maxQ:\n        ans = max(ans, x + y + maxQ[0][0])\n      # Remove the points that contribute less value and have a bigger x.\n      while maxQ and y - x >= maxQ[-1][0]:\n        maxQ.pop()\n      maxQ.append((y - x, x))\n\n    return ans\n", "class Solution:\n  def findMaxValueOfEquation(self, points: list[list[int]], k: int) -> int:\n    ans = -math.inf\n    maxHeap = []  # (y - x, x)\n\n    for x, y in points:\n      while maxHeap and x + maxHeap[0][1] > k:\n        heapq.heappop(maxHeap)\n      if maxHeap:\n        ans = max(ans, x + y - maxHeap[0][0])\n      heapq.heappush(maxHeap, (x - y, -x))\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1401, "slug": "circle-and-rectangle-overlapping", "solutions": ["class Solution:\n    def checkOverlap(\n        self,\n        radius: int,\n        xCenter: int,\n        yCenter: int,\n        x1: int,\n        y1: int,\n        x2: int,\n        y2: int,\n    ) -> bool:\n        def f(i: int, j: int, k: int) -> int:\n            if i <= k <= j:\n                return 0\n            return i - k if k < i else k - j\n\n        a = f(x1, x2, xCenter)\n        b = f(y1, y2, yCenter)\n        return a * a + b * b <= radius * radius\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1481, "slug": "least-number-of-unique-integers-after-k-removals", "solutions": ["class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        cnt = Counter(arr)\n        for i, v in enumerate(sorted(cnt.values())):\n            k -= v\n            if k < 0:\n                return len(cnt) - i\n        return 0\n", "class Solution:\n  def findLeastNumOfUniqueInts(self, arr: list[int], k: int) -> int:\n    minHeap = list(collections.Counter(arr).values())\n    heapq.heapify(minHeap)\n\n    # Greedily remove the k least frequent numbers to have the least number of unique integers.\n    while k > 0:\n      k -= heapq.heappop(minHeap)\n\n    return len(minHeap) + (1 if k < 0 else 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1432, "slug": "max-difference-you-can-get-from-changing-an-integer", "solutions": ["class Solution:\n    def maxDiff(self, num: int) -> int:\n        a, b = str(num), str(num)\n        for c in a:\n            if c != \"9\":\n                a = a.replace(c, \"9\")\n                break\n        if b[0] != \"1\":\n            b = b.replace(b[0], \"1\")\n        else:\n            for c in b[1:]:\n                if c not in \"01\":\n                    b = b.replace(c, \"0\")\n                    break\n        return int(a) - int(b)\n", "class Solution:\n  def maxDiff(self, num: int) -> int:\n    s = str(num)\n\n    def firstNot(s: str, t: str) -> int:\n      for i, c in enumerate(s):\n        if all(c != d for d in t):\n          return i\n      return 0\n\n    firstNot9 = firstNot(s, '9')\n    firstNot01 = firstNot(s, '01')\n    a = s.replace(s[firstNot9], '9')\n    b = s.replace(s[firstNot01], '1' if firstNot01 == 0 else '0')\n    return int(a) - int(b)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1434, "slug": "number-of-ways-to-wear-different-hats-to-each-other", "solutions": ["class Solution:\n    def numberWays(self, hats: List[List[int]]) -> int:\n        g = defaultdict(list)\n        for i, h in enumerate(hats):\n            for v in h:\n                g[v].append(i)\n        mod = 10**9 + 7\n        n = len(hats)\n        m = max(max(h) for h in hats)\n        f = [[0] * (1 << n) for _ in range(m + 1)]\n        f[0][0] = 1\n        for i in range(1, m + 1):\n            for j in range(1 << n):\n                f[i][j] = f[i - 1][j]\n                for k in g[i]:\n                    if j >> k & 1:\n                        f[i][j] = (f[i][j] + f[i - 1][j ^ (1 << k)]) % mod\n        return f[m][-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1486, "slug": "xor-operation-in-an-array", "solutions": ["class Solution:\n    def xorOperation(self, n: int, start: int) -> int:\n        return reduce(xor, ((start + 2 * i) for i in range(n)))\n", "class Solution:\n  def xorOperation(self, n: int, start: int) -> int:\n    return functools.reduce(operator.xor,\n                            [start + 2 * i for i in range(n)])\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1455, "slug": "check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence", "solutions": ["class Solution:\n    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\n        for i, s in enumerate(sentence.split(), 1):\n            if s.startswith(searchWord):\n                return i\n        return -1\n", "class Solution:\n  def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\n    words = sentence.split()\n\n    for i, word in enumerate(words):\n      if word.startswith(searchWord):\n        return i + 1\n\n    return -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1444, "slug": "number-of-ways-of-cutting-a-pizza", "solutions": ["class Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        @cache\n        def dfs(i: int, j: int, k: int) -> int:\n            if k == 0:\n                return int(s[m][n] - s[i][n] - s[m][j] + s[i][j] > 0)\n            ans = 0\n            for x in range(i + 1, m):\n                if s[x][n] - s[i][n] - s[x][j] + s[i][j] > 0:\n                    ans += dfs(x, j, k - 1)\n            for y in range(j + 1, n):\n                if s[m][y] - s[i][y] - s[m][j] + s[i][j] > 0:\n                    ans += dfs(i, y, k - 1)\n            return ans % mod\n\n        mod = 10**9 + 7\n        m, n = len(pizza), len(pizza[0])\n        s = [[0] * (n + 1) for _ in range(m + 1)]\n        for i, row in enumerate(pizza, 1):\n            for j, c in enumerate(row, 1):\n                s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + int(c == 'A')\n        return dfs(0, 0, k - 1)\n", "class Solution:\n  def ways(self, pizza: list[str], k: int) -> int:\n    MOD = 1_000_000_007\n    M = len(pizza)\n    N = len(pizza[0])\n    prefix = [[0] * (N + 1) for _ in range(M + 1)]\n\n    for i in range(M):\n      for j in range(N):\n        prefix[i + 1][j + 1] = ((pizza[i][j] == 'A') + prefix[i][j + 1] +\n                                prefix[i + 1][j] - prefix[i][j])\n\n    def hasApple(row1: int, row2: int, col1: int, col2: int) -> bool:\n      \"\"\"Returns True if pizza[row1..row2)[col1..col2) has apple.\"\"\"\n      return (prefix[row2][col2] - prefix[row1][col2] -\n              prefix[row2][col1] + prefix[row1][col1]) > 0\n\n    @functools.lru_cache(None)\n    def dp(m: int, n: int, k: int) -> int:\n      \"\"\"Returns the number of ways to cut pizza[m..M)[n..N) with k cuts.\"\"\"\n      if k == 0:\n        return 1 if hasApple(m, M, n, N) else 0\n\n      res = 0\n\n      for i in range(m + 1, M):  # Cut horizontally.\n        if hasApple(m, i, n, N) and hasApple(i, M, n, N):\n          res += dp(i, n, k - 1)\n\n      for j in range(n + 1, N):  # Cut vertically.\n        if hasApple(m, M, n, j) and hasApple(m, M, j, N):\n          res += dp(m, j, k - 1)\n\n      return res % MOD\n\n    return dp(0, 0, k - 1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1496, "slug": "path-crossing", "solutions": ["class Solution:\n    def isPathCrossing(self, path: str) -> bool:\n        i = j = 0\n        vis = {(0, 0)}\n        for c in path:\n            match c:\n                case 'N':\n                    i -= 1\n                case 'S':\n                    i += 1\n                case 'E':\n                    j += 1\n                case 'W':\n                    j -= 1\n            if (i, j) in vis:\n                return True\n            vis.add((i, j))\n        return False\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1456, "slug": "maximum-number-of-vowels-in-a-substring-of-given-length", "solutions": ["class Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        vowels = set(\"aeiou\")\n        ans = cnt = sum(c in vowels for c in s[:k])\n        for i in range(k, len(s)):\n            cnt += int(s[i] in vowels) - int(s[i - k] in vowels)\n            ans = max(ans, cnt)\n        return ans\n", "class Solution:\n  def maxVowels(self, s: str, k: int) -> int:\n    ans = 0\n    mx = 0\n    VOWELS = 'aeiou'\n\n    for i, c in enumerate(s):\n      if c in VOWELS:\n        mx += 1\n      if i >= k and s[i - k] in VOWELS:\n        mx -= 1\n      ans = max(ans, mx)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1420, "slug": "build-array-where-you-can-find-the-maximum-exactly-k-comparisons", "solutions": ["class Solution:\n    def numOfArrays(self, n: int, m: int, k: int) -> int:\n        if k == 0:\n            return 0\n        dp = [[[0] * (m + 1) for _ in range(k + 1)] for _ in range(n + 1)]\n        mod = 10**9 + 7\n        for i in range(1, m + 1):\n            dp[1][1][i] = 1\n        for i in range(2, n + 1):\n            for c in range(1, min(k + 1, i + 1)):\n                for j in range(1, m + 1):\n                    dp[i][c][j] = dp[i - 1][c][j] * j\n                    for j0 in range(1, j):\n                        dp[i][c][j] += dp[i - 1][c - 1][j0]\n                        dp[i][c][j] %= mod\n        ans = 0\n        for i in range(1, m + 1):\n            ans += dp[n][k][i]\n            ans %= mod\n        return ans\n", "class Solution:\n  def numOfArrays(self, n: int, m: int, k: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i][j][k] := the number of ways to build an array of length i, where j\n    # is the maximum number and k is `search_cost`\n    dp = [[[0] * (k + 1) for j in range(m + 1)] for _ in range(n + 1)]\n\n    for j in range(1, m + 1):\n      dp[1][j][1] = 1\n\n    for i in range(2, n + 1):  # for each length\n      for j in range(1, m + 1):  # for each max value\n        for cost in range(1, k + 1):  # for each cost\n          # 1. Appending any of [1, j] in the i-th position doesn't change the\n          #    maximum and cost.\n          dp[i][j][cost] = j * dp[i - 1][j][cost] % MOD\n          # 2. Appending j in the i-th position makes j the new max and cost 1.\n          for prevMax in range(1, j):\n            dp[i][j][cost] += dp[i - 1][prevMax][cost - 1]\n            dp[i][j][cost] %= MOD\n\n    return sum(dp[n][j][k] for j in range(1, m + 1)) % MOD\n", "class Solution:\n  def numOfArrays(self, n: int, m: int, k: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i][j][k] := the number of ways to build an array of length i, where j\n    # is the maximum number and k is the `search_cost`\n    dp = [[[0] * (k + 1) for j in range(m + 1)] for _ in range(n + 1)]\n    # prefix[i][j][k] := sum(dp[i][x][k]), where 1 <= x <= j\n    prefix = [[[0] * (k + 1) for j in range(m + 1)] for _ in range(n + 1)]\n\n    for j in range(1, m + 1):\n      dp[1][j][1] = 1\n      prefix[1][j][1] = j\n\n    for i in range(2, n + 1):  # for each length\n      for j in range(1, m + 1):  # for each max value\n        for cost in range(1, k + 1):  # for each cost\n          # 1. Appending any of [1, j] in the i-th position doesn't change the\n          #    maximum and cost.\n          # 2. Appending j in the i-th position makes j the new max and cost 1.\n          dp[i][j][cost] = (j * dp[i - 1][j][cost] +\n                            prefix[i - 1][j - 1][cost - 1]) % MOD\n          prefix[i][j][cost] = (dp[i][j][cost] + prefix[i][j - 1][cost]) % MOD\n\n    return sum(dp[n][j][k] for j in range(1, m + 1)) % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1480, "slug": "running-sum-of-1d-array", "solutions": ["class Solution:\n    def runningSum(self, nums: List[int]) -> List[int]:\n        return list(accumulate(nums))\n", "class Solution:\n  def runningSum(self, nums: list[int]) -> list[int]:\n    return itertools.accumulate(nums)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1403, "slug": "minimum-subsequence-in-non-increasing-order", "solutions": ["class Solution:\n    def minSubsequence(self, nums: List[int]) -> List[int]:\n        ans = []\n        s, t = sum(nums), 0\n        for x in sorted(nums, reverse=True):\n            t += x\n            ans.append(x)\n            if t > s - t:\n                break\n        return ans\n", "class Solution:\n  def minSubsequence(self, nums: list[int]) -> list[int]:\n    ans = []\n    maxHeap = [-num for num in nums]\n    heapq.heapify(maxHeap)\n    half = sum(nums) // 2\n\n    while half >= 0:\n      ans.append(-maxHeap[0])\n      half += heapq.heappop(maxHeap)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1435, "slug": "create-a-session-bar-chart", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1443, "slug": "minimum-time-to-collect-all-apples-in-a-tree", "solutions": ["class Solution:\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\n        def dfs(u, cost):\n            if vis[u]:\n                return 0\n            vis[u] = True\n            nxt_cost = 0\n            for v in g[u]:\n                nxt_cost += dfs(v, 2)\n            if not hasApple[u] and nxt_cost == 0:\n                return 0\n            return cost + nxt_cost\n\n        g = defaultdict(list)\n        for u, v in edges:\n            g[u].append(v)\n            g[v].append(u)\n        vis = [False] * n\n        return dfs(0, 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1411, "slug": "number-of-ways-to-paint-n-3-grid", "solutions": ["class Solution:\n    def numOfWays(self, n: int) -> int:\n        mod = 10**9 + 7\n        f0 = f1 = 6\n        for _ in range(n - 1):\n            g0 = (3 * f0 + 2 * f1) % mod\n            g1 = (2 * f0 + 2 * f1) % mod\n            f0, f1 = g0, g1\n        return (f0 + f1) % mod\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1451, "slug": "rearrange-words-in-a-sentence", "solutions": ["class Solution:\n    def arrangeWords(self, text: str) -> str:\n        words = text.split()\n        words[0] = words[0].lower()\n        words.sort(key=len)\n        words[0] = words[0].title()\n        return \" \".join(words)\n", "class Solution:\n  def arrangeWords(self, text: str) -> str:\n    words = text.split()\n    count = collections.defaultdict(list)\n\n    for word in words:\n      count[len(word)].append(word.lower())\n\n    c2 = OrderedDict(sorted(count.items()))\n\n    ans = []\n\n    for l in c2:\n      for word in c2[l]:\n        ans.append(word)\n\n    ans[0] = ans[0].capitalize()\n\n    return ' '.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1484, "slug": "group-sold-products-by-the-date", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1469, "slug": "find-all-the-lonely-nodes", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def getLonelyNodes(self, root: Optional[TreeNode]) -> List[int]:\n        def dfs(root: Optional[TreeNode]):\n            if root is None or root.left == root.right:\n                return\n            if root.left is None:\n                ans.append(root.right.val)\n            if root.right is None:\n                ans.append(root.left.val)\n            dfs(root.left)\n            dfs(root.right)\n\n        ans = []\n        dfs(root)\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1438, "slug": "longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit", "solutions": ["class Solution:\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\n        sl = SortedList()\n        ans = j = 0\n        for i, x in enumerate(nums):\n            sl.add(x)\n            while sl[-1] - sl[0] > limit:\n                sl.remove(nums[j])\n                j += 1\n            ans = max(ans, i - j + 1)\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1421, "slug": "npv-queries", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1430, "slug": "check-if-a-string-is-a-valid-sequence-from-root-to-leaves-path-in-a-binary-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isValidSequence(self, root: TreeNode, arr: List[int]) -> bool:\n        def dfs(root, u):\n            if root is None or root.val != arr[u]:\n                return False\n            if u == len(arr) - 1:\n                return root.left is None and root.right is None\n            return dfs(root.left, u + 1) or dfs(root.right, u + 1)\n\n        return dfs(root, 0)\n", "class Solution:\n  def isValidSequence(self, root: TreeNode | None, arr: list[int]) -> bool:\n    def isValidSequence(root: TreeNode | None, i: int) -> bool:\n      if not root:\n        return False\n      if i == len(arr) - 1:\n        return root.val == arr[i] and not root.left and not root.right\n      return root.val == arr[i] and (\n          isValidSequence(root.left, i + 1) or\n          isValidSequence(root.right, i + 1))\n\n    return isValidSequence(root, 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1495, "slug": "friendly-movies-streamed-last-month", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1410, "slug": "html-entity-parser", "solutions": ["class Solution:\n    def entityParser(self, text: str) -> str:\n        d = {\n            '&quot;': '\"',\n            '&apos;': \"'\",\n            '&amp;': \"&\",\n            \"&gt;\": '>',\n            \"&lt;\": '<',\n            \"&frasl;\": '/',\n        }\n        i, n = 0, len(text)\n        ans = []\n        while i < n:\n            for l in range(1, 8):\n                j = i + l\n                if text[i:j] in d:\n                    ans.append(d[text[i:j]])\n                    i = j\n                    break\n            else:\n                ans.append(text[i])\n                i += 1\n        return ''.join(ans)\n", "class Solution:\n  def entityParser(self, text: str) -> str:\n    entityToChar = {'&quot;': '\"', '&apos;': '\\'',\n                    '&gt;': '>', '&lt;': '<', '&frasl;': '/'}\n\n    for entity, c in entityToChar.items():\n      text = text.replace(entity, c)\n\n    # Process '&' in last.\n    return text.replace('&amp;', '&')\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1419, "slug": "minimum-number-of-frogs-croaking", "solutions": ["class Solution:\n    def minNumberOfFrogs(self, croakOfFrogs: str) -> int:\n        if len(croakOfFrogs) % 5 != 0:\n            return -1\n        idx = {c: i for i, c in enumerate('croak')}\n        cnt = [0] * 5\n        ans = x = 0\n        for i in map(idx.get, croakOfFrogs):\n            cnt[i] += 1\n            if i == 0:\n                x += 1\n                ans = max(ans, x)\n            else:\n                if cnt[i - 1] == 0:\n                    return -1\n                cnt[i - 1] -= 1\n                if i == 4:\n                    x -= 1\n        return -1 if x else ans\n", "class Solution:\n  def minNumberOfFrogs(self, croakOfFrogs: str) -> int:\n    CROAK = 'croak'\n    ans = 0\n    frogs = 0\n    count = [0] * 5\n\n    for c in croakOfFrogs:\n      count[CROAK.index(c)] += 1\n      if any(count[i] > count[i - 1] for i in range(1, 5)):\n        return -1\n      if c == 'c':\n        frogs += 1\n      elif c == 'k':\n        frogs -= 1\n      ans = max(ans, frogs)\n\n    return ans if frogs == 0 else -1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1446, "slug": "consecutive-characters", "solutions": ["class Solution:\n    def maxPower(self, s: str) -> int:\n        ans = t = 1\n        for a, b in pairwise(s):\n            if a == b:\n                t += 1\n                ans = max(ans, t)\n            else:\n                t = 1\n        return ans\n", "class Solution:\n  def maxPower(self, s: str) -> int:\n    ans = 1\n    count = 1\n\n    for i in range(1, len(s)):\n      count = count + 1 if s[i] == s[i - 1] else 1\n      ans = max(ans, count)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1424, "slug": "diagonal-traverse-ii", "solutions": ["class Solution:\n    def findDiagonalOrder(self, nums: List[List[int]]) -> List[int]:\n        arr = []\n        for i, row in enumerate(nums):\n            for j, v in enumerate(row):\n                arr.append((i + j, j, v))\n        arr.sort()\n        return [v[2] for v in arr]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1473, "slug": "paint-house-iii", "solutions": ["class Solution:\n    def minCost(\n        self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int\n    ) -> int:\n        f = [[[inf] * (target + 1) for _ in range(n + 1)] for _ in range(m)]\n        if houses[0] == 0:\n            for j, c in enumerate(cost[0], 1):\n                f[0][j][1] = c\n        else:\n            f[0][houses[0]][1] = 0\n        for i in range(1, m):\n            if houses[i] == 0:\n                for j in range(1, n + 1):\n                    for k in range(1, min(target + 1, i + 2)):\n                        for j0 in range(1, n + 1):\n                            if j == j0:\n                                f[i][j][k] = min(\n                                    f[i][j][k], f[i - 1][j][k] + cost[i][j - 1]\n                                )\n                            else:\n                                f[i][j][k] = min(\n                                    f[i][j][k], f[i - 1][j0][k - 1] + cost[i][j - 1]\n                                )\n            else:\n                j = houses[i]\n                for k in range(1, min(target + 1, i + 2)):\n                    for j0 in range(1, n + 1):\n                        if j == j0:\n                            f[i][j][k] = min(f[i][j][k], f[i - 1][j][k])\n                        else:\n                            f[i][j][k] = min(f[i][j][k], f[i - 1][j0][k - 1])\n\n        ans = min(f[-1][j][target] for j in range(1, n + 1))\n        return -1 if ans >= inf else ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1478, "slug": "allocate-mailboxes", "solutions": ["class Solution:\n    def minDistance(self, houses: List[int], k: int) -> int:\n        houses.sort()\n        n = len(houses)\n        g = [[0] * n for _ in range(n)]\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 1, n):\n                g[i][j] = g[i + 1][j - 1] + houses[j] - houses[i]\n        f = [[inf] * (k + 1) for _ in range(n)]\n        for i in range(n):\n            f[i][1] = g[0][i]\n            for j in range(2, min(k + 1, i + 2)):\n                for p in range(i):\n                    f[i][j] = min(f[i][j], f[p][j - 1] + g[p + 1][i])\n        return f[-1][k]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1491, "slug": "average-salary-excluding-the-minimum-and-maximum-salary", "solutions": ["class Solution:\n    def average(self, salary: List[int]) -> float:\n        s = sum(salary) - min(salary) - max(salary)\n        return s / (len(salary) - 2)\n", "class Solution:\n  def average(self, salary: list[int]) -> float:\n    return (sum(salary) - max(salary) - min(salary)) / (len(salary) - 2)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1461, "slug": "check-if-a-string-contains-all-binary-codes-of-size-k", "solutions": ["class Solution:\n    def hasAllCodes(self, s: str, k: int) -> bool:\n        n = len(s)\n        m = 1 << k\n        if n - k + 1 < m:\n            return False\n        ss = {s[i : i + k] for i in range(n - k + 1)}\n        return len(ss) == m\n", "class Solution:\n  def hasAllCodes(self, s: str, k: int) -> bool:\n    n = 1 << k\n    if len(s) < n:\n      return False\n\n    # used[i] := True if i is a substring of `s`\n    used = [0] * n\n\n    windowStr = 0 if k == 1 else int(s[0:k - 1], 2)\n    for i in range(k - 1, len(s)):\n      # Include the s[i].\n      windowStr = (windowStr << 1) + int(s[i])\n      # Discard the s[i - k].\n      windowStr &= n - 1\n      used[windowStr] = True\n\n    return all(u for u in used)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1450, "slug": "number-of-students-doing-homework-at-a-given-time", "solutions": ["class Solution:\n    def busyStudent(\n        self, startTime: List[int], endTime: List[int], queryTime: int\n    ) -> int:\n        return sum(x <= queryTime <= y for x, y in zip(startTime, endTime))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1466, "slug": "reorder-routes-to-make-all-paths-lead-to-the-city-zero", "solutions": ["class Solution:\n    def minReorder(self, n: int, connections: List[List[int]]) -> int:\n        def dfs(a: int, fa: int) -> int:\n            return sum(c + dfs(b, a) for b, c in g[a] if b != fa)\n\n        g = [[] for _ in range(n)]\n        for a, b in connections:\n            g[a].append((b, 1))\n            g[b].append((a, 0))\n        return dfs(0, -1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1463, "slug": "cherry-pickup-ii", "solutions": ["class Solution:\n    def cherryPickup(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        f = [[[-1] * n for _ in range(n)] for _ in range(m)]\n        f[0][0][n - 1] = grid[0][0] + grid[0][n - 1]\n        for i in range(1, m):\n            for j1 in range(n):\n                for j2 in range(n):\n                    x = grid[i][j1] + (0 if j1 == j2 else grid[i][j2])\n                    for y1 in range(j1 - 1, j1 + 2):\n                        for y2 in range(j2 - 1, j2 + 2):\n                            if 0 <= y1 < n and 0 <= y2 < n and f[i - 1][y1][y2] != -1:\n                                f[i][j1][j2] = max(f[i][j1][j2], f[i - 1][y1][y2] + x)\n        return max(f[-1][j1][j2] for j1, j2 in product(range(n), range(n)))\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1426, "slug": "counting-elements", "solutions": ["class Solution:\n    def countElements(self, arr: List[int]) -> int:\n        cnt = Counter(arr)\n        return sum(v for x, v in cnt.items() if cnt[x + 1])\n", "class Solution:\n  def countElements(self, arr: list[int]) -> int:\n    count = collections.Counter(arr)\n    return sum(freq\n               for a, freq in count.items()\n               if count[a + 1] > 0)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1400, "slug": "construct-k-palindrome-strings", "solutions": ["class Solution:\n    def canConstruct(self, s: str, k: int) -> bool:\n        if len(s) < k:\n            return False\n        cnt = Counter(s)\n        return sum(v & 1 for v in cnt.values()) <= k\n", "class Solution:\n  def canConstruct(self, s: str, k: int) -> bool:\n    # If |s| < k, we cannot construct k strings from the s.\n    # If the number of letters that have odd counts > k, the minimum number of\n    # palindromic strings we can construct is > k.\n    return sum(freq & 1\n               for freq in collections.Counter(s).values()) <= k <= len(s)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1498, "slug": "number-of-subsequences-that-satisfy-the-given-sum-condition", "solutions": ["class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        mod = 10**9 + 7\n        nums.sort()\n        n = len(nums)\n        f = [1] + [0] * n\n        for i in range(1, n + 1):\n            f[i] = f[i - 1] * 2 % mod\n        ans = 0\n        for i, x in enumerate(nums):\n            if x * 2 > target:\n                break\n            j = bisect_right(nums, target - x, i + 1) - 1\n            ans = (ans + f[j - i]) % mod\n        return ans\n", "class Solution:\n  def numSubseq(self, nums: list[int], target: int) -> int:\n    MOD = 1_000_000_007\n    n = len(nums)\n    ans = 0\n\n    nums.sort()\n\n    l = 0\n    r = n - 1\n    while l <= r:\n      if nums[l] + nums[r] <= target:\n        ans += pow(2, r - l, MOD)\n        l += 1\n      else:\n        r -= 1\n\n    return ans % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1485, "slug": "clone-binary-tree-with-random-pointer", "solutions": ["# Definition for Node.\n# class Node:\n#     def __init__(self, val=0, left=None, right=None, random=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n#         self.random = random\n\n\nclass Solution:\n    def copyRandomBinaryTree(self, root: 'Optional[Node]') -> 'Optional[NodeCopy]':\n        def dfs(root):\n            if root is None:\n                return None\n            if root in mp:\n                return mp[root]\n            copy = NodeCopy(root.val)\n            mp[root] = copy\n            copy.left = dfs(root.left)\n            copy.right = dfs(root.right)\n            copy.random = dfs(root.random)\n            return copy\n\n        mp = {}\n        return dfs(root)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1427, "slug": "perform-string-shifts", "solutions": ["class Solution:\n    def stringShift(self, s: str, shift: List[List[int]]) -> str:\n        x = sum((b if a else -b) for a, b in shift)\n        x %= len(s)\n        return s[-x:] + s[:-x]\n", "class Solution:\n  def stringShift(self, s: str, shift: list[list[int]]) -> str:\n    move = 0\n\n    for direction, amount in shift:\n      if direction == 0:\n        move -= amount\n      else:\n        move += amount\n\n    move %= len(s)\n    return s[-move:] + s[:-move]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1423, "slug": "maximum-points-you-can-obtain-from-cards", "solutions": ["class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        ans = s = sum(cardPoints[-k:])\n        for i, x in enumerate(cardPoints[:k]):\n            s += x - cardPoints[-k + i]\n            ans = max(ans, s)\n        return ans\n", "class Solution:\n  def maxScore(self, cardPoints: list[int], k: int) -> int:\n    n = len(cardPoints)\n    summ = sum(cardPoints)\n    windowSum = sum(cardPoints[:n - k])\n    ans = summ - windowSum\n\n    for i in range(k):\n      windowSum -= cardPoints[i]\n      windowSum += cardPoints[i + n - k]\n      ans = max(ans, summ - windowSum)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1448, "slug": "count-good-nodes-in-binary-tree", "solutions": ["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        def dfs(root: TreeNode, mx: int):\n            if root is None:\n                return\n            nonlocal ans\n            if mx <= root.val:\n                ans += 1\n                mx = root.val\n            dfs(root.left, mx)\n            dfs(root.right, mx)\n\n        ans = 0\n        dfs(root, -1000000)\n        return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1459, "slug": "rectangles-area", "solutions": [], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1441, "slug": "build-an-array-with-stack-operations", "solutions": ["class Solution:\n    def buildArray(self, target: List[int], n: int) -> List[str]:\n        ans = []\n        cur = 1\n        for x in target:\n            while cur < x:\n                ans.extend([\"Push\", \"Pop\"])\n                cur += 1\n            ans.append(\"Push\")\n            cur += 1\n        return ans\n", "class Solution:\n  def buildArray(self, target: list[int], n: int) -> list[str]:\n    ans = []\n    i = 0  # Target pointer\n    num = 1  # Curr num\n\n    while i < len(target):\n      t = target[i]\n      if t == num:\n        ans.append('Push')\n        i += 1\n      else:\n        ans.append('Push')\n        ans.append('Pop')\n      num += 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1429, "slug": "first-unique-number", "solutions": ["class FirstUnique:\n    def __init__(self, nums: List[int]):\n        self.cnt = Counter(nums)\n        self.unique = OrderedDict({v: 1 for v in nums if self.cnt[v] == 1})\n\n    def showFirstUnique(self) -> int:\n        return -1 if not self.unique else next(v for v in self.unique.keys())\n\n    def add(self, value: int) -> None:\n        self.cnt[value] += 1\n        if self.cnt[value] == 1:\n            self.unique[value] = 1\n        elif value in self.unique:\n            self.unique.pop(value)\n\n\n# Your FirstUnique object will be instantiated and called as such:\n# obj = FirstUnique(nums)\n# param_1 = obj.showFirstUnique()\n# obj.add(value)\n", "class FirstUnique:\n  def __init__(self, nums: list[int]):\n    self.seen = set()\n    self.unique = {}\n    for num in nums:\n      self.add(num)\n\n  def showFirstUnique(self) -> int:\n    return next(iter(self.unique), -1)\n\n  def add(self, value: int) -> None:\n    if value not in self.seen:\n      self.seen.add(value)\n      self.unique[value] = 1\n    elif value in self.unique:\n      # We have added this value before, and this is the second time we're\n      # adding it. So, erase the value from `unique`.\n      self.unique.pop(value)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1404, "slug": "number-of-steps-to-reduce-a-number-in-binary-representation-to-one", "solutions": ["class Solution:\n    def numSteps(self, s: str) -> int:\n        carry = False\n        ans = 0\n        for c in s[:0:-1]:\n            if carry:\n                if c == '0':\n                    c = '1'\n                    carry = False\n                else:\n                    c = '0'\n            if c == '1':\n                ans += 1\n                carry = True\n            ans += 1\n        if carry:\n            ans += 1\n        return ans\n", "class Solution:\n  def numSteps(self, s: str) -> int:\n    ans = 0\n    chars = list(s)\n\n    # All the trailing 0s can be popped by 1 step.\n    while chars[-1] == '0':\n      chars.pop()\n      ans += 1\n\n    if ''.join(chars) == '1':\n      return ans\n\n    # `s` is now odd, so add 1 to `s` and cost 1 step.\n    # All the 1s will become 0s and can be popped by 1 step.\n    # All the 0s will become 1s and can be popped by 2 steps (adding 1 then\n    # dividing by 2).\n    return ans + 1 + sum(1 if c == '1' else 2 for c in chars)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1490, "slug": "clone-n-ary-tree", "solutions": ["\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children if children is not None else []\n\"\"\"\n\n\nclass Solution:\n    def cloneTree(self, root: 'Node') -> 'Node':\n        if root is None:\n            return None\n        children = [self.cloneTree(child) for child in root.children]\n        return Node(root.val, children)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1415, "slug": "the-k-th-lexicographical-string-of-all-happy-strings-of-length-n", "solutions": ["class Solution:\n    def getHappyString(self, n: int, k: int) -> str:\n        def dfs():\n            if len(s) == n:\n                ans.append(\"\".join(s))\n                return\n            if len(ans) >= k:\n                return\n            for c in \"abc\":\n                if not s or s[-1] != c:\n                    s.append(c)\n                    dfs()\n                    s.pop()\n\n        ans = []\n        s = []\n        dfs()\n        return \"\" if len(ans) < k else ans[k - 1]\n", "class Solution:\n  def getHappyString(self, n: int, k: int) -> str:\n    nextLetters = {'a': 'bc', 'b': 'ac', 'c': 'ab'}\n    q = collections.deque(['a', 'b', 'c'])\n\n    while len(q[0]) != n:\n      u = q.popleft()\n      for nextLetter in nextLetters[u[-1]]:\n        q.append(u + nextLetter)\n\n    return '' if len(q) < k else q[k - 1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1422, "slug": "maximum-score-after-splitting-a-string", "solutions": ["class Solution:\n    def maxScore(self, s: str) -> int:\n        l, r = 0, s.count(\"1\")\n        ans = 0\n        for x in s[:-1]:\n            l += int(x) ^ 1\n            r -= int(x)\n            ans = max(ans, l + r)\n        return ans\n", "class Solution:\n  def maxScore(self, s: str) -> int:\n    ans = 0\n    zeros = 0\n    ones = s.count('1')\n\n    for i in range(len(s) - 1):\n      if s[i] == '0':\n        zeros += 1\n      else:\n        ones -= 1\n      ans = max(ans, zeros + ones)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1414, "slug": "find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k", "solutions": ["class Solution:\n    def findMinFibonacciNumbers(self, k: int) -> int:\n        a = b = 1\n        while b <= k:\n            a, b = b, a + b\n        ans = 0\n        while k:\n            if k >= b:\n                k -= b\n                ans += 1\n            a, b = b - a, a\n        return ans\n", "class Solution:\n  def findMinFibonacciNumbers(self, k: int) -> int:\n    if k < 2:  # k == 0 or k == 1\n      return k\n\n    a = 1  # F_1\n    b = 1  # F_2\n\n    while b <= k:\n      #    a, b = F_{i + 1}, F_{i + 2}\n      # -> a, b = F_{i + 2}, F_{i + 3}\n      a, b = b, a + b\n\n    return 1 + self.findMinFibonacciNumbers(k - a)\n", "class Solution:\n  def findMinFibonacciNumbers(self, k: int) -> int:\n    ans = 0\n    a = 1  # F_1\n    b = 1  # F_2\n\n    while b <= k:\n      #    a, b = F_{i + 1}, F_{i + 2}\n      # -> a, b = F_{i + 2}, F_{i + 3}\n      a, b = b, a + b\n\n    while a > 0:\n      if a <= k:\n        k -= a\n        ans += 1\n      #    a, b = F_{i + 2}, F_{i + 3}\n      # -> a, b = F_{i + 1}, F_{i + 2}\n      a, b = b - a, a\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1487, "slug": "making-file-names-unique", "solutions": ["class Solution:\n    def getFolderNames(self, names: List[str]) -> List[str]:\n        d = defaultdict(int)\n        for i, name in enumerate(names):\n            if name in d:\n                k = d[name]\n                while f'{name}({k})' in d:\n                    k += 1\n                d[name] = k + 1\n                names[i] = f'{name}({k})'\n            d[names[i]] = 1\n        return names\n", "class Solution:\n  def getFolderNames(self, names: list[str]) -> list[str]:\n    ans = []\n    nameToSuffix = {}\n\n    for name in names:\n      if name in nameToSuffix:\n        suffix = nameToSuffix[name] + 1\n        newName = self._getName(name, suffix)\n        while newName in nameToSuffix:\n          suffix += 1\n          newName = self._getName(name, suffix)\n        nameToSuffix[name] = suffix\n        nameToSuffix[newName] = 0\n        ans.append(newName)\n      else:\n        nameToSuffix[name] = 0\n        ans.append(name)\n\n    return ans\n\n  def _getName(self, name: str, suffix: int) -> str:\n    return name + '(' + str(suffix) + ')'\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1465, "slug": "maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts", "solutions": ["class Solution:\n    def maxArea(\n        self, h: int, w: int, horizontalCuts: List[int], verticalCuts: List[int]\n    ) -> int:\n        horizontalCuts.extend([0, h])\n        verticalCuts.extend([0, w])\n        horizontalCuts.sort()\n        verticalCuts.sort()\n        x = max(b - a for a, b in pairwise(horizontalCuts))\n        y = max(b - a for a, b in pairwise(verticalCuts))\n        return (x * y) % (10**9 + 7)\n", "class Solution:\n  def maxArea(\n      self,\n      h: int,\n      w: int,\n      horizontalCuts: list[int],\n      verticalCuts: list[int],\n  ) -> int:\n    MOD = 1_000_000_007\n    # the maximum gap of each direction\n    maxGapX = max(b - a\n                  for a, b in itertools.pairwise(\n                      [0] + sorted(horizontalCuts) + [h]))\n    maxGapY = max(b - a\n                  for a, b in itertools.pairwise(\n                      [0] + sorted(verticalCuts) + [w]))\n    return maxGapX * maxGapY % MOD\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1425, "slug": "constrained-subsequence-sum", "solutions": ["class Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        q = deque([0])\n        n = len(nums)\n        f = [0] * n\n        ans = -inf\n        for i, x in enumerate(nums):\n            while i - q[0] > k:\n                q.popleft()\n            f[i] = max(0, f[q[0]]) + x\n            ans = max(ans, f[i])\n            while q and f[q[-1]] <= f[i]:\n                q.pop()\n            q.append(i)\n        return ans\n", "class Solution:\n  def constrainedSubsetSum(self, nums: list[int], k: int) -> int:\n    # dp[i] := the maximum the sum of non-empty subsequences in nums[0..i]\n    dp = [0] * len(nums)\n    # dq stores dp[i - k], dp[i - k + 1], ..., dp[i - 1] whose values are > 0\n    # in decreasing order.\n    dq = collections.deque()\n\n    for i, num in enumerate(nums):\n      if dq:\n        dp[i] = max(dq[0], 0) + num\n      else:\n        dp[i] = num\n      while dq and dq[-1] < dp[i]:\n        dq.pop()\n      dq.append(dp[i])\n      if i >= k and dp[i - k] == dq[0]:\n        dq.popleft()\n\n    return max(dp)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1475, "slug": "final-prices-with-a-special-discount-in-a-shop", "solutions": ["class Solution:\n    def finalPrices(self, prices: List[int]) -> List[int]:\n        stk = []\n        for i in reversed(range(len(prices))):\n            x = prices[i]\n            while stk and x < stk[-1]:\n                stk.pop()\n            if stk:\n                prices[i] -= stk[-1]\n            stk.append(x)\n        return prices\n", "class Solution:\n  def finalPrices(self, prices: list[int]) -> list[int]:\n    ans = prices.copy()\n    stack = []\n\n    for i, price in enumerate(prices):\n      # stack[-1] := i in the problem description.\n      while stack and prices[stack[-1]] >= price:\n        ans[stack.pop()] -= price\n      stack.append(i)\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1482, "slug": "minimum-number-of-days-to-make-m-bouquets", "solutions": ["class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def check(days: int) -> int:\n            cnt = cur = 0\n            for x in bloomDay:\n                cur = cur + 1 if x <= days else 0\n                if cur == k:\n                    cnt += 1\n                    cur = 0\n            return cnt >= m\n\n        mx = max(bloomDay)\n        l = bisect_left(range(mx + 2), True, key=check)\n        return -1 if l > mx else l\n", "class Solution:\n  def minDays(self, bloomDay: list[int], m: int, k: int) -> int:\n    if len(bloomDay) < m * k:\n      return -1\n\n    def getBouquetCount(waitingDays: int) -> int:\n      \"\"\"\n      Returns the number of bouquets (k flowers needed) can be made after the\n      `waitingDays`.\n      \"\"\"\n      bouquetCount = 0\n      requiredFlowers = k\n      for day in bloomDay:\n        if day > waitingDays:\n          # Reset `requiredFlowers` since there was not enough adjacent flowers.\n          requiredFlowers = k\n        else:\n          requiredFlowers -= 1\n          if requiredFlowers == 0:\n            # Use k adjacent flowers to make a bouquet.\n            bouquetCount += 1\n            requiredFlowers = k\n      return bouquetCount\n\n    l = min(bloomDay)\n    r = max(bloomDay)\n\n    while l < r:\n      mid = (l + r) // 2\n      if getBouquetCount(mid) >= m:\n        r = mid\n      else:\n        l = mid + 1\n\n    return l\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1409, "slug": "queries-on-a-permutation-with-key", "solutions": ["class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        p = list(range(1, m + 1))\n        ans = []\n        for v in queries:\n            j = p.index(v)\n            ans.append(j)\n            p.pop(j)\n            p.insert(0, v)\n        return ans\n", "class FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def add(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def processQueries(self, queries: list[int], m: int) -> list[int]:\n    ans = []\n    # Map [-m, m] to [0, 2 * m].\n    tree = FenwickTree(2 * m + 1)\n    numToIndex = {num: num + m for num in range(1, m + 1)}\n\n    for num in range(1, m + 1):\n      tree.add(num + m, 1)\n\n    nextEmptyIndex = m  # Map 0 to m.\n\n    for query in queries:\n      index = numToIndex[query]\n      ans.append(tree.get(index - 1))\n      # Move `query` from `index` to `nextEmptyIndex`.\n      tree.add(index, -1)\n      tree.add(nextEmptyIndex, 1)\n      numToIndex[query] = nextEmptyIndex\n      nextEmptyIndex -= 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1436, "slug": "destination-city", "solutions": ["class Solution:\n    def destCity(self, paths: List[List[str]]) -> str:\n        s = {a for a, _ in paths}\n        return next(b for _, b in paths if b not in s)\n", "class Solution:\n  def destCity(self, paths: list[list[str]]) -> str:\n    count = collections.Counter()\n\n    for a, b in paths:\n      count[a] += 1\n\n    for a, b in paths:\n      if b in count:\n        count[b] -= 1\n        if count[b] == 0:\n          del count[b]\n      else:\n        return b\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1472, "slug": "design-browser-history", "solutions": ["class BrowserHistory:\n    def __init__(self, homepage: str):\n        self.stk1 = []\n        self.stk2 = []\n        self.visit(homepage)\n\n    def visit(self, url: str) -> None:\n        self.stk1.append(url)\n        self.stk2.clear()\n\n    def back(self, steps: int) -> str:\n        while steps and len(self.stk1) > 1:\n            self.stk2.append(self.stk1.pop())\n            steps -= 1\n        return self.stk1[-1]\n\n    def forward(self, steps: int) -> str:\n        while steps and self.stk2:\n            self.stk1.append(self.stk2.pop())\n            steps -= 1\n        return self.stk1[-1]\n\n\n# Your BrowserHistory object will be instantiated and called as such:\n# obj = BrowserHistory(homepage)\n# obj.visit(url)\n# param_2 = obj.back(steps)\n# param_3 = obj.forward(steps)\n", "class BrowserHistory:\n  def __init__(self, homepage: str):\n    self.history = []\n    self.visit(homepage)\n\n  def visit(self, url: str) -> None:\n    self.history.append(url)\n    self.future = []\n\n  def back(self, steps: int) -> str:\n    while len(self.history) > 1 and steps > 0:\n      self.future.append(self.history.pop())\n      steps -= 1\n    return self.history[-1]\n\n  def forward(self, steps: int) -> str:\n    while self.future and steps > 0:\n      self.history.append(self.future.pop())\n      steps -= 1\n    return self.history[-1]\n", "class Node:\n  def __init__(self, url: str):\n    self.prev = None\n    self.next = None\n    self.url = url\n\n\nclass BrowserHistory:\n  def __init__(self, homepage: str):\n    self.curr = Node(homepage)\n\n  def visit(self, url: str) -> None:\n    self.curr.next = Node(url)\n    self.curr.next.prev = self.curr\n    self.curr = self.curr.next\n\n  def back(self, steps: int) -> str:\n    while self.curr.prev and steps > 0:\n      self.curr = self.curr.prev\n      steps -= 1\n    return self.curr.url\n\n  def forward(self, steps: int) -> str:\n    while self.curr.next and steps > 0:\n      self.curr = self.curr.next\n      steps -= 1\n    return self.curr.url\n", "class BrowserHistory:\n  def __init__(self, homepage: str):\n    self.urls = []\n    self.index = -1\n    self.lastIndex = -1\n    self.visit(homepage)\n\n  def visit(self, url: str) -> None:\n    self.index += 1\n    if self.index < len(self.urls):\n      self.urls[self.index] = url\n    else:\n      self.urls.append(url)\n    self.lastIndex = self.index\n\n  def back(self, steps: int) -> str:\n    self.index = max(0, self.index - steps)\n    return self.urls[self.index]\n\n  def forward(self, steps: int) -> str:\n    self.index = min(self.lastIndex, self.index + steps)\n    return self.urls[self.index]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1405, "slug": "longest-happy-string", "solutions": ["class Solution:\n    def longestDiverseString(self, a: int, b: int, c: int) -> str:\n        h = []\n        if a > 0:\n            heappush(h, [-a, 'a'])\n        if b > 0:\n            heappush(h, [-b, 'b'])\n        if c > 0:\n            heappush(h, [-c, 'c'])\n\n        ans = []\n        while len(h) > 0:\n            cur = heappop(h)\n            if len(ans) >= 2 and ans[-1] == cur[1] and ans[-2] == cur[1]:\n                if len(h) == 0:\n                    break\n                nxt = heappop(h)\n                ans.append(nxt[1])\n                if -nxt[0] > 1:\n                    nxt[0] += 1\n                    heappush(h, nxt)\n                heappush(h, cur)\n            else:\n                ans.append(cur[1])\n                if -cur[0] > 1:\n                    cur[0] += 1\n                    heappush(h, cur)\n\n        return ''.join(ans)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1488, "slug": "avoid-flood-in-the-city", "solutions": ["class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        n = len(rains)\n        ans = [-1] * n\n        sunny = SortedList()\n        rainy = {}\n        for i, v in enumerate(rains):\n            if v:\n                if v in rainy:\n                    idx = sunny.bisect_right(rainy[v])\n                    if idx == len(sunny):\n                        return []\n                    ans[sunny[idx]] = v\n                    sunny.discard(sunny[idx])\n                rainy[v] = i\n            else:\n                sunny.add(i)\n                ans[i] = 1\n        return ans\n", "from sortedcontainers import SortedSet\n\n\nclass Solution:\n  def avoidFlood(self, rains: list[int]) -> list[int]:\n    ans = [-1] * len(rains)\n    lakeIdToFullDay = {}\n    emptyDays = SortedSet()  # indices of rains[i] == 0\n\n    for i, lakeId in enumerate(rains):\n      if lakeId == 0:\n        emptyDays.add(i)\n        continue\n        # The lake was full in a previous day. Greedily find the closest day\n        # to make the lake empty.\n      if lakeId in lakeIdToFullDay:\n        fullDay = lakeIdToFullDay[lakeId]\n        emptyDayIndex = emptyDays.bisect_right(fullDay)\n        if emptyDayIndex == len(emptyDays):  # Not found.\n          return []\n        # Empty the lake at this day.\n        emptyDay = emptyDays[emptyDayIndex]\n        ans[emptyDay] = lakeId\n        emptyDays.discard(emptyDay)\n      # The lake with `lakeId` becomes full at the day `i`.\n      lakeIdToFullDay[lakeId] = i\n\n    # Empty an arbitrary lake if there are remaining empty days.\n    for emptyDay in emptyDays:\n      ans[emptyDay] = 1\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1470, "slug": "shuffle-the-array", "solutions": ["class Solution:\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\n        return [x for pair in zip(nums[:n], nums[n:]) for x in pair]\n", "class Solution:\n  def shuffle(self, nums: list[int], n: int) -> list[int]:\n    ans = []\n    for a, b in zip(nums[:n], nums[n:]):\n      ans.append(a)\n      ans.append(b)\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1477, "slug": "find-two-non-overlapping-sub-arrays-each-with-target-sum", "solutions": ["class Solution:\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        d = {0: 0}\n        s, n = 0, len(arr)\n        f = [inf] * (n + 1)\n        ans = inf\n        for i, v in enumerate(arr, 1):\n            s += v\n            f[i] = f[i - 1]\n            if s - target in d:\n                j = d[s - target]\n                f[i] = min(f[i], i - j)\n                ans = min(ans, f[j] + i - j)\n            d[s] = i\n        return -1 if ans > n else ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1402, "slug": "reducing-dishes", "solutions": ["class Solution:\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\n        satisfaction.sort(reverse=True)\n        ans = s = 0\n        for x in satisfaction:\n            s += x\n            if s <= 0:\n                break\n            ans += s\n        return ans\n", "class Solution:\n  def maxSatisfaction(self, satisfaction: list[int]) -> int:\n    ans = 0\n    sumSatisfaction = 0\n\n    for s in sorted(satisfaction, reverse=True):\n      sumSatisfaction += s\n      if sumSatisfaction <= 0:\n        return ans\n      ans += sumSatisfaction\n\n    return ans\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1431, "slug": "kids-with-the-greatest-number-of-candies", "solutions": ["class Solution:\n    def kidsWithCandies(self, candies: List[int], extraCandies: int) -> List[bool]:\n        mx = max(candies)\n        return [candy + extraCandies >= mx for candy in candies]\n", "class Solution:\n  def kidsWithCandies(\n      self,\n      candies: list[int],\n      extraCandies: int,\n  ) -> list[bool]:\n    maxCandy = max(candies)\n    return [candy + extraCandies >= maxCandy for candy in candies]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1439, "slug": "find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows", "solutions": ["class Solution:\n    def kthSmallest(self, mat: List[List[int]], k: int) -> int:\n        pre = [0]\n        for cur in mat:\n            pre = sorted(a + b for a in pre for b in cur[:k])[:k]\n        return pre[-1]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1413, "slug": "minimum-value-to-get-positive-step-by-step-sum", "solutions": ["class Solution:\n    def minStartValue(self, nums: List[int]) -> int:\n        s, t = 0, inf\n        for num in nums:\n            s += num\n            t = min(t, s)\n        return max(1, 1 - t)\n", "class Solution:\n  def minStartValue(self, nums: list[int]) -> int:\n    summ = 0\n    minSum = 0\n\n    for num in nums:\n      summ += num\n      minSum = min(minSum, summ)\n\n    return 1 - minSum\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1433, "slug": "check-if-a-string-can-break-another-string", "solutions": ["class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        cs1 = sorted(s1)\n        cs2 = sorted(s2)\n        return all(a >= b for a, b in zip(cs1, cs2)) or all(\n            a <= b for a, b in zip(cs1, cs2)\n        )\n", "class Solution:\n  def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n    count = collections.Counter(s1)\n    count.subtract(collections.Counter(s2))\n\n    for a, b in itertools.pairwise(string.ascii_lowercase):\n      count[b] += count[a]\n\n    return (all(value <= 0 for value in count.values()) or\n            all(value >= 0 for value in count.values()))\n", "class Solution:\n  def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n    count1 = collections.Counter(s1)\n    count2 = collections.Counter(s2)\n\n    def canBreak(count1: dict[str, int], count2: dict[str, int]) -> bool:\n      \"\"\"Returns True if count1 can break count2.\"\"\"\n      diff = 0\n      for c in string.ascii_lowercase:\n        diff += count2[c] - count1[c]\n        # count2 is alphabetically greater than count1.\n        if diff < 0:\n          return False\n      return True\n\n    return canBreak(count1, count2) or canBreak(count2, count1)\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1474, "slug": "delete-n-nodes-after-m-nodes-of-a-linked-list", "solutions": ["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def deleteNodes(self, head: ListNode, m: int, n: int) -> ListNode:\n        pre = head\n        while pre:\n            for _ in range(m - 1):\n                if pre:\n                    pre = pre.next\n            if pre is None:\n                return head\n            cur = pre\n            for _ in range(n):\n                if cur:\n                    cur = cur.next\n            pre.next = None if cur is None else cur.next\n            pre = pre.next\n        return head\n", "class Solution:\n  def deleteNodes(\n      self,\n      head: ListNode | None,\n      m: int,\n      n: int,\n  ) -> ListNode | None:\n    curr = head\n    prev = None  # prev.next == curr\n\n    while curr:\n      # Set the m-th node as `prev`.\n      for _ in range(m):\n        if not curr:\n          break\n        prev = curr\n        curr = curr.next\n      # Set the (m + n + 1)-th node as `curr`.\n      for _ in range(n):\n        if not curr:\n          break\n        curr = curr.next\n      # Delete the nodes [m + 1..n - 1].\n      prev.next = curr\n\n    return head\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1458, "slug": "max-dot-product-of-two-subsequences", "solutions": ["class Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        m, n = len(nums1), len(nums2)\n        f = [[-inf] * (n + 1) for _ in range(m + 1)]\n        for i, x in enumerate(nums1, 1):\n            for j, y in enumerate(nums2, 1):\n                v = x * y\n                f[i][j] = max(f[i - 1][j], f[i][j - 1], max(0, f[i - 1][j - 1]) + v)\n        return f[m][n]\n", "class Solution:\n  def maxDotProduct(self, A: list[int], B: list[int]) -> int:\n    m = len(A)\n    n = len(B)\n    # dp[i][j] := the maximum dot product of the two subsequences nums[0..i)\n    # and nums2[0..j)\n    dp = [[-math.inf] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m):\n      for j in range(n):\n        dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j],\n                               max(0, dp[i][j]) + A[i] * B[j])\n\n    return dp[m][n]\n"], "topic_tags": [], "collection_date": "2025-03-28"}
{"problem_id": 1493, "slug": "longest-subarray-of-1s-after-deleting-one-element", "solutions": ["class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:\n        n = len(nums)\n        left = [0] * (n + 1)\n        right = [0] * (n + 1)\n        for i, x in enumerate(nums, 1):\n            if x:\n                left[i] = left[i - 1] + 1\n        for i in range(n - 1, -1, -1):\n            if nums[i]:\n                right[i] = right[i + 1] + 1\n        return max(left[i] + right[i + 1] for i in range(n))\n", "class Solution:\n  def longestSubarray(self, nums: list[int]) -> int:\n    ans = 0\n    zeros = 0\n\n    l = 0\n    for r, num in enumerate(nums):\n      if num == 0:\n        zeros += 1\n      while zeros == 2:\n        if nums[l] == 0:\n          zeros -= 1\n        l += 1\n      ans = max(ans, r - l)\n\n    return ans\n", "class Solution:\n  def longestSubarray(self, nums: list[int]) -> int:\n    l = 0\n    zeros = 0\n\n    for num in nums:\n      if num == 0:\n        zeros += 1\n      if zeros > 1:\n        if nums[l] == 0:\n          zeros -= 1\n        l += 1\n\n    return len(nums) - l - 1\n"], "topic_tags": [], "collection_date": "2025-03-28"}
